<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bootstrap</title>
    <url>/2020/07/26/Bootstrap/</url>
    <content><![CDATA[<h1 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><pre><code>一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。
    * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。
    * 好处：
        1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。
        2. 响应式布局。
            * 同一套页面可以兼容不同分辨率的设备。
</code></pre><a id="more"></a>
<h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><pre><code>    1. 下载Bootstrap
    2. 在项目中将Bootstrap解压后的这三个文件夹复制
    3. 创建html页面，引入必要的资源文件
</code></pre><p>下面的代码是Bootstap的模板。只是简单的引入了各种资源文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><pre><code>* 同一套页面可以兼容不同分辨率的设备。
* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子
* 步骤：
    1. 定义容器。相当于之前的table、
        * 容器分类：
            1. container：两边留白
            2. container-fluid：每一种设备都是100%宽度
    2. 定义行。相当于之前的tr   样式：row
    3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目
        * 设备代号：
            1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12
            2. sm：小屏幕 平板 (≥768px)
            3. md：中等屏幕 桌面显示器 (≥992px)
            4. lg：大屏幕 大桌面显示器 (≥1200px)

    * 注意：
        1. 一行中如果格子数目超过12，则超出部分自动换行。
        2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。
        3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。
</code></pre><h1 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h1><pre><code>1. 全局CSS样式：
    * 按钮：class=&quot;btn btn-default&quot;
    * 图片：
        *  class=&quot;img-responsive&quot;：图片在任意尺寸都占100%
        *  图片形状
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形
            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框
    * 表格
        * table
        * table-bordered
        * table-hover
    * 表单
        * 给表单项添加：class=&quot;form-control&quot; 
2. 组件：
    * 导航条
    * 分页条
3. 插件：
    * 轮播图
</code></pre><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;
    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;

    &lt;!-- Bootstrap --&gt;
    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre><p>​    </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.paddtop</span>&#123;</span></span><br><span class="line">            padding-top: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.search-btn</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line"><span class="css">            <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ffc900</span>;</span></span><br><span class="line">            width: 90px;</span><br><span class="line">            height: 35px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>:<span class="selector-id">#ffc900</span> ;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 35px;</span><br><span class="line">            margin-top: 15px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.search-input</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line"><span class="css">            <span class="selector-tag">border</span><span class="selector-pseudo">:2px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ffc900</span>;</span></span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 35px;</span><br><span class="line">            padding-left: 5px;</span><br><span class="line">            margin-top: 15px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.jx</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border-bottom</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ffc900</span>;</span></span><br><span class="line">            padding: 5px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.company</span>&#123;</span></span><br><span class="line">            height: 40px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#ffc900</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:40px</span> ;</span></span><br><span class="line">            font-size: 8px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 1.页眉部分--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/top_banner.jpg"</span> <span class="attr">class</span>=<span class="string">"img-responsive"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row paddtop"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/logo.jpg"</span> <span class="attr">class</span>=<span class="string">"img-responsive"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-5"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"search-input"</span> <span class="attr">placeholder</span>=<span class="string">"请输入线路名称"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"search-btn"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/hotel_tel.png"</span> <span class="attr">class</span>=<span class="string">"img-responsive"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--导航栏--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-default"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- Brand and toggle get grouped for better mobile display --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- 定义汉堡按钮 --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle collapsed"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#bs-example-navbar-collapse-1"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="comment">&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse navbar-collapse"</span> <span class="attr">id</span>=<span class="string">"bs-example-navbar-collapse-1"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.navbar-collapse --&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.container-fluid --&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--轮播图--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"carousel-example-generic"</span> <span class="attr">class</span>=<span class="string">"carousel slide"</span> <span class="attr">data-ride</span>=<span class="string">"carousel"</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- Indicators --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"carousel-indicators"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">data-slide-to</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">data-slide-to</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">data-slide-to</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- Wrapper for slides --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"carousel-inner"</span> <span class="attr">role</span>=<span class="string">"listbox"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item active"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/banner_1.jpg"</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/banner_2.jpg"</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/banner_3.jpg"</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- Controls --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"left carousel-control"</span> <span class="attr">href</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-slide</span>=<span class="string">"prev"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-chevron-left"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Previous<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"right carousel-control"</span> <span class="attr">href</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-slide</span>=<span class="string">"next"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-chevron-right"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 2.主体部分--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row jx"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/icon_5.jpg"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>黑马精选<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row paddtop"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row jx"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/icon_6.jpg"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span>&gt;</span>国内游<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row paddtop"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/guonei_1.jpg"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-8"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"thumbnail"</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/jiangxuan_3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span><span class="symbol">&amp;yen;</span> 699<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 3.页脚部分--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/footer_service.png"</span> <span class="attr">class</span>=<span class="string">"img-responsive"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row company"</span>&gt;</span></span><br><span class="line">           江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
        <category>Bootstrap</category>
      </categories>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/2020/07/25/Annotation-reflection/</url>
    <content><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-什么是注解？"><a href="#1-什么是注解？" class="headerlink" title="1.什么是注解？"></a>1.什么是注解？</h2><ul>
<li>Annotation 的作用<ul>
<li>不是程序本身，可以对程序作出解释。</li>
<li><span style="color:red">可以被其他程序读取</span></li>
</ul>
</li>
<li><p>Annotation的格式：</p>
<ul>
<li>注解是以“@注释名”在代码中存在的，还可以添加一些参数值；例如：@SuppressWarnings(value = “unchecked”)</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li>
</ul>
</li>
</ul>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么是注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="comment">//@Override 重写的注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        @Deprecated的程序元素是程序员不鼓励使用的程序元素，通常是因为它是危险的，或者因为存在更好的替代方法。编译器在不被弃用的代码中使用或覆盖不推荐使用的程序元素时发出警告。 </p>
<p>​        @SuppressWarnings表示在注释元素（以及注释元素中包含的所有程序元素）中应该抑制命名的编译器警告。</p>
<h2 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2. 内置注解"></a>2. 内置注解</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200709213747686.png" alt="image-20200709213747686"></p>
<h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3.元注解"></a>3.元注解</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200709214745014.png" alt="image-20200709214745014"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">//测试元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个注解</span></span><br><span class="line"><span class="comment">//Target 表示我们的注解可以用在哪些地方</span></span><br><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="comment">//Retention 表示我们的注解在什么地方还有效（默认runtime）</span></span><br><span class="line"><span class="comment">//runtime&gt;class&gt;sources</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//Documented 表示是否将我们的注解生成在JAVAdoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//Inherited 子类可以继承父类的注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200709215534409.png" alt="image-20200709215534409"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注解可以显式赋值，如果没有默认值，我们就必须给注解赋值</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>2(age=<span class="number">18</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>3(<span class="string">"polly"</span>) <span class="comment">//只有value可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123;</span><br><span class="line">    <span class="comment">//注解的参数：参数类型+参数名（）；</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;<span class="comment">//如果默认值为-1.代表不存在</span></span><br><span class="line">    String[] schools() <span class="keyword">default</span> &#123;<span class="string">"电大"</span>,<span class="string">"武汉理工"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation3&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><img src="/2020/07/25/Annotation-reflection/image-20200710085718593.png" alt="image-20200710085718593"></p>
<h2 id="1-反射概述"><a href="#1-反射概述" class="headerlink" title="1.反射概述"></a>1.反射概述</h2><p><img src="/2020/07/25/Annotation-reflection/1.png" alt="1"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710090843745.png" alt="image-20200710090843745"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710091053707.png" alt="image-20200710091053707"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710091228956.png" alt="image-20200710091228956"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么叫反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test02</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//通过反射获取类的Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        Class c2 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line">        Class c3 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line">        Class c4 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line">        <span class="comment">//一个类在内存中只有一个Class对象</span></span><br><span class="line">        <span class="comment">//一个类被加载后，类的整个结构都会被封装在Class对象中</span></span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实体类：pojo，entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", id="</span> + id +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710093022835.png" alt="image-20200710093022835"></p>
<h2 id="2-得到Class类的几种方式"><a href="#2-得到Class类的几种方式" class="headerlink" title="2.得到Class类的几种方式"></a>2.得到Class类的几种方式</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200710093403014.png" alt="image-20200710093403014"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710093558936.png" alt="image-20200710093558936"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试Class类的创建方法有哪些</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"这个人是"</span>+person.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：通过对象获得</span></span><br><span class="line">        Class c1 = person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：forname获得</span></span><br><span class="line">        Class c2 = Class.forName(<span class="string">"com.polly.reflection.Student"</span>);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：通过类名.class获得</span></span><br><span class="line">        Class c3 = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四：基本内置类型包装类都有一个Type属性</span></span><br><span class="line">        Class&lt;Integer&gt; c4 = Integer.TYPE;</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得父类类型</span></span><br><span class="line">        Class c5 = c1.getSuperclass();</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"学生"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"老师"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710094528757.png" alt="image-20200710094528757"></p>
<h2 id="3-哪些类型可以有Class对象"><a href="#3-哪些类型可以有Class对象" class="headerlink" title="3.哪些类型可以有Class对象"></a>3.哪些类型可以有Class对象</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200710094645592.png" alt="image-20200710094645592"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.management.VMOption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有类型的Class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = Object<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//类</span></span><br><span class="line">        Class c2 = Comparable<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//接口</span></span><br><span class="line">        Class c3 = String[]<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//一维数组</span></span><br><span class="line">        Class c4 = <span class="keyword">int</span>[][]<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//二维数组</span></span><br><span class="line">        Class c5 = Override<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//注解</span></span><br><span class="line">        Class c6 = ElementType<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//枚举</span></span><br><span class="line">        Class c7 = Integer<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//基本数据类型</span></span><br><span class="line">        Class c8 = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>; <span class="comment">//void</span></span><br><span class="line">        Class c9 = Class<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//Class</span></span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.println(a.getClass().hashCode());</span><br><span class="line">        System.out.println(b.getClass().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类加载内存分析"><a href="#4-类加载内存分析" class="headerlink" title="4.类加载内存分析"></a>4.类加载内存分析</h2><p><img src="/2020/07/25/Annotation-reflection/2.png" alt="2"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710095653892.png" alt="image-20200710095653892"></p>
<p><img src="/2020/07/25/Annotation-reflection/4.png" alt="4"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(A.m);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.加载到内存，会产生一个类对应Class对象</span></span><br><span class="line"><span class="comment">        2.链接，链接结束后m=0</span></span><br><span class="line"><span class="comment">        3.初始化</span></span><br><span class="line"><span class="comment">            &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">                    System.out.println("A类静态代码块初始化");</span></span><br><span class="line"><span class="comment">                    m = 300;</span></span><br><span class="line"><span class="comment">                    m = 100;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            m = 100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A类静态代码块初始化"</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A类的无参构造初始化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710100911134.png" alt="image-20200710100911134"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类什么时候会初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"main类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//1.主动引用</span></span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//2.反射也会产生主动引用</span></span><br><span class="line">        Class.forName(<span class="string">"com.polly.reflection.Son"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不会产生类的引用的方法:通过子类去调用父类的静态变量</span></span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">        <span class="comment">//不会产生类的引用的方法:通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line">        Son[] array = <span class="keyword">new</span> Son[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//不会产生类的引用的方法:引用常量不会触发此类的初始化</span></span><br><span class="line">        System.out.println(Son.M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类被加载"</span>);</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200710101635987.png" alt="image-20200710101635987"></p>
<p><img src="/2020/07/25/Annotation-reflection/3.jpg" alt="3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类的加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//获取系统类加载器的父类加载器--&gt;扩展类加载器</span></span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        <span class="comment">//获取扩展类加载器的父类加载器--&gt;根加载器（C/C++）</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line">        <span class="comment">//测试当前类是那个加载器加载的</span></span><br><span class="line">        ClassLoader classLoader = Class.forName(<span class="string">"com.polly.reflection.test07"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//测试JDK内部类是那个加载器加载的</span></span><br><span class="line">        classLoader = Class.forName(<span class="string">"java.lang.Object"</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//如何获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d</span></span><br><span class="line"><span class="comment">jdk.internal.loader.ClassLoaders$PlatformClassLoader@10f87f48</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="6-获得类的运行时结构"><a href="#6-获得类的运行时结构" class="headerlink" title="6.获得类的运行时结构"></a>6.获得类的运行时结构</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200710103448104.png" alt="image-20200710103448104"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line">        <span class="comment">//获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName()); <span class="comment">//获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">//获得类名</span></span><br><span class="line">        <span class="comment">//获得类的属性</span></span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line">        Field[] fields = c1.getFields(); <span class="comment">//只能找到public属性，还有父类的；</span></span><br><span class="line">        fields = c1.getDeclaredFields(); <span class="comment">//可以找到所有属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定属性的值</span></span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//获得类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line">        Method[] methods = c1.getMethods(); <span class="comment">//获得本类及其父类的全部public方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正常的："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        methods = c1.getDeclaredMethods(); <span class="comment">//获得本类的所有方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">"getDeclaredMethods："</span>+method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得指定方法</span></span><br><span class="line">        <span class="comment">//重载，所以需要参数 </span></span><br><span class="line">        Method getName = c1.getMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Method setName = c1.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(getName);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line">        <span class="comment">//获得指定构造器</span></span><br><span class="line">        System.out.println(<span class="string">"==================================="</span>);</span><br><span class="line">        Constructor[] constructors = c1.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        constructors = c1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">"#"</span>+constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor declaredConstructor = c1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(declaredConstructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710105959678.png" alt="image-20200710105959678"></p>
<h2 id="7-动态创建对象执行方法"><a href="#7-动态创建对象执行方法" class="headerlink" title="7.动态创建对象执行方法"></a>7.动态创建对象执行方法</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200710110045851.png" alt="image-20200710110045851"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710112526160.png" alt="image-20200710112526160"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200710112635115.png" alt="image-20200710112635115"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态的创建对象，通过反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//获得Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.polly.reflection.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造一个对象</span></span><br><span class="line">        User user = (User) c1.newInstance(); <span class="comment">//本质上是调用了类的无参构造</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器创建对象</span></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        User user2 = (User) constructor.newInstance(<span class="string">"polly"</span>, <span class="number">001</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用普通方法</span></span><br><span class="line">        User user3 = (User) c1.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//通过反射获取一个方法</span></span><br><span class="line">        Method setName = c1.getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        setName.invoke(user3,<span class="string">"panyan"</span>);</span><br><span class="line">        <span class="comment">//invoke：激活的意思</span></span><br><span class="line">        <span class="comment">//（对象，“方法的值”）</span></span><br><span class="line">        System.out.println(user3.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=============================================="</span>);</span><br><span class="line">        <span class="comment">//通过反射操作属性</span></span><br><span class="line">        User user4 = (User) c1.getDeclaredConstructor().newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">//不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true)</span></span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(user4,<span class="string">"panyan2"</span>);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分析性能问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test10</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"普通方法执行10亿次："</span>+(endTime-startTime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">"getName"</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"反射方法执行10亿次："</span>+(endTime-startTime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射方式调用 关闭检测</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method getName = c1.getDeclaredMethod(<span class="string">"getName"</span>,<span class="keyword">null</span>);</span><br><span class="line">        getName.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            getName.invoke(user,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"关闭检测de反射方法执行10亿次："</span>+(endTime-startTime)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">        test02();</span><br><span class="line">        test03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">普通方法执行10亿次：3ms</span></span><br><span class="line"><span class="comment">反射方法执行10亿次：256ms</span></span><br><span class="line"><span class="comment">关闭检测de反射方法执行10亿次：113ms</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>
<h2 id="8-获取泛型信息"><a href="#8-获取泛型信息" class="headerlink" title="8.获取泛型信息"></a>8.获取泛型信息</h2><p><img src="/2020/07/25/Annotation-reflection/image-20200711085906815.png" alt="image-20200711085906815"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射获取泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,User&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test02"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        Method method = Test11.class.getMethod("test01", Map.class, List.class);</span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">"#"</span>+genericParameterType);</span><br><span class="line">            <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(actualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======================================="</span>);</span><br><span class="line">        method = test11.class.getMethod("test02",null);</span><br><span class="line">        Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(actualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#java.util.Map&lt;java.lang.String, com.zenner.reflection.User&gt;</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class com.zenner.reflection.User</span></span><br><span class="line"><span class="comment">#java.util.List&lt;com.zenner.reflection.User&gt;</span></span><br><span class="line"><span class="comment">class com.zenner.reflection.User</span></span><br><span class="line"><span class="comment">=======================================</span></span><br><span class="line"><span class="comment">class java.lang.String</span></span><br><span class="line"><span class="comment">class com.zenner.reflection.User</span></span><br><span class="line"><span class="comment">*?</span></span><br></pre></td></tr></table></figure>
<h2 id="9-获取注解信息"><a href="#9-获取注解信息" class="headerlink" title="9.获取注解信息"></a>9.获取注解信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.polly.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习反射操作注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">"com.polly.reflection.Student2"</span>);</span><br><span class="line">        <span class="comment">//通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得注解的value的值</span></span><br><span class="line">        Tablepan tablepan = (Tablepan) c1.getAnnotation(Tablepan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String value = tablepan.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//获得类指定的注解</span></span><br><span class="line">        Field f = c1.getDeclaredField(<span class="string">"id"</span>);</span><br><span class="line">        Fieldpan annotation = f.getAnnotation(Fieldpan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(annotation.columnName());</span><br><span class="line">        System.out.println(annotation.type());</span><br><span class="line">        System.out.println(annotation.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Tablepan</span>(<span class="string">"db_student"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Fieldpan</span>(columnName = <span class="string">"db_id"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@Fieldpan</span>(columnName = <span class="string">"db_age"</span>,type = <span class="string">"int"</span>,length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Fieldpan</span>(columnName = <span class="string">"db_name"</span>,type = <span class="string">"varchar"</span>,length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student2</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类名的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Tablepan&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Fieldpan&#123;</span><br><span class="line">    <span class="function">String <span class="title">columnName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射应用案例"><a href="#反射应用案例" class="headerlink" title="反射应用案例"></a>反射应用案例</h1><p>原本的这两个都有问题；</p>
<h2 id="1-反射与工厂设计模式"><a href="#1-反射与工厂设计模式" class="headerlink" title="1. 反射与工厂设计模式"></a>1. 反射与工厂设计模式</h2><p>工厂类每有一个子类都要写一个工厂类，这样的工厂类不能重复使用。所以我们使用反射中的<code>Class.forName(&quot;包.类&quot;)</code>，再用<code>newInstance</code>方法获得；进一步的可以使用泛型，通过传入想要的类的<code>Class</code>是的这个工厂类天下通行；</p>
<h2 id="2-反射与单例设计模式"><a href="#2-反射与单例设计模式" class="headerlink" title="2. 反射与单例设计模式"></a>2. 反射与单例设计模式</h2><p>单例设计模式是饿汉式的；</p>
<ol>
<li>构造方法私有化，只有一个static方法</li>
<li>但在多线程下，同时获取这种单例的实例化对象就可能出现多个对象；所以在这里使用<code>synchronic</code>关键字同步构造方法的结构，再用volate关键字使得私有的类属性（本类的对象索引属性）直接使用内存中的，而不是副本；</li>
</ol>
<h1 id="反射与类操作"><a href="#反射与类操作" class="headerlink" title="反射与类操作"></a>反射与类操作</h1><h2 id="1-获取类结果信息"><a href="#1-获取类结果信息" class="headerlink" title="1. 获取类结果信息"></a>1. 获取类结果信息</h2><p>获取类：四种</p>
<h2 id="3-反射调用普通方法"><a href="#3-反射调用普通方法" class="headerlink" title="3. 反射调用普通方法"></a>3. 反射调用普通方法</h2><p>获取方法：四种</p>
<p>然后再通过反射获取方法的结构；</p>
<p>最重要的方法：<code>invoke</code></p>
<h2 id="4-反射调用属性"><a href="#4-反射调用属性" class="headerlink" title="4. 反射调用属性"></a>4. 反射调用属性</h2><p>获取成员</p>
<p>Field类中的方法 </p>
<ul>
<li>设置属性内容： set</li>
<li><p>获取属性内容：get</p>
</li>
<li><p>解除封装：setAccessible；</p>
</li>
</ul>
<h2 id="5-Unsafe工具类"><a href="#5-Unsafe工具类" class="headerlink" title="5. Unsafe工具类"></a>5. Unsafe工具类</h2><p><code>Unsafe</code>的获取过程需要反射：</p>
<p>因为它构造方法私有化，类属性有一个static <code>unsafe</code>类型的也是私有化的。但是不是单例设计模式那种。所以就是一个完全封闭的类。要进去就得开上帝视角，也就是解除封装获取那个属性就好了。</p>
<p>他能绕过实例化的管理。</p>
<p>然后利用这个实例化对象里的：<code>allocateInstance</code>方法给别的单例设计模式弄一个实例化对象；并未这种方式不调用构造方法；</p>
<h1 id="反射与简单Java类"><a href="#反射与简单Java类" class="headerlink" title="反射与简单Java类"></a>反射与简单Java类</h1><h2 id="1-传统属性赋值弊端"><a href="#1-传统属性赋值弊端" class="headerlink" title="1. 传统属性赋值弊端"></a>1. 传统属性赋值弊端</h2><p>属性太多时，类里的方法大部分都是setter和getter；本质上他们都是重复的；可以用反射来解决这个问题</p>
<h2 id="2-属性自动赋值的实现思路"><a href="#2-属性自动赋值的实现思路" class="headerlink" title="2. 属性自动赋值的实现思路"></a>2. 属性自动赋值的实现思路</h2><p>要给一个类传属性的值。要通过反射的方式。这里就是在主方法获得class对象然后得到很多相应的信息。这里讲的东西把反射的过程集成到一个<code>ClassInstanceFactory</code> 类里。希望它是一个万能的东西：接受反射对象和属性内容并获取指定类的实例化对象；</p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200711213813976.png" alt="image-20200711213813976"></p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200711215017363.png" alt="image-20200711215017363"></p>
<h2 id="3-设置各种数据类型"><a href="#3-设置各种数据类型" class="headerlink" title="3. 设置各种数据类型"></a>3. 设置各种数据类型</h2><p>在这里实现了所有可能出现的类型；包括：Long,int,double,Date</p>
<h2 id="4-级联对象实例化"><a href="#4-级联对象实例化" class="headerlink" title="4. 级联对象实例化"></a>4. 级联对象实例化</h2><p>也就是各种类相互融合在了一起；比如部门属于一个公司，部门类里就有公司属性，公司类里就有部门属性。然后公司类，部门类里也都有name属性；</p>
<p>外部获取时也就是：<code>getDept().getDname()</code>，<code>getDept().getCompany().setName(&quot;sdsf&quot;)</code>；</p>
<p>而这里级联里可能就写很长，如果其中一个对象的实例化得不到。那么就影响整个代码运行。所以这里他想要自动实现对象实例化</p>
<p>级联对象一般都用“.”来取。以这个为判断； </p>
<h2 id="5-级联属性赋值"><a href="#5-级联属性赋值" class="headerlink" title="5. 级联属性赋值"></a>5. 级联属性赋值</h2><h1 id="ClassLoader类加载器"><a href="#ClassLoader类加载器" class="headerlink" title="ClassLoader类加载器"></a>ClassLoader类加载器</h1><h2 id="1-类加载器简介"><a href="#1-类加载器简介" class="headerlink" title="1. 类加载器简介"></a>1. 类加载器简介</h2><p>java提供了一个环境变量：<code>CLASSPATH</code>，这个环境变量的作用主要在JVM进程启动的时候进行类加载路径的定义；</p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713154229442.png" alt="image-20200713154229442"></p>
<p>Class类是反射的根源：他里面有一个<code>getClassLoader</code>方法</p>
<p> <img src="/2020/07/25/Annotation-reflection/image-20200713155403252.png" alt="image-20200713155403252"></p>
<p>获得类加载器，就可以实现类的反射加载处理：</p>
<h2 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h2><p>自定义加载器是在所有加载器之后；之前他们都得用<code>classPath</code>，有了自定义加载器就可以在系统内任意位置都可以进行加载；</p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713160252710.png" alt="image-20200713160252710"></p>
<ol>
<li><p>写了一个简单类，放在D盘路径上不打包：<code>javac Message.java</code>，并且不打包（使得classpath无法加载）。</p>
</li>
<li><p>自定义一个类加载器，并继承自classLoader类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>&lt;?&gt; <span class="title">loadData</span>(<span class="title">String</span> <span class="title">className</span>) <span class="title">throws</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> [] data = <span class="keyword">this</span>.loadClassData; 	<span class="comment">//	读来的二进制数据文件</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dafindClass(className, data, <span class="number">0</span>, data.length);	<span class="comment">// 重要的一步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里获取的Class对象就可以用Class里面的方法实例化，实现后续操作</p>
</li>
</ol>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713161646497.png" alt="image-20200713161646497"></p>
<p>java提供了双亲加载机制：系统类有由系统加载器加载。自定义的加载器不能够加载；自定义类才可以有自定义加载器加载；</p>
<h1 id="反射与代理设计模式"><a href="#反射与代理设计模式" class="headerlink" title="反射与代理设计模式"></a>反射与代理设计模式</h1><h2 id="1-静态代理设计模式"><a href="#1-静态代理设计模式" class="headerlink" title="1. 静态代理设计模式"></a>1. 静态代理设计模式</h2><p>代理设计模式必须要有一个接口，接着实现；</p>
<p>传统设计模式弊端：客户端和接口子类产生了耦合问题，最好再引入工厂设计模式</p>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713162457378.png" alt="image-20200713162457378"></p>
<p>一个代理类，只为一个接口服务；这里想要一个代理类，满足所有的业务接口</p>
<h2 id="2-代理设计模式"><a href="#2-代理设计模式" class="headerlink" title="2. 代理设计模式"></a>2. 代理设计模式</h2><ul>
<li>不管是真实代理类还是静态代理类都一定要接收真实业务实现子类对象；</li>
<li>由于动态代理类不再与某一个具体的接口进行捆绑应该可以动态获取类的接口；</li>
</ul>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713163649309.png" alt="image-20200713163649309"></p>
<p>这里要用到一个<code>invocationHandle</code>的接口来处理，他有一个<code>invoke</code>方法</p>
<p>还有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance​(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/Annotation-reflection/image-20200713164430363.png" alt="image-20200713164430363"></p>
<h2 id="3-CGLIB实现代理设计"><a href="#3-CGLIB实现代理设计" class="headerlink" title="3. CGLIB实现代理设计"></a>3. CGLIB实现代理设计</h2><p>可以实现基于类的代理设计模式。不再与接口联系</p>
<h1 id="反射与Annotation"><a href="#反射与Annotation" class="headerlink" title="反射与Annotation"></a>反射与Annotation</h1><h2 id="1-获取Annotation信息"><a href="#1-获取Annotation信息" class="headerlink" title="1. 获取Annotation信息"></a>1. 获取Annotation信息</h2><h2 id="2-自定义Annotation"><a href="#2-自定义Annotation" class="headerlink" title="2. 自定义Annotation"></a>2. 自定义Annotation</h2><h2 id="3-工厂设计模式与Annotation"><a href="#3-工厂设计模式与Annotation" class="headerlink" title="3. 工厂设计模式与Annotation"></a>3. 工厂设计模式与Annotation</h2>]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>注解与反射</category>
      </categories>
  </entry>
  <entry>
    <title>AJAX_JSON</title>
    <url>/2020/08/07/AJAX-JSON/</url>
    <content><![CDATA[<h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>ASynchronous JavaScript And XML    异步的JavaScript 和 XML
</code></pre><h3 id="1-异步和同步：客户端和服务器端相互通信的基础上"><a href="#1-异步和同步：客户端和服务器端相互通信的基础上" class="headerlink" title="1. 异步和同步：客户端和服务器端相互通信的基础上"></a>1. 异步和同步：客户端和服务器端相互通信的基础上</h3><pre><code>        * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。
        * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。

        Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 
        通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

        提升用户的体验
</code></pre><p><img src="/2020/08/07/AJAX-JSON/1.同步和异步.bmp" alt="1.同步和异步"></p>
<a id="more"></a>
<h2 id="二、实现方式："><a href="#二、实现方式：" class="headerlink" title="二、实现方式："></a>二、实现方式：</h2><h3 id="1-原生的JS实现方式（了解）"><a href="#1-原生的JS实现方式（了解）" class="headerlink" title="1. 原生的JS实现方式（了解）"></a>1. 原生的JS实现方式（了解）</h3><pre><code>                 //1.创建核心对象
                var xmlhttp;
                if (window.XMLHttpRequest)
                {// code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp=new XMLHttpRequest();
                }
                else
                {// code for IE6, IE5
                    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                }

                //2. 建立连接
                /*
                    参数：
                        1. 请求方式：GET、POST
                            * get方式，请求参数在URL后边拼接。send方法为空参
                            * post方式，请求参数在send方法中定义
                        2. 请求的URL：
                        3. 同步或异步请求：true（异步）或 false（同步）

                 */
                xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);

                //3.发送请求
                xmlhttp.send();

                //4.接受并处理来自服务器的响应结果
                //获取方式 ：xmlhttp.responseText
                //什么时候获取？当服务器响应成功后再获取

                //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。
                xmlhttp.onreadystatechange=function()
                {
                    //判断readyState就绪状态是否为4，判断status响应状态码是否为200
                    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
                    {
                       //获取服务器的响应结果
                        var responseText = xmlhttp.responseText;
                        alert(responseText);
                    }
                }
</code></pre><h3 id="2-JQeury实现方式"><a href="#2-JQeury实现方式" class="headerlink" title="2. JQeury实现方式"></a>2. JQeury实现方式</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">* 语法：$.ajax(&#123;键值对&#125;);</span><br><span class="line"> <span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">              url:"ajaxServlet1111" , // 请求路径</span><br><span class="line">              type:"POST" , //请求方式</span><br><span class="line">              <span class="comment">//data: "username=jack&amp;age=23",//请求参数</span></span><br><span class="line">              data:&#123;"username":"jack","age":23&#125;,</span><br><span class="line">              success:function (data) &#123;</span><br><span class="line">                  alert(data);</span><br><span class="line">              &#125;,//响应成功后的回调函数</span><br><span class="line">              error:function () &#123;</span><br><span class="line">                  alert("出错啦...")</span><br><span class="line">              &#125;,//表示如果请求响应出现错误，会执行的回调函数</span><br><span class="line">	</span><br><span class="line">              dataType:"text"//设置接受到的响应数据的格式</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="get-：发送get请求"><a href="#get-：发送get请求" class="headerlink" title="$.get()：发送get请求"></a>$.get()：发送get请求</h4><pre><code>            * 语法：$.get(url, [data], [callback], [type])
                * 参数：
                    * url：请求路径
                    * data：请求参数
                    * callback：回调函数
                    * type：响应结果的类型
</code></pre><h4 id="post-：发送post请求"><a href="#post-：发送post请求" class="headerlink" title="$.post()：发送post请求"></a>$.post()：发送post请求</h4><pre><code>            * 语法：$.post(url, [data], [callback], [type])
                * 参数：
                    * url：请求路径
                    * data：请求参数
                    * callback：回调函数
                    * type：响应结果的类型
</code></pre><h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><h2 id="一、概念-1"><a href="#一、概念-1" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>JavaScript Object Notation        JavaScript对象表示法
    Person p = new Person();
    p.setName(&quot;张三&quot;);
    p.setAge(23);
    p.setGender(&quot;男&quot;);

    var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;};

    * json现在多用于存储和交换文本信息的语法
    * 进行数据的传输
    * JSON 比 XML 更小、更快，更易解析。
</code></pre><h2 id="二、语法："><a href="#二、语法：" class="headerlink" title="二、语法："></a>二、语法：</h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><pre><code>        * 数据在名称/值对中：json数据是由键值对构成的
            * 键用引号(单双都行)引起来，也可以不使用引号
            * 值得取值类型：
                1. 数字（整数或浮点数）
                2. 字符串（在双引号中）
                3. 逻辑值（true 或 false）
                4. 数组（在方括号中）    {&quot;persons&quot;:[{},{}]}
                5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}}
                6. null
        * 数据由逗号分隔：多个键值对由逗号分隔
        * 花括号保存对象：使用{}定义json 格式
        * 方括号保存数组：[]
</code></pre><h3 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据:"></a>2. 获取数据:</h3><pre><code>        1. json对象.键名
        2. json对象[&quot;键名&quot;]
        3. 数组对象[索引]
        4. 遍历
                 //1.定义基本格式
                var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &#39;gender&#39;: true};

                var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true},
                    {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true},
                    {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}];
                //获取person对象中所有的键和值
                //for in 循环
               /* for(var key in person){
                    //这样的方式获取不行。因为相当于  person.&quot;name&quot;
                    //alert(key + &quot;:&quot; + person.key);
                    alert(key+&quot;:&quot;+person[key]);
                }*/

               //获取ps中的所有值
                for (var i = 0; i &lt; ps.length; i++) {
                    var p = ps[i];
                    for(var key in p){
                        alert(key+&quot;:&quot;+p[key]);
                    }
                }
</code></pre><h2 id="三、JSON数据和Java对象的相互转换"><a href="#三、JSON数据和Java对象的相互转换" class="headerlink" title="三、JSON数据和Java对象的相互转换"></a>三、JSON数据和Java对象的相互转换</h2><pre><code>    * JSON解析器：
        * 常见的解析器：Jsonlib，Gson，fastjson，jackson
</code></pre><h3 id="1-JSON转为Java对象"><a href="#1-JSON转为Java对象" class="headerlink" title="1. JSON转为Java对象"></a>1. JSON转为Java对象</h3><pre><code>        1. 导入jackson的相关jar包
        2. 创建Jackson核心对象 ObjectMapper
        3. 调用ObjectMapper的相关方法进行转换
            1. readValue(json字符串数据,Class)
</code></pre><h3 id="2-Java对象转换JSON"><a href="#2-Java对象转换JSON" class="headerlink" title="2. Java对象转换JSON"></a>2. Java对象转换JSON</h3><pre><code>        1. 使用步骤：
            1. 导入jackson的相关jar包
            2. 创建Jackson核心对象 ObjectMapper
            3. 调用ObjectMapper的相关方法进行转换
                1. 转换方法：
                    * writeValue(参数1，obj):
                        参数1：
                            File：将obj对象转换为JSON字符串，并保存到指定的文件中
                            Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
                            OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中
                    * writeValueAsString(obj):将对象转为json字符串

                2. 注解：
                    1. @JsonIgnore：排除属性。
                    2. @JsonFormat：属性值得格式化
                        * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)

                3. 复杂java对象转换
                    1. List：数组
                    2. Map：对象格式一致
</code></pre><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 校验用户名是否存在
    1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：
        1. $.get(type):将最后一个参数type指定为&quot;json&quot;
        2. 在服务器端设置MIME类型
            response.setContentType(&quot;application/json;charset=utf-8&quot;);
</code></pre>]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/07/14/Collections/</url>
    <content><![CDATA[<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</E></p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<a id="more"></a>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="/2020/07/14/Collections/Collection集合体系图.png" alt></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">"小李广"</span>);</span><br><span class="line">    	coll.add(<span class="string">"扫地僧"</span>);</span><br><span class="line">    	coll.add(<span class="string">"石破天"</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">"判断  扫地僧 是否在集合中"</span>+coll.contains(<span class="string">"扫地僧"</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">"删除石破天："</span>+coll.remove(<span class="string">"石破天"</span>));</span><br><span class="line">    	System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h1 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p><img src="/2020/07/14/Collections/image-20200713221746680.png" alt="image-20200713221746680"></p>
<p><img src="/2020/07/14/Collections/image-20200713221902199.png" alt="image-20200713221902199"></p>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="/2020/07/14/Collections/迭代器原理图.bmp" alt></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<p><img src="/2020/07/14/Collections/image-20200713222654725.png" alt="image-20200713222654725"></p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">"小河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"老河神"</span>);</span><br><span class="line">    	coll.add(<span class="string">"神婆"</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-数据结构"><a href="#第三章-数据结构" class="headerlink" title="第三章 数据结构"></a>第三章 数据结构</h1><h2 id="3-1-数据结构有什么用？"><a href="#3-1-数据结构有什么用？" class="headerlink" title="3.1 数据结构有什么用？"></a>3.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<p><img src="/2020/07/14/Collections/数据结构比喻.png" alt></p>
<h2 id="3-2-常见的数据结构"><a href="#3-2-常见的数据结构" class="headerlink" title="3.2 常见的数据结构"></a>3.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
<p><img src="/2020/07/14/Collections/堆栈.png" alt></p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<p><img src="/2020/07/14/Collections/队列图.bmp" alt></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
<p><img src="/2020/07/14/Collections/数组查询快.png" alt></p>
</li>
<li><p>增删元素慢</p>
<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="/2020/07/14/Collections/数组添加.png" alt></li>
<li><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/2020/07/14/Collections/数组删除.png" alt></li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<p><img src="/2020/07/14/Collections/单链表结构特点.png" alt></p>
</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p><img src="/2020/07/14/Collections/单链表结构.png" alt></p>
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/2020/07/14/Collections/增加结点.png" alt></p>
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/2020/07/14/Collections/删除结点.bmp" alt></p>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<p><img src="/2020/07/14/Collections/二叉树.bmp" alt></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
</ol>
<ol>
<li>根节点是黑色的</li>
</ol>
<ol>
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
<p>红黑树的特点:</p>
<pre><code>速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍
</code></pre><h1 id="第四章-List集合"><a href="#第四章-List集合" class="headerlink" title="第四章 List集合"></a>第四章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p>
<p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="4-1-List接口介绍"><a href="#4-1-List接口介绍" class="headerlink" title="4.1 List接口介绍"></a>4.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="4-2-List接口中常用方法"><a href="#4-2-List接口中常用方法" class="headerlink" title="4.2 List接口中常用方法"></a>4.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p><img src="/2020/07/14/Collections/image-20200714085253907.png" alt="image-20200714085253907"></p>
<p><img src="/2020/07/14/Collections/image-20200714085806030.png" alt="image-20200714085806030"></p>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">"图图"</span>);</span><br><span class="line">    	list.add(<span class="string">"小美"</span>);</span><br><span class="line">    	list.add(<span class="string">"不高兴"</span>);x</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">"没头脑"</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素  </span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第五章-List的子类"><a href="#第五章-List的子类" class="headerlink" title="第五章 List的子类"></a>第五章 List的子类</h1><h2 id="5-1-ArrayList集合"><a href="#5-1-ArrayList集合" class="headerlink" title="5.1 ArrayList集合"></a>5.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p><span style="color:red">通过查看源码就发现每次增删用<code>ArrayList</code>都会在系统底层复制一遍再增删。</span></p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="5-2-LinkedList集合"><a href="#5-2-LinkedList集合" class="headerlink" title="5.2 LinkedList集合"></a>5.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p><img src="/2020/07/14/Collections/双向链表.png" alt></p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<p><img src="/2020/07/14/Collections/image-20200714091240166.png" alt="image-20200714091240166"></p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素        <span style="color:red">相当于<code>removeFirst</code></span></li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈        </li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">"abc1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-Vector-集合"><a href="#5-3-Vector-集合" class="headerlink" title="5.3 Vector 集合"></a>5.3 Vector 集合</h2><p>jdk1.1时期的；它是同步的，速度比<code>ArrayList</code>要慢。因为它更早，早于迭代器出现的时间，所以早期它迭代用的是把元素转成枚举类型再进行迭代，<code>Elements</code>方法；</p>
<h1 id="第六章-Set接口"><a href="#第六章-Set接口" class="headerlink" title="第六章 Set接口"></a>第六章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="6-1-HashSet集合介绍"><a href="#6-1-HashSet集合介绍" class="headerlink" title="6.1 HashSet集合介绍"></a>6.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">"cba"</span>));</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"bac"</span>); </span><br><span class="line">        set.add(<span class="string">"cba"</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>)</span><br><span class="line">        Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            Interge n = it.next();</span><br><span class="line">            System.out.println(n)	<span class="comment">// 1,2,3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="6-2-HashSet集合存储数据的结构（哈希表）"><a href="#6-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="6.2  HashSet集合存储数据的结构（哈希表）"></a>6.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p><img src="/2020/07/14/Collections/image-20200714103345777.png" alt="image-20200714103345777"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zenner.Demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写的Person类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写hashcode</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zenner.Demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h1 = p1.hashCode();</span><br><span class="line">        System.out.println(h1); <span class="comment">//189568618</span></span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> h2 = p2.hashCode();</span><br><span class="line">        System.out.println(h2); <span class="comment">//793589513</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            toString方法的源码</span></span><br><span class="line"><span class="comment">                return getclass().getName() + "@" + Integer.toHexString(hashcode())</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(p1); <span class="comment">// com.zenner.Demo.Person@b4c966a (189568618 的十六进制) //com.zenner.Demo.Person@1</span></span><br><span class="line">        System.out.println(p2); <span class="comment">// com.zenner.Demo.Person@2f4d3709  //com.zenner.Demo.Person@1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            字符串哈希值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(s1.hashCode());  <span class="comment">// 96354</span></span><br><span class="line">        System.out.println(s2.hashCode());  <span class="comment">// 96354</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">189568618</span></span><br><span class="line"><span class="comment">793589513</span></span><br><span class="line"><span class="comment">com.zenner.Demo.Person@b4c966a</span></span><br><span class="line"><span class="comment">com.zenner.Demo.Person@2f4d3709</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p><img src="/2020/07/14/Collections/image-20200714104748790.png" alt="image-20200714104748790"></p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p>
<p><img src="/2020/07/14/Collections/哈希表.png" alt></p>
<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<p><img src="/2020/07/14/Collections/哈希流程图.png" alt></p>
<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="6-3-HashSet存储自定义类型元素"><a href="#6-3-HashSet存储自定义类型元素" class="headerlink" title="6.3  HashSet存储自定义类型元素"></a>6.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 </p>
<p><img src="/2020/07/14/Collections/image-20200714111613117.png" alt="image-20200714111613117"></p>
<p>创建自定义Student类 ：<code>ALt+insert</code>选<code>hashcode and equals</code>可自动生成类的比较这两个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭德纲"</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"于谦"</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">"郭麒麟"</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>
<h2 id="6-3-LinkedHashSet-（有序，不允许重复的结构）"><a href="#6-3-LinkedHashSet-（有序，不允许重复的结构）" class="headerlink" title="6.3 LinkedHashSet （有序，不允许重复的结构）"></a>6.3 LinkedHashSet （有序，不允许重复的结构）</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">"bbb"</span>);</span><br><span class="line">		set.add(<span class="string">"aaa"</span>);</span><br><span class="line">		set.add(<span class="string">"abc"</span>);</span><br><span class="line">		set.add(<span class="string">"bbc"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>
<h2 id="6-9-可变参数"><a href="#6-9-可变参数" class="headerlink" title="6.9  可变参数"></a>6.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>
<p>其实这个书写完全等价与</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>
<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第七章-集合"><a href="#第七章-集合" class="headerlink" title="第七章  集合"></a>第七章  集合</h1><h2 id="7-1-常用功能"><a href="#7-1-常用功能" class="headerlink" title="7.1 常用功能"></a>7.1 常用功能</h2><ul>
<li><code>java.utils.集合</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 集合<span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        集合.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        集合.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>
<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="7-2-Comparator比较器"><a href="#7-2-Comparator比较器" class="headerlink" title="7.2 Comparator比较器"></a>7.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 集合<span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        集合.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>
<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 集合<span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        集合.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>
<h2 id="7-3-简述Comparable和Comparator两个接口的区别。"><a href="#7-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="7.3 简述Comparable和Comparator两个接口的区别。"></a>7.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过集合.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如集合.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="7-4-练习：使用Comparable比较自定义对象"><a href="#7-4-练习：使用Comparable比较自定义对象" class="headerlink" title="7.4  练习：使用Comparable比较自定义对象"></a>7.4  练习：使用Comparable比较自定义对象</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">               <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", age="</span> + age +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"rose"</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"jack"</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"abc"</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"ace"</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"mark"</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        集合.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现，当我们调用集合.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">'jack'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'abc'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'mark'</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'ace'</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">'rose'</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-扩展：用Comparator增加一种临时的比较机制"><a href="#2-5-扩展：用Comparator增加一种临时的比较机制" class="headerlink" title="2.5 扩展：用Comparator增加一种临时的比较机制"></a>2.5 扩展：用Comparator增加一种临时的比较机制</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用集合.sort(List list,Comparetor<T> c)方式，自己定义规则：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">集合.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">集合.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;</span><br><span class="line">Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第八章-集合工具类"><a href="#第八章-集合工具类" class="headerlink" title="第八章 集合工具类"></a>第八章 集合工具类</h1><h2 id="8-1-Stack栈操作"><a href="#8-1-Stack栈操作" class="headerlink" title="8.1 Stack栈操作"></a>8.1 Stack栈操作</h2><p>Java里面使用Stack来描述栈的操作，这个类定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以发现Stack是Vector的子类，但它使用的并不是Vector提供的方法；</p>
<ul>
<li><code>public E push(E item)</code>：入栈</li>
<li><code>public E pop()</code>： 出栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Stack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; all = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        all.push(<span class="string">"A"</span>);</span><br><span class="line">        all.push(<span class="string">"B"</span>);</span><br><span class="line">        all.push(<span class="string">"C"</span>);</span><br><span class="line">        System.out.println(all.pop());	<span class="comment">// C</span></span><br><span class="line">        System.out.println(all.pop());	<span class="comment">// B</span></span><br><span class="line">        System.out.println(all.pop());	<span class="comment">// A</span></span><br><span class="line">        System.out.println(all.pop());  <span class="comment">// 无数据。EmptyStackException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-Queue队列"><a href="#8-2-Queue队列" class="headerlink" title="8.2 Queue队列"></a>8.2 Queue队列</h2><p><img src="/2020/07/14/Collections/image-20200715103518929.png" alt="image-20200715103518929"></p>
<p>如果将队列应用在多线程的“生产者与消费者”的模型处理上，那么对于生产者过快的情况下，就没有必要等待消费者获取数据了。可以将所有的数据先保存在队列当中。 </p>
<p>队列的实现可以用LinkedList子类来完成。</p>
<p><img src="/2020/07/14/Collections/image-20200715103932152.png" alt="image-20200715103932152"></p>
<ul>
<li><code>public boolean offer(E e)</code>： 向队列之中追加数据，也可以直接使用<code>add</code>方法</li>
<li><code>public E poll()</code>： 弹出队头并删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.offer(<span class="string">"X"</span>);</span><br><span class="line">        queue.offer(<span class="string">"A"</span>);</span><br><span class="line">        queue.offer(<span class="string">"Z"</span>);</span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// X</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// A</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// Z</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了LinkedList子类之外，还有一个优先级队列的概念，可以使用 <code>PriorityQueue</code></p>
<p><img src="/2020/07/14/Collections/image-20200715110200190.png" alt="image-20200715110200190"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;String&gt;();</span><br><span class="line">        queue.offer(<span class="string">"X"</span>);</span><br><span class="line">        queue.offer(<span class="string">"A"</span>);</span><br><span class="line">        queue.offer(<span class="string">"Z"</span>);</span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// A</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// X</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// Z</span></span><br><span class="line">        System.out.println(queue.poll());   <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-Properties属性操作"><a href="#8-3-Properties属性操作" class="headerlink" title="8.3 Properties属性操作"></a>8.3 Properties属性操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Properties</span> <span class="keyword">extends</span> <span class="title">Hashtable</span>&lt;<span class="title">Object</span>,​<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Properties</code>只能操作的类型是<code>String</code>类型，在<code>Properties</code>之中如果想要实现属性的操作可以采用如下的方法来实现。</p>
<ul>
<li><code>public String getProperty(String key)</code> :  取得属性</li>
<li><p><code>public Object setProperty(String key, String value)</code> : 设置属性</p>
</li>
<li><p><code>public String getProperty(String key,String defaultValue)</code> : 取得属性，不存在返回默认值</p>
</li>
<li><p><code>public void store(OutputStream out, String comments) throws IOException</code> ： 存储属性内容</p>
</li>
<li><code>public void load(InputStream inStream) throws IOException</code> ： 通过输入流读取属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Properties</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">"zenner"</span>,<span class="string">"zenner006.github.io"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"巨饼"</span>,<span class="string">"9.9毛钱"</span>);</span><br><span class="line">        System.out.println(prop.getProperty(<span class="string">"zenner"</span>)); <span class="comment">// zenner006.github.io</span></span><br><span class="line">        System.out.println(prop.getProperty(<span class="string">"sina"</span>,<span class="string">"NoFound"</span>)); <span class="comment">// NoFound</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类只能操作字符串，而Map则能操作的就很多。但是Properties可以通过输出输入流处理属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04PropertiesToFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Properties类与文件操作</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">"zenner"</span>,<span class="string">"zenner006.github.io"</span>);</span><br><span class="line">        prop.setProperty(<span class="string">"巨饼"</span>,<span class="string">"9.9毛钱"</span>);</span><br><span class="line">        prop.store(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"./info.properties"</span>)),</span><br><span class="line">                <span class="string">"Something all is well"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Something all is well</span></span><br><span class="line"><span class="comment">#Wed Jul 15 11:29:16 CST 2020</span></span><br><span class="line">zenner=zenner006.github.io</span><br><span class="line">\u5DE8\u997C=9.9\u6BDB\u94B1</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05PropertiesLoadFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"./info.properties"</span>)));</span><br><span class="line">        System.out.println(prop.getProperty(<span class="string">"zenner"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-Collections-工具类（注意不是Collection）"><a href="#8-4-Collections-工具类（注意不是Collection）" class="headerlink" title="8.4 Collections 工具类（注意不是Collection）"></a>8.4 Collections 工具类（注意不是Collection）</h2><p><code>Collections</code>是java提供的一组集合数据的操作工具类，也就是说利用它可以实现各个集合的操作。</p>
<p><img src="/2020/07/14/Collections/image-20200715113720649.png" alt="image-20200715113720649"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Collections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Collections处理list集合</span></span><br><span class="line">        List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collections.addAll(all,<span class="string">"Hello"</span>,<span class="string">"world"</span>,<span class="string">"today"</span>);</span><br><span class="line">        System.out.println(all);    <span class="comment">//[Hello, world, today]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现数据反转</span></span><br><span class="line">        Collections.reverse(all);</span><br><span class="line">        System.out.println(all);    <span class="comment">// [today, world, Hello]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        System.out.println(Collections.binarySearch(all, <span class="string">"R"</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(Collections.binarySearch(all, <span class="string">"Hello"</span>)); <span class="comment">// -1 不排序返回-1</span></span><br><span class="line">        Collections.sort(all);</span><br><span class="line">        System.out.println(all);    <span class="comment">// [Hello, today, world]</span></span><br><span class="line">        System.out.println(Collections.binarySearch(all, <span class="string">"Hello"</span>)); <span class="comment">// 0    排序后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Collection是集合接口，允许保存单值对象</li>
<li>Collections是集合操作的工具类。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title>Cookie_Session_JSP</title>
    <url>/2020/08/02/Cookie-Session-JSP/</url>
    <content><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><pre><code>1. 会话：一次会话中包含多次请求和响应。
    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止
2. 功能：在一次会话的范围内的多次请求间，共享数据
3. 方式：
    1. 客户端会话技术：Cookie
    2. 服务器端会话技术：Session
</code></pre><a id="more"></a>
<h1 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>客户端会话技术，将数据保存到客户端
</code></pre><h2 id="二、-快速入门："><a href="#二、-快速入门：" class="headerlink" title="二、 快速入门："></a>二、 快速入门：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 使用步骤：</span><br><span class="line">	<span class="number">1</span>. 创建Cookie对象，绑定数据</span><br><span class="line">		* <span class="keyword">new</span> Cookie(String name, String value) </span><br><span class="line">	<span class="number">2</span>. 发送Cookie对象</span><br><span class="line">		* response.addCookie(Cookie cookie) </span><br><span class="line">	<span class="number">3</span>. 获取Cookie，拿到数据</span><br><span class="line">		* Cookie[]  request.getCookies()</span><br></pre></td></tr></table></figure>
<h2 id="三、实现原理"><a href="#三、实现原理" class="headerlink" title="三、实现原理"></a>三、实现原理</h2><pre><code>    * 基于响应头set-cookie和请求头cookie实现
    * 响应头里的set-cookie会使得客户端自动保存cookie内容

    * 然后浏览器再次请求的请求头里就有一个 Cookie: msg=hello
</code></pre><p><img src="/2020/08/02/Cookie-Session-JSP/image-20200802101026624.png" alt="image-20200802101026624"></p>
<h2 id="四、cookie的细节"><a href="#四、cookie的细节" class="headerlink" title="四、cookie的细节"></a>四、cookie的细节</h2><h3 id="1-一次可不可以发送多个cookie"><a href="#1-一次可不可以发送多个cookie" class="headerlink" title="1. 一次可不可以发送多个cookie?"></a>1. 一次可不可以发送多个cookie?</h3><pre><code>        * 可以
        * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。
</code></pre><h3 id="2-cookie在浏览器中保存多长时间？"><a href="#2-cookie在浏览器中保存多长时间？" class="headerlink" title="2. cookie在浏览器中保存多长时间？"></a>2. cookie在浏览器中保存多长时间？</h3><pre><code>        1. 默认情况下，当浏览器关闭后，Cookie数据被销毁
        2. 持久化存储：
            * setMaxAge(int seconds)
                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
                2. 负数：默认值
                3. 零：删除cookie信息
</code></pre><h3 id="3-cookie能不能存中文？"><a href="#3-cookie能不能存中文？" class="headerlink" title="3. cookie能不能存中文？"></a>3. cookie能不能存中文？</h3><pre><code>        * 在tomcat 8 之前 cookie中不能直接存储中文数据。
            * 需要将中文数据转码---一般采用URL编码(%E3)
        * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析
</code></pre><h3 id="4-cookie共享问题？"><a href="#4-cookie共享问题？" class="headerlink" title="4. cookie共享问题？"></a>4. cookie共享问题？</h3><pre><code>        1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
            * 默认情况下cookie不能共享

            * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
                * 如果要共享，则可以将path设置为&quot;/&quot;
        2. 不同的tomcat服务器间cookie共享问题？
            * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
                * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享
</code></pre><h2 id="五、Cookie的特点和作用"><a href="#五、Cookie的特点和作用" class="headerlink" title="五、Cookie的特点和作用"></a>五、Cookie的特点和作用</h2><pre><code>    1. cookie存储数据在客户端浏览器：容易丢失也容易被篡改
    2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)

    * 作用：
        1. cookie一般用于存出少量的不太敏感的数据
        2. 在不登录的情况下，完成服务器对客户端的身份识别
</code></pre><h2 id="六、案例：记住上一次访问时间"><a href="#六、案例：记住上一次访问时间" class="headerlink" title="六、案例：记住上一次访问时间"></a>六、案例：记住上一次访问时间</h2><h3 id="1-需求："><a href="#1-需求：" class="headerlink" title="1. 需求："></a>1. 需求：</h3><pre><code>        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。
        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串
</code></pre><h3 id="2-分析："><a href="#2-分析：" class="headerlink" title="2. 分析："></a>2. 分析：</h3><pre><code>        1. 可以采用Cookie来完成
        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie
            1. 有：不是第一次访问
                1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20
                2. 写回Cookie：lastTime=2018年6月10日11:50:01
            2. 没有：是第一次访问
                1. 响应数据：您好，欢迎您首次访问
                2. 写回Cookie：lastTime=2018年6月10日11:50:01
</code></pre><h3 id="3-代码实现："><a href="#3-代码实现：" class="headerlink" title="3. 代码实现："></a>3. 代码实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">package</span> cn.itcast.cookie;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">	<span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">	<span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line">	<span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">	<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">	<span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">	<span class="keyword">import</span> java.io.IOException;</span><br><span class="line">	<span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line">	<span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line">	<span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line">	<span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/cookieTest"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应的消息体的数据格式以及编码</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取所有Cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//没有cookie为lastTime</span></span><br><span class="line">        <span class="comment">//2.遍历cookie数组</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="comment">//3.获取cookie的名称</span></span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="comment">//4.判断名称是否是：lastTime</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"lastTime"</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//有该Cookie，不是第一次访问</span></span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">true</span>;<span class="comment">//有lastTime的cookie</span></span><br><span class="line">					</span><br><span class="line">                       <span class="comment">//响应数据</span></span><br><span class="line">                    <span class="comment">//获取Cookie的value，时间</span></span><br><span class="line">                    String value = cookie.getValue();</span><br><span class="line">                    System.out.println(<span class="string">"解码前："</span>+value);</span><br><span class="line">                    <span class="comment">//URL解码：</span></span><br><span class="line">                    value = URLDecoder.decode(value,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"解码后："</span>+value);</span><br><span class="line">                    response.getWriter().write(<span class="string">"&lt;h1&gt;欢迎回来，您上次访问时间为:"</span>+value+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">                       </span><br><span class="line">                    <span class="comment">//设置Cookie的value</span></span><br><span class="line">                    <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">                    Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">                    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">                    String str_date = sdf.format(date);</span><br><span class="line">                    System.out.println(<span class="string">"编码前："</span>+str_date);</span><br><span class="line">                    <span class="comment">//URL编码</span></span><br><span class="line">                    str_date = URLEncoder.encode(str_date,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"编码后："</span>+str_date);</span><br><span class="line">                    cookie.setValue(str_date);</span><br><span class="line">                    <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                 </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length == <span class="number">0</span> || flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="comment">//没有，第一次访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Cookie的value</span></span><br><span class="line">            <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">            Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">            String str_date = sdf.format(date);</span><br><span class="line">            System.out.println(<span class="string">"编码前："</span>+str_date);</span><br><span class="line">            <span class="comment">//URL编码</span></span><br><span class="line">            str_date = URLEncoder.encode(str_date,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"编码后："</span>+str_date);</span><br><span class="line"></span><br><span class="line">            Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"lastTime"</span>,str_date);</span><br><span class="line">            <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">            cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">            response.getWriter().write(<span class="string">"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h1><h2 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h2><pre><code>    * Java Server Pages： java服务器端页面
        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码
        * 用于简化书写！！！
</code></pre><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><pre><code>    * JSP本质上就是一个Servlet
</code></pre><p><img src="/2020/08/02/Cookie-Session-JSP/image-20200802111153121.png" alt="image-20200802111153121"></p>
<h2 id="三、JSP的脚本：JSP定义Java代码的方式"><a href="#三、JSP的脚本：JSP定义Java代码的方式" class="headerlink" title="三、JSP的脚本：JSP定义Java代码的方式"></a>三、JSP的脚本：JSP定义Java代码的方式</h2><pre><code>    1. &lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。
    2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。
    3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。
</code></pre><h2 id="四、JSP的内置对象："><a href="#四、JSP的内置对象：" class="headerlink" title="四、JSP的内置对象："></a>四、JSP的内置对象：</h2><pre><code>    * 在jsp页面中不需要获取和创建，可以直接使用的对象
    * jsp一共有9个内置对象。
    * 今天学习3个：
        * request
        * response
        * out：字符输出流对象。可以将数据输出到页面上。和 response.getWriter() 类似
            * response.getWriter()和out.write()的区别：
                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。
                * response.getWriter()数据输出永远在out.write()之前
</code></pre><h2 id="五、案例-改造Cookie案例"><a href="#五、案例-改造Cookie案例" class="headerlink" title="五、案例:改造Cookie案例"></a>五、案例:改造Cookie案例</h2><h1 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h1><h2 id="一、概念-1"><a href="#一、概念-1" class="headerlink" title="一、概念"></a>一、概念</h2><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
<h2 id="二、快速入门："><a href="#二、快速入门：" class="headerlink" title="二、快速入门："></a>二、快速入门：</h2><pre><code>    1. 获取HttpSession对象：
        HttpSession session = request.getSession();
    2. 使用HttpSession对象：
        Object getAttribute(String name)  
        void setAttribute(String name, Object value)
        void removeAttribute(String name)  
</code></pre><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><pre><code>    * Session的实现是依赖于Cookie的。
    * 把Session对象生成的id通过Cookie响应给浏览器，然后浏览器再传回服务器，谁要获取Session就能通过Cookie中保存的id获取
</code></pre><p>​    <img src="/2020/08/02/Cookie-Session-JSP/image-20200802112904671.png" alt="image-20200802112904671"></p>
<h2 id="四、细节："><a href="#四、细节：" class="headerlink" title="四、细节："></a>四、细节：</h2><h3 id="1-当客户端关闭后，服务器不关闭，两次获取session是否为同一个？"><a href="#1-当客户端关闭后，服务器不关闭，两次获取session是否为同一个？" class="headerlink" title="1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？"></a>1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</h3><pre><code>        * 默认情况下。不是。
        * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
             Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());
             c.setMaxAge(60*60);
             response.addCookie(c);
</code></pre><h3 id="2-客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"><a href="#2-客户端不关闭，服务器关闭后，两次获取的session是同一个吗？" class="headerlink" title="2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"></a>2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</h3><pre><code>        * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作
            * session的钝化：
                * 在服务器正常关闭之前，将session对象系列化到硬盘上
            * session的活化：
                * 在服务器启动后，将session文件转化为内存中的session对象即可。
</code></pre><h3 id="3-session什么时候被销毁？"><a href="#3-session什么时候被销毁？" class="headerlink" title="3. session什么时候被销毁？"></a>3. session什么时候被销毁？</h3><pre><code>        1. 服务器关闭
        2. session对象调用invalidate() 。
        3. session默认失效时间 30分钟
            选择性配置修改    
            &lt;session-config&gt;
                &lt;session-timeout&gt;30&lt;/session-timeout&gt;
            &lt;/session-config&gt;
</code></pre><h2 id="五、session的特点"><a href="#五、session的特点" class="headerlink" title="五、session的特点"></a>五、session的特点</h2><pre><code>     1. session用于存储一次会话的多次请求的数据，存在服务器端
     2. session可以存储任意类型，任意大小的数据

    * session与Cookie的区别：
        1. session存储数据在服务器端，Cookie在客户端
        2. session没有数据大小限制，Cookie有
        3. session数据安全，Cookie相对于不安全
</code></pre><h1 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h1><pre><code>1. 案例需求：
    1. 访问带有验证码的登录页面login.jsp
    2. 用户输入用户名，密码以及验证码。
        * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误
        * 如果验证码输入有误，跳转登录页面，提示：验证码错误
        * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您


2. 分析：
</code></pre><p>​    </p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2020/07/17/Databases/</url>
    <content><![CDATA[<h1 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h1><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB
2. 什么数据库？
    * 用于存储和管理数据的仓库。

3. 数据库的特点：
    1. 持久化存储数据的。其实数据库就是一个文件系统
    2. 方便存储和管理数据
    3. 使用了统一的方式操作数据库 -- SQL
</code></pre><a id="more"></a>
<pre><code>4. 常见的数据库软件
    * 参见《MySQL基础.pdf》
</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><pre><code>1. 安装
    * 参见《MySQL基础.pdf》
2. 卸载
    1. 去mysql的安装目录找到my.ini文件
        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
    2. 卸载MySQL
    3. 删除C:/ProgramData目录下的MySQL文件夹。

3. 配置
    * MySQL服务启动
        1. 手动。
        2. cmd--&gt; services.msc 打开服务的窗口
        3. 使用管理员打开cmd
            * net start mysql : 启动mysql的服务
            * net stop mysql:关闭mysql服务
    * MySQL登录
        1. mysql -uroot -p密码
        2. mysql -h[ip] -uroot -p连接目标的密码
        3. mysql --host=ip --user=root --password=连接目标的密码
    * MySQL退出
        1. exit
        2. quit

    * MySQL目录结构
        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;
            * 配置文件 my.ini
        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;
            * 几个概念
                * 数据库：文件夹
                * 表：文件
                * 数据：数据
</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？
    Structured Query Language：结构化查询语言
    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。

2.SQL通用语法
    1. SQL 语句可以单行或多行书写，以分号结尾。
    2. 可使用空格和缩进来增强语句的可读性。
    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
    4. 3 种注释
        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) （--后应有空格才起作用）
        * 多行注释: /* 注释 */

3. SQL分类
    1) DDL(Data Definition Language)数据定义语言
        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
    2) DML(Data Manipulation Language)数据操作语言
        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
    3) DQL(Data Query Language)数据查询语言
        用来查询数据库中表的记录(数据)。关键字：select, where 等
    4) DCL(Data Control Language)数据控制语言(了解)
        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等
</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><h3 id="一、操作数据库：CRUD"><a href="#一、操作数据库：CRUD" class="headerlink" title="一、操作数据库：CRUD"></a>一、操作数据库：CRUD</h3><h4 id="1-C-Create-创建"><a href="#1-C-Create-创建" class="headerlink" title="1. C(Create):创建"></a>1. C(Create):创建</h4><pre><code>        * 创建数据库：
            * create database 数据库名称;
        * 创建数据库，判断不存在，再创建：
            * create database if not exists 数据库名称;
        * 创建数据库，并指定字符集 
            * create database 数据库名称 character set 字符集名;

        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
            * create database if not exists db4 character set gbk;
</code></pre><h4 id="2-R-Retrieve-：查询"><a href="#2-R-Retrieve-：查询" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><pre><code>        * 查询所有数据库的名称:
            * show databases;
        * 查询某个数据库的字符集:查询某个数据库的创建语句
            * show create database 数据库名称;
</code></pre><h4 id="3-U-Update-修改"><a href="#3-U-Update-修改" class="headerlink" title="3. U(Update):修改"></a>3. U(Update):修改</h4><pre><code>        * 修改数据库的字符集
            * alter database 数据库名称 character set 字符集名称;
</code></pre><h4 id="4-D-Delete-删除"><a href="#4-D-Delete-删除" class="headerlink" title="4. D(Delete):删除"></a>4. D(Delete):删除</h4><pre><code>        * 删除数据库
            * drop database 数据库名称;
        * 判断数据库存在，存在再删除
            * drop database if exists 数据库名称;
</code></pre><h4 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5. 使用数据库"></a>5. 使用数据库</h4><pre><code>        * 查询当前正在使用的数据库名称
            * select database();
        * 使用数据库
            * use 数据库名称;
</code></pre><h3 id="二、操作表"><a href="#二、操作表" class="headerlink" title="二、操作表"></a>二、操作表</h3><h4 id="1-C-Create-创建-1"><a href="#1-C-Create-创建-1" class="headerlink" title="1. C(Create):创建"></a>1. C(Create):创建</h4><pre><code>        1. 语法：
            create table 表名(
                列名1 数据类型1,
                列名2 数据类型2,
                ....
                列名n 数据类型n
            );
            * 注意：最后一列，不需要加逗号（,）

            * 数据库类型：
                1. int：整数类型
                    * age int,
                2. double:小数类型
                    * score double(5,2)
                3. date:日期，只包含年月日，yyyy-MM-dd
                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss
                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss     
                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值
                6. varchar：字符串
                    * name varchar(20):姓名最大20个字符
                    * zhangsan 8个字符  张三 2个字符
        * 创建表
            create table student(
                id int,
                name varchar(32),
                age int ,
                score double(4,1),
                birthday date,
                insert_time timestamp
            );
        * 复制表：
            * create table 表名 like 被复制的表名;          
</code></pre><h4 id="2-R-Retrieve-：查询-1"><a href="#2-R-Retrieve-：查询-1" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h4><pre><code>        * 查询某个数据库中所有的表名称
            * show tables;
        * 查询表结构
            * desc 表名;
</code></pre><h4 id="3-U-Update-修改-1"><a href="#3-U-Update-修改-1" class="headerlink" title="3. U(Update):修改"></a>3. U(Update):修改</h4><pre><code>        1. 修改表名
            alter table 表名 rename to 新的表名;
        2. 修改表的字符集
            alter table 表名 character set 字符集名称;
        3. 添加一列
            alter table 表名 add 列名 数据类型;
        4. 修改列名称 类型
            alter table 表名 change 列名 新列别 新数据类型;
            alter table 表名 modify 列名 新数据类型;
        5. 删除列
            alter table 表名 drop 列名;
</code></pre><h4 id="4-D-Delete-删除-1"><a href="#4-D-Delete-删除-1" class="headerlink" title="4. D(Delete):删除"></a>4. D(Delete):删除</h4><pre><code>        * drop table 表名;
        * drop table  if exists 表名 ;
</code></pre><ul>
<li>客户端图形化工具：SQLYog</li>
</ul>
<h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><h3 id="1-添加数据："><a href="#1-添加数据：" class="headerlink" title="1. 添加数据："></a>1. 添加数据：</h3><pre><code>    * 语法：
        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
    * 注意：
        1. 列名和值要一一对应。
        2. 如果表名后，不定义列名，则默认给所有列添加值
            insert into 表名 values(值1,值2,...值n);
        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
</code></pre><h3 id="2-删除数据："><a href="#2-删除数据：" class="headerlink" title="2. 删除数据："></a>2. 删除数据：</h3><pre><code>    * 语法：
        * delete from 表名 [where 条件]
    * 注意：
        1. 如果不加条件，则删除表中所有记录。
        2. 如果要删除所有记录
            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
</code></pre><h3 id="3-修改数据："><a href="#3-修改数据：" class="headerlink" title="3. 修改数据："></a>3. 修改数据：</h3><pre><code>    * 语法：
        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

    * 注意：
        1. 如果不加任何条件，则会将表中所有记录全部修改。
</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;
</code></pre><p>​    </p>
<h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h3><pre><code>    select
        字段列表
    from
        表名列表
    where
        条件列表
    group by
        分组字段
    having
        分组之后的条件
    order by
        排序
    limit
        分页限定
</code></pre><h3 id="2-基础查询"><a href="#2-基础查询" class="headerlink" title="2. 基础查询"></a>2. 基础查询</h3><pre><code>    1. 多个字段的查询
        select 字段名1，字段名2... from 表名；
        * 注意：
            * 如果查询所有字段，则可以使用*来替代字段列表。
    2. 去除重复：
        * distinct
    3. 计算列
        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
            * 表达式1：哪个字段需要判断是否为null
            * 如果该字段为null后的替换值。
    4. 起别名：
        * as：as也可以省略
</code></pre><h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h3><h4 id="1-where子句后跟条件"><a href="#1-where子句后跟条件" class="headerlink" title="(1) where子句后跟条件"></a>(1) where子句后跟条件</h4><h4 id="2-运算符"><a href="#2-运算符" class="headerlink" title="(2) 运算符"></a>(2) 运算符</h4><pre><code>        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;
        * BETWEEN...AND  
        * IN( 集合) 
        * LIKE：模糊查询
            * 占位符：
                * _:单个任意字符
                * %：多个任意字符
        * IS NULL  
        * and  或 &amp;&amp;
        * or  或 || 
        * not  或 !
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询年龄大于20岁</span><br><span class="line">	</span><br><span class="line">SELECT * FROM student WHERE age &gt; 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;&#x3D; 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄等于20岁</span><br><span class="line">SELECT * FROM student WHERE age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄不等于20岁</span><br><span class="line">SELECT * FROM student WHERE age !&#x3D; 20;</span><br><span class="line">SELECT * FROM student WHERE age &lt;&gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于等于20 小于等于30</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp;  age &lt;&#x3D;30;</span><br><span class="line">SELECT * FROM student WHERE age &gt;&#x3D; 20 AND  age &lt;&#x3D;30;</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;</span><br><span class="line"></span><br><span class="line">-- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">SELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25</span><br><span class="line">SELECT * FROM student WHERE age IN (22,18,25);</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩为null</span><br><span class="line">SELECT * FROM student WHERE english &#x3D; NULL; -- 不对的。null值不能使用 &#x3D; （!&#x3D;） 判断</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE english IS NULL;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩不为null</span><br><span class="line">SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询姓马的有哪些？ like</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;</span><br><span class="line">-- 查询姓名第二个字是化的人</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;</span><br><span class="line">			</span><br><span class="line">-- 查询姓名是3个字的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;</span><br><span class="line">-- 查询姓名中包含德的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;</span><br></pre></td></tr></table></figure>
<h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><h2 id="1-排序查询"><a href="#1-排序查询" class="headerlink" title="1. 排序查询"></a>1. 排序查询</h2><pre><code>    * 语法：order by 子句
        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...

    * 排序方式：
        * ASC：升序，默认的。
        * DESC：降序。

    * 注意：
        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。
</code></pre><h2 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2. 聚合函数"></a>2. 聚合函数</h2><p>将一列数据作为一个整体，进行纵向的计算。</p>
<pre><code>    1. count：计算个数
        1. 一般选择非空的列：主键
        2. count(*)
    2. max：计算最大值
    3. min：计算最小值
    4. sum：计算和
    5. avg：计算平均值
    * 注意：聚合函数的计算，排除null值。
        解决方案：
            1. 选择不包含非空的列进行计算
            2. IFNULL函数

    例：SELECT count(name) FROM student; 
</code></pre><h2 id="3-分组查询"><a href="#3-分组查询" class="headerlink" title="3. 分组查询:"></a>3. 分组查询:</h2><pre><code>    1. 语法：group by 分组字段；
    2. 注意：
        1. 分组之后查询的字段：分组字段、聚合函数
        2. where 和 having 的区别？
            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

        -- 按照性别分组。分别查询男、女同学的平均分

        SELECT sex , AVG(math) FROM student GROUP BY sex;

        -- 按照性别分组。分别查询男、女同学的平均分,人数

        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;

        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人
        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;

        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;
</code></pre><p>​            </p>
<h2 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4. 分页查询"></a>4. 分页查询</h2><pre><code>    1. 语法：limit 开始的索引,每页查询的条数;
    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
        -- 每页显示3条记录 

        SELECT * FROM student LIMIT 0,3; -- 第1页

        SELECT * FROM student LIMIT 3,3; -- 第2页

        SELECT * FROM student LIMIT 6,3; -- 第3页


    3. limit 是一个MySQL&quot;方言&quot;
</code></pre>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>Filter_Listener</title>
    <url>/2020/08/05/Filter-Listener/</url>
    <content><![CDATA[<h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><h2 id="一、-概念："><a href="#一、-概念：" class="headerlink" title="一、 概念："></a>一、 概念：</h2><pre><code>    * 生活中的过滤器：净水器,空气净化器，土匪、
    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
    * 过滤器的作用：
        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...
</code></pre><h2 id="二、-快速入门："><a href="#二、-快速入门：" class="headerlink" title="二、 快速入门："></a>二、 快速入门：</h2><h3 id="1-步骤："><a href="#1-步骤：" class="headerlink" title="1. 步骤："></a>1. 步骤：</h3><pre><code>        1. 定义一个类，实现接口Filter
        2. 覆写方法
        3. 配置拦截路径
            1. web.xml
            2. 注解
</code></pre><a id="more"></a>
<h3 id="2-代码："><a href="#2-代码：" class="headerlink" title="2. 代码："></a>2. 代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)<span class="comment">//访问所有资源之前，都会执行该过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo1</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"filterDemo1被执行了...."</span>);</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、过滤器细节："><a href="#三、过滤器细节：" class="headerlink" title="三、过滤器细节："></a>三、过滤器细节：</h2><h3 id="1-web-xml配置"><a href="#1-web-xml配置" class="headerlink" title="1. web.xml配置"></a>1. web.xml配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-过滤器执行流程"><a href="#2-过滤器执行流程" class="headerlink" title="2. 过滤器执行流程"></a>2. 过滤器执行流程</h3><pre><code>        1. 执行过滤器
        2. 执行放行后的资源
        3. 回来执行过滤器放行代码下边的代码
</code></pre><h3 id="3-过滤器生命周期方法"><a href="#3-过滤器生命周期方法" class="headerlink" title="3. 过滤器生命周期方法"></a>3. 过滤器生命周期方法</h3><pre><code>        1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
        2. doFilter:每一次请求被拦截资源时，会执行。执行多次
        3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
</code></pre><h3 id="4-过滤器配置详解"><a href="#4-过滤器配置详解" class="headerlink" title="4. 过滤器配置详解"></a>4. 过滤器配置详解</h3><h4 id="拦截路径配置："><a href="#拦截路径配置：" class="headerlink" title="* 拦截路径配置："></a>* 拦截路径配置：</h4><pre><code>            1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行
            2. 拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行
            3. 后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行
            4. 拦截所有资源：/*        访问所有资源时，过滤器都会被执行
</code></pre><h4 id="拦截方式配置"><a href="#拦截方式配置" class="headerlink" title="* 拦截方式配置"></a>* 拦截方式配置</h4><p>资源被访问的方式</p>
<pre><code>            * 注解配置：
                * 设置dispatcherTypes属性
                    1. REQUEST：默认值。浏览器直接请求资源
                    2. FORWARD：转发访问资源c
                    3. INCLUDE：包含访问资源
                    4. ERROR：错误跳转资源
                    5. ASYNC：异步访问资源
            * web.xml配置
                * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可
</code></pre><h3 id="5-过滤器链-配置多个过滤器"><a href="#5-过滤器链-配置多个过滤器" class="headerlink" title="5. 过滤器链(配置多个过滤器)"></a>5. 过滤器链(配置多个过滤器)</h3><pre><code>        * 执行顺序：如果有两个过滤器：过滤器1和过滤器2
            1. 过滤器1
            2. 过滤器2
            3. 资源执行
            4. 过滤器2
            5. 过滤器1 

        * 过滤器先后顺序问题：
            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
                * 如： AFilter 和 BFilter，AFilter就先执行了。
            2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行
</code></pre><h2 id="四、案例："><a href="#四、案例：" class="headerlink" title="四、案例："></a>四、案例：</h2><h3 id="1-案例1-登录验证"><a href="#1-案例1-登录验证" class="headerlink" title="1. 案例1_登录验证"></a>1. 案例1_登录验证</h3><pre><code>        * 需求：
            1. 访问day17_case案例的资源。验证其是否登录
            2. 如果登录了，则直接放行。
            3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。
</code></pre><p>​    </p>
<h3 id="2-案例2-敏感词汇过滤"><a href="#2-案例2-敏感词汇过滤" class="headerlink" title="2. 案例2_敏感词汇过滤"></a>2. 案例2_敏感词汇过滤</h3><pre><code>        * 需求：
            1. 对day17_case案例录入的数据进行敏感词汇过滤
            2. 敏感词汇参考《敏感词汇.txt》
            3. 如果是敏感词汇，替换为 *** 

        * 分析：
            1. 对request对象进行增强。增强获取参数相关方法
            2. 放行。传递代理对象


        * 增强对象的功能：
            * 设计模式：一些通用的解决固定问题的方式
            1. 装饰模式
            2. 代理模式
                * 概念：
                    1. 真实对象：被代理的对象
                    2. 代理对象：
                    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的
                 * 实现方式：
                     1. 静态代理：有一个类文件描述代理模式
                     2. 动态代理：在内存中形成代理类
                        * 实现步骤：
                            1. 代理对象和真实对象实现相同的接口
                            2. 代理对象 = Proxy.newProxyInstance();
                            3. 使用代理对象调用方法。
                            4. 增强方法

                        * 增强方式：
                            1. 增强参数列表
                            2. 增强返回值类型
                            3. 增强方法体执行逻辑    
</code></pre><h1 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h1><h2 id="一、-概念：web的三大组件之一。"><a href="#一、-概念：web的三大组件之一。" class="headerlink" title="一、 概念：web的三大组件之一。"></a>一、 概念：web的三大组件之一。</h2><pre><code>    * 事件监听机制
        * 事件    ：一件事情
        * 事件源 ：事件发生的地方
        * 监听器 ：一个对象
        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码


* ServletContextListener:监听ServletContext对象的创建和销毁
    * 方法：
        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法
    * 步骤：
        1. 定义一个类，实现ServletContextListener接口
        2. 复写方法
        3. 配置
            1. web.xml
                    &lt;listener&gt;
                      &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;
                       &lt;/listener&gt;

                    * 指定初始化参数&lt;context-param&gt;
            2. 注解：
                * @WebListener
</code></pre>]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>HEML_CSS</title>
    <url>/2020/07/20/HEML-CSS/</url>
    <content><![CDATA[<h1 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h1><h2 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：</h2><pre><code>* 概念：用于采集用户输入的数据的。用于和服务器进行交互。
* form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围
        * 属性：
            * action：指定提交数据的URL
            * method:指定提交方式
                * 分类：一共7种，2种比较常用
                   * get：
                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。
                        2. 请求参数大小是有限制的。
                        3. 不太安全。
                   * post：
                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)
                        2. 请求参数的大小没有限制。
                        3. 较为安全。

        * 表单项中的数据要想被提交：必须指定其name属性
</code></pre><a id="more"></a>
<h2 id="表单项标签："><a href="#表单项标签：" class="headerlink" title="表单项标签："></a>表单项标签：</h2><h3 id="input：可以通过type属性值，改变元素展示的样式"><a href="#input：可以通过type属性值，改变元素展示的样式" class="headerlink" title="input：可以通过type属性值，改变元素展示的样式"></a>input：可以通过type属性值，改变元素展示的样式</h3><pre><code>    * type属性：
                * text：文本输入框，默认值
                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息    
                * password：密码输入框
                * radio:单选框
                    * 注意：
                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。
                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值
                        3. checked属性，可以指定默认值
                * checkbox：复选框
                    * 注意：
                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值
                        2. checked属性，可以指定默认值

                * file：文件选择框
                * hidden：隐藏域，用于提交一些信息。
                * 按钮：
                    * submit：提交按钮。可以提交表单
                    * button：普通按钮
                    * image：图片提交按钮
                        * src属性指定图片的路径    
                * color:取色器
                * date : 生日
                * datetime-local:生日
                * email:邮箱
                * 

* label：指定输入项的文字描述信息
               * 注意：
                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。
</code></pre><h3 id="select-下拉列表"><a href="#select-下拉列表" class="headerlink" title="select: 下拉列表"></a>select: 下拉列表</h3><pre><code>            * 子元素：option，指定列表项
                    * 添加一个 selected 即表示默认。
</code></pre><h3 id="textarea：文本域"><a href="#textarea：文本域" class="headerlink" title="textarea：文本域"></a>textarea：文本域</h3><pre><code>            * cols：指定列数，每一行有多少个字符
            * rows：默认多少行。
</code></pre><h1 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h1><h3 id="1-概念：-Cascading-Style-Sheets-层叠样式表"><a href="#1-概念：-Cascading-Style-Sheets-层叠样式表" class="headerlink" title="1. 概念： Cascading Style Sheets 层叠样式表"></a>1. 概念： Cascading Style Sheets 层叠样式表</h3><pre><code>    * 层叠：多个样式可以作用在同一个html的元素上，同时生效
</code></pre><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="2. 好处："></a>2. 好处：</h3><pre><code>    1. 功能强大
    2. 将内容展示和样式控制分离
        * 降低耦合度。解耦
        * 让分工协作更容易
        * 提高开发效率
</code></pre><h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><h3 id="1-内联样式"><a href="#1-内联样式" class="headerlink" title="1. 内联样式"></a>1. 内联样式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* 在标签内使用style属性指定css代码</span><br><span class="line">* 如：<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:red;"</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-内部样式"><a href="#2-内部样式" class="headerlink" title="2. 内部样式"></a>2. 内部样式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* 在head标签内，定义style标签，style标签的标签体内容就是css代码</span><br><span class="line">* 如：</span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-外部样式"><a href="#3-外部样式" class="headerlink" title="3. 外部样式"></a>3. 外部样式</h3><pre><code>        1. 定义css资源文件。
        2. 在head标签内，定义link标签，引入外部的资源文件
        * 如：
            * a.css文件：
                div{
                    color:green;
                }
            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;
            &lt;div&gt;hello css&lt;/div&gt;
            &lt;div&gt;hello css&lt;/div&gt;

    * 注意：
        * 1,2,3种方式 css作用范围越来越大
        * 1方式不常用，后期常用2,3
        * 3种格式可以写为：
            &lt;style&gt;
                @import &quot;css/a.css&quot;;
            &lt;/style&gt;
</code></pre><h3 id="4-css语法："><a href="#4-css语法：" class="headerlink" title="4. css语法："></a>4. css语法：</h3><pre><code>    * 格式：
        选择器 {
            属性名1:属性值1;
            属性名2:属性值2;
            ...
        }
    * 选择器:筛选具有相似特征的元素
    * 注意：
        * 每一对属性需要使用；隔开，最后一对属性可以不加；
</code></pre><h3 id="5-选择器：筛选具有相似特征的元素"><a href="#5-选择器：筛选具有相似特征的元素" class="headerlink" title="5. 选择器：筛选具有相似特征的元素"></a>5. 选择器：筛选具有相似特征的元素</h3><pre><code>    * 分类：
        1. 基础选择器
            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一
                * 语法：#id属性值{}
                * 注意：id是下面优先级最高的。
            2. 元素选择器：选择具有相同标签名称的元素
                * 语法： 标签名称{}
                * 注意：id选择器优先级高于元素选择器
            3. 类选择器：选择具有相同的class属性值的元素。
                * 语法：.class属性值{}
                * 注意：类选择器选择器优先级高于元素选择器
        2. 扩展选择器：
            1. 选择所有元素：
                * 语法： *{}
            2. 并集选择器：
                * 选择器1,选择器2{}

            3. 子选择器：筛选选择器1元素下的选择器2元素
                * 语法：  选择器1 选择器2{}
            4. 父选择器：筛选选择器2的父元素选择器1
                * 语法：  选择器1 &gt; 选择器2{}

            5. 属性选择器：选择元素名称，属性名=属性值的元素
                * 语法：  元素名称[属性名=&quot;属性值&quot;]{}

            6. 伪类选择器：选择一些元素具有的状态
                * 语法： 元素:状态{}
                * 如： &lt;a&gt;
                    * 状态：
                        * link：初始化的状态
                        * visited：被访问过的状态
                        * active：正在访问状态
                        * hover：鼠标悬浮状态
</code></pre><h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6. 属性"></a>6. 属性</h3><h4 id="（1）-字体、文本"><a href="#（1）-字体、文本" class="headerlink" title="（1） 字体、文本"></a>（1） 字体、文本</h4><pre><code>        * font-size：字体大小
        * color：文本颜色
        * text-align：对其方式
        * line-height：行高 
</code></pre><h4 id="（2）-背景"><a href="#（2）-背景" class="headerlink" title="（2） 背景"></a>（2） 背景</h4><pre><code>        * background：
</code></pre><h4 id="（3）-边框"><a href="#（3）-边框" class="headerlink" title="（3） 边框"></a>（3） 边框</h4><pre><code>        * border：设置边框，复合属性
</code></pre><h4 id="（4）-尺寸"><a href="#（4）-尺寸" class="headerlink" title="（4） 尺寸"></a>（4） 尺寸</h4><pre><code>        * width：宽度
        * height：高度
</code></pre><h4 id="（5）-盒子模型：控制布局"><a href="#（5）-盒子模型：控制布局" class="headerlink" title="（5） 盒子模型：控制布局"></a>（5） 盒子模型：控制布局</h4><pre><code>        * margin：外边距
        * padding：内边距
            * 默认情况下内边距会影响整个盒子的大小
            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小

        * float：浮动
            * left
            * right
</code></pre><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;注册页面&lt;/title&gt;
    &lt;style&gt;
        *{
            margin: 0px;
            padding: 0px;
            box-sizing: border-box;
        }
        body{
            background: url(&quot;img/register_bg.png&quot;) no-repeat center;
            padding-top: 25px;
        }

        .rg_layout{
            width: 900px;
            height: 500px;
            border: 8px solid #EEEEEE;
            background-color: white;
            /*让div水平居中*/
            margin: auto;
        }

        .rg_left{
            /*border: 1px solid red;*/
            float: left;
            margin: 15px;
        }
        .rg_left &gt; p:first-child{
            color:#FFD026;
            font-size: 20px;
        }

        .rg_left &gt; p:last-child{
            color:#A6A6A6;
            font-size: 20px;

        }
</code></pre><p>​        </p>
<pre><code>        .rg_center{
            float: left;
           /* border: 1px solid red;*/

        }

        .rg_right{
            /*border: 1px solid red;*/
            float: right;
            margin: 15px;
        }

        .rg_right &gt; p:first-child{
            font-size: 15px;

        }
        .rg_right p a {
            color:pink;
        }

        .td_left{
            width: 100px;
            text-align: right;
            height: 45px;
        }
        .td_right{
            padding-left: 50px ;
        }

        #username,#password,#email,#name,#tel,#birthday,#checkcode{
            width: 251px;
            height: 32px;
            border: 1px solid #A6A6A6 ;
            /*设置边框圆角*/
            border-radius: 5px;
            padding-left: 10px;
        }
        #checkcode{
            width: 110px;
        }

        #img_check{
            height: 32px;
            vertical-align: middle;
        }

        #btn_sub{
            width: 150px;
            height: 40px;
            background-color: #FFD026;
            border: 1px solid #FFD026 ;
        }

    &lt;/style&gt;

    &lt;/head&gt;
    &lt;body&gt;

    &lt;div class=&quot;rg_layout&quot;&gt;
        &lt;div class=&quot;rg_left&quot;&gt;
            &lt;p&gt;新用户注册&lt;/p&gt;
            &lt;p&gt;USER REGISTER&lt;/p&gt;

        &lt;/div&gt;

        &lt;div class=&quot;rg_center&quot;&gt;
            &lt;div class=&quot;rg_form&quot;&gt;
                &lt;!--定义表单 form--&gt;
                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;
                    &lt;table&gt;
                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;
                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男
                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女
                            &lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;
                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;
                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
</code></pre><p>​        </p>
<pre><code>                        &lt;tr&gt;
                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;

                &lt;/form&gt;
</code></pre><p>​        </p>
<pre><code>            &lt;/div&gt;

        &lt;/div&gt;

        &lt;div class=&quot;rg_right&quot;&gt;
            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;
        &lt;/div&gt;
</code></pre><p>​        </p>
<pre><code>    &lt;/div&gt;
</code></pre><p>​        </p>
<pre><code>    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>]]></content>
      <categories>
        <category>web</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2020/07/19/HTML/</url>
    <content><![CDATA[<h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><ul>
<li><p>JavaWeb：</p>
<ul>
<li>使用Java语言开发基于互联网的项目 </li>
</ul>
</li>
<li><p>软件架构：</p>
<pre><code>  1. C/S: Client/Server 客户端/服务器端
      * 在用户本地有一个客户端程序，在远程有一个服务器端程序
      * 如：QQ，迅雷...
      * 优点：
          1. 用户体验好
      * 缺点：
          1. 开发、安装，部署，维护 麻烦
  2. B/S: Browser/Server 浏览器/服务器端 
      * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序
      * 优点：
          1. 开发、安装，部署，维护 简单
      * 缺点：
          1. 如果应用过大，用户的体验可能会受到影响
          2. 对硬件要求过高
</code></pre>  <a id="more"></a>
<ul>
<li>B/S架构详解<ul>
<li>资源分类：<ol>
<li>静态资源：<ul>
<li>使用静态网页开发技术发布的资源。</li>
<li>特点：<ul>
<li>所有用户访问，得到的结果是一样的。</li>
<li>如：文本，图片，音频、视频, HTML,CSS,JavaScript</li>
<li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li>
</ul>
</li>
</ul>
</li>
<li>动态资源：<ul>
<li>使用动态网页及时发布的资源。</li>
<li>特点：<ul>
<li>所有用户访问，得到的结果可能不一样。</li>
<li>如：jsp/servlet,php,asp…</li>
<li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>我们要学习动态资源，必须先学习静态资源！</p>
<pre><code>  * 静态资源：
      * HTML：用于搭建基础网页，展示页面的内容
      * CSS：用于美化页面，布局页面
      * JavaScript：控制页面的元素，让页面有一些动态的效果
</code></pre></li>
</ul>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-概念：是最基础的网页开发语言"><a href="#1-概念：是最基础的网页开发语言" class="headerlink" title="1. 概念：是最基础的网页开发语言"></a>1. 概念：是最基础的网页开发语言</h2><pre><code>    * Hyper Text Markup Language 超文本标记语言
        * 超文本:
            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.
        * 标记语言:
            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml
            * 标记语言不是编程语言
</code></pre><h2 id="2-快速入门："><a href="#2-快速入门：" class="headerlink" title="2. 快速入门："></a>2. 快速入门：</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><pre><code>        1. html文档后缀名 .html 或者 .htm
        2. 标签分为
            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;
            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;

        3. 标签可以嵌套：
            需要正确嵌套，不能你中有我，我中有你
            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;
            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;

        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来
        5. html的标签不区分大小写，但是建议使用小写。
</code></pre><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">FONT</span> <span class="attr">color</span>=<span class="string">'red'</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">'green'</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-标签学习："><a href="#3-标签学习：" class="headerlink" title="3. 标签学习："></a>3. 标签学习：</h2><h3 id="1-文件标签：构成html最基本的标签"><a href="#1-文件标签：构成html最基本的标签" class="headerlink" title="(1) 文件标签：构成html最基本的标签"></a>(1) 文件标签：构成html最基本的标签</h3><pre><code>        * html:html文档的根标签
        * head：头标签。用于指定html文档的一些属性。引入外部的资源
        * title：标题标签。
        * body：体标签
        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档
</code></pre><h3 id="2-文本标签：和文本有关的标签"><a href="#2-文本标签：和文本有关的标签" class="headerlink" title="(2) 文本标签：和文本有关的标签"></a>(2) 文本标签：和文本有关的标签</h3><pre><code>        * 注释：&lt;!-- 注释内容 --&gt;
        * &lt;h1&gt; to &lt;h6&gt;：标题标签
            * h1~h6:字体大小逐渐递减
        * &lt;p&gt;：段落标签
        * &lt;br&gt;：换行标签
        * &lt;hr&gt;：展示一条水平线
            * 属性：
                * color：颜色
                * width：宽度
                * size：高度
                * align：对其方式
                    * center：居中
                    * left：左对齐
                    * right：右对齐
        * &lt;b&gt;：字体加粗
        * &lt;i&gt;：字体斜体
        * &lt;font&gt;:字体标签
        * &lt;center&gt;:文本居中
            * 属性：
                * color：颜色
                * size：大小
                * face：字体

        * 属性定义：
            * color：
                1. 英文单词：red,green,blue
                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)
                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF
            * width：
                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)
                2. 数值%：占比相对于父元素的比例
</code></pre><p>有一些特殊符号需要标记来写出来：</p>
<p><img src="/2020/07/19/HTML/特殊字符表.png" alt="特殊字符表"></p>
<h3 id="3-图片标签："><a href="#3-图片标签：" class="headerlink" title="(3) 图片标签："></a>(3) 图片标签：</h3><pre><code>        * img：展示图片
            * 属性：
                * src：指定图片的位置

        * 代码：
             &lt;!--展示一张图片 img--&gt;

            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;

            &lt;!--
                相对路径
                    * 以.开头的路径
                        * ./：代表当前目录  ./image/1.jpg
                        * ../:代表上一级目录
             --&gt;

            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;

            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;
</code></pre><h3 id="4-列表标签："><a href="#4-列表标签：" class="headerlink" title="(4) 列表标签："></a>(4) 列表标签：</h3><pre><code>        * 有序列表：
            * ol:
            * li:
        * 无序列表：
            * ul:
            * li:
</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">早上起床干的事情</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">"A"</span> <span class="attr">start</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>睁眼<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>看手机<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>穿衣服<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>洗漱<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">早上起床干的事情</span><br><span class="line">	E. 睁眼</span><br><span class="line">	F. 看手机</span><br><span class="line">	G. 穿衣服</span><br><span class="line">	H. 洗漱</span><br><span class="line">无序列表：type可以设置列表前是圆还是方框</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"disc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"circle"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"square"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="5-链接标签："><a href="#5-链接标签：" class="headerlink" title="(5) 链接标签："></a>(5) 链接标签：</h3><pre><code>        * a:定义一个超链接
            * 属性：
                * href：指定访问资源的URL(统一资源定位符)
                * target：指定打开资源的方式
                    * _self:默认值，在当前页面打开
                    * _blank：在空白页面打开

        * 代码：
             &lt;!--超链接  a--&gt;

            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;

            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;
            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;

            &lt;br&gt;

            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt; 
            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;

            &lt;br&gt;
            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;
</code></pre><h3 id="6-div和span："><a href="#6-div和span：" class="headerlink" title="(6) div和span："></a>(6) div和span：</h3><pre><code>        * div:每一个div占满一整行。块级标签
        * span：文本信息在一行展示，行内标签 内联标签
</code></pre><h3 id="7-语义化标签："><a href="#7-语义化标签：" class="headerlink" title="(7) 语义化标签："></a>(7) 语义化标签：</h3><p>html5中为了提高程序的可读性，提供了一些标签。</p>
<pre><code>        1. &lt;header&gt;：页眉
        2. &lt;footer&gt;：页脚
</code></pre><h3 id="8-表格标签："><a href="#8-表格标签：" class="headerlink" title="(8) 表格标签："></a>(8) 表格标签：</h3><pre><code>        * table：定义表格
            * width：宽度
            * border：边框
            * cellpadding：定义内容和单元格的距离
            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、
            * bgcolor：背景色
            * align：对齐方式
        * tr：定义行
            * bgcolor：背景色
            * align：对齐方式
        * td：定义单元格
            * colspan：合并列
            * rowspan：合并行
        * th：定义表头单元格
        * &lt;caption&gt;：表格标题
        * &lt;thead&gt;：表示表格的头部分
        * &lt;tbody&gt;：表示表格的体部分
        * &lt;tfoot&gt;：表示表格的脚部分
</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    
2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
3. 如果某一行有多个单元格，则使用
    &lt;tr&gt;
        &lt;td&gt;
            &lt;table&gt;&lt;/table&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

4. 代码实现

    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;黑马旅游网&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;!--采用table来完成布局--&gt;
        &lt;!--最外层的table，用于整个页面的布局--&gt;
        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
           &lt;!-- 第1行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第2行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;

                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第3行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;
                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;
                            &lt;td&gt;
                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;

                            &lt;td&gt;
                                门票
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第4行 轮播图 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第5行 黑马精选--&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;
                    黑马精选
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第6行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第7行 国内游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;
                    国内游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第8行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre><p>​        </p>
<pre><code>                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第9行 境外游 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;
                    境外游
                    &lt;hr  color=&quot;#ffd700&quot; &gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第10行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;
                        &lt;tr&gt;
                            &lt;td rowspan=&quot;2&quot;&gt;
                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
                        &lt;/tr&gt;

                        &lt;tr&gt;
                            &lt;td&gt;

                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;

                            &lt;td&gt;

                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;
                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;
                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;
                            &lt;/td&gt;
</code></pre><p>​        </p>
<pre><code>                        &lt;/tr&gt;
                    &lt;/table&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;!-- 第11行 --&gt;
            &lt;tr&gt;
                &lt;td&gt;
                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

            &lt;!-- 第12行 --&gt;
            &lt;tr&gt;
                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;
                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;
                    江苏传智播客教育科技股份有限公司
                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882
                    &lt;/font&gt;
                &lt;/td&gt;
            &lt;/tr&gt;

        &lt;/table&gt;
</code></pre><p>​        </p>
<pre><code>    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>]]></content>
      <categories>
        <category>web</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC连接池和JDBC template</title>
    <url>/2020/07/19/JDBC-connection-pool-JDBC-template/</url>
    <content><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>其实就是一个容器(集合)，存放数据库连接的容器。<br>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
<h2 id="2-好处："><a href="#2-好处：" class="headerlink" title="2. 好处："></a>2. 好处：</h2><pre><code>    1. 节约资源
    2. 用户访问高效
</code></pre><h2 id="3-实现："><a href="#3-实现：" class="headerlink" title="3. 实现："></a>3. 实现：</h2><h3 id="（1）-标准接口：DataSource-javax-sql包下的"><a href="#（1）-标准接口：DataSource-javax-sql包下的" class="headerlink" title="（1） 标准接口：DataSource   javax.sql包下的 "></a>（1） 标准接口：DataSource   javax.sql包下的 <a id="more"></a></h3><pre><code>    1. 方法：
        * 获取连接：getConnection()
        * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接
</code></pre><h3 id="（2）-数据库连接池实现技术"><a href="#（2）-数据库连接池实现技术" class="headerlink" title="（2） 数据库连接池实现技术"></a>（2） 数据库连接池实现技术</h3><p>一般我们不去实现它，有数据库厂商来实现</p>
<pre><code>    1. C3P0：数据库连接池技术
    2. Druid：数据库连接池实现技术，由阿里巴巴提供的
</code></pre><h2 id="4-C3P0：数据库连接池技术"><a href="#4-C3P0：数据库连接池技术" class="headerlink" title="4. C3P0：数据库连接池技术"></a>4. C3P0：数据库连接池技术</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，
            * 不要忘记导入数据库驱动jar包
        2. 定义配置文件：
            * 名称： c3p0.properties 或者 c3p0-config.xml
            * 路径：直接将文件放在src目录下即可。

        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource
        4. 获取连接： getConnection
</code></pre><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//2. 获取连接对象</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.datasource.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c3p0演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取DataSource，使用默认配置</span></span><br><span class="line">        DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span> ; i++) &#123;</span><br><span class="line">            Connection conn = ds.getConnection();</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+conn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接到连接池中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//testNamedConfig();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNamedConfig</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.1 获取DataSource，使用指定名称配置</span></span><br><span class="line">        DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">"otherc3p0"</span>);</span><br><span class="line">        <span class="comment">//2.获取连接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            Connection conn = ds.getConnection();</span><br><span class="line">            System.out.println(i+<span class="string">":"</span>+conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Druid：数据库连接池实现技术，由阿里巴巴提供的"><a href="#5-Druid：数据库连接池实现技术，由阿里巴巴提供的" class="headerlink" title="5. Druid：数据库连接池实现技术，由阿里巴巴提供的"></a>5. Druid：数据库连接池实现技术，由阿里巴巴提供的</h2><h3 id="1-步骤："><a href="#1-步骤：" class="headerlink" title="(1) 步骤："></a>(1) 步骤：</h3><pre><code>        1. 导入jar包 druid-1.0.9.jar
        2. 定义配置文件：
            * 是properties形式的
            * 可以叫任意名称，可以放在任意目录下
        3. 加载配置文件。Properties
        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory
        5. 获取连接：getConnection
    * 代码：
         //3.加载配置文件
        Properties pro = new Properties();
        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);
        pro.load(is);
        //4.获取连接池对象
        DataSource ds = DruidDataSourceFactory.createDataSource(pro);
        //5.获取连接
        Connection conn = ds.getConnection();
</code></pre><h3 id="2-定义工具类"><a href="#2-定义工具类" class="headerlink" title="(2) 定义工具类"></a>(2) 定义工具类</h3><pre><code>        1. 定义一个类 JDBCUtils
        2. 提供静态代码块加载配置文件，初始化连接池对象
        3. 提供方法
            1. 获取连接方法：通过数据库连接池获取连接
            2. 释放资源
            3. 获取连接池的方法
</code></pre><ul>
<li>代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 释放资源</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* if(stmt != null)&#123;</span></span><br><span class="line"><span class="comment">			            try &#123;</span></span><br><span class="line"><span class="comment">			                stmt.close();</span></span><br><span class="line"><span class="comment">			            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">			                e.printStackTrace();</span></span><br><span class="line"><span class="comment">			            &#125;</span></span><br><span class="line"><span class="comment">			        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			        if(conn != null)&#123;</span></span><br><span class="line"><span class="comment">			            try &#123;</span></span><br><span class="line"><span class="comment">			                conn.close();//归还连接</span></span><br><span class="line"><span class="comment">			            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">			                e.printStackTrace();</span></span><br><span class="line"><span class="comment">			            &#125;</span></span><br><span class="line"><span class="comment">			        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接池方法</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>使用定义好的工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.datasource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用新的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 完成添加操作：给account表添加一条记录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            String sql = <span class="string">"insert into account values(null,?,?)"</span>;</span><br><span class="line">            <span class="comment">//3.获取pstmt对象</span></span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">//4.给？赋值</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>,<span class="string">"王五"</span>);</span><br><span class="line">            pstmt.setDouble(<span class="number">2</span>,<span class="number">3000</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            <span class="keyword">int</span> count = pstmt.executeUpdate();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6. 释放资源</span></span><br><span class="line">            JDBCUtils.close(pstmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
<h2 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h2><pre><code>    1. 导入jar包
    2. 创建JdbcTemplate对象。依赖于数据源DataSource
        * JdbcTemplate template = new JdbcTemplate(ds);

    3. 调用JdbcTemplate的方法来完成CRUD的操作
        * update():执行DML语句。增、删、改语句
        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合
            * 注意：这个方法查询的结果集长度只能是1
        * queryForList():查询结果将结果集封装为list集合
            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
        * query():查询结果，将结果封装为JavaBean对象
            * query的参数：RowMapper
                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装
                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)
        * queryForObject：查询结果，将结果封装为对象
            * 一般用于聚合函数的查询
</code></pre><ul>
<li>小试牛刀</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jdbctemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTemplate入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.创建JDBCTemplate对象</span></span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">        <span class="comment">//3.调用方法</span></span><br><span class="line">        String sql = <span class="string">"update account set balance=5000 where id=?;"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql,<span class="number">3</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul>
<li>需求</li>
</ul>
<pre><code>            1. 修改1号数据的 salary 为 10000
            2. 添加一条记录
            3. 删除刚才添加的记录
            4. 查询id为1的记录，将其封装为Map集合
            5. 查询所有记录，将其封装为List
            6. 查询所有记录，将其封装为Emp对象的List集合
            7. 查询总记录数
</code></pre><ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.domain.Emp;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Junit单元测试，可以让方法独立执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 1. 修改1号数据的 salary 为 10000</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义sql</span></span><br><span class="line">        String sql = <span class="string">"update emp set salary = 10000 where id = 1001"</span>;</span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 2. 添加一条记录</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>, <span class="string">"郭靖"</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 3.删除刚才添加的记录</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from emp where id = ?"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = template.update(sql, <span class="number">1015</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">				     * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp where id = ? or id = ?"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">                <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">                <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">                Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">                <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">                <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">                <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ​				</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">                System.out.println(emp);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">        Long total = template.queryForObject(sql, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA的开发环境配置</title>
    <url>/2020/07/30/IDEA/</url>
    <content><![CDATA[<h1 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h1><p>第一步配置项目环境是在箭头指的地方设置。这里叫做 <code>project structure</code></p>
<p><img src="/2020/07/30/IDEA/image-20200730110224635.png" alt="image-20200730110224635"></p>
<p>打开后可以看到一些东西：</p>
<h2 id="一、project"><a href="#一、project" class="headerlink" title="一、project"></a>一、project</h2><p><img src="/2020/07/30/IDEA/image-20200730110334254.png" alt="image-20200730110334254"></p>
<p>Project里设置SDK和你编译后的输出位置。一般需要明确的输出这个out地址。如果不设置可能Tomcat报错，也可以等Tomcat报错的时候再设置。</p>
<a id="more"></a>
<h2 id="二、Modules"><a href="#二、Modules" class="headerlink" title="二、Modules"></a>二、Modules</h2><p><img src="/2020/07/30/IDEA/image-20200730110525645.png" alt="image-20200730110525645"></p>
<p>在Midule里设置<code>source</code>，<code>path</code>和<code>Dependencies</code>；</p>
<p>如果是要打开别人的项目。在source里可以直接指定src文件夹的位置就可以。</p>
<p><img src="/2020/07/30/IDEA/image-20200730110805581.png" alt="image-20200730110805581"></p>
<p>如果直接报错比如：<code>javax.Servlet</code>不存在这个时候，就需要在<code>Dependencies</code>里加入依赖包。不过这个错误一般在自己新建后的项目里都不会出现。或者作死自己删除了这个 <code>Module</code>设置。</p>
<h2 id="三、facets"><a href="#三、facets" class="headerlink" title="三、facets"></a>三、facets</h2><p>这里要设置成项目的web文件夹</p>
<p><img src="/2020/07/30/IDEA/image-20200730111217197.png" alt="image-20200730111217197"></p>
<p>如果成了别的什么就404访问不到web文件夹下的资源文件。</p>
<h2 id="四、Artifacts"><a href="#四、Artifacts" class="headerlink" title="四、Artifacts"></a>四、Artifacts</h2><p>这个地方设置的是整个项目生成的结果。Tomcat在工作时不会访问你写这个项目的地方但是它是要访问这个项目部署的地方：</p>
<p><img src="/2020/07/30/IDEA/image-20200730111535916.png" alt="image-20200730111535916"></p>
<p>这个只要设置了就没什么问题</p>
<p>但是在后面的Tomcat设置时 deployment，也就是部署这一步就是告诉你这个项目部署的是啥。他不会找你的工作目录，这里需要告诉Tomcat这个Artifacts到底在哪里。</p>
<p><img src="/2020/07/30/IDEA/image-20200730111626667.png" alt="image-20200730111626667"></p>
<p>所以点加号设置Artifacts</p>
<p><img src="/2020/07/30/IDEA/image-20200730111835083.png" alt="image-20200730111835083"></p>
<p>如果这里只有External Source那么就要返回上一步查看Artifaces设置好了没。</p>
<h1 id="设置Tomcat"><a href="#设置Tomcat" class="headerlink" title="设置Tomcat"></a>设置Tomcat</h1><p>Tomcat是要为每一个项目单独设置一个的。所以新的项目就不要用之前的了，在这里要选+号。</p>
<p><img src="/2020/07/30/IDEA/image-20200730112007243.png" alt="image-20200730112007243"></p>
<p>之所以要用单独设置可以看看配置文件。在启动Tomcat后，输出的信息里有这个：</p>
<p><img src="/2020/07/30/IDEA/image-20200730112146777.png" alt="image-20200730112146777"></p>
<p>这个文件夹下就是Idea单独为这个项目搞得一个设置目录</p>
<p><img src="/2020/07/30/IDEA/image-20200730112332842.png" alt="image-20200730112332842"></p>
<p>这个文件夹下保存着之前部署的项目位置，也就是Artifaces设置的位置。</p>
<p>所以这个文件夹会告诉Tomcat要去哪里找请求的东西。</p>
<p><img src="/2020/07/30/IDEA/image-20200730112544593.png" alt="image-20200730112544593"></p>
<p>而这个设置文件夹则是IDEA与Tomcat进行关联设置的。</p>
]]></content>
      <categories>
        <category>web</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2020/07/18/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h1><p>概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</p>
<p>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<h2 id="二、快速入门："><a href="#二、快速入门：" class="headerlink" title="二、快速入门："></a>二、快速入门：</h2><h3 id="1-步骤："><a href="#1-步骤：" class="headerlink" title="1. 步骤："></a>1. 步骤：</h3><pre><code>1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
    1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
    2.右键--&gt;Add As Library
2. 注册驱动
3. 获取数据库连接对象 Connection
4. 定义sql
5. 获取执行sql语句的对象 Statement
6. 执行sql，接受返回结果
7. 处理结果
8. 释放资源
</code></pre><h3 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2. 代码实现："></a>2. 代码实现：</h3> <a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 导入驱动jar包</span></span><br><span class="line"><span class="comment">//2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line"><span class="comment">//4.定义sql语句</span></span><br><span class="line">String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line"><span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//6.执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line"><span class="comment">//7.处理结果</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//8.释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<h2 id="三、详解各个对象："><a href="#三、详解各个对象：" class="headerlink" title="三、详解各个对象："></a>三、详解各个对象：</h2><h3 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="1. DriverManager：驱动管理对象"></a>1. DriverManager：驱动管理对象</h3><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><h5 id="1-注册驱动：告诉程序该使用哪一个数据库驱动jar"><a href="#1-注册驱动：告诉程序该使用哪一个数据库驱动jar" class="headerlink" title="(1) 注册驱动：告诉程序该使用哪一个数据库驱动jar"></a>(1) 注册驱动：告诉程序该使用哪一个数据库驱动jar</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> <span class="comment">//注册与给定的驱动程序 DriverManager 。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//写代码使用： </span></span></span><br><span class="line"><span class="function">Class.<span class="title">forName</span><span class="params">(<span class="string">"com.mysql.jdbc.Driver"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过查看源码发现：在<code>com.mysql.jdbc.Driver</code>类中存在静态代码块<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p>
<h5 id="2-获取数据库连接："><a href="#2-获取数据库连接：" class="headerlink" title="(2) 获取数据库连接："></a>(2) 获取数据库连接：</h5><p>方法：<code>static Connection getConnection(String url, String user, String password)</code></p>
<p>参数：</p>
<ul>
<li>url：指定连接的路径<ul>
<li>语法：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li>
<li>例子：<code>jdbc:mysql://localhost:3306/db3</code></li>
<li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：<code>jdbc:mysql:///数据库名称</code></li>
</ul>
</li>
<li>user：用户名</li>
<li>password：密码 </li>
</ul>
<h3 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="2. Connection：数据库连接对象"></a>2. Connection：数据库连接对象</h3><h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h4><h5 id="1-获取执行sql-的对象"><a href="#1-获取执行sql-的对象" class="headerlink" title="(1) 获取执行sql 的对象"></a>(1) 获取执行sql 的对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-管理事务："><a href="#2-管理事务：" class="headerlink" title="(2) 管理事务："></a>(2) 管理事务：</h5><pre><code>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
提交事务：commit() 
回滚事务：rollback() 
</code></pre><h3 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="3. Statement：执行sql的对象"></a>3. Statement：执行sql的对象</h3><h4 id="执行sql"><a href="#执行sql" class="headerlink" title="执行sql"></a>执行sql</h4><ol>
<li><code>boolean execute(String sql)</code> ：可以执行任意的sql （了解）</li>
<li><code>int executeUpdate(String sql)</code> ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句<pre><code> 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。
</code></pre></li>
<li><code>ResultSet executeQuery(String sql)</code>  ：执行DQL（select)语句<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4></li>
</ol>
<p>题目：</p>
<pre><code>1. account表 添加一条记录
2. account表 修改记录
3. account表 删除一条记录
</code></pre><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * account表 添加一条记录 insert 语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 注册驱动 </span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="comment">//2. 定义sql</span></span><br><span class="line">            String sql = <span class="string">"insert into account values(null,'王五',3000)"</span>;	<span class="comment">// 添加</span></span><br><span class="line">            <span class="comment">// String sql  = "update account set balance = 1500 where id = 3";	// 更改</span></span><br><span class="line">            <span class="comment">// String sql  = "delete from account where id = 3";	// 删除</span></span><br><span class="line">            <span class="comment">// String sql  = "create table student (id int , name varchar(20))";	// 创建表，DDL语句，不过不常用；</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.获取Connection对象</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">            <span class="comment">//4.获取执行sql的对象 Statement</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            <span class="keyword">int</span> count = stmt.executeUpdate(sql);<span class="comment">//影响的行数</span></span><br><span class="line">            <span class="comment">//6.处理结果</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"添加成功！"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"添加失败！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//stmt.close();</span></span><br><span class="line">            <span class="comment">//7. 释放资源</span></span><br><span class="line">            <span class="comment">//避免空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-ResultSet：结果集对象-封装查询结果"><a href="#4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="4. ResultSet：结果集对象,封装查询结果"></a>4. ResultSet：结果集对象,封装查询结果</h3><ul>
<li>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</li>
<li>getXxx(参数):获取数据<ul>
<li>Xxx：代表数据类型   如： int getInt() ,    String getString()</li>
<li>参数：<ol>
<li>int：代表列的编号,从1开始   如： getString(1)</li>
<li>String：代表列名称。 如： getDouble(“balance”)</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>        * 注意：
            * 使用步骤：
                1. 游标向下移动一行
                2. 判断是否有数据
                3. 获取数据
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环判断游标是否是最后一行末尾。</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    <span class="comment">//6.2 获取数据</span></span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(id + <span class="string">"---"</span> + name + <span class="string">"---"</span> + balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>        * 练习：
            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。
                1. 定义Emp类
                2. 定义方法 public List&lt;Emp&gt; findAll(){}
                3. 实现方法 select * from emp;
</code></pre><h3 id="5-PreparedStatement：执行sql的对象"><a href="#5-PreparedStatement：执行sql的对象" class="headerlink" title="5. PreparedStatement：执行sql的对象"></a>5. PreparedStatement：执行sql的对象</h3><h4 id="1-SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题"><a href="#1-SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题" class="headerlink" title="(1)  SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题"></a>(1)  SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</h4><pre><code>1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a
2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39; 
</code></pre><h4 id="2-解决sql注入问题："><a href="#2-解决sql注入问题：" class="headerlink" title="(2) 解决sql注入问题："></a>(2) 解决sql注入问题：</h4><p>使用PreparedStatement对象来解决</p>
<h4 id="3-预编译的SQL："><a href="#3-预编译的SQL：" class="headerlink" title="(3) 预编译的SQL："></a>(3) 预编译的SQL：</h4><p>参数使用?作为占位符</p>
<h4 id="4-步骤："><a href="#4-步骤：" class="headerlink" title="(4) 步骤："></a>(4) 步骤：</h4><pre><code>            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar
            2. 注册驱动
            3. 获取数据库连接对象 Connection
            4. 定义sql
                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;
            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) 
            6. 给？赋值：
                * 方法： setXxx(参数1,参数2)
                    * 参数1：？的位置编号 从1 开始
                    * 参数2：？的值
            7. 执行sql，接受返回结果，不需要传递sql语句
            8. 处理结果
            9. 释放资源
</code></pre><h4 id="5-注意：后期都会使用PreparedStatement来完成增删改查的所有操作"><a href="#5-注意：后期都会使用PreparedStatement来完成增删改查的所有操作" class="headerlink" title="(5) 注意：后期都会使用PreparedStatement来完成增删改查的所有操作"></a>(5) 注意：后期都会使用PreparedStatement来完成增删改查的所有操作</h4><pre><code>            1. 可以防止SQL注入
            2. 效率更高
</code></pre><h1 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h1><pre><code>* 目的：简化书写
* 分析：
    1. 注册驱动也抽取
    2. 抽取一个方法获取连接对象
        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。
        * 解决：配置文件
            jdbc.properties
                url=
                user=
                password=
    3. 抽取一个方法释放资源
</code></pre><ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">            ClassLoader classLoader = JDBCUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">            URL res  = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            System.out.println(path);<span class="comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">            <span class="comment">//2. 加载文件</span></span><br><span class="line">            <span class="comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            <span class="comment">//4. 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 获取连接</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 释放资源</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 释放资源</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习：</p>
<ul>
<li>需求：<ol>
<li>通过键盘录入用户名和密码</li>
<li>判断用户是否登录成功<ul>
<li>select * from user where username = “” and password = “”;</li>
<li>如果这个sql有查询结果，则成功，反之，则失败</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>创建数据库表 user</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    username VARCHAR(32),</span><br><span class="line">    PASSWORD VARCHAR(32)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);</span><br><span class="line">INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);</span><br></pre></td></tr></table></figure>
<pre><code>2. 代码实现：
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo9</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.键盘录入，接受用户名和密码</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">        String username = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">        String password = sc.nextLine();</span><br><span class="line">        <span class="comment">//2.调用方法</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">new</span> JDBCDemo9().login(username, password);</span><br><span class="line">        <span class="comment">//3.判断结果，输出不同语句</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            System.out.println(<span class="string">"登录成功！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">				     * 登录方法</span></span><br><span class="line"><span class="comment">				     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username ,String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="keyword">null</span> || password == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt =  <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn =  JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username = '"</span>+username+<span class="string">"' and password = '"</span>+password+<span class="string">"' "</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行查询</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.判断</span></span><br><span class="line">            <span class="comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span></span><br><span class="line"><span class="comment">				                return true;</span></span><br><span class="line"><span class="comment">				            &#125;else&#123;</span></span><br><span class="line"><span class="comment">				                return false;</span></span><br><span class="line"><span class="comment">				            &#125;*/</span></span><br><span class="line">            <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h1><h2 id="1-事务："><a href="#1-事务：" class="headerlink" title="1. 事务："></a>1. 事务：</h2><p>一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
<h2 id="2-操作："><a href="#2-操作：" class="headerlink" title="2. 操作："></a>2. 操作：</h2><pre><code>    1. 开启事务
    2. 提交事务
    3. 回滚事务
</code></pre><h2 id="3-使用Connection对象来管理事务"><a href="#3-使用Connection对象来管理事务" class="headerlink" title="3. 使用Connection对象来管理事务"></a>3. 使用Connection对象来管理事务</h2><pre><code>    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务
        * 在执行sql之前开启事务
    * 提交事务：commit() 
        * 当所有sql都执行完提交事务
    * 回滚事务：rollback() 
        * 在catch中回滚事务
</code></pre><h2 id="4-代码："><a href="#4-代码：" class="headerlink" title="4. 代码："></a>4. 代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);			<span class="comment">// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 设置事务开始</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">//4. 设置参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();					<span class="comment">//！！！！！！！！！！！！！！！！！！！！！！	提交事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();	<span class="comment">// ！！！！！！！！！！！！！！！！！！在异常并且conn存在时回滚！！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP_MVC_EL_JSTL</title>
    <url>/2020/08/03/JSP-MVC-EL-JSTL/</url>
    <content><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP:"></a>JSP:</h1><h2 id="一、指令"><a href="#一、指令" class="headerlink" title="一、指令"></a>一、指令</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><pre><code>        用于配置JSP页面，导入资源文件
</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="2. 格式："></a>2. 格式：</h3><pre><code>        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;
</code></pre><h3 id="3-分类："><a href="#3-分类：" class="headerlink" title="3. 分类："></a>3. 分类：</h3><h4 id="page-：-配置JSP页面的"><a href="#page-：-配置JSP页面的" class="headerlink" title="page        ： 配置JSP页面的"></a>page        ： 配置JSP页面的</h4><pre><code>            * contentType：等同于response.setContentType()
                1. 设置响应体的mime类型以及字符集
                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
            * import：导包
            * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
            * isErrorPage：标识当前也是是否是错误页面。
                * true：是，可以使用内置对象exception
                * false：否。默认值。不可以使用内置对象exception
</code></pre><a id="more"></a>
<h4 id="include-：-页面包含的。导入页面的资源文件"><a href="#include-：-页面包含的。导入页面的资源文件" class="headerlink" title="include    ： 页面包含的。导入页面的资源文件"></a>include    ： 页面包含的。导入页面的资源文件</h4><pre><code>            * &lt;%@include file=&quot;top.jsp&quot;%&gt;
</code></pre><h4 id="taglib-：-导入资源"><a href="#taglib-：-导入资源" class="headerlink" title="taglib    ： 导入资源"></a>taglib    ： 导入资源</h4><pre><code>            * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
                * prefix：前缀，自定义的
</code></pre><h2 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释:"></a>二、注释:</h2><pre><code>    1. html注释：
        &lt;!-- --&gt;:只能注释html代码片段
    2. jsp注释：推荐使用
        &lt;%-- --%&gt;：可以注释所有
</code></pre><h2 id="三、内置对象"><a href="#三、内置对象" class="headerlink" title="三、内置对象"></a>三、内置对象</h2><pre><code>    * 在jsp页面中不需要创建，直接使用的对象
    * 一共有9个：
            变量名                    真实类型                        作用
        * pageContext                PageContext                    当前页面共享数据，还可以获取其他八个内置对象
        * request                    HttpServletRequest            一次请求访问的多个资源(转发)
        * session                    HttpSession                    一次会话的多个请求间
        * application                ServletContext                所有用户间共享数据
        * response                    HttpServletResponse            响应对象
        * page                        Object                        当前页面(Servlet)的对象  this
        * out                        JspWriter                    输出对象，数据输出到页面上
        * config                    ServletConfig                Servlet的配置对象
        * exception                    Throwable                    异常对象
</code></pre><p>​    </p>
<h1 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h1><h2 id="一、-jsp演变历史"><a href="#一、-jsp演变历史" class="headerlink" title="一、 jsp演变历史"></a>一、 jsp演变历史</h2><pre><code>    1. 早期只有servlet，只能使用response输出标签数据，非常麻烦
    2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作
    3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性
</code></pre><h2 id="二、-MVC"><a href="#二、-MVC" class="headerlink" title="二、 MVC"></a>二、 MVC</h2><pre><code>    1. M：Model，模型。JavaBean
        * 完成具体的业务操作，如：查询数据库，封装对象
    2. V：View，视图。JSP
        * 展示数据
    3. C：Controller，控制器。Servlet
        * 获取用户的输入
        * 调用模型
        * 将数据交给视图进行展示
</code></pre><p><img src="/2020/08/03/JSP-MVC-EL-JSTL/MVC开发模式.bmp" alt="MVC开发模式"></p>
<pre><code>    * 优缺点：
        1. 优点：
            1. 耦合性低，方便维护，可以利于分工协作
            2. 重用性高

        2. 缺点：
            1. 使得项目架构变得复杂，对开发人员要求高
</code></pre><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>    Expression Language 表达式语言
</code></pre><h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><pre><code>    替换和简化jsp页面中java代码的编写
</code></pre><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><pre><code>    ${表达式}
</code></pre><h2 id="四、注意："><a href="#四、注意：" class="headerlink" title="四、注意："></a>四、注意：</h2><pre><code>    * jsp默认支持el表达式的。如果要忽略el表达式
        1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式
        2. \${表达式} ：忽略当前这个el表达式
</code></pre><h2 id="五、使用："><a href="#五、使用：" class="headerlink" title="五、使用："></a>五、使用：</h2><h3 id="1-运算："><a href="#1-运算：" class="headerlink" title="1. 运算："></a>1. 运算：</h3><pre><code>        * 运算符：
            1. 算数运算符： + - * /(div) %(mod)
            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=
            3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not)
            4. 空运算符： empty
                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
                * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
                * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0
</code></pre><h3 id="2-获取值"><a href="#2-获取值" class="headerlink" title="2. 获取值"></a>2. 获取值</h3><pre><code>        1. el表达式只能从域对象中获取值
        2. 语法：
            1. ${域名称.键名}：从指定域中获取指定键的值
                * 域名称：
                    1. pageScope        --&gt; pageContext
                    2. requestScope     --&gt; request
                    3. sessionScope     --&gt; session
                    4. applicationScope --&gt; application（ServletContext）
                * 举例：在request域中存储了name=张三
                * 获取：${requestScope.name}

            2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。

            3. 获取对象、List集合、Map集合的值
                1. 对象：${域名称.键名.属性名}
                    * 本质上会去调用对象的getter方法

                2. List集合：${域名称.键名[索引]}

                3. Map集合：
                    * ${域名称.键名.key名称}
                    * ${域名称.键名[&quot;key名称&quot;]}
</code></pre><h3 id="3-隐式对象："><a href="#3-隐式对象：" class="headerlink" title="3. 隐式对象："></a>3. 隐式对象：</h3><pre><code>        * el表达式中有11个隐式对象
        * pageContext：
            * 获取jsp其他八个内置对象
                * ${pageContext.request.contextPath}：动态获取虚拟目录
</code></pre><p>​    </p>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><h2 id="一、概念-1"><a href="#一、概念-1" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>    JavaServer Pages Tag Library  JSP标准标签库
    * 是由Apache组织提供的开源的免费的jsp标签        &lt;标签&gt;
</code></pre><h2 id="二、作用-1"><a href="#二、作用-1" class="headerlink" title="二、作用"></a>二、作用</h2><p>用于简化和替换jsp页面上的java代码        </p>
<h2 id="三、使用步骤："><a href="#三、使用步骤：" class="headerlink" title="三、使用步骤："></a>三、使用步骤：</h2><pre><code>    1. 导入jstl相关jar包
    2. 引入标签库：taglib指令：  &lt;%@ taglib %&gt;
    3. 使用标签
</code></pre><h2 id="四、常用的JSTL标签"><a href="#四、常用的JSTL标签" class="headerlink" title="四、常用的JSTL标签"></a>四、常用的JSTL标签</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a>1. if</h3><p>相当于java代码的if语句</p>
<pre><code>        1. 属性：
            * test 必须属性，接受boolean表达式
                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
                * 一般情况下，test属性值会结合el表达式一起使用
            2. 注意：
                * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签
</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//判断request域中的一个list集合是否为空，如果不为null则显示遍历集合</span></span><br><span class="line"></span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"aaaa"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"list"</span>,list);</span><br><span class="line"></span><br><span class="line">    request.setAttribute(<span class="string">"number"</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;not empty list&#125;"</span>&gt;</span><br><span class="line">    遍历集合...</span><br><span class="line"></span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;number % 2 != 0&#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">        $&#123;number&#125;为奇数</span><br><span class="line"></span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;number % 2 == 0&#125;"</span>&gt;</span><br><span class="line"></span><br><span class="line">    $&#123;number&#125;为偶数</span><br><span class="line"></span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-choose"><a href="#2-choose" class="headerlink" title="2. choose"></a>2. choose</h3><p>相当于java代码的switch语句</p>
<pre><code>        1. 使用choose标签声明                     相当于switch声明
        2. 使用when标签做判断                     相当于case
        3. 使用otherwise标签做其他情况的声明        相当于default
</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 1&#125;"&gt;星期一&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 2&#125;"&gt;星期二&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 3&#125;"&gt;星期三&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 4&#125;"&gt;星期四&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 5&#125;"&gt;星期五&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 6&#125;"&gt;星期六&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;number == 7&#125;"&gt;星期天&lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-foreach"><a href="#3-foreach" class="headerlink" title="3. foreach"></a>3. foreach</h3><p>相当于java代码的for语句</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    foreach:相当于java代码的<span class="keyword">for</span>语句</span><br><span class="line">        <span class="number">1</span>. 完成重复的操作</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            * 属性：</span><br><span class="line">                begin：开始值</span><br><span class="line">                end：结束值</span><br><span class="line">                <span class="keyword">var</span>：临时变量</span><br><span class="line">                step：步长</span><br><span class="line">                varStatus:循环状态对象</span><br><span class="line">                    index:容器中元素的索引，从<span class="number">0</span>开始</span><br><span class="line">                    count:循环次数，从<span class="number">1</span>开始</span><br><span class="line">        <span class="number">2</span>. 遍历容器</span><br><span class="line">            List&lt;User&gt; list;</span><br><span class="line">            <span class="keyword">for</span>(User user : list)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            * 属性：</span><br><span class="line">                items:容器对象</span><br><span class="line">                <span class="keyword">var</span>:容器中元素的临时变量</span><br><span class="line">                varStatus:循环状态对象</span><br><span class="line">                    index:容器中元素的索引，从<span class="number">0</span>开始</span><br><span class="line">                    count:循环次数，从<span class="number">1</span>开始</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"10"</span> <span class="keyword">var</span>=<span class="string">"i"</span> step=<span class="string">"2"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">    $&#123;i&#125; &lt;h3&gt;$&#123;s.index&#125;&lt;h3&gt; &lt;h4&gt; $&#123;s.count&#125; &lt;/h4&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"aaa"</span>);</span><br><span class="line">        list.add(<span class="string">"bbb"</span>);</span><br><span class="line">        list.add(<span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">"list"</span>,list);</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"str"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line"></span><br><span class="line">            $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<h2 id="五、练习："><a href="#五、练习：" class="headerlink" title="五、练习："></a>五、练习：</h2><pre><code>    * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中
</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.ArrayList"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.List"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"cn.itcast.domain.User"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Date"</span> %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: zenner</span><br><span class="line">  Date: <span class="number">2020</span>/<span class="number">8</span>/<span class="number">3</span></span><br><span class="line">  Time: <span class="number">11</span>:<span class="number">29</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--准备数据--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">23</span>,<span class="keyword">new</span> Date()));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">"李四"</span>,<span class="number">24</span>,<span class="keyword">new</span> Date()));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">"王五"</span>,<span class="number">25</span>,<span class="keyword">new</span> Date()));</span><br><span class="line">    request.setAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;table border=<span class="string">"1"</span> width=<span class="string">"500"</span> align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;编号&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;生日&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;%--  数据行  --%&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">"$&#123;list&#125;"</span> <span class="keyword">var</span>=<span class="string">"user"</span> varStatus=<span class="string">"s"</span>&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;s.count%2==0&#125;"</span>&gt;</span><br><span class="line">            &lt;tr bgcolor=<span class="string">"red"</span>&gt;</span><br><span class="line">                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.birStr&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/c:if&gt;</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;s.count%2!=0&#125;"</span>&gt;</span><br><span class="line">            &lt;tr bgcolor=<span class="string">"green"</span>&gt;</span><br><span class="line">                &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;$&#123;user.birStr&#125;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/c:if&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h1><pre><code>1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互
2. 业务逻辑层：处理业务逻辑的。
3. 数据访问层：操作数据存储文件。
</code></pre><p><img src="/2020/08/03/JSP-MVC-EL-JSTL/三层架构.bmp" alt="三层架构"></p>
<h1 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h1><pre><code>1. 需求：用户信息的增删改查操作
2. 设计：
    1. 技术选型：Servlet + JSP + MySQL + JDBCTemplate + Duird + BeanUtilS + tomcat
    2. 数据库设计：
        create database day17; -- 创建数据库
        use day17;                -- 使用数据库
        create table user(   -- 创建表
            id int primary key auto_increment,
            name varchar(20) not null,
            gender varchar(5),
            age int,
            address varchar(32),
            qq    varchar(20),
            email varchar(50)
        );

3. 开发：
    1. 环境搭建
        1. 创建数据库环境
        2. 创建项目，导入需要的jar包

    2. 编码


4. 测试
5. 部署运维
</code></pre><p><img src="/2020/08/03/JSP-MVC-EL-JSTL/列表查询分析.bmp" alt="列表查询分析"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>JQuery</title>
    <url>/2020/08/06/JQuery-beginning/</url>
    <content><![CDATA[<h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>    一个JavaScript框架。简化JS开发
    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。

    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已
</code></pre><h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><pre><code>    1. 步骤：
        1. 下载JQuery
            * 目前jQuery有三个大版本：
                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，
                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，
                     最终版本：1.12.4 (2016年5月20日)
                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，
                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，
                     最终版本：2.2.4 (2016年5月20日)
                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，
                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。
                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）
            * jquery-xxx.js 与 jquery-xxx.min.js区别：
                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些
                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快

        2. 导入JQuery的js文件：导入min.js文件
        3. 使用
            var div1 = $(&quot;#div1&quot;);
            alert(div1.html());
</code></pre><h2 id="三、JQuery对象和JS对象区别与转换"><a href="#三、JQuery对象和JS对象区别与转换" class="headerlink" title="三、JQuery对象和JS对象区别与转换"></a>三、JQuery对象和JS对象区别与转换</h2><pre><code>    1. JQuery对象在操作时，更加方便。
    2. JQuery对象和js对象方法不通用的.
    3. 两者相互转换
        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)
        * js -- &gt; jq : $(js对象)
</code></pre><a id="more"></a>
<h2 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a>四、选择器</h2><p>筛选具有相似特征的元素(标签)</p>
<h3 id="1-基本操作学习："><a href="#1-基本操作学习：" class="headerlink" title="1. 基本操作学习："></a>1. 基本操作学习：</h3><h4 id="（1）-事件绑定"><a href="#（1）-事件绑定" class="headerlink" title="（1） 事件绑定"></a>（1） 事件绑定</h4><pre><code>            //1.获取b1按钮
            $(&quot;#b1&quot;).click(function(){
                alert(&quot;abc&quot;);
            });
</code></pre><h4 id="（2）-入口函数"><a href="#（2）-入口函数" class="headerlink" title="（2） 入口函数"></a>（2） 入口函数</h4><pre><code>             $(function () {

                });
             window.onload  和 $(function) 区别
                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉
                 * $(function)可以定义多次的。
</code></pre><h4 id="（3）-样式控制：css方法"><a href="#（3）-样式控制：css方法" class="headerlink" title="（3） 样式控制：css方法"></a>（3） 样式控制：css方法</h4><pre><code>             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);
              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);
</code></pre><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><h4 id="（1）-基本选择器"><a href="#（1）-基本选择器" class="headerlink" title="（1） 基本选择器"></a>（1） 基本选择器</h4><pre><code>            1. 标签选择器（元素选择器）
                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素
            2. id选择器 
                * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素
            3. 类选择器
                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素
            4. 并集选择器：
                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素
</code></pre><h4 id="2-层级选择器"><a href="#2-层级选择器" class="headerlink" title="(2) 层级选择器"></a>(2) 层级选择器</h4><pre><code>            1. 后代选择器
                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素        
            2. 子选择器
                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素
</code></pre><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="(3) 属性选择器"></a>(3) 属性选择器</h4><pre><code>            1. 属性名称选择器 
                * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器
            2. 属性选择器
                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器
            3. 复合属性选择器
                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器
</code></pre><h4 id="4-过滤选择器"><a href="#4-过滤选择器" class="headerlink" title="(4) 过滤选择器"></a>(4) 过滤选择器</h4><pre><code>            1. 首元素选择器 
                * 语法： :first 获得选择的元素中的第一个元素
            2. 尾元素选择器 
                * 语法： :last 获得选择的元素中的最后一个元素
            3. 非元素选择器
                * 语法： :not(selector) 不包括指定内容的元素
            4. 偶数选择器
                * 语法： :even 偶数，从 0 开始计数
            5. 奇数选择器
                * 语法： :odd 奇数，从 0 开始计数
            6. 等于索引选择器
                * 语法： :eq(index) 指定索引元素
            7. 大于索引选择器 
                * 语法： :gt(index) 大于指定索引元素
            8. 小于索引选择器 
                * 语法： :lt(index) 小于指定索引元素
            9. 标题选择器
                * 语法： :header 获得标题（h1~h6）元素，固定写法
</code></pre><h4 id="5-表单过滤选择器"><a href="#5-表单过滤选择器" class="headerlink" title="(5) 表单过滤选择器"></a>(5) 表单过滤选择器</h4><pre><code>            1. 可用元素选择器 
                * 语法： :enabled 获得可用元素
            2. 不可用元素选择器 
                * 语法： :disabled 获得不可用元素
            3. 选中选择器 
                * 语法： :checked 获得单选/复选框选中的元素
            4. 选中选择器 
                * 语法： :selected 获得下拉框选中的元素
</code></pre><h2 id="五、DOM操作"><a href="#五、DOM操作" class="headerlink" title="五、DOM操作"></a>五、DOM操作</h2><pre><code>    1. 内容操作
        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;
        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容
        3. val()： 获取/设置元素的value属性值
    2. 属性操作
        1. 通用属性操作
            1. attr(): 获取/设置元素的属性
            2. removeAttr():删除属性
            3. prop():获取/设置元素的属性
            4. removeProp():删除属性

            * attr和prop区别？
                1. 如果操作的是元素的固有属性，则建议使用prop
                2. 如果操作的是元素自定义的属性，则建议使用attr
        2. 对class属性操作
            1. addClass():添加class属性值
            2. removeClass():删除class属性值
            3. toggleClass():切换class属性
                * toggleClass(&quot;one&quot;): 
                    * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加
            4. css():
    3. CRUD操作:
        1. append():父元素将子元素追加到末尾
            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾
        2. prepend():父元素将子元素追加到开头
            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头
        3. appendTo():
            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾
        4. prependTo()：
            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头


        5. after():添加元素到元素后边
            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系
        6. before():添加元素到元素前边
            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系
        7. insertAfter()
            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系
        8. insertBefore()
            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系

        9. remove():移除元素
            * 对象.remove():将对象删除掉
        10. empty():清空元素的所有后代元素。
            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点
</code></pre><h2 id="六、案例"><a href="#六、案例" class="headerlink" title="六、案例"></a>六、案例</h2><h1 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h1><h2 id="一、动画"><a href="#一、动画" class="headerlink" title="一、动画"></a>一、动画</h2><h3 id="1-三种方式显示和隐藏元素"><a href="#1-三种方式显示和隐藏元素" class="headerlink" title="1. 三种方式显示和隐藏元素"></a>1. 三种方式显示和隐藏元素</h3><pre><code>        1. 默认显示和隐藏方式
            1. show([speed,[easing],[fn]])
                1. 参数：
                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)
                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;
                        * swing：动画执行时效果是 先慢，中间快，最后又慢
                        * linear：动画执行时速度是匀速的
                    3. fn：在动画完成时执行的函数，每个元素执行一次。

            2. hide([speed,[easing],[fn]])
            3. toggle([speed],[easing],[fn])

        2. 滑动显示和隐藏方式
            1. slideDown([speed],[easing],[fn])
            2. slideUp([speed,[easing],[fn]])
            3. slideToggle([speed],[easing],[fn])

        3. 淡入淡出显示和隐藏方式
            1. fadeIn([speed],[easing],[fn])
            2. fadeOut([speed],[easing],[fn])
            3. fadeToggle([speed,[easing],[fn]])
</code></pre><h2 id="二、遍历"><a href="#二、遍历" class="headerlink" title="二、遍历"></a>二、遍历</h2><h3 id="1-js的遍历方式"><a href="#1-js的遍历方式" class="headerlink" title="1. js的遍历方式"></a>1. js的遍历方式</h3><pre><code>        * for(初始化值;循环结束条件;步长)
</code></pre><h3 id="2-jq的遍历方式"><a href="#2-jq的遍历方式" class="headerlink" title="2. jq的遍历方式"></a>2. jq的遍历方式</h3><h4 id="1-jq对象-each-callback"><a href="#1-jq对象-each-callback" class="headerlink" title="(1) jq对象.each(callback)"></a>(1) jq对象.each(callback)</h4><pre><code>            1. 语法：
                jquery对象.each(function(index,element){});
                    * index:就是元素在集合中的索引
                    * element：就是集合中的每一个元素对象

                    * this：集合中的每一个元素对象
            2. 回调函数返回值：
                * true:如果当前function返回为false，则结束循环(break)。
                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)
</code></pre><h4 id="2-each-object-callback"><a href="#2-each-object-callback" class="headerlink" title="(2) $.each(object, [callback])"></a>(2) $.each(object, [callback])</h4><h4 id="3-for-of-jquery-3-0-版本之后提供的方式"><a href="#3-for-of-jquery-3-0-版本之后提供的方式" class="headerlink" title="(3) for..of: jquery 3.0 版本之后提供的方式"></a>(3) for..of: jquery 3.0 版本之后提供的方式</h4><pre><code>            for(元素对象 of 容器对象)
</code></pre><h2 id="三、-事件绑定"><a href="#三、-事件绑定" class="headerlink" title="三、 事件绑定"></a>三、 事件绑定</h2><h3 id="1-jquery标准的绑定方式"><a href="#1-jquery标准的绑定方式" class="headerlink" title="1. jquery标准的绑定方式"></a>1. jquery标准的绑定方式</h3><pre><code>        * jq对象.事件方法(回调函数)；
        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
            * 表单对象.submit();//让表单提交
</code></pre><h3 id="2-on绑定事件-off解除绑定"><a href="#2-on绑定事件-off解除绑定" class="headerlink" title="2. on绑定事件/off解除绑定"></a>2. on绑定事件/off解除绑定</h3><pre><code>        * jq对象.on(&quot;事件名称&quot;,回调函数)
        * jq对象.off(&quot;事件名称&quot;)
            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑
</code></pre><h3 id="3-事件切换：toggle"><a href="#3-事件切换：toggle" class="headerlink" title="3. 事件切换：toggle"></a>3. 事件切换：toggle</h3><pre><code>        * jq对象.toggle(fn1,fn2...)
            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....

        * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。
             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h2><pre><code>    1. 广告显示和隐藏
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;
            &lt;style&gt;
                #content{width:100%;height:500px;background:#999}
            &lt;/style&gt;

            &lt;!--引入jquery--&gt;
            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
            &lt;script&gt;
                /*
                    需求：
                        1. 当页面加载完，3秒后。自动显示广告
                        2. 广告显示5秒后，自动消失。

                    分析：
                        1. 使用定时器来完成。setTimeout (执行一次定时器)
                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display
                        3. 使用  show/hide方法来完成广告的显示
                 */

                //入口函数，在页面加载完成之后，定义定时器，调用这两个方法
                $(function () {
                   //定义定时器，调用adShow方法 3秒后执行一次
                   setTimeout(adShow,3000);
                   //定义定时器，调用adHide方法，8秒后执行一次
                    setTimeout(adHide,8000);
                });
                //显示广告
                function adShow() {
                    //获取广告div，调用显示方法
                    $(&quot;#ad&quot;).show(&quot;slow&quot;);
                }
                //隐藏广告
                function adHide() {
                    //获取广告div，调用隐藏方法
                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);
                }
</code></pre><p>​<br>​                &lt;/script&gt;<br>​            &lt;/head&gt;<br>​            <body><br>​            <!-- 整体的DIV --><br>​            <div>
​                <!-- 广告DIV -->
​                <div id="ad" style="display: none;">
​                    <img style="width:100%" src="/2020/08/06/JQuery-beginning/../../../../../video/study/黑马java57期/java/03-javaWeb/day21_JQuery高级/img/adv.jpg">
​                </div><br>​            </div></body></p>
<pre><code>            &lt;!-- 下方正文部分 --&gt;
            &lt;div id=&quot;content&quot;&gt;
                正文部分
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    2. 抽奖
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;
            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;

            &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;

                /*
                    分析：
                        1. 给开始按钮绑定单击事件
                            1.1 定义循环定时器
                            1.2 切换小相框的src属性
                                * 定义数组，存放图片资源路径
                                * 生成随机数。数组索引


                        2. 给结束按钮绑定单击事件
                            1.1 停止定时器
                            1.2 给大相框设置src属性

                 */
                var imgs = [&quot;../img/man00.jpg&quot;,
                            &quot;../img/man01.jpg&quot;,
                            &quot;../img/man02.jpg&quot;,
                            &quot;../img/man03.jpg&quot;,
                            &quot;../img/man04.jpg&quot;,
                            &quot;../img/man05.jpg&quot;,
                            &quot;../img/man06.jpg&quot;,
                            ];
                var startId;//开始定时器的id
                var index;//随机角标
                $(function () {
                    //处理按钮是否可以使用的效果
                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);
                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);


                   //1. 给开始按钮绑定单击事件
                    $(&quot;#startID&quot;).click(function () {
                        // 1.1 定义循环定时器 20毫秒执行一次
                        startId = setInterval(function () {
                            //处理按钮是否可以使用的效果
                            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);
                            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);


                            //1.2生成随机角标 0-6
                            index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999
                            //1.3设置小相框的src属性
                            $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);

                        },20);
                    });


                    //2. 给结束按钮绑定单击事件
                    $(&quot;#stopID&quot;).click(function () {
                        //处理按钮是否可以使用的效果
                        $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);
                        $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);


                       // 1.1 停止定时器
                        clearInterval(startId);
                       // 1.2 给大相框设置src属性
                        $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();
                        //显示1秒之后
                        $(&quot;#img2ID&quot;).show(1000);
                    });
                });
</code></pre><p>​<br>​<br>​                &lt;/script&gt;<br>​            </p>
<pre><code>        &lt;/head&gt;
        &lt;body&gt;

        &lt;!-- 小像框 --&gt;
        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;
            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;
        &lt;/div&gt;

        &lt;!-- 大像框 --&gt;
        &lt;div
                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;
            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;
        &lt;/div&gt;

        &lt;!-- 开始按钮 --&gt;
        &lt;input
                id=&quot;startID&quot;
                type=&quot;button&quot;
                value=&quot;点击开始&quot;
                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;

        &lt;!-- 停止按钮 --&gt;
        &lt;input
                id=&quot;stopID&quot;
                type=&quot;button&quot;
                value=&quot;点击停止&quot;
                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;


        &lt;/body&gt;
        &lt;/html&gt;
</code></pre><h2 id="五、插件：增强JQuery的功能"><a href="#五、插件：增强JQuery的功能" class="headerlink" title="五、插件：增强JQuery的功能"></a>五、插件：增强JQuery的功能</h2><pre><code>    1. 实现方式：
        1. $.fn.extend(object) 
            * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)
        2. $.extend(object)
            * 增强JQeury对象自身的功能  $/jQuery
</code></pre><p>​            </p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM第二章：自动内存管理</title>
    <url>/2020/07/24/JVM-C2/</url>
    <content><![CDATA[<h1 id="一、运行时数据区"><a href="#一、运行时数据区" class="headerlink" title="一、运行时数据区"></a>一、运行时数据区</h1><p>前面两个部分都是了解了的。</p>
<h2 id="3-HotSpot虚拟机对象探秘："><a href="#3-HotSpot虚拟机对象探秘：" class="headerlink" title="3. HotSpot虚拟机对象探秘："></a>3. HotSpot虚拟机对象探秘：</h2><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><ol>
<li><p>JVM遇到一个<code>new</code>关键字后：</p>
<ul>
<li>在常量池中看能够定位 <code>类的符号引用</code>， 并检查这个符号引用代表的类是否被加载，解析和初始化过。没有的话就加载这个类；</li>
</ul>
</li>
<li><p>接着为新生对象分配内存：这里讨论了三种分配内存的方式</p>
</li>
</ol>
<ul>
<li>假设内存绝对规整: 一端使用过的,另一端是没用过的: 把指针向空闲的那边移动需要空间大小就好    (指针碰撞)</li>
<li>使用过的内存和空闲内存交错在一起, 就需要维护一个内存空闲列表; 从中挑选出需要大小的一片内存,进行分配;</li>
<li>给每个线程划分一块自己的私有内存区域: 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)<ul>
<li>虚拟机使用TLAB: <code>-XX:+/-UseTLAB</code></li>
</ul>
</li>
</ul>
<ol>
<li>JVM给对象进行必要的设置: Object.Class,    Hashcode,    类的元数据信息,    对象的GC分代年龄    (    放在对象的<code>对象头</code>里)</li>
<li>这些做完JVM就创建了一个对象;   但JAVA程序才开始用构造函数初始化这个实例化对象</li>
</ol>
<a id="more"></a>
<h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>一个对象在堆中的存在可以划分为三个部分：对象头（Header），实例数据（Instance data）和对齐填充；</p>
<ol>
<li><p>对象头</p>
<ul>
<li>存储两类信息“<ol>
<li>对象自身的运行时数据</li>
<li>类型指针：对象指向它的类型元数据的指针；（可确定这个对象是哪个类的实例）</li>
</ol>
</li>
</ul>
</li>
<li><p>实例数据</p>
<ul>
<li>真正存储对象实例信息的地方，无论父类的还是子类定义的都得放在这里面；</li>
<li>存储顺序受虚拟机分配策略参数（-XX:FieldsAllocationStyle 参数）和字段在Java源码中定义顺序的影响；</li>
</ul>
</li>
<li><p>对齐填充</p>
<p>对象必须是8字节的倍数；所以满足这个要求就填充一下；</p>
</li>
</ol>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>java会通过栈上的 reference 数据来操作堆上的对象。</p>
<p>主流的访问方式主要有使用句柄和直接指针两种方式。</p>
<ul>
<li>使用句柄访问，java堆中就会划分出一块内存作为<code>句柄池</code> ，reference 保存的就是句柄地址。而句柄包含了 <code>对象实例数据</code> 和 <code>对象类型数据</code> 各自的具体地址信息；</li>
<li>直接用指针访问的话， Java堆中对象的内存布局就必须考虑 <code>对象类型数据</code> 的相关信息（地址）放在哪里；</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title>MySql约束</title>
    <url>/2020/07/17/MySql-constraint/</url>
    <content><![CDATA[<h1 id="第一章-约束"><a href="#第一章-约束" class="headerlink" title="第一章 约束"></a>第一章 约束</h1><h2 id="一、概念："><a href="#一、概念：" class="headerlink" title="一、概念："></a>一、概念：</h2><p>对表中的数据进行限定，保证数据的正确性、有效性和完整性。    </p>
<h2 id="二、分类："><a href="#二、分类：" class="headerlink" title="二、分类："></a>二、分类：</h2><pre><code>    1. 主键约束：primary key
    2. 非空约束：not null
    3. 唯一约束：unique
    4. 外键约束：foreign key
</code></pre><h2 id="三、非空约束"><a href="#三、非空约束" class="headerlink" title="三、非空约束"></a>三、非空约束</h2><p>not null，某一列的值不能为null <a id="more"></a></p>
<h3 id="1-创建表时添加约束"><a href="#1-创建表时添加约束" class="headerlink" title="1. 创建表时添加约束"></a>1. 创建表时添加约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	id INT,</span><br><span class="line">	NAME VARCHAR(20) NOT NULL -- name为非空</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2-创建表完后，添加非空约束"><a href="#2-创建表完后，添加非空约束" class="headerlink" title="2. 创建表完后，添加非空约束"></a>2. 创建表完后，添加非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure>
<h3 id="3-删除name的非空约束"><a href="#3-删除name的非空约束" class="headerlink" title="3. 删除name的非空约束"></a>3. 删除name的非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20);</span><br></pre></td></tr></table></figure>
<h2 id="四、唯一约束"><a href="#四、唯一约束" class="headerlink" title="四、唯一约束"></a>四、唯一约束</h2><p>unique，某一列的值不能重复</p>
<h3 id="1-注意："><a href="#1-注意：" class="headerlink" title="1. 注意："></a>1. 注意：</h3><pre><code>        * 唯一约束可以有NULL值，但是只能有一条记录为null
</code></pre><h3 id="2-在创建表时，添加唯一约束"><a href="#2-在创建表时，添加唯一约束" class="headerlink" title="2. 在创建表时，添加唯一约束"></a>2. 在创建表时，添加唯一约束</h3><pre><code>        CREATE TABLE stu(
            id INT,
            phone_number VARCHAR(20) UNIQUE -- 手机号
        );
</code></pre><h3 id="3-删除唯一约束"><a href="#3-删除唯一约束" class="headerlink" title="3. 删除唯一约束"></a>3. 删除唯一约束</h3><pre><code>        ALTER TABLE stu DROP INDEX phone_number;
</code></pre><h3 id="4-在表创建完后，添加唯一约束"><a href="#4-在表创建完后，添加唯一约束" class="headerlink" title="4. 在表创建完后，添加唯一约束"></a>4. 在表创建完后，添加唯一约束</h3><pre><code>        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
</code></pre><h2 id="五、主键约束：primary-key。"><a href="#五、主键约束：primary-key。" class="headerlink" title="五、主键约束：primary key。"></a>五、主键约束：primary key。</h2><h3 id="1-注意：-1"><a href="#1-注意：-1" class="headerlink" title="1. 注意："></a>1. 注意：</h3><pre><code>        1. 含义：非空且唯一
        2. 一张表只能有一个字段为主键
        3. 主键就是表中记录的唯一标识
</code></pre><h3 id="2-在创建表时，添加主键约束"><a href="#2-在创建表时，添加主键约束" class="headerlink" title="2. 在创建表时，添加主键约束"></a>2. 在创建表时，添加主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key,-- 给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="3-删除主键"><a href="#3-删除主键" class="headerlink" title="3. 删除主键"></a>3. 删除主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 错误 alter table stu modify id int ;</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br><span class="line">-- 删除主键只能去除主键描述，不能去除not null的描述。这是在添加主键时一块看到的</span><br></pre></td></tr></table></figure>
<h3 id="4-创建完表后，添加主键"><a href="#4-创建完表后，添加主键" class="headerlink" title="4. 创建完表后，添加主键"></a>4. 创建完表后，添加主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT PRIMARY KEY;</span><br></pre></td></tr></table></figure>
<h3 id="5-自动增长："><a href="#5-自动增长：" class="headerlink" title="5. 自动增长："></a>5. 自动增长：</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.  概念"></a>1.  概念</h4><p>如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p>
<h4 id="2-在创建表时，添加主键约束，并且完成主键自增长"><a href="#2-在创建表时，添加主键约束，并且完成主键自增长" class="headerlink" title="2. 在创建表时，添加主键约束，并且完成主键自增长"></a>2. 在创建表时，添加主键约束，并且完成主键自增长</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">	id int primary key auto_increment,-- 给id添加主键约束</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="3-删除自动增长"><a href="#3-删除自动增长" class="headerlink" title="3. 删除自动增长"></a>3. 删除自动增长</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT;</span><br></pre></td></tr></table></figure>
<h4 id="4-添加自动增长"><a href="#4-添加自动增长" class="headerlink" title="4. 添加自动增长"></a>4. 添加自动增长</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>
<h4 id="5-实例："><a href="#5-实例：" class="headerlink" title="5. 实例："></a>5. 实例：</h4><p>添加了的UNIQUE：<img src="/2020/07/17/MySql-constraint/image-20200717212741981.png" alt="image-20200717212741981"></p>
<p>删除UNIQUE：<img src="/2020/07/17/MySql-constraint/image-20200717212840136.png" alt="image-20200717212840136"></p>
<p>添加主键和自动增长：<img src="/2020/07/17/MySql-constraint/image-20200717211545947.png" alt="image-20200717211545947"></p>
<p>删除自动增长：<img src="/2020/07/17/MySql-constraint/image-20200717211650687.png" alt="image-20200717211650687"></p>
<p>删除主键：<img src="/2020/07/17/MySql-constraint/image-20200717211737868.png" alt="image-20200717211737868"></p>
<p>再删除null：<img src="/2020/07/17/MySql-constraint/image-20200717211850385.png" alt="image-20200717211850385"></p>
<h2 id="六、-外键约束：foreign-key"><a href="#六、-外键约束：foreign-key" class="headerlink" title="六、 外键约束：foreign key"></a>六、 外键约束：foreign key</h2><p>让表与表产生关系，从而保证数据的正确性。</p>
<h3 id="1-在创建表时，可以添加外键"><a href="#1-在创建表时，可以添加外键" class="headerlink" title="1. 在创建表时，可以添加外键"></a>1. 在创建表时，可以添加外键</h3><ul>
<li>语法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	....</span><br><span class="line">	外键列</span><br><span class="line">	constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-删除外键"><a href="#2-删除外键" class="headerlink" title="2. 删除外键"></a>2. 删除外键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure>
<h3 id="3-创建表之后，添加外键"><a href="#3-创建表之后，添加外键" class="headerlink" title="3. 创建表之后，添加外键"></a>3. 创建表之后，添加外键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</span><br></pre></td></tr></table></figure>
<h3 id="4-级联操作"><a href="#4-级联操作" class="headerlink" title="4. 级联操作"></a>4. 级联操作</h3><p>外键表想要修改id那么用了这个列的表也能同时一块修改，这样的操作就是级联操作。也就是凡是引用了它的表都能修改了。</p>
<h4 id="1-添加级联操作"><a href="#1-添加级联操作" class="headerlink" title="1. 添加级联操作"></a>1. 添加级联操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 </span><br><span class="line">		FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;</span><br></pre></td></tr></table></figure>
<h4 id="2-分类："><a href="#2-分类：" class="headerlink" title="2. 分类："></a>2. 分类：</h4><pre><code>            1. 级联更新：ON UPDATE CASCADE ：一块能更新
            2. 级联删除：ON DELETE CASCADE ：一块能删除
</code></pre><h3 id="5-实例"><a href="#5-实例" class="headerlink" title="5. 实例"></a>5. 实例</h3><p>外键：<img src="/2020/07/17/MySql-constraint/image-20200717214619493.png" alt="image-20200717214619493"></p>
<p>作为外键自身还不知道：<img src="/2020/07/17/MySql-constraint/image-20200717214659917.png" alt="image-20200717214659917"></p>
<p>删除外键后，那一列也无太大反应：<img src="/2020/07/17/MySql-constraint/image-20200717214832168.png" alt="image-20200717214832168"></p>
<p>但是可以加入一些department表中没有的部门了：<img src="/2020/07/17/MySql-constraint/image-20200717214919416.png" alt="image-20200717214919416"></p>
<p>添加外键：</p>
<p><img src="/2020/07/17/MySql-constraint/image-20200717215249576.png" alt="image-20200717215249576"></p>
<p>但由于其中含有department表中没有的项，所以把它删除掉后才可以再次设置外键：</p>
<h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><h2 id="一、多表之间的关系"><a href="#一、多表之间的关系" class="headerlink" title="一、多表之间的关系"></a>一、多表之间的关系</h2><h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="1. 分类："></a>1. 分类：</h3><pre><code>        （1） 一对一(了解)：
            * 如：人和身份证
            * 分析：一个人只有一个身份证，一个身份证只能对应一个人
        （2） 一对多(多对一)：
            * 如：部门和员工
            * 分析：一个部门有多个员工，一个员工只能对应一个部门
        （3） 多对多：
            * 如：学生和课程
            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择
</code></pre><h3 id="2-实现关系："><a href="#2-实现关系：" class="headerlink" title="2. 实现关系："></a>2. 实现关系：</h3><pre><code>        1. 一对多(多对一)：
            * 如：部门和员工
            * 实现方式：在多的一方建立外键，指向一的一方的主键。
        2. 多对多：
            * 如：学生和课程
            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键
        3. 一对一(了解)：
            * 如：人和身份证
            * 实现方式：一对一关系实现，可以在任意一方添加唯一非空外键指向另一方的主键（UNIQUR，not null）。
</code></pre><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建旅游线路分类表 tab_category</span><br><span class="line">-- cid 旅游线路分类主键，自动增长</span><br><span class="line">-- cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">	cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建旅游线路表 tab_route</span><br><span class="line">&#x2F;*</span><br><span class="line">rid 旅游线路主键，自动增长</span><br><span class="line">rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">price 价格</span><br><span class="line">rdate 上架时间，日期类型</span><br><span class="line">cid 外键，所属分类</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">	rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">	price DOUBLE,</span><br><span class="line">	rdate DATE,</span><br><span class="line">	cid INT,</span><br><span class="line">	FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;*创建用户表 tab_user</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">	uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">	PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">	NAME VARCHAR(100),</span><br><span class="line">	birthday DATE,</span><br><span class="line">	sex CHAR(1) DEFAULT &#39;男&#39;,</span><br><span class="line">	telephone VARCHAR(11),</span><br><span class="line">	email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">	rid INT, -- 线路id</span><br><span class="line">	DATE DATETIME,</span><br><span class="line">	uid INT, -- 用户id</span><br><span class="line">	-- 创建复合主键</span><br><span class="line">	PRIMARY KEY(rid,uid), -- 联合主键</span><br><span class="line">	FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">	FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h2 id="二、数据库设计的范式"><a href="#二、数据库设计的范式" class="headerlink" title="二、数据库设计的范式"></a>二、数据库设计的范式</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求<br>    设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>    目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><pre><code>        1. 第一范式（1NF）：每一列都是不可分割的原子数据项
        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）
            * 几个概念：
                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A
                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数
                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。
                    例如：（学号，课程名称） --&gt; 分数
                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。
                    例如：（学号，课程名称） -- &gt; 姓名
                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A
                    例如：学号--&gt;系名，系名--&gt;系主任
                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码
                    例如：该表中码为：（学号，课程名称）
                    * 主属性：码属性组中的所有属性
                    * 非主属性：除过码属性组的属性

        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
</code></pre><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><h2 id="一、命令行："><a href="#一、命令行：" class="headerlink" title="一、命令行："></a>一、命令行：</h2><pre><code>    * 语法：
        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径
        * 还原：
            1. 登录数据库
            2. 创建数据库
            3. 使用数据库 
            4. 执行文件。source 文件路径
</code></pre><h2 id="二、图形化工具："><a href="#二、图形化工具：" class="headerlink" title="二、图形化工具："></a>二、图形化工具：</h2>]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>Maven基础</title>
    <url>/2021/03/13/Maven-basic-md/</url>
    <content><![CDATA[<h2 id="第一章-Maven介绍"><a href="#第一章-Maven介绍" class="headerlink" title="第一章 Maven介绍"></a>第一章 Maven介绍</h2><h3 id="1-1-什么是Maven"><a href="#1-1-什么是Maven" class="headerlink" title="1.1 什么是Maven"></a>1.1 什么是Maven</h3><p>Maven 是一个项目管理工具，它包含了一个<strong>项目对象模型</strong> (POM：Project Object Model)，一组<strong>标准集合</strong>，一个<strong>项目生命周期</strong>(Project Lifecycle)，一个<strong>依赖管理系统</strong>(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</p>
<h3 id="1-2-Maven两个经典作用"><a href="#1-2-Maven两个经典作用" class="headerlink" title="1.2 Maven两个经典作用"></a>1.2 Maven两个经典作用</h3><h4 id="1-2-1-Maven-的依赖管理"><a href="#1-2-1-Maven-的依赖管理" class="headerlink" title="1.2.1 Maven 的依赖管理"></a>1.2.1 Maven 的依赖管理</h4><p>要将项目运行起来，就得要把项目所依赖得jar包添加到工程，项目工程大小就很大，得几兆。</p>
<p>如果使用Maven则会发现总体上工程的大小会少很多。</p>
<p>因为Maven把所用到得jar包管理到了一个仓库中。它让任何想要用jar包的工程都去从仓库中引用。那么每个工程就不用自己携带jar包了。在每个项目中放置jar包在jar包仓库中的坐标即可。</p>
<p>这个就叫做Maven的<strong>依赖管理</strong>。</p>
<p>Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210313221728818.png" alt="image-20210313221728818"></p>
<a id="more"></a>
<p>maven 工程中不直接将 jar 包导入到工程中，而是<strong>通过在 pom.xml 文件中添加所需 jar 包的坐标</strong>。</p>
<blockquote>
<p>问题一：通过读取 pom.xml 文件中的坐标，再到仓库中找到 jar 包，会不会很慢？从而导致这种方式 不可行！</p>
<p>​             通过 pom.xml 文件配置要引入的 jar 包的坐标，再读取坐标并到仓库中加载 jar 包，这样我们就可以直接使用 jar 包了，为了解决这个过程中速度慢的问题，maven 中也有索引的概念，通 过建立索引，可以大大提高加载 jar 包的速度，使得我们认为 jar 包基本跟放在本地的工程文件中再 读取出来的速度是一样的。</p>
</blockquote>
<h4 id="1-2-2-项目的一键构建"><a href="#1-2-2-项目的一键构建" class="headerlink" title="1.2.2 项目的一键构建"></a>1.2.2 项目的一键构建</h4><p>项目往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。</p>
<p><strong>构建</strong>指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理的过程。</p>
<p><strong>一键构建</strong>指的是整个构建过程，使用 maven一个命令（<strong>mvn tomcat:run</strong>）可以轻松完成整个工作。</p>
<h2 id="第二章-Maven的使用"><a href="#第二章-Maven的使用" class="headerlink" title="第二章 Maven的使用"></a>第二章 Maven的使用</h2><h3 id="2-1-Maven的安装"><a href="#2-1-Maven的安装" class="headerlink" title="2.1 Maven的安装"></a>2.1 Maven的安装</h3><h4 id="2-1-1-下载与安装"><a href="#2-1-1-下载与安装" class="headerlink" title="2.1.1 下载与安装"></a>2.1.1 下载与安装</h4><p>下载后解压即可，放在一个没有中文没有空格的路径下。</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210314193027480.png" alt="image-20210314193027480"></p>
<h4 id="2-1-2-配置系统变量"><a href="#2-1-2-配置系统变量" class="headerlink" title="2.1.2 配置系统变量"></a>2.1.2 配置系统变量</h4><p>配置 <strong>MAVEN_HOME</strong> ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录）</p>
<p>然后在系统变量中加入 <strong>%MAVEN_HOME%/bin</strong></p>
<h4 id="2-1-3-Maven-版本测试"><a href="#2-1-3-Maven-版本测试" class="headerlink" title="2.1.3 Maven 版本测试"></a>2.1.3 Maven 版本测试</h4><p><code>mvn -v</code> 检查maven是否安装成功。</p>
<h3 id="2-2-Maven仓库"><a href="#2-2-Maven仓库" class="headerlink" title="2.2 Maven仓库"></a>2.2 Maven仓库</h3><h4 id="2-2-1-Maven-仓库的分类"><a href="#2-2-1-Maven-仓库的分类" class="headerlink" title="2.2.1 Maven 仓库的分类"></a>2.2.1 Maven 仓库的分类</h4><p><strong>“远程仓库”</strong>，<strong>“本地仓库”</strong>，“<strong>中央仓库</strong>”的关系</p>
<ul>
<li><strong>本地仓库</strong>：用来存储从远程仓库或中央仓库下载的插件和 jar 包，<ul>
<li>默认本地仓库位置在 <code>${user.dir}/.m2/repository</code>，<code>${user.dir}</code>表示 windows 用户目录。</li>
</ul>
</li>
<li><strong>远程仓库</strong>：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。</li>
<li><strong>中央仓库</strong>：在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a> ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件。</li>
</ul>
<p><img src="/2021/03/13/Maven-basic-md/maven仓库的种类和关系.png" alt="maven仓库的种类和关系"></p>
<h4 id="2-2-2-Maven-本地仓库的配置"><a href="#2-2-2-Maven-本地仓库的配置" class="headerlink" title="2.2.2 Maven 本地仓库的配置"></a>2.2.2 Maven 本地仓库的配置</h4><p>在 <code>MAVE_HOME/conf/settings.xml</code> 文件中配置本地仓库位置（maven 的安装目录下)</p>
<p>打开 settings.xml文件，配置其中<code>localRepository</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\software\Programing_software\maven_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-全局-setting-与用户-setting"><a href="#2-2-3-全局-setting-与用户-setting" class="headerlink" title="2.2.3 全局 setting 与用户 setting"></a>2.2.3 全局 setting 与用户 setting</h4><p>maven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。 </p>
<p>在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project 项目，它作为 maven 的全局配置。 </p>
<p>如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：<code>${user.dir} /.m2/settings.xml</code> 目录中,<code>${user.dir}</code> 指 windows 中的用户目录。 </p>
<p>maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210314195549254.png" alt="image-20210314195549254"></p>
<h3 id="2-3-Maven-工程的认识"><a href="#2-3-Maven-工程的认识" class="headerlink" title="2.3 Maven 工程的认识"></a>2.3 Maven 工程的认识</h3><h4 id="2-3-1-Maven-工程的目录结构"><a href="#2-3-1-Maven-工程的目录结构" class="headerlink" title="2.3.1 Maven 工程的目录结构"></a>2.3.1 Maven 工程的目录结构</h4><p>这个目录结构不是上面那个Maven软件的目录结构。而是用Maven管理的工程的目录结构</p>
<p>一个项目管理起来所需要的几个组成部分都有四种：</p>
<p>（1）核心代码部分</p>
<p>（2）配置文件部分</p>
<p>（3）测试代码部分</p>
<p>（4）测试配置部分</p>
<p>传统项目目录结构：</p>
<p>src目录下存放着四种代码。打包的时候可能会发生交叉混乱。</p>
<p>Maven建立了一个项目的标准目录结构</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210314195150747.png" alt="image-20210314195150747"></p>
<h2 id="第3章-Maven-常用命令"><a href="#第3章-Maven-常用命令" class="headerlink" title="第3章 Maven 常用命令"></a>第3章 Maven 常用命令</h2><h3 id="3-1-Maven-常用命令"><a href="#3-1-Maven-常用命令" class="headerlink" title="3.1 Maven 常用命令"></a>3.1 Maven 常用命令</h3><p>在Maven工程下，打开命令提示符，可以输入Maven 常用命令对Maven工程进行操作。</p>
<h4 id="3-1-1-mvn-clean"><a href="#3-1-1-mvn-clean" class="headerlink" title="3.1.1 mvn clean"></a>3.1.1 mvn clean</h4><p>可以把target文件夹删除掉。也就是删除之前编译的信息。</p>
<h4 id="3-1-2-mvn-compile"><a href="#3-1-2-mvn-compile" class="headerlink" title="3.1.2 mvn compile"></a>3.1.2 mvn compile</h4><p>仅把<code>src/main</code>目录下的代码进行编译。</p>
<h4 id="3-1-3-mvn-test"><a href="#3-1-3-mvn-test" class="headerlink" title="3.1.3 mvn test"></a>3.1.3 mvn test</h4><p>对<code>src/test</code>下的代码进行测试。而且还把<code>src/main</code>目录下的代码也进行编译</p>
<h4 id="3-1-4-mvn-package"><a href="#3-1-4-mvn-package" class="headerlink" title="3.1.4 mvn package"></a>3.1.4 mvn package</h4><p>对整个项目进行打包。还生成了war文件。</p>
<p>查看pom.xml文件就会发现，配置文件中配置了打包成war包。</p>
<h4 id="3-1-5-mvn-install"><a href="#3-1-5-mvn-install" class="headerlink" title="3.1.5 mvn install"></a>3.1.5 mvn install</h4><p>相当于<code>mvn package</code>后，再把war包安装到了本地仓库。</p>
<h3 id="3-2-Maven-指令的生命周期"><a href="#3-2-Maven-指令的生命周期" class="headerlink" title="3.2 Maven 指令的生命周期"></a>3.2 Maven 指令的生命周期</h3><p>Maven工程的过程</p>
<p><strong>清理生命周期（Clean Lifecycle）</strong> 在进行真正的构建之前进行一些清理工作。</p>
<p><strong>默认生命周期（Default Lifecycle）</strong> 构建的核心部分，编译，测试，打包，部署等等。</p>
<p><strong>站点生命周期（Site Lifecycle）</strong> 生成项目报告，站点，发布站点。</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210315110019302.png" alt="image-20210315110019302"></p>
<h3 id="3-3-Maven概念模型"><a href="#3-3-Maven概念模型" class="headerlink" title="3.3 Maven概念模型"></a>3.3 Maven概念模型</h3><p>Maven 包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段 (phase)中插件(plugin)目标(goal)的逻辑。</p>
<p><img src="/2021/03/13/Maven-basic-md/image-20210315110905565.png" alt="image-20210315110905565"></p>
<h3 id="3-4-idea开发maven项目"><a href="#3-4-idea开发maven项目" class="headerlink" title="3.4 idea开发maven项目"></a>3.4 idea开发maven项目</h3><h4 id="3-4-1-在idea中配置maven"><a href="#3-4-1-在idea中配置maven" class="headerlink" title="3.4.1 在idea中配置maven"></a>3.4.1 在idea中配置maven</h4><p>要在idea中使用maven就要配置它。</p>
<p>setttings里搜maven。然后填写maven主目录，设置文件路径，还有本地仓库路径。</p>
<p>running里面配置：<code>-DarchetypeCatalog=internal</code> 使得它首先从本地仓库中找包。</p>
<p>再对maven下的setting进行配置阿里云的镜像：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-使用maven骨架创建java工程"><a href="#3-4-2-使用maven骨架创建java工程" class="headerlink" title="3.4.2 使用maven骨架创建java工程"></a>3.4.2 使用maven骨架创建java工程</h4><p>新建maven项目就好。选择quickstart骨架。然后结束后，它不会把整个的目录创建好，需要手动补齐。</p>
<p>添加 resources文件。</p>
<h4 id="3-4-3-使用maven无骨架创建java工程"><a href="#3-4-3-使用maven无骨架创建java工程" class="headerlink" title="3.4.3 使用maven无骨架创建java工程"></a>3.4.3 使用maven无骨架创建java工程</h4><p>新建maven项目就好。然后结束后，他有着默认的maven目录结构。</p>
<h4 id="3-4-4-使用maven骨架创建web工程"><a href="#3-4-4-使用maven骨架创建web工程" class="headerlink" title="3.4.4 使用maven骨架创建web工程"></a>3.4.4 使用maven骨架创建web工程</h4><p>用到了webapp骨架。创建好以后，只有<code>src/main/webapp</code>目录。其他的需要自主创建。</p>
<h3 id="3-5-创建一个servlet"><a href="#3-5-创建一个servlet" class="headerlink" title="3.5 创建一个servlet"></a>3.5 创建一个servlet</h3><h4 id="3-5-1-指定某目录为web资源包"><a href="#3-5-1-指定某目录为web资源包" class="headerlink" title="3.5.1 指定某目录为web资源包"></a>3.5.1 指定某目录为web资源包</h4><p>可以在<code>webapp</code>下加入网页资源文件。要想在其他文件夹下加入网页资源文件可以把该文件设为该工程的”project structure”，“module”，然后“web”。</p>
<h4 id="3-5-2-导入项目依赖的jar包"><a href="#3-5-2-导入项目依赖的jar包" class="headerlink" title="3.5.2 导入项目依赖的jar包"></a>3.5.2 导入项目依赖的jar包</h4><p>给<code>pom.xml</code>加入依赖jar包。可以直接在中央仓库中找xml的写法。</p>
<p>这里写了一个<code>servlet</code>。需要两个jar包。<code>servlet</code> 和 <code>jsp</code></p>
<p>然后用 <code>mvn tomcat:run</code> 来运行。</p>
<p>发现报错</p>
<h4 id="3-5-3-解决jar包冲突"><a href="#3-5-3-解决jar包冲突" class="headerlink" title="3.5.3 解决jar包冲突"></a>3.5.3 解决jar包冲突</h4><p>因为tomcat是maven带的。它里面也带了<code>servlet</code> 和 <code>jsp</code>。运行时把代码拿进去发现这两个对象不一样。所以会出现冲突。</p>
<p>为解决这个问题需要给<code>pom.xml</code>里的依赖包加入一个范围。这个范围决定了该<code>jar</code>包仅在写的时候不让他报错就好。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样下来就可以使得代码用tomcat里的包了。</p>
<h4 id="3-5-4-maven工程运行环境修改"><a href="#3-5-4-maven工程运行环境修改" class="headerlink" title="3.5.4 maven工程运行环境修改"></a>3.5.4 maven工程运行环境修改</h4><p>还可以用tomcat7，还设置了端口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般这种可以设置动态模板的方式来定义。</p>
<p>setting ——Live templates——加号选择创建动态模板的组。然后在该组里创建模板。写入模板代码，然后定义模板使用范围XML。就可以在XML中写入tomcat7，自动导入tomcat7插件模板。</p>
<h4 id="3-5-5-maven的java工程从mysql中取数据"><a href="#3-5-5-maven的java工程从mysql中取数据" class="headerlink" title="3.5.5 maven的java工程从mysql中取数据"></a>3.5.5 maven的java工程从mysql中取数据</h4><ol>
<li>先在mySQL里建立一个数据库，建立表Items，有id，name两个列</li>
<li>创建一个java工程</li>
<li>创建一个Items类，有两个私有变量。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/2020/07/28/Slash-offer-05/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="python解法"><a href="#python解法" class="headerlink" title="python解法"></a>python解法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        L = []</span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">" "</span>:</span><br><span class="line">                L.append(s[last:i]+<span class="string">"%20"</span>)</span><br><span class="line">                last = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> last &lt; len(s):</span><br><span class="line">            L.append(s[last:len(s)])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(L)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.replaceSpace(<span class="string">"I am the Only King!"</span>))</span><br><span class="line">    print(a.replaceSpace(<span class="string">"  "</span>))</span><br></pre></td></tr></table></figure>
<h2 id="java解法"><a href="#java解法" class="headerlink" title="java解法"></a>java解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Slash_offer.easy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slash_offer_05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Slash_offer_05 slash_offer_05 = <span class="keyword">new</span> Slash_offer_05();</span><br><span class="line">        System.out.println(slash_offer_05.replaceSpace(<span class="string">"I am the king"</span>));</span><br><span class="line">        System.out.println(slash_offer_05.replaceSpace(<span class="string">"  "</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span> [] res = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span> * length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">' '</span>==(s.charAt(i)))&#123;</span><br><span class="line">                res[j++] = <span class="string">'%'</span>;</span><br><span class="line">                res[j++] = <span class="string">'2'</span>;</span><br><span class="line">                res[j++] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[j++] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res,<span class="number">0</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>剑指offer</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_11</title>
    <url>/2020/07/22/Slash-offer-11/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剑指 Offer 11. 旋转数组的最小数字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span></span><br><span class="line"><span class="comment"> * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</span></span><br><span class="line"><span class="comment"> * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：[3,4,5,1,2]</span></span><br><span class="line"><span class="comment"> * 输出：1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 2：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：[2,2,2,0,1]</span></span><br><span class="line"><span class="comment"> * 输出：0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 解题：  二分查找</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 这里把前部分数组叫做递增数组，把后部分数组叫做旋转数组。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 由于不是一个严格递增的数组所以需要对原来的二分查找有所修改。</span></span><br><span class="line"><span class="comment">       * 当然开始也是求出位置为一半的值：mid</span></span><br><span class="line"><span class="comment">       * number[mid]和 number[left] 与 number[right] 相比较。考虑：</span></span><br><span class="line"><span class="comment">       *      情况一：number[mid] 小于 number[left] 说明mid在被旋转的数组区域，</span></span><br><span class="line"><span class="comment">       *          那么mid之后的就可以被舍弃了，最小值不在这里，但mid不能被舍弃，因为它还有可能是最小值。right = mid</span></span><br><span class="line"><span class="comment">       *      情况二：number[mid] 大于等于 number[left] 说明mid在递增的前一部分区间。</span></span><br><span class="line"><span class="comment">       *          那么mid之前的被舍弃，最小值不在这部分，mid也可以被舍弃。 left = mid + 1</span></span><br><span class="line"><span class="comment">       *      情况三：被舍弃后可能会出现完全递增的情况，即递增数组部分完全被舍弃了。</span></span><br><span class="line"><span class="comment">       *          此时也是需要判断  number[left] 与 number[right] ；</span></span><br><span class="line"><span class="comment">       *          如果 number[left] 小于 number[right]： 直接返回 number[left]</span></span><br><span class="line"><span class="comment">       *      情况四：一轮舍弃之后还可能出现 number[right] 是最小值的情况，即之前的都递增，到 right位置掉了下来。</span></span><br><span class="line"><span class="comment">       *            这种情况可以在下一轮自动找出来。</span></span><br><span class="line"><span class="comment">       *              比如[1,2,0] left会编程0位置上，那么left==right跳出循环。</span></span><br><span class="line"><span class="comment">       *              但是如果是 [1,2,3,0] 那么mid是2的位置属于情况二,left变成3的位置，数组成了[3,0]。</span></span><br><span class="line"><span class="comment">       *              此时再求mid是3的位置，number[mid] 等于 number[left]    属于情况二，left变为0的位置跳出循环。</span></span><br><span class="line"><span class="comment">       * 所以二分查找的重点在于左右游标的一个只管mid另一个要舍掉更多。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 如果思考一个完全递增数组的二分查找的话。也可以分析出这样的多种情况；</span></span><br><span class="line"><span class="comment">       * 求出位置为一半的值：mid</span></span><br><span class="line"><span class="comment">       * number[mid]和 要查找的 target 相比较。考虑：</span></span><br><span class="line"><span class="comment">       *      情况一：number[mid] 小于 target；那么肯定 target 在 mid之后；</span></span><br><span class="line"><span class="comment">       *      情况二：number[mid] 大于 target；那么 target在 mid 之前。</span></span><br><span class="line"><span class="comment">       *      情况三：number[mid] 等于 target；那么 target就在 mid 位置，直接返回mid</span></span><br><span class="line"><span class="comment">       *      情况一和情况二下，这个舍弃 mid，那边都可以选择不要，还是要考虑最后怎么跳出循环：</span></span><br><span class="line"><span class="comment">       *           例如数组：[1,2,3] 查找 3 ；mid找到是2的位置，小于 target 3，此时让left = mid + 1那么就能直接跳出循环。</span></span><br><span class="line"><span class="comment">       *                            查找 1 ；同样的mid在 2 的位置， 大于 target 3 让 right = mid - 1 直接就能跳出循环。</span></span><br><span class="line"><span class="comment">       *           在数组：[1,2]    查找 2 ： mid 在1的位置，小于target 2， 让 left = mid + 1 也能跳出循环。</span></span><br></pre></td></tr></table></figure>
<p>有重复数字报错了；</p>
<h2 id="补救"><a href="#补救" class="headerlink" title="补救"></a>补救</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**     </span></span><br><span class="line"><span class="comment">* 以上的题解都是在假设数组中没有重复元素的情况下如何去二分查找</span></span><br><span class="line"><span class="comment">   *      解决重复数字方法一：赋值 left 和 right 后把她两往前滑一滑：</span></span><br><span class="line"><span class="comment">   *          在依然 left &lt; right 的情况下：</span></span><br><span class="line"><span class="comment">   *              判断 right 左边的 numbers[right - 1] 是否等于 numbers[right]，等于就往左滑</span></span><br><span class="line"><span class="comment">   *              判断 left  右边的 numbers[left + 1] 是否等于  numbers[left], 等于就往右滑</span></span><br><span class="line"><span class="comment">   *          其实这种处理办法还是在把重复的数字块当作一个数字，也就是说把	[10,1,10,10,10] 当作 [10,1,10]</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *      解决重复数组的方法二：就是把等于这一项单列出来上面分析把大于和等于放在一起考虑。但是后来发现他们是不能放在一起考虑的：</span></span><br><span class="line"><span class="comment">   *          比如： [10, 1, 10, 10, 10], 这里mid在索引为 2 的位置，把大于等于放在一起考虑则就默认中间是没有小于1这种情况存在的。</span></span><br><span class="line"><span class="comment">   *              不如就等于时把high慢慢往下放，直到循环条件不满足时；</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>
<h2 id="补救代码一："><a href="#补救代码一：" class="headerlink" title="补救代码一："></a>补救代码一：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right &amp;&amp;  (numbers[right-<span class="number">1</span>] == numbers[right]))&#123;</span><br><span class="line">        right = right-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right &amp;&amp; (numbers[left+<span class="number">1</span>] == numbers[left]))&#123;</span><br><span class="line">        left = left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[left] &lt; numbers[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &lt; numbers[left] )&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp;  (numbers[right-<span class="number">1</span>] == numbers[right]))&#123;</span><br><span class="line">                right = right-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt;= numbers[left])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (numbers[left+<span class="number">1</span>] == numbers[left]))&#123;</span><br><span class="line">                left = left+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补救代码二："><a href="#补救代码二：" class="headerlink" title="补救代码二："></a>补救代码二：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[left] &lt; numbers[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &lt; numbers[left] )&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt;= numbers[left])&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/2020/07/28/Slash-offer-06/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>还是很好写的。很多数据结构的变换都不需要考虑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        root = head</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            res.insert(<span class="number">0</span>,root.val)</span><br><span class="line">            root = root.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    Head = ListNode(<span class="number">1</span>)</span><br><span class="line">    R = Head</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(L):</span><br><span class="line">        R.next = ListNode(L[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        R = R.next</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.reversePrint(Head))</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>这里用到了<code>Stack</code>类</p>
<p><img src="/2020/07/28/Slash-offer-06/image-20200728215332498.png" alt="image-20200728215332498"></p>
<p><img src="/2020/07/28/Slash-offer-06/SouthEast" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Slash_offer.easy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">          val = x;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slash_offer_06_</span>从尾到头打印链表 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Slash_offer_06_从尾到头打印链表 slash_offer_06_从尾到头打印链表 = <span class="keyword">new</span> Slash_offer_06_从尾到头打印链表();</span><br><span class="line">        <span class="keyword">int</span> [] L = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        ListNode Head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode R = Head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;L.length)&#123;</span><br><span class="line">            R.next = <span class="keyword">new</span> ListNode(L[i++]);</span><br><span class="line">            R = R.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : slash_offer_06_从尾到头打印链表.reversePrint(Head)) &#123;</span><br><span class="line">            System.out.println(i1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; integers = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode R = head;</span><br><span class="line">        <span class="keyword">while</span> (R!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            integers.push(R.val);</span><br><span class="line">            R = R.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = integers.size();</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length ; i++) &#123;</span><br><span class="line">            ints[i] = integers.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>剑指offer</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <url>/2020/07/23/Slash-offer-14-1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里就自己手动算了几个值；</p>
<pre><code>1 是没法分的
2 可以分为 1 和 1    积为 1
3 可分为 1 和 2         积为 2 
4 可分为 (2,2),(1,3) 最大积为4
5 可分为(1,4),(2,3)    最大积为 6
6 可分为(1,5)(2,4),(3,3)    最大积为9

虽然可以分为多个但是多个也是由几个值加在一起的。比如分的时候分出来了5以上那么一定会把他再分。而前期算出来了每个值的最大值都可以后面再利用。

比如再计算7，它可分为(1,6)(2,5)(3,4);
虽然其中5和6还可以再分。但此时我们就不管它分不分了，直接在上面查表。
发现5分之后的最大值是6，6分之后的最大值是9；
明显这是比5或6在原来的贡献更大，并且已知是他所能分开的最大贡献了。于是后面维护这个表就好了。

当然还有别的更好的算法吧。但这个是可以求得结果的。
</code></pre><p>HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; integerIntegerHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    integerIntegerHashMap.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    integerIntegerHashMap.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    integerIntegerHashMap.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    integerIntegerHashMap.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span> ; i &lt;= n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = integerIntegerHashMap.get(j) * integerIntegerHashMap.get(i-j);</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; MAX)&#123;</span><br><span class="line">                MAX = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        integerIntegerHashMap.put(i,MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> integerIntegerHashMap.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            ints[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span> ; i &lt; ints.length ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = ints[j] * ints[i - j];</span><br><span class="line">                <span class="keyword">if</span> (MAX &lt; temp) &#123;</span><br><span class="line">                    MAX = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ints.length; i++)&#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别写了下hashmap和数组，结果HashMap高一点点</p>
<h1 id="看答案"><a href="#看答案" class="headerlink" title="看答案"></a>看答案</h1><p>看到了一个挺好的动态规划。他把剪绳子分成了两种。眼下手里已经剪了的部分乘上剩下部分；剩下部分有两种命运： </p>
<ol>
<li>不剪了； </li>
<li>接着剪；他要从里面选较大的那个；</li>
</ol>
<script type="math/tex; mode=display">
F(n)=max(i×(n−i),i×F(n−i)),  i=1,2,...,n−2。</script><p>我们发现任何大于 3 的数都可以拆分为数字 1，2，3的和，且它们对 3 的余数总是 0，1，2，因此我们可以仅用 dp[0]，dp[1]，dp[2] 表示所有大于 3 的值，这样空间复杂度可降到 O(1)。</p>
<p><img src="https://pic.leetcode-cn.com/3be12f435b2a0668eecd747c5d08188128fde7764b99116123b86880280f62ca-14.gif" alt="14.gif"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i % <span class="number">3</span>] = max(max(dp[(i - <span class="number">1</span>) % <span class="number">3</span>], i - <span class="number">1</span>),</span><br><span class="line">                <span class="number">2</span> * max(dp[(i - <span class="number">2</span>) % <span class="number">3</span>], i - <span class="number">2</span>),</span><br><span class="line">                <span class="number">3</span> * max(dp[(i - <span class="number">3</span>) % <span class="number">3</span>], i - <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> dp[n % <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream</title>
    <url>/2020/07/16/Stream/</url>
    <content><![CDATA[<h1 id="第一章-Stream流"><a href="#第一章-Stream流" class="headerlink" title="第一章 Stream流"></a>第一章 Stream流</h1><h2 id="1-1-Stream流基本操作"><a href="#1-1-Stream流基本操作" class="headerlink" title="1.1 Stream流基本操作"></a>1.1 Stream流基本操作</h2><p>类集里支持有数据的流式分析处理操作，为此专门提供了一个Stream的接口，同时Collection接口里也提供有为此接口实例化的方法：</p>
<ul>
<li><p><code>public default Stream&lt;E&gt; straem()</code> : 获得Stream接口对象。</p>
</li>
<li><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>：一个断言里面写一个lambda表达式</p>
</li>
</ul>
<p>Stream主要功能是进行数据的分析处理，同时主要是针对于集合中的数据进行分析操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Stream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Stream的基本操作</span></span><br><span class="line">        List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collections.addAll(all, <span class="string">"java"</span>,<span class="string">"javascript"</span>,<span class="string">"python"</span>,<span class="string">"Ruby"</span>,<span class="string">"go"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = all.stream();</span><br><span class="line">        <span class="comment">// 输出元素的个数</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.count()); // 5</span></span><br><span class="line">        <span class="comment">// 输出满足条件的元素，用filter方法</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.filter((ele) -&gt; ele.toLowerCase().contains("j")).count());</span></span><br><span class="line">        <span class="comment">// 2 上一句输出了这句输出就会报错：IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line">        List&lt;String&gt; result = stream.filter((ele) -&gt; ele.toLowerCase().contains(<span class="string">"j"</span>)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(result); <span class="comment">//[java, javascript]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>public Stream&lt;T&gt; limit(long maxSize)</code>：设置取出的最大数据量</li>
<li><code>public Stream &lt;T&gt; skip(long n)</code> ：跳过指定数据量<a id="more"></a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Stream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Stream的基本操作</span></span><br><span class="line">        List&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Collections.addAll(all, <span class="string">"java"</span>,<span class="string">"javascript"</span>,<span class="string">"JSP"</span>,<span class="string">"Json"</span>,<span class="string">"python"</span>,<span class="string">"Ruby"</span>,<span class="string">"go"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = all.stream();</span><br><span class="line">        <span class="comment">// 输出元素的个数</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.count()); // 5</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	 输出满足条件的元素，用filter方法</span></span><br><span class="line"><span class="comment">        	 2 上一句输出了这句输出就会报错：IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//        System.out.println(stream.filter((ele) -&gt; ele.toLowerCase().contains("j")).count());</span></span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; result = stream.filter((ele) -&gt; ele.toLowerCase().contains(<span class="string">"j"</span>)).skip(<span class="number">2</span>).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(result); <span class="comment">//[java, javascript]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stream 只要是利用自身的特点实现数据的分析处理操作。 </p>
<h2 id="1-2-MapReduce基础模型"><a href="#1-2-MapReduce基础模型" class="headerlink" title="1.2 MapReduce基础模型"></a>1.2 MapReduce基础模型</h2><p>同样是很多的对象进行过滤,选择其中包含“强”的。并且进行商品单价和数量的处理，随后分析汇总</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DoubleSummaryStatistics stat = all.stream().filter((ele)-&gt;ele.getName().contains(<span class="string">"强"</span>)).mapToDouble((orderObject)-&gt;orderObject.getPrice() * orderObject.getAmout().summaryStatistics());</span><br><span class="line">System.out.println(<span class="string">"购买数量： "</span> + stat.getCount());</span><br><span class="line">System.out.println(<span class="string">"购买总价： "</span> + stat.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均价格： "</span> + stat.getAverage());</span><br><span class="line">System.out.println(<span class="string">"最高花费： "</span> + stat.getMax());</span><br><span class="line">System.out.println(<span class="string">"最低花费： "</span> + stat.getMin());</span><br></pre></td></tr></table></figure>
<h2 id="1-3-各种类型获得Stream流的方法"><a href="#1-3-各种类型获得Stream流的方法" class="headerlink" title="1.3 各种类型获得Stream流的方法"></a>1.3 各种类型获得Stream流的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</span></span><br><span class="line"><span class="comment">    获取一个流非常简单，有以下几种常用的方式：</span></span><br><span class="line"><span class="comment">        - 所有的Collection集合都可以通过stream默认方法获取流；</span></span><br><span class="line"><span class="comment">            default Stream&lt;E&gt; stream​()</span></span><br><span class="line"><span class="comment">        - Stream接口的静态方法of可以获取数组对应的流。</span></span><br><span class="line"><span class="comment">            static &lt;T&gt; Stream&lt;T&gt; of​(T... values)</span></span><br><span class="line"><span class="comment">            参数是一个可变参数,那么我们就可以传递一个数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01GetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把集合转换为Stream流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取键,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取值,存储到一个Collection集合中</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取键值对(键与值的映射关系 entrySet)</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//可变参数可以传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">"a"</span>,<span class="string">"bb"</span>,<span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-常用方法"><a href="#1-4-常用方法" class="headerlink" title="1.4  常用方法"></a>1.4  常用方法</h2><ul>
<li><strong>延迟方法</strong>：返回值依然是Stream接口自身类型的方法，所以可以支持链式调用</li>
<li><p><strong>终结方法</strong>：返回值类型不再是Stream接口自身类型方法。终结方法包括：<code>count</code>和<code>foreach</code></p>
<h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接受一个<code>Consumer</code>接口函数，会将每一个流元素交给该函数进行 处理</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_forEach</span></span><br><span class="line"><span class="comment">    void forEach(Consumer&lt;? super T&gt; action);</span></span><br><span class="line"><span class="comment">    该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。</span></span><br><span class="line"><span class="comment">    Consumer接口是一个消费型的函数式接口,可以传递Lambda表达式,消费数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    简单记:</span></span><br><span class="line"><span class="comment">        forEach方法,用来遍历流中的数据</span></span><br><span class="line"><span class="comment">        是一个终结方法,遍历之后就不能继续调用Stream流中的其他方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Stream_forEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>, <span class="string">"田七"</span>);</span><br><span class="line">        <span class="comment">//使用Stream流中的方法forEach对Stream流中的数据进行遍历</span></span><br><span class="line">        <span class="comment">/*stream.forEach((String name)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        stream.forEach(name-&gt;System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h4><p>这个接口是一个函数式接口，其中唯一的抽象方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_filter:用于对Stream流中的数据进行过滤</span></span><br><span class="line"><span class="comment">    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span></span><br><span class="line"><span class="comment">    filter方法的参数Predicate是一个函数式接口,所以可以传递Lambda表达式,对数据进行过滤</span></span><br><span class="line"><span class="comment">    Predicate中的抽象方法:</span></span><br><span class="line"><span class="comment">        boolean test(T t);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Stream_filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">//对Stream流中的元素进行过滤,只要姓张的人</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.filter((String name)-&gt;&#123;<span class="keyword">return</span> name.startsWith(<span class="string">"张"</span>);&#125;);</span><br><span class="line">        <span class="comment">//遍历stream2流</span></span><br><span class="line">        stream2.forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Stream流属于管道流,只能被消费(使用)一次</span></span><br><span class="line"><span class="comment">            第一个Stream流调用完毕方法,数据就会流转到下一个Stream上</span></span><br><span class="line"><span class="comment">            而这时第一个Stream流已经使用完毕,就会关闭了</span></span><br><span class="line"><span class="comment">            所以第一个Stream流就不能再调用方法了</span></span><br><span class="line"><span class="comment">            IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//遍历stream流</span></span><br><span class="line">        stream.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该接口需要一个<code>Function</code>函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型数据。</p>
<h4 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h4><p>其中唯一的抽象方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以将一种<code>T</code>类型转换成为<code>R</code>类型,而这种转换的动作就称为映射。</p>
<h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_map:用于类型转换</span></span><br><span class="line"><span class="comment">    如果需要将流中的元素映射到另一个流中，可以使用map方法.</span></span><br><span class="line"><span class="comment">    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class="line"><span class="comment">    该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</span></span><br><span class="line"><span class="comment">    Function中的抽象方法:</span></span><br><span class="line"><span class="comment">        R apply(T t);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Stream_map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个String类型的Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>);</span><br><span class="line">        <span class="comment">//使用map方法,把字符串类型的整数,转换(映射)为Integer类型的整数</span></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//遍历Stream2流</span></span><br><span class="line">        stream2.forEach(i-&gt; System.out.println(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>返回一个<code>long</code>值代表元素个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_count:用于统计Stream流中元素的个数</span></span><br><span class="line"><span class="comment">    long count();</span></span><br><span class="line"><span class="comment">    count方法是一个终结方法,返回值是一个long类型的整数</span></span><br><span class="line"><span class="comment">    所以不能再继续调用Stream流中的其他方法了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05Stream_count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count);<span class="comment">//7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取用前几个：-limit"><a href="#取用前几个：-limit" class="headerlink" title="取用前几个： limit"></a>取用前几个： limit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_limit:用于截取流中的元素</span></span><br><span class="line"><span class="comment">    limit方法可以对流进行截取，只取用前n个。方法签名：</span></span><br><span class="line"><span class="comment">    Stream&lt;T&gt; limit(long maxSize);</span></span><br><span class="line"><span class="comment">        参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作</span></span><br><span class="line"><span class="comment">    limit方法是一个延迟方法,只是对流中的元素进行截取,返回的是一个新的流,所以可以继续调用Stream流中的其他方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Stream_limit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">//使用limit对Stream流中的元素进行截取,只要前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.limit(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//遍历stream2流</span></span><br><span class="line">        stream2.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳过前几个方法：skip"><a href="#跳过前几个方法：skip" class="headerlink" title="跳过前几个方法：skip"></a>跳过前几个方法：skip</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_skip:用于跳过元素</span></span><br><span class="line"><span class="comment">    如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流：</span></span><br><span class="line"><span class="comment">    Stream&lt;T&gt; skip(long n);</span></span><br><span class="line"><span class="comment">        如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07Stream_skip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        <span class="comment">//使用skip方法跳过前3个元素</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = stream.skip(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//遍历stream2流</span></span><br><span class="line">        stream2.forEach(name-&gt; System.out.println(name));   <span class="comment">// 灰太狼,红太狼</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并：concat"><a href="#合并：concat" class="headerlink" title="合并：concat"></a>合并：concat</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stream流中的常用方法_concat:用于把流组合到一起</span></span><br><span class="line"><span class="comment">    如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat</span></span><br><span class="line"><span class="comment">    static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08Stream_concat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"张三丰"</span>, <span class="string">"张翠山"</span>, <span class="string">"赵敏"</span>, <span class="string">"周芷若"</span>, <span class="string">"张无忌"</span>);</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        String[] arr = &#123;<span class="string">"美羊羊"</span>,<span class="string">"喜洋洋"</span>,<span class="string">"懒洋洋"</span>,<span class="string">"灰太狼"</span>,<span class="string">"红太狼"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr);</span><br><span class="line">        <span class="comment">//把以上两个流组合为一个流</span></span><br><span class="line">        Stream&lt;String&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">        <span class="comment">//遍历concat流</span></span><br><span class="line">        concat.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>Stream</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat&amp;SerVlet</title>
    <url>/2020/07/28/Tomcat-SerVlet/</url>
    <content><![CDATA[<h1 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h1><pre><code>1. 软件架构
    1. C/S：客户端/服务器端
    2. B/S：浏览器/服务器端

2. 资源分类
    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析
        * 如： html,css,JavaScript
    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器
        * 如：servlet/jsp,php,asp....
</code></pre><a id="more"></a>
<pre><code>3. 网络通信三要素
    1. IP：电子设备(计算机)在网络中的唯一标识。
    2. 端口：应用程序在计算机中的唯一标识。 0~65536
    3. 传输协议：规定了数据传输的规则
        1. 基础协议：
            1. tcp:安全协议，三次握手。 速度稍慢
            2. udp：不安全协议。 速度快
</code></pre><h1 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h1><pre><code>* 服务器：安装了服务器软件的计算机
* 服务器软件：接收用户的请求，处理请求，做出响应
* web服务器软件：接收用户的请求，处理请求，做出响应。
    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
    * web容器


* 常见的java相关的web服务器软件：
    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 
    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。


* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范
</code></pre><h2 id="Tomcat：web服务器软件"><a href="#Tomcat：web服务器软件" class="headerlink" title="Tomcat：web服务器软件"></a>Tomcat：web服务器软件</h2><pre><code>    1. 下载：http://tomcat.apache.org/
    2. 安装：解压压缩包即可。
        * 注意：安装目录建议不要有中文和空格
    3. 卸载：删除目录就行了
</code></pre><p><img src="/2020/07/28/Tomcat-SerVlet/image-20200728151006071.png" alt="image-20200728151006071">        </p>
<pre><code>    4. 启动：
        * bin/startup.bat ,双击运行该文件即可
        * 访问：浏览器输入：http://localhost:8080 回车访问自己
                          http://别人的ip:8080 访问别人


        * 可能遇到的问题：
            1. 黑窗口一闪而过：
                * 原因： 没有正确配置JAVA_HOME环境变量
                * 解决方案：正确配置JAVA_HOME环境变量

            2. 启动报错：
                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程
                    * netstat -ano
                    找到占用自己端口的进程
                    杀死进程就好了
                2. 温柔：修改自身的端口号
                    * conf/server.xml
                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;
                       connectionTimeout=&quot;20000&quot;
                       redirectPort=&quot;8445&quot; /&gt;
                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。
                        * 好处：在访问时，就不用输入端口号
    5. 关闭：
        1. 正常关闭：
            * bin/shutdown.bat
            * ctrl+c
        2. 强制关闭：
            * 点击启动窗口的×
    6. 配置:
        * 部署项目的方式：
            1. 直接将项目放到webapps目录下即可。
                * /hello：项目的访问路径--&gt;虚拟目录
                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。
                    * war包会自动解压缩

            2. 配置conf/server.xml文件
                在&lt;Host&gt;标签体中配置
                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;
                * docBase:项目存放的路径
                * path：虚拟目录

            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写
                &lt;Context docBase=&quot;D:\hello&quot; /&gt;
                * 虚拟目录：xml文件的名称

        * 静态项目和动态项目：
            * 目录结构
                * java动态项目的目录结构：
                    -- 项目的根目录
                        -- WEB-INF目录：
                            -- web.xml：web项目的核心配置文件
                            -- classes目录：放置字节码文件的目录
                            -- lib目录：放置依赖的jar包


        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。
</code></pre><h1 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>运行在服务器端的小程序</p>
<pre><code>    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法。
</code></pre><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><pre><code>    1. 创建JavaEE项目
    2. 定义一个类，实现Servlet接口
        * public class ServletDemo1 implements Servlet
    3. 实现接口中的抽象方法
    4. 配置Servlet
         在web.xml中配置：
        &lt;!--配置Servlet --&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;
        &lt;/servlet&gt;

        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
</code></pre><h2 id="3-执行原理："><a href="#3-执行原理：" class="headerlink" title="3. 执行原理："></a>3. 执行原理：</h2><pre><code>    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。
    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名
    4. tomcat会将字节码文件加载进内存，并且创建其对象
    5. 调用其方法
</code></pre><p><img src="/2020/07/28/Tomcat-SerVlet/image-20200728164857661.png" alt="image-20200728164857661"></p>
<h2 id="4-Servlet中的生命周期方法："><a href="#4-Servlet中的生命周期方法：" class="headerlink" title="4. Servlet中的生命周期方法："></a>4. Servlet中的生命周期方法：</h2><pre><code>    1. 被创建：执行init方法，只执行一次
        * Servlet什么时候被创建？
            * 默认情况下，第一次被访问时，Servlet被创建
            * 可以配置执行Servlet的创建时机。
                * 在&lt;servlet&gt;标签下配置
                    1. 第一次被访问时，创建
                        * &lt;load-on-startup&gt;的值为负数
                    2. 在服务器启动时，创建
                        * &lt;load-on-startup&gt;的值为0或正整数


        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
            * 多个用户同时访问时，可能存在线程安全问题。
            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

    2. 提供服务：执行service方法，执行多次
        * 每次访问Servlet时，Service方法都会被调用一次。
    3. 被销毁：执行destroy方法，只执行一次
        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁
        * 只有服务器正常关闭时，才会执行destroy方法。
        * destroy方法在Servlet被销毁之前执行，一般用于释放资源
</code></pre><h2 id="5-Servlet3-0："><a href="#5-Servlet3-0：" class="headerlink" title="5. Servlet3.0："></a>5. Servlet3.0：</h2><pre><code>    * 好处：
        * 支持注解配置。可以不需要web.xml了。

    * 步骤：
        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
        2. 定义一个类，实现Servlet接口
        3. 复写方法
        4. 在类上使用 @WebServlet注解，进行配置
            * @WebServlet(&quot;资源路径&quot;)


            @Target({ElementType.TYPE})
            @Retention(RetentionPolicy.RUNTIME)
            @Documented
            public @interface WebServlet {
                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;

                String[] value() default {};//代表urlPatterns()属性配置

                String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;

                int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;

                WebInitParam[] initParams() default {};

                boolean asyncSupported() default false;

                String smallIcon() default &quot;&quot;;

                String largeIcon() default &quot;&quot;;

                String description() default &quot;&quot;;

                String displayName() default &quot;&quot;;
            }
</code></pre><h2 id="6-Servlet的体系结构"><a href="#6-Servlet的体系结构" class="headerlink" title="6. Servlet的体系结构"></a>6. Servlet的体系结构</h2><pre><code>    Servlet -- 接口
        |
    GenericServlet -- 抽象类
        |
    HttpServlet  -- 抽象类

    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可

    * HttpServlet：对http协议的一种封装，简化操作
        1. 定义类继承HttpServlet
        2. 复写doGet/doPost方法

7. Servlet相关配置
    1. urlpartten:Servlet访问路径
        1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})
        2. 路径定义规则：
            1. /xxx：路径匹配
            2. /xxx/xxx:多层路径，目录结构
            3. *.do：扩展名匹配
</code></pre><h1 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h1><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件
    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;

2. 工作空间项目    和     tomcat部署的web项目
    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源
    * WEB-INF目录下的资源不能被浏览器直接访问。
3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动
</code></pre>]]></content>
      <categories>
        <category>java</category>
        <category>java web</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>SerVlet</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 数据库系统的基本原理</title>
    <url>/2020/10/09/database-principle-and-application-chapter-01/</url>
    <content><![CDATA[<h1 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h1><h2 id="1-1-2-数据库系统的概念"><a href="#1-1-2-数据库系统的概念" class="headerlink" title="1.1.2 数据库系统的概念"></a>1.1.2 数据库系统的概念</h2><p>数据库的总目标就是使用户能有效且方便的管理和使用数据库数据。</p>
<h3 id="1-数据（Data）"><a href="#1-数据（Data）" class="headerlink" title="1. 数据（Data）"></a><strong>1. 数据</strong>（Data）</h3><p>数据是数据库存储的基本对象；描述现实世界中各种具体事务或抽象概念的、可存储并具有明确意义的符号记录。</p>
<h3 id="2-数据库（Database-DB）"><a href="#2-数据库（Database-DB）" class="headerlink" title="2. 数据库（Database. DB）"></a><strong>2. 数据库</strong>（Database. DB）</h3><p>数据库是长期存储在计算机内、有组织的、可共享的（1）<strong>大量数据的集合</strong>。数据库中的数据按一定的数据模型组织，描述和存储，具有（2）<strong>较小的冗余</strong>、（3）<strong>较高的数据独立性</strong>和（4）<strong>易扩展性</strong>。</p>
<h3 id="3-数据库管理系统（Database-Management-System，-DBMS）"><a href="#3-数据库管理系统（Database-Management-System，-DBMS）" class="headerlink" title="3. 数据库管理系统（Database Management System， DBMS）"></a><strong>3. 数据库管理系统</strong>（Database Management System， DBMS）</h3><p>数据库管理系统是数据库系统的核心；</p>
<p>它位于用户和操作系统之间的一层数据库管理软件；</p>
<p>它为用户或应用程序提供访问数据库的方法，包括数据库的（1）<strong>定义</strong>、（2）<strong>建立</strong>、（3）<strong>查询</strong>、（4）<strong>更新</strong>及各种数据控制等。</p>
<a id="more"></a>
<ul>
<li><p><strong>数据定义语言</strong></p>
<p>DBMS提供了数据定义语言（Data Definition Language， DDL）；</p>
<p>通过它可以定义：（1）数据对象（包括表，视图，索引，存储过程等）（2）数据的完整约束 等</p>
<p>​    数据的完整性约束主要有<strong>实体完整性</strong>、<strong>参照完整性</strong>和<strong>用户定义的完整性</strong>；</p>
</li>
<li><p><strong>数据操纵语言</strong></p>
<p>DBMS提供了数据操纵语言（Data Manipulation Language，DML），用户可以通过它对数据库数据进行增加，删除，修改和查询操作，简称为“增删改查”；</p>
</li>
<li><p><strong>数据控制语言</strong></p>
<p>DBMS提供了数据控制语言（Data Control Language， DCL）</p>
<p>（1）用户可以通过它完成对用户访问权限的授予和撤销，即安全性控制；</p>
<p>（2）解决多用户对数据库的并发使用所产生的事务处理问题，即并发控制；</p>
<p>（3）数据库的转储，恢复功能；</p>
<p>（4）数据库的性能监视、分析功能；</p>
</li>
<li><p>数据的组织、存储和管理</p>
<p>DBMS要分类组织、存储和管理各种数据；确定以何种存储方式存储数据，以何种方法来提取存取效率；这些都要由DBMS来自动实现；</p>
</li>
</ul>
<h3 id="4-数据库系统（DataBase-System，DBS）"><a href="#4-数据库系统（DataBase-System，DBS）" class="headerlink" title="4. 数据库系统（DataBase System，DBS）"></a>4. 数据库系统（DataBase System，DBS）</h3><p>​    数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库（DB）、数据库管理系统、应用系统和数据库管理员构成；</p>
<h3 id="5-数据库应用系统（DataBase-Application-System，DBAS）"><a href="#5-数据库应用系统（DataBase-Application-System，DBAS）" class="headerlink" title="5. 数据库应用系统（DataBase Application System，DBAS）"></a>5. 数据库应用系统（DataBase Application System，DBAS）</h3><p>数据库应用系统主要是指实现业务逻辑的应用程序；</p>
<h2 id="1-1-3-数据管理技术的发展阶段"><a href="#1-1-3-数据管理技术的发展阶段" class="headerlink" title="1.1.3 数据管理技术的发展阶段"></a>1.1.3 数据管理技术的发展阶段</h2><p>数据管理技术的发展经历了人工管理、文件管理系统、数据库系统和高级数据库系统4个阶段。</p>
<h3 id="1-人工发展阶段"><a href="#1-人工发展阶段" class="headerlink" title="1. 人工发展阶段"></a>1. 人工发展阶段</h3><p>这阶段计算机主要用于科学计算。外存储器只有磁带、卡片和纸袋等；软件只有汇编语言；数据处理方式基本上是批处理。具有的特点：</p>
<p>1）数据不保存</p>
<p>2）数据不具有独立性（数据与程序没有解耦合）</p>
<p>3）数据不共享：数据是面向程序的；</p>
<p>4）只有程序的概念，没有文件的概念；</p>
<h3 id="2-文件管理系统阶段"><a href="#2-文件管理系统阶段" class="headerlink" title="2. 文件管理系统阶段"></a>2. 文件管理系统阶段</h3><p>这一阶段，计算机不仅仅用于科学计算，还用于信息管理。</p>
<p>也已经有了外存储器，可以进行长期保存。</p>
<p>软件方面有了操作系统进行文件管理；</p>
<p>数据处理方式不仅有批处理还有联机实时处理；</p>
<p>这个阶段，数据被存储在不同的文件中，程序开发人员需要编写不同的应用程序将记录从不同的文件中提取出来进行访问，或者将记录加入到相应的文件中。</p>
<p><strong>文件管理系统阶段存储、组织信息的主要弊端如下：</strong></p>
<p>1）数据的冗余和不一致</p>
<p>​        相同信息可能在多个文件中重复存储，并且可能出些不一致的情况    </p>
<p>2）数据独立性差</p>
<p>​        数据与程序之间存在关联。通常是一个程序管理一份数据文件，而难以再扩充功能。</p>
<p>3）数据孤立</p>
<p>​        这些数据分散在不同的文件中，文件又可能具有不同的格式，所以编写新应用程序检索多个文件中的数据是很困难的；</p>
<h3 id="3-数据库系统阶段"><a href="#3-数据库系统阶段" class="headerlink" title="3. 数据库系统阶段"></a>3. 数据库系统阶段</h3><p><strong>数据库系统的特点</strong></p>
<ol>
<li><p>数据结构化</p>
<p>数据库系统中实现了整体数据的结构化，即不仅要考虑某个应用的数据结构，还要考虑整个组织的数据结构，而且数据之间时具有联系的；比如：学生数据的组织不仅仅只是面向教务处的学生选课系统，而是应该面向各个与学生相关的部门的不同应用；</p>
</li>
<li><p>数据的共享性高，冗余度低，易扩充</p>
<p>数据库系统是从整体角度来看待和描述数据的，数据可以被多个用户、多个应用共享使用。</p>
<p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还可以避免数据之间的不一致性问题；</p>
<p>并且数据是面向系统的，可以很容易的增加新应用。</p>
</li>
<li><p>数据独立性高</p>
<p>数据独立性是指应用程序与数据库的数据结构之间相互独立，其包括物理独立性和逻辑独立性；</p>
<p><strong>物理独立性</strong> 指当数据的<strong>物理结构</strong>改变时尽量不影响<strong>整体逻辑结构</strong>及<strong>应用程序</strong>；</p>
<p><strong>逻辑独立性</strong> 指当数据的<strong>整体逻辑结构</strong>改变时尽量不影响<strong>应用程序</strong>，这样就认为数据库达到了逻辑独立性；</p>
<p>数据和程序的独立把数据的定义从程序中分离出来，加上存取数据的方法由DBMS负责提供；</p>
</li>
<li><p>数据由DBMS统一管理和控制</p>
<p>数据库中数据的共享使得DBMS必须提供以下数据控制功能</p>
<ul>
<li><strong>数据的完整性检查</strong>：数据的完整性指数据的<strong>正确性</strong>、<strong>有效性</strong>和<strong>相容性</strong>。把数据控制在有效的范围内，保证数据之间满足一定的关系；</li>
<li><strong>并发控制</strong>：多个用户同时操作数据时可能会相互干扰而得到错误结果；因此对多用户的并发擦破做加以控制和协调。</li>
<li><strong>数据的安全性保护</strong>：数据库安全性是防止不合法的使用造成数据的泄露和破坏，使每个用户只能按规定对某些数据以某些方式进行使用和处理；</li>
<li><strong>数据库的恢复</strong>：DBMS提供了数据的备份和恢复功能，可将数据库从错误状态恢复到某一已知的正确状态；</li>
</ul>
</li>
</ol>
<h2 id="1-1-4-数据库系统的用户"><a href="#1-1-4-数据库系统的用户" class="headerlink" title="1.1.4 数据库系统的用户"></a>1.1.4 数据库系统的用户</h2><h3 id="1-数据库管理员（Database-Administrator-DBA）"><a href="#1-数据库管理员（Database-Administrator-DBA）" class="headerlink" title="1. 数据库管理员（Database Administrator,DBA）"></a>1. 数据库管理员（Database Administrator,DBA）</h3><p>职责如下：</p>
<ol>
<li><p>参与数据库的设计</p>
</li>
<li><p>定义数据的安全性要求和完整性约束条件</p>
</li>
<li><p>日常维护</p>
<ul>
<li>定期备份数据库</li>
<li>监视数据库运行</li>
<li>确保正常运行所需的空余磁盘空间，并且需要时升级磁盘空间；</li>
</ul>
</li>
<li><p>数据库的改进和重组、重构</p>
<ul>
<li>监视系统与性期间的各个性能指标，对运行情况进行记录、统计分析，不断改进数据库设计</li>
<li>数据库运行过程中，大量数据不断插入、删除和修改，时间一长，会影响系统的性能。因此DBA要定期对数据库进行重组，以提高系统性能；</li>
<li>当用户需求增加或改变时，要对数据库进行较大改造，包括修改部分设计，即进行数据库的重构；</li>
</ul>
</li>
</ol>
<h3 id="2-数据库用户"><a href="#2-数据库用户" class="headerlink" title="2. 数据库用户"></a>2. 数据库用户</h3><p>根据工作性质及人员的技能把数据库用户分为四类：</p>
<ol>
<li>最终用户</li>
<li>专业用户</li>
<li>系统分析员和数据库设计人员</li>
<li>应用程序员</li>
</ol>
<h1 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h1><p>在数据库技术中，用数据模型的概念来描述数据库的结构和语义，对现实世界的数据进行抽象；</p>
<h2 id="1-2-1-数据抽象过程"><a href="#1-2-1-数据抽象过程" class="headerlink" title="1.2.1 数据抽象过程"></a>1.2.1 数据抽象过程</h2><p>根据数据抽象的级别定义了4种模型，即<strong>概念模型</strong>、<strong>逻辑模型</strong>，<strong>外部模型</strong>和<strong>内部模型</strong></p>
<p><strong>概念模型</strong> 是表达用户需求观点的数据库全局逻辑结构的模型；</p>
<p><strong>逻辑模型</strong> 是表达计算机实现观点的数据库全局逻辑结构的模型；</p>
<p><strong>外部模型</strong> 是表达用户使用观点的数据库局部逻辑结构的模型；</p>
<p><strong>内部模型</strong> 是表达数据库物理结构的模型</p>
<p><img src="/2020/10/09/database-principle-and-application-chapter-01/940167-20180116172511756-1457166920.png" alt="数据库系统的基本概念（第一章）-----数据抽象的级别"></p>
<p>数据抽象的过程即数据库设计的过程：</p>
<p><strong>step - 1</strong>：根据用户需求设计数据库的概念模型，这是”综合“的过程；</p>
<p><strong>step - 2</strong>：根据转换规则把概念模型转换成数据库的逻辑模型，这是一个”转换“的过程；</p>
<p><strong>step - 3</strong>：根据用户的业务特点设计不同的外部模型，给应用程序使用。</p>
<p><strong>step - 4</strong>：实现数据库式，要根据逻辑模型设计其内部模型； </p>
<h3 id="1-概念模型"><a href="#1-概念模型" class="headerlink" title="1. 概念模型"></a>1. 概念模型</h3><p>抽象的最高级别；</p>
<p><strong>概念模型的特点：</strong></p>
<blockquote>
<ol>
<li>概念模型表达了数据库的整体逻辑结构，是<strong>实体管理人员</strong>面对实体的全面描述；</li>
<li>概念模型是从用户需求的观点出发对数据建模；</li>
<li>概念模型独立于软件和硬件；</li>
<li>概念模型是数据库设计人员和用户之间进行交流的工具</li>
</ol>
</blockquote>
<p>概念模型主要采用的是 <strong>实体-联系模型</strong>，即<strong>E-R模型</strong>。</p>
<p><strong>实体</strong>是客观世界可以相互区别的对象，这种对象可以是具体的，也可以是抽象的；</p>
<p><strong>联系</strong>是两个或多个实体之间的关联。两个实体之间的联系可以分为三种：一对一(1:1)，一对多(1:n)，多对多（n:m）；</p>
<h3 id="2-逻辑模型"><a href="#2-逻辑模型" class="headerlink" title="2. 逻辑模型"></a>2. 逻辑模型</h3><p>选定DBMS后，就要将概念模型按照选定的DBMS的特点转换成逻辑模型；</p>
<p><strong>逻辑模型的特点：</strong></p>
<blockquote>
<ol>
<li>逻辑模型表达了数据库的整体逻辑结构，是<strong>设计人员</strong>面对实体数据库的全面描述；</li>
<li>逻辑模型是从数据库实现的观点出发对数据建模；</li>
<li><p>逻辑模型硬件独立，但软件依赖；</p>
</li>
<li><p>逻辑模型是数据库设计人员和应用程序员之进行交流的工具；</p>
</li>
</ol>
</blockquote>
<p>逻辑模型有三种：<strong>层次模型</strong>，<strong>网状模型</strong>，<strong>关系模型</strong>；</p>
<p><strong>层次模型</strong>的数据结构是树状结构；</p>
<p><strong>网状模型</strong>的数据结构是有向图；</p>
<p><strong>关系模型</strong>采用二维表格存储数据；</p>
<h3 id="3-外部模型"><a href="#3-外部模型" class="headerlink" title="3. 外部模型"></a>3. 外部模型</h3><p>根据不同业务特点，可以分别设计不同的外部模型；</p>
<p><strong>外部模型的特点</strong>：</p>
<blockquote>
<ol>
<li>外部模型是逻辑模型的一个逻辑子集；</li>
<li>硬件独立，软件依赖；</li>
<li>外部模型反映了用户使用数据库的特点；</li>
</ol>
</blockquote>
<p>从整个系统考查，外部模型具有下列特点：</p>
<blockquote>
<ol>
<li>简化了用户的观点；外部模型是根据应用需要设计的，无关数据不放入，使用户更为简便的使用数据库；</li>
<li>有助于数据库的安全保护；无关数据不会放入，保证了数据安全；</li>
<li>外部模型是对概念模型的支持；</li>
</ol>
</blockquote>
<h3 id="4-内部模型"><a href="#4-内部模型" class="headerlink" title="4. 内部模型"></a>4. 内部模型</h3><p>内部模型又称为物理模型，是数据库最底层的抽象，它描述数据在磁盘上的存储方式、存取设备和存取方式。</p>
<p>内部模型是与硬件和软件紧密相连的。但目前的计算机系统的发展使得人们不必考虑内部级的设计细节，由系统自动实现；</p>
<h2 id="1-2-2-关系模型"><a href="#1-2-2-关系模型" class="headerlink" title="1.2.2 关系模型"></a>1.2.2 关系模型</h2><h3 id="1-数据模型的三要素"><a href="#1-数据模型的三要素" class="headerlink" title="1. 数据模型的三要素"></a>1. 数据模型的三要素</h3><p>数据模型是数据库概念的核心和基础，精确的描述了系统的静态特性、动态特性和完整性约束条件；</p>
<p>数据模型通常由<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>数据完整性约束</strong>3个部分组成；</p>
<ol>
<li><p>数据结构</p>
<p>常见的数据模型有<strong>层次模型</strong>、<strong>网状模型</strong>和<strong>关系模型</strong>，关系模型占统治地位；</p>
<p>数据结构是所描述的对象类型的集合，是对<strong>系统静态特性</strong>的描述；</p>
</li>
<li><p>数据操作</p>
<p>是对数据库表中记录的值允许执行的操作集合，包括操作及有关的操作规则。</p>
<p>数据库对数据操作主要有增删改查4种操作；数据模型必须定义这些操作的含义，符号，操作规则及实现语言；</p>
<p>数据操作是对<strong>系统动态特性</strong>的描述；</p>
</li>
<li><p>数据的完整性约束</p>
<p>完整性规则是给定的数据模型种数据及其联系所具有的制约和依存规则，用于限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容；</p>
<p>在关系模型中，任何关系都必须满足实体完整性和参照完整性；</p>
</li>
</ol>
<h3 id="2-关系数据模型的数据结构"><a href="#2-关系数据模型的数据结构" class="headerlink" title="2. 关系数据模型的数据结构"></a>2. 关系数据模型的数据结构</h3><p>关系模型中的一些术语：</p>
<ol>
<li><p>关系（Relation）</p>
<p>一个关系就是一张规范的二维表；一个规范化的关系必须满足的最基本的一条是关系的每一列不可再分；</p>
</li>
<li><p>元组（Tuple)</p>
<p>表中的一行即为一个元组；</p>
</li>
<li><p>属性（Attribute）</p>
<p>表中的一列即为一个属性；</p>
</li>
<li><p>码（Key）</p>
<p>码也称为关键字或关键码；</p>
<p>表中的某个属性或者属性的组合能唯一的确定一个元组，那么这个属性或者属性的组合就成为码；</p>
<p>在一个关系中可以有多个码；</p>
</li>
<li><p>关系模式</p>
<p>对关系的描述一般表示为：</p>
<blockquote>
<p>关系名（属性1，属性2，属性3，… ,属性n）</p>
</blockquote>
</li>
</ol>
<h3 id="3-关系数据模型的操作与完整性约束"><a href="#3-关系数据模型的操作与完整性约束" class="headerlink" title="3. 关系数据模型的操作与完整性约束"></a>3. 关系数据模型的操作与完整性约束</h3><p>关系数据模型的操作主要包括查询、插入、删除和更新数据。这些操作必须满足关系的完整性约束条件；</p>
<h1 id="1-3-数据库体系结构"><a href="#1-3-数据库体系结构" class="headerlink" title="1.3 数据库体系结构"></a>1.3 数据库体系结构</h1><p>数据库系统的设计目标是允许用户逻辑地处理数据，而不涉及数据在计算机内部的存储，在数据组织和用户应用之间提供某种程度的独立性；</p>
<h2 id="1-3-1-数据库系统的三级结构"><a href="#1-3-1-数据库系统的三级结构" class="headerlink" title="1.3.1 数据库系统的三级结构"></a>1.3.1 数据库系统的三级结构</h2><p><img src="/2020/10/09/database-principle-and-application-chapter-01/672567-20180825135457384-1547424591.png" alt="数据库技术丛书:SQ"></p>
<p>数据库分为3个抽象级，用户级，概念级和物理级；</p>
<h3 id="1-用户级数据库"><a href="#1-用户级数据库" class="headerlink" title="1. 用户级数据库"></a>1. 用户级数据库</h3><p>用户级对应于外模式，是用户看到和使用的数据库；</p>
<h3 id="2-概念级数据库"><a href="#2-概念级数据库" class="headerlink" title="2. 概念级数据库"></a>2. 概念级数据库</h3><p>概念级数据库对应于概念模式。介于用户级和物理级之间，是数据库管理员看到和管理的数据库，又称为DBA视图；</p>
<p>概念级模式把用户视图有机地结合成一个整体，综合、平衡考虑所有用户要求，实现数据的一致性，最大限度地降低数据冗余，准确反映数据之间的联系；</p>
<h3 id="3-物理级数据库"><a href="#3-物理级数据库" class="headerlink" title="3. 物理级数据库"></a>3. 物理级数据库</h3><p>物理级数据库对应用内模式，是数据库的底层表示，是描述数据的实际存储组织，是最接近物理存储的级，又称为内部视图；</p>
<p><strong>物理级数据库由内部记录组成</strong>，物理级数据库不是真正的物理存储，而是最接近物理存储的级；</p>
<h2 id="1-3-2-数据库系统的三级模式"><a href="#1-3-2-数据库系统的三级模式" class="headerlink" title="1.3.2 数据库系统的三级模式"></a>1.3.2 数据库系统的三级模式</h2><p>数据库系统包括三级模式，即概念模式、外模式和内模式；</p>
<h3 id="1-概念模式"><a href="#1-概念模式" class="headerlink" title="1. 概念模式"></a>1. 概念模式</h3><p>概念模式又称为模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图；</p>
<p>一个数据库仅有一个概念模式；</p>
<p>定义概念模式时，不仅要定义<strong>数据的逻辑结构</strong>（数据记录的数据项，数据项名字，类型，取值范围等），而且还要定义<strong>数据之间的联系</strong>，定义<strong>与数据有关的安全性、完整性要求</strong>；</p>
<h3 id="2-外模式"><a href="#2-外模式" class="headerlink" title="2. 外模式"></a>2. 外模式</h3><p>外模式又称为子模式或用户模式，是数据库用户能看到和使用局部数据的逻辑结构和特征的描述，是数据库用户的数据视图；</p>
<p>他与某一应用有关的数据的逻辑表示；</p>
<p>一个数据库可以有多个外模式；</p>
<p>外模式主要描述用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件；</p>
<h3 id="3-内模式"><a href="#3-内模式" class="headerlink" title="3. 内模式"></a>3. 内模式</h3><p>内模式又称为存储模式或物理模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<p>一个数据库只有一个内模式；</p>
<p>内模式定义的是 存储记录的类型、存储域的表示、存储记录的物理顺序、 索引和存储路径等数据的存储组织；</p>
<h2 id="1-3-3-数据库系统的二级映射和数据独立性"><a href="#1-3-3-数据库系统的二级映射和数据独立性" class="headerlink" title="1.3.3 数据库系统的二级映射和数据独立性"></a>1.3.3 数据库系统的二级映射和数据独立性</h2><h3 id="1-数据库系统的二级映射"><a href="#1-数据库系统的二级映射" class="headerlink" title="1. 数据库系统的二级映射"></a>1. 数据库系统的二级映射</h3><p>二级映射是：<strong>外模式/概念模式映射</strong> 和 <strong>概念模式/内模式映射</strong></p>
<p>三个抽象级通过二级映射相互转换。</p>
<h3 id="2-数据独立性"><a href="#2-数据独立性" class="headerlink" title="2. 数据独立性"></a>2. 数据独立性</h3><p>数据独立性是指应用程序和数据之间的独立性；包括物理独立性和逻辑独立性；</p>
<ol>
<li><p>数据独立性</p>
<p>物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是独立的。通过<strong>概念模式/内模式映射</strong>来实现；</p>
<p>当数据库存储结构改变时，由DBA对模式/内模式映射作相应的改变，可以使概念模式保持不变；</p>
</li>
<li><p>逻辑独立性</p>
<p>逻辑独立性是指用户的应用程序与逻辑结构是相互独立的。逻辑独立性是通过<strong>外模式/概念模式映射</strong>来实现的；</p>
<p>当概念模式改变时，由DBA对<strong>外模式/概念模式映射</strong>作相应改变，可使外模式保持不变；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理及应用</category>
        <category>数据库基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 关系数据库标准语言 SQL</title>
    <url>/2020/10/24/database-principle-and-application-chapter-02/</url>
    <content><![CDATA[<h1 id="2-1-SQL语言介绍"><a href="#2-1-SQL语言介绍" class="headerlink" title="2.1 SQL语言介绍"></a>2.1 SQL语言介绍</h1><p>SQL（Structured Query Language）语言是一种在关系数据库中定义和操纵数据的标准语言，是用户与数据库之间进行交流的接口。</p>
<h2 id="2-1-1-SQL数据库的体系结构"><a href="#2-1-1-SQL数据库的体系结构" class="headerlink" title="2.1.1 SQL数据库的体系结构"></a>2.1.1 SQL数据库的体系结构</h2><p>SQL语言支持关系数据库的三级模式、二级映像的结构，二级映像保证了数据库的数据独立性；</p>
<p>SQL的关系数据库具有的特点：</p>
<ol>
<li>SQL用户可以是应用程序，也可以是终端用户。（嵌入应用程序中，也可以直接访问）</li>
<li>SQL用户可以用SQL语言对基本表和视图进行查询。</li>
<li>一个视图是从若干基本表或其他视图上导出的表。在数据库中只存放该视图的定义，不存放该视图所对应的数据。数据都是来自于基本表。视图是一个虚表；</li>
<li>一个或一些基本表对应一个数据文件<ul>
<li>一个基本表也可以放在若干数据文件中。</li>
<li>一个数据文件对应存储设备上的一个存储文件；</li>
</ul>
</li>
<li>一个基本表可以带若干索引。索引也放在数据文件中。</li>
<li>一个表空间可以由若干数据文件组成；</li>
<li>一个数据库可以由多个存储文件组成；</li>
</ol>
<a id="more"></a>
<p><img src="/2020/10/24/database-principle-and-application-chapter-02/image-20201016162050404.png" alt="image-20201016162050404"></p>
<h2 id="2-1-2-SQL的特点"><a href="#2-1-2-SQL的特点" class="headerlink" title="2.1.2 SQL的特点"></a>2.1.2 SQL的特点</h2><p>SQL语言是一个综合的、通用的、功能极强的同时简洁易学的语言；集数据定义、数据查询、数据操纵和数据控制于一体；</p>
<ol>
<li>综合统一：风格统一，可以完成数据生命周期中的全部活动。</li>
<li>高度非过程化：指示做什么，而与去做的过程无关；</li>
<li>面向集合的操作方式：一次操作得到若干记录；</li>
<li>同一种语法结构提供两种使用方式：SQL既可以是独立式语言，又是嵌入式语言；</li>
<li>语言简洁，易学易用</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Sql功能</th>
<th style="text-align:center">动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据定义</td>
<td style="text-align:center">CREATE、DROP、ALTER</td>
</tr>
<tr>
<td>数据操纵</td>
<td style="text-align:center">INSERT、DELETE、UPDATE、SELECT</td>
</tr>
<tr>
<td>数据控制</td>
<td style="text-align:center">COMMIT、ROLLBACK、GRANT、REVOKE</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-1-3-SQL语言的组成"><a href="#2-1-3-SQL语言的组成" class="headerlink" title="2.1.3 SQL语言的组成"></a>2.1.3 SQL语言的组成</h2><h3 id="1-数据定义语言（DDL）"><a href="#1-数据定义语言（DDL）" class="headerlink" title="1. 数据定义语言（DDL）"></a>1. 数据定义语言（DDL）</h3><p>​    创建、修改、删除和重命名数据库（CREATE、DROP、ALTER、RENAME）；还有删除表中所有行，但不删除表（TRUNCATE）</p>
<h3 id="2-数据操作语言（DML）"><a href="#2-数据操作语言（DML）" class="headerlink" title="2. 数据操作语言（DML）"></a>2. 数据操作语言（DML）</h3><p>​    增删改查现有数据行</p>
<h3 id="3-数据控制语言（DCL）"><a href="#3-数据控制语言（DCL）" class="headerlink" title="3. 数据控制语言（DCL）"></a>3. 数据控制语言（DCL）</h3><p>​    用于事务控制，并发控制，完整性和安全性控制等；</p>
<h1 id="2-2-数据定义"><a href="#2-2-数据定义" class="headerlink" title="2.2 数据定义"></a>2.2 数据定义</h1><p>SQL的数据定义包括数据库定义、表的定义、视图和索引的定义；</p>
<h2 id="2-2-1-数据库的定义和删除"><a href="#2-2-1-数据库的定义和删除" class="headerlink" title="2.2.1 数据库的定义和删除"></a>2.2.1 数据库的定义和删除</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>	数据库名</span><br></pre></td></tr></table></figure>
<h3 id="2-选则数据库"><a href="#2-选则数据库" class="headerlink" title="2. 选则数据库"></a>2. 选则数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名</span><br></pre></td></tr></table></figure>
<h3 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名</span><br></pre></td></tr></table></figure>
<h2 id="2-2-2-数据类型"><a href="#2-2-2-数据类型" class="headerlink" title="2.2.2 数据类型"></a>2.2.2 数据类型</h2><p>Mysql支持的数据库类型主要分为4类，即<strong>字符串类型</strong>、<strong>数值类型</strong>、<strong>日期和时间类型</strong>，<strong>布尔类型</strong>。</p>
<h3 id="1-字符串类型"><a href="#1-字符串类型" class="headerlink" title="1. 字符串类型"></a>1. 字符串类型</h3><p>常用字符类型式<code>CHAR</code>, <code>VARCHAR</code>类型</p>
<ul>
<li><code>CHAR</code>：描述定长的字符串，说明格式的语法为：<code>CHAR(L)</code>；L表示字符串最大长度，取值范围为 1 ~ 255；比L大截断，小了补空格填补；</li>
<li><code>VARCHAR</code>：描述变长的字符串，说明格式为：<code>VARCHAR(L)</code>；L表示字符串长度，取值范围为 1 ~ 255；比L大截断，<strong>小了不会用空格填补，按实际长度存储</strong>；</li>
</ul>
<p>​    字符串要用单引号或双引号括起来；</p>
<h3 id="2-数值类型"><a href="#2-数值类型" class="headerlink" title="2. 数值类型"></a>2. 数值类型</h3><p>常用数值类型是<code>INT</code>,<code>DECIMAL</code>类型</p>
<ul>
<li><code>INT</code>：表示整数，存储长度默认为4个字节。说明格式为<code>INT</code>;</li>
<li><code>DECIMAL</code>：用来表示所有的数值数据，说明格式为<code>DECIMAL(p,s)</code>，<code>p</code>表示数值数据的最大长度， <code>s</code>表示数值数据中小数点后的数组位数，<code>p</code>，<code>s</code>在定义时可以省略；</li>
</ul>
<h3 id="3-日期和时间类型"><a href="#3-日期和时间类型" class="headerlink" title="3. 日期和时间类型"></a>3. 日期和时间类型</h3><p>常用的日期和时间类型时<code>DATA</code>，<code>TIME</code>，<code>DATETIME</code>类型</p>
<ul>
<li><code>DATE</code>：用来保存固定长度的日期数据，说明格式为<code>DATE</code>; 日期值格式为<code>YYYY-MM-DD</code>;</li>
<li><code>TIME</code>：保存固定长度的时间数据，说明格式为<code>TIME</code>；时间值格式为<code>HH:MM:SS</code>;</li>
<li><code>DATETIME</code>：保存固定长度的日期时间数据，说明格式为<code>DATETIME</code>；日期时间值格式为<code>YYYY-MM-DD HH:MM:SS</code>；</li>
</ul>
<h3 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4. 布尔类型"></a>4. 布尔类型</h3><p>布尔类型<code>BOOLEAN</code>类型只有两个值——<code>TRUE</code>和<code>FALSE</code>，即真值和假值；</p>
<h2 id="2-2-3-基本表的定义、删除和修改"><a href="#2-2-3-基本表的定义、删除和修改" class="headerlink" title="2.2.3 基本表的定义、删除和修改"></a>2.2.3 基本表的定义、删除和修改</h2><p>表是数据库存储数据的基本单元；</p>
<p>表中存储数据的逻辑结构是一张二维表，即表由行、列两部分组成。</p>
<p>称表中的一行 为  一条记录；</p>
<p>称表中的一列 为 一个属性；</p>
<h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h3><pre class="mermaid">graph TD
A[创建表] -->B(定义表的结构)
B -->C[表名]
B -->D[各个列]
D -->E[列名]
D -->F[列的数据类型]
D -->H[列上的约束]
B -->G[表上的约束]</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">(</span><br><span class="line">	&lt;列明&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span>&lt;默认值&gt;]</span><br><span class="line">	[,···]</span><br><span class="line">)；</span><br></pre></td></tr></table></figure>
<p><strong>TIP</strong>：</p>
<ol>
<li>使用 <code>DESC</code> 显示表的结构</li>
<li>设置了自增类型的字段，需将其设置为主键，否则创建失败。</li>
<li>表明日期时间可用当下系统时间补充，用<code>CURRENT_TIMESTAMP</code>;</li>
</ol>
<h3 id="2-利用子查询来创建表"><a href="#2-利用子查询来创建表" class="headerlink" title="2. 利用子查询来创建表"></a>2. 利用子查询来创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">	<span class="keyword">SELECT</span> 语法；</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_c</span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept；</span><br></pre></td></tr></table></figure>
<h3 id="3-修改表的结构"><a href="#3-修改表的结构" class="headerlink" title="3. 修改表的结构"></a>3. 修改表的结构</h3><p>对表的修改包括：增加新的列，删除原有的列或修改列的数据类型，宽度等；</p>
<p>​    1）增加一个新列    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] &lt;列名&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span> &lt;默认值&gt;];</span><br></pre></td></tr></table></figure>
<p>一次只能增加一个新列</p>
<p>​    2）修改一个表中已有的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  MOIFY [<span class="keyword">COLUMN</span>] &lt;列名&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span> &lt;默认值&gt;];</span><br></pre></td></tr></table></figure>
<p>​    3）从一个表中删除一列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  <span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] &lt;列名&gt;；</span><br></pre></td></tr></table></figure>
<h3 id="4-截断表和删除表"><a href="#4-截断表和删除表" class="headerlink" title="4. 截断表和删除表"></a>4. 截断表和删除表</h3><p>​    1）截断表：删除数据保留表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure>
<p>​    2）删除表：删除数据和表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure>
<h1 id="2-3-数据查询"><a href="#2-3-数据查询" class="headerlink" title="2.3 数据查询"></a>2.3 数据查询</h1><p><code>SELECT</code>语句的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * | &lt;列名 | 列表达式&gt;[,&lt;列名 | 列表达式&gt;]···</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt;]···</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组列名<span class="number">1</span>&gt;[,&lt;分组列名<span class="number">2</span>&gt;]]···</span><br><span class="line">	[ <span class="keyword">HAVING</span> &lt;组条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序列名<span class="number">1</span> [ <span class="keyword">ASC</span>| <span class="keyword">DESC</span> ]&gt;[,&lt;排序列名<span class="number">2</span> [ <span class="keyword">ASC</span>| <span class="keyword">DESC</span> ]&gt;]···];</span><br></pre></td></tr></table></figure>
<p><code>[]</code>表示该部分可选；<code>&lt;&gt;</code>表示该部分必有。</p>
<p>执行过程如下</p>
<ol>
<li>读取<code>FROM</code>子句中的表、视图的数据，如果是多个表或视图，执行笛卡尔积操作；</li>
<li>选择满足<code>WHERE</code>子句中给出的条件表达式的记录；</li>
<li>按<code>GROUP BY</code>子句中指定列的值对记录进行分组，同时提取满足HAVING子句中组条件表达式的那些组；</li>
<li>按<code>SELECT</code>子句中给出的列名或列表达式求值输出；</li>
<li><code>ORDER BY</code>子句对输出的记录进行排序；</li>
</ol>
<h2 id="2-3-1-基本查询"><a href="#2-3-1-基本查询" class="headerlink" title="2.3.1 基本查询"></a>2.3.1 基本查询</h2><h3 id="1-SELECT子句的规定"><a href="#1-SELECT子句的规定" class="headerlink" title="1. SELECT子句的规定"></a>1. SELECT子句的规定</h3><p><code>SELECT</code>子句用于描述输出值的列明或表达式；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ <span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span> ] * | &lt;列名或列名表达式&gt;</span><br></pre></td></tr></table></figure>
<p><code>DISTINCT</code>：表示输出无重复结果的记录； <code>ALL</code>：选项是默认的表示输出所有记录，包括重复记录</p>
<p>1）查询所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure>
<p>2）查询指定的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, dname <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure>
<p>3）去掉重复的行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<p>上面的这个语句会把所有的输出出来，有重复的行值出现，需要去掉重复的记录，则可以用下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> deptno, job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure>
<h3 id="2-为列起别名的操作"><a href="#2-为列起别名的操作" class="headerlink" title="2. 为列起别名的操作"></a>2. 为列起别名的操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">原字段名 [AS] 列别名</span><br></pre></td></tr></table></figure>
<h3 id="3-使用WHERE子句指定查询条件"><a href="#3-使用WHERE子句指定查询条件" class="headerlink" title="3. 使用WHERE子句指定查询条件"></a>3. 使用WHERE子句指定查询条件</h3><p><code>WHERE</code>子句后的行表达式可以由运算符组合而成，常用的比较运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符名称</th>
<th style="text-align:center">符号及格式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">算术比较判断</td>
<td style="text-align:center"><code>&lt;、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、=</code></td>
<td style="text-align:center">比较两个表达式的值</td>
</tr>
<tr>
<td style="text-align:center">逻辑比较判断</td>
<td style="text-align:center"><code>NOT、AND、OR</code></td>
<td style="text-align:center">非与或操作（优先级高低排序）</td>
</tr>
<tr>
<td style="text-align:center">之间判断</td>
<td style="text-align:center"><code>&lt;表达式&gt;[ NOT ] BETWEEN &lt;值1&gt; AND &lt;值2&gt;</code></td>
<td style="text-align:center">搜索（不）在指定范围里的值</td>
</tr>
<tr>
<td style="text-align:center">字符串模糊判$断^1$</td>
<td style="text-align:center"><code>&lt;字符串&gt; [ NOT ] LIKE &lt;匹配模式&gt;</code></td>
<td style="text-align:center">查找（不）在给定模式的值</td>
</tr>
<tr>
<td style="text-align:center">空值判断</td>
<td style="text-align:center"><code>&lt;表达式&gt; IS [ NOT ] NULL</code></td>
<td style="text-align:center">判断是否为空值</td>
</tr>
<tr>
<td style="text-align:center">之内判断</td>
<td style="text-align:center"><code>&lt;表达式&gt; [ NOT ] IN (&lt;集合&gt;)</code></td>
<td style="text-align:center">判断表示式的值是否在集合内</td>
</tr>
</tbody>
</table>
</div>
<p>模糊判断匹配字符串模式使用通配符 <code>%</code> 和 <code>_</code> 。<code>%</code>用于表示0个或任意多个字符，<code>_</code>表示任意一个字符；</p>
<h3 id="4-使用ORDER-BY子句对查询结果排序"><a href="#4-使用ORDER-BY子句对查询结果排序" class="headerlink" title="4. 使用ORDER BY子句对查询结果排序"></a>4. 使用ORDER BY子句对查询结果排序</h3><p>使用<code>ORDER BY</code>子句对查询结果进行排序时要注意一下两点：</p>
<p>（1）当<code>SELECT</code>语句中包含多个子句时，<code>ORDER BY</code> 必须是最后一个；</p>
<p>（2）可以使用列的别名、列的位置（SELECT子句中的顺序）进行排序；</p>
<h2 id="2-3-2-分组查询"><a href="#2-3-2-分组查询" class="headerlink" title="2.3.2 分组查询"></a>2.3.2 分组查询</h2><p>数据分组市容过在<code>SELECT</code>语句中加入<code>GROUP BY</code>子句完成的。通常用聚合函数对每个组的数据进行汇总、统计；用 <code>HAVING</code> 子句来限定查询结果集中只显示分组后的、其聚合函数的值满足指定条件的那些组；</p>
<h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>COUNT(*)</code> <code>COUNT(&lt;列名&gt;)</code></td>
<td style="text-align:center">记录的个数；对一列中的值计算个数</td>
</tr>
<tr>
<td style="text-align:center"><code>SUM(&lt;列名&gt;)</code></td>
<td style="text-align:center">求某一列的总和</td>
</tr>
<tr>
<td style="text-align:center"><code>AVG(&lt;列名&gt;)</code></td>
<td style="text-align:center">求某一列的平均值</td>
</tr>
<tr>
<td style="text-align:center"><code>MAX(&lt;列名&gt;)</code></td>
<td style="text-align:center">求某一列的最大值</td>
</tr>
<tr>
<td style="text-align:center"><code>MIN()</code></td>
<td style="text-align:center">求某一列的最小值</td>
</tr>
</tbody>
</table>
</div>
<p>使用聚合函数要注意的点：</p>
<p>（1）聚合函数只能出现在所查询的列、<code>ORDER BY</code>子句、<code>HAVING</code>子句中，不能出现在<code>WHERE</code>子句、<code>GROUP BY</code>子句中。</p>
<p>（2）除了<code>COUNT(*)</code>之外，其他聚合函数都忽略对列值为<code>NULL</code>的统计；</p>
<h3 id="2-使用GROUP-BY子句"><a href="#2-使用GROUP-BY子句" class="headerlink" title="2. 使用GROUP BY子句"></a>2. 使用GROUP BY子句</h3><p>1）按单列分组</p>
<p>【例】查询emp表中每个部门的平均工资和最高工资，按部门编号升序排列；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资，<span class="keyword">MAX</span>(sal) 最高工资 <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno；</span><br></pre></td></tr></table></figure>
<p>2）按多列分组</p>
<p>【例】查询emp表中每个部门、每种岗位的平均工资和最高工资；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资，<span class="keyword">MAX</span>(sal) 最高工资 <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno, job</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno；</span><br></pre></td></tr></table></figure>
<h3 id="3-使用HAVING子句"><a href="#3-使用HAVING子句" class="headerlink" title="3. 使用HAVING子句"></a>3. 使用HAVING子句</h3><p>【例】查询部门编号在30以下的各个部门的部门编号、平均工资，要求只显示平均工资大于等于2000的信息；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资 <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">WHERE</span> deptno&lt;<span class="number">30</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sal)&gt;=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-3-连接查询"><a href="#2-3-3-连接查询" class="headerlink" title="2.3.3 连接查询"></a>2.3.3 连接查询</h2><p>连接查询是指对两个或两个以上的表或视图的查询。连接查询是关系数据库中最主要、最有意义的查询，是关系数据库的一项核心功能；</p>
<p>MySql提供了4种类型的连接，即<strong>相等连接</strong>、<strong>自身连接</strong>、<strong>不等连接</strong>和<strong>外连接</strong>；</p>
<h3 id="1-相等连接"><a href="#1-相等连接" class="headerlink" title="1. 相等连接"></a>1. 相等连接</h3><p>也称为简单连接或内连接，是把两个表中指定列的值相等的行连接起来；</p>
<p>【例】查询工资大于等于3000的员工的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal, e.deptno, loc</span><br><span class="line">	<span class="keyword">FROM</span> emp e, dept d</span><br><span class="line">	<span class="keyword">WHERE</span> e.deptno = d.deptno</span><br><span class="line">	<span class="keyword">AND</span> sal &gt;= <span class="number">3000</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> e.deptno;</span><br></pre></td></tr></table></figure>
<p>可用ON子句来实现内连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal, e.deptno, loc</span><br><span class="line">	<span class="keyword">FROM</span> emp e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d</span><br><span class="line">	<span class="keyword">ON</span> e.deptno = d.deptno</span><br><span class="line">	<span class="keyword">WHERE</span> sal &gt;= <span class="number">3000</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> e.deptno;</span><br></pre></td></tr></table></figure>
<h3 id="2-自身连接"><a href="#2-自身连接" class="headerlink" title="2. 自身连接"></a>2. 自身连接</h3><p>是通过把一个表定义为两个不同别名的方法来完成自身连接的；</p>
<p>【例】一个雇员表，含有雇员编号，管理员编号。管理员也是雇员；所以这两列有参照关系；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename 雇员, m.ename 管理员</span><br><span class="line">	<span class="keyword">FROM</span> emp e, emp m</span><br><span class="line">	<span class="keyword">WHERE</span> m.empno = e.mgr</span><br><span class="line">	<span class="keyword">AND</span> e.deptno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-不等连接"><a href="#3-不等连接" class="headerlink" title="3. 不等连接"></a>3. 不等连接</h3><p>用其他运算符产生的连接叫做不等连接；</p>
<h3 id="4-左外连接"><a href="#4-左外连接" class="headerlink" title="4. 左外连接"></a>4. 左外连接</h3><p>左外连接的格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM 表 1 LEFT OUTER JOIN 表 2 ON 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure>
<p>左外连接的结果是显示表1中的所有记录和表2中与表1.列相同的记录；</p>
<h3 id="5-右外连接"><a href="#5-右外连接" class="headerlink" title="5. 右外连接"></a>5. 右外连接</h3><p>右外连接的格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM 表1 RIGHT OUTER JOIN 表2 ON 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure>
<p>左外连接的结果是显示表2中的所有记录和表1中与表2.列相同的记录；</p>
<h2 id="2-3-4-子查询"><a href="#2-3-4-子查询" class="headerlink" title="2.3.4 子查询"></a>2.3.4 子查询</h2><p>子查询是指嵌入在其他SQL语句中的一个查询。最多可以嵌套255层；</p>
<p>使用子查询可以用一系列简单的查询构成复杂的查询，从而增强SQL语句的功能；</p>
<p><strong>执行步骤</strong></p>
<p>（1）首先取外层查询中表的第一个记录，根据它与内存查询相关列值进行内层查询的处理，若处理结果为真，则取此记录放入结果集。</p>
<p>（2）然后取外层表的下一个记录进行内层查询的处理</p>
<p>（3）重复这一过程，直到外层查询中表的全部记录处理完为止；</p>
<h3 id="1-返回单值的子查询"><a href="#1-返回单值的子查询" class="headerlink" title="1. 返回单值的子查询"></a>1. 返回单值的子查询</h3><p>单值子查询向外层查询值返回一个值；</p>
<h3 id="2-返回多值的子查询"><a href="#2-返回多值的子查询" class="headerlink" title="2. 返回多值的子查询"></a>2. 返回多值的子查询</h3><p>多值子查询可以向外层查询返回多个值；在WHERE子句中使用多值子查询时必须使用多值比较运算符，例如 <code>[not] IN</code>，<code>[not] EXISTS</code>，<code>ANY</code>，<code>ALL</code>，其中<code>ANY</code>，<code>ALL</code>必须与比较运算符结合使用；</p>
<p><strong>1）使用 IN 操作符的多值子查询</strong></p>
<p>比较运算符<code>IN</code>的含义为子查询返回列表中的任何一个。</p>
<p><code>IN</code>操作符比较子查询返回列表中的每一个值，并且显示任何相等的数据行；</p>
<p>【例】查询所在岗位工资最高的员工信息，不包括CLERK和PRESIDENT；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, sal <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">WHERE</span> sal <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> job)</span><br><span class="line">	<span class="keyword">AND</span> job&lt;&gt;<span class="string">'CLERK'</span> <span class="keyword">AND</span> job&lt;&gt;<span class="string">'PRESIDENT'</span>;</span><br></pre></td></tr></table></figure>
<p>注：这个例子的答案是错误的；根据薪资不能成立某岗薪资最高员工的参照关系；</p>
<p>大约应该写成这样才是正确的，不过这已经失去了展示 IN 操作符的意义了；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, sal <span class="keyword">FROM</span> emp, (<span class="keyword">SELECT</span> job, <span class="keyword">MAX</span>(sal) <span class="keyword">as</span> MAXsal <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> job) <span class="keyword">as</span> M</span><br><span class="line">	<span class="keyword">WHERE</span> job = M.job <span class="keyword">AND</span> sal = M.Maxsal</span><br><span class="line">	<span class="keyword">AND</span> job&lt;&gt;<span class="string">'CLERK'</span> <span class="keyword">AND</span> job&lt;&gt;<span class="string">'PRESIDENT'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2）使用ALL操作符的多值子查询</strong></p>
<p><code>ALL</code>操作符比较子查询返回列表中的每一个值。 <code>&lt; ALL</code> 为小于最小的，  <code>&gt; ALL</code> 为大于最大的；</p>
<p>【例】查询高于部门20的所有雇员工资的雇员信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">WHERE</span> sal &gt; <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno = <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p><strong>3）使用ANY操作符的多值子查询</strong></p>
<p><code>ANY</code>操作符比较子查询返回列表中的每一个值。 <code>&lt; ALL</code> 为小于最大的，  <code>&gt; ALL</code> 为大于最小的；</p>
<p>【例】查询高于部门20的任何雇员工资的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp</span><br><span class="line">	<span class="keyword">WHERE</span> sal &gt; <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno = <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>4）使用EXISTS操作符的多行查询</strong></p>
<p><code>EXISTS</code>操作符比较子查询返回列表中的每一个行。</p>
<p>使用 <code>EXISTS</code> 时应注意外层查询的 <code>WHERE</code> 子句格式为 <code>WHERE EXISTS</code>；  在内层子查询必须有<code>WHERE</code> 子句；</p>
<h2 id="2-3-5-合并查询结果"><a href="#2-3-5-合并查询结果" class="headerlink" title="2.3.5 合并查询结果"></a>2.3.5 合并查询结果</h2><p>当两个 <code>SELECT</code> 查询结果的结构完全一致时，可以对这两个查询执行合并运算，运算符为 <code>UNION</code>；</p>
<p><code>UNION</code> 的语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">1</span></span><br><span class="line">	<span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">2</span></span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> XXX;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>UNION</code> 在连接数据表的查询结果时，结果会删除重复的行，返回的行都是唯一的；</p>
</li>
<li><p>在使用 <code>UNION ALL</code> 的时候，结果不会删除重复行；</p>
</li>
<li>对合并查询结果进行排序，要排序的列名一定是来自第一个表中的列名（即使是别名）；</li>
</ul>
<h1 id="2-4-数据的维护"><a href="#2-4-数据的维护" class="headerlink" title="2.4 数据的维护"></a>2.4 数据的维护</h1><p>数据维护是指用<code>INSERT</code>, <code>DELETE</code>，<code>UPDATE</code>语句来插入、删除、更新数据库表中记录行的数据，由DML语言实现；</p>
<h2 id="2-4-1-插入数据"><a href="#2-4-1-插入数据" class="headerlink" title="2.4.1 插入数据"></a>2.4.1 插入数据</h2><h3 id="1-INSERT语句"><a href="#1-INSERT语句" class="headerlink" title="1. INSERT语句"></a>1. INSERT语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 [ ( 列名<span class="number">1</span>[, 列名<span class="number">2</span>···]) ]</span><br><span class="line">	<span class="keyword">VALUES</span> (值<span class="number">1</span>[,值<span class="number">2</span>···])</span><br><span class="line">	[,(值<span class="number">1</span>[,值<span class="number">2</span>···]),···,(值<span class="number">1</span>[,值<span class="number">2</span>···])]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<p>（1）插入数据时，列的个数、数据类型、顺序必须要和所提供数据的个数、数据类型，顺序保持一致或匹配；</p>
<p>（2）如果省略了表名后面列的列名表，即表示要为所有列插入数据，则必须根据表结构定义中的顺序为所有列提供数据，否则会出错；</p>
<p>【例】复制另一个表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_c</span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure>
<p>【例】插入数据示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_c(deptno, dname, loc)</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="number">50</span>, <span class="string">'PERSONNEL'</span>, <span class="string">'HONGKONG'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_c</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="number">50</span>, <span class="string">'PERSONNEL'</span>, <span class="string">'HONGKONG'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-利用子查询向表中插入数据"><a href="#2-利用子查询向表中插入数据" class="headerlink" title="2. 利用子查询向表中插入数据"></a>2. 利用子查询向表中插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[ ( 列名<span class="number">1</span> [ ,列名<span class="number">2</span>··· ] ) ]</span><br><span class="line">	<span class="keyword">SELECT</span> 语句;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-2-更新数据"><a href="#2-4-2-更新数据" class="headerlink" title="2.4.2 更新数据"></a>2.4.2 更新数据</h2><h3 id="1-UPDATE语句"><a href="#1-UPDATE语句" class="headerlink" title="1. UPDATE语句"></a>1. UPDATE语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line">	<span class="keyword">SET</span> 列名 = 值 [,列名=值,··· ]</span><br><span class="line">	[ <span class="keyword">where</span> &lt;条件&gt; ];</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：如果不用<code>WHERE</code>子句先定要更新的数据行，则会更新整个表的数据行；</p>
<p><strong>注意</strong>：MySql运行在 <code>SAFE_UPDATES</code> 模式下，该模式会导致在非主键条件下无法执行 <code>UPDATE</code> 或 <code>DELETE</code> 命令，需要执行 <code>SET SAFE_UPDATES = 0</code> 修改数据库模式；</p>
<p>【例】更新 dept_c 表中部门10的地址为 <code>CHINA</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SAFE_UPDATES = <span class="number">0</span></span><br><span class="line"><span class="keyword">UPDATE</span> dept_c</span><br><span class="line">	<span class="keyword">SET</span> loc = <span class="string">'CHINA'</span></span><br><span class="line">	<span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>【例】将 dept_c 表中所有部门的地址改为 <code>CHICAGO</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE dept_c</span><br><span class="line">	SET loc &#x3D; &#39;CHICAGO&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="2-利用子查询修改记录"><a href="#2-利用子查询修改记录" class="headerlink" title="2. 利用子查询修改记录"></a>2. 利用子查询修改记录</h3><p>【例】更新部门40的部门名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dept_c</span><br><span class="line">	<span class="keyword">SET</span> dname = (<span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptno=<span class="number">40</span>)</span><br><span class="line">	<span class="keyword">WHERE</span> deptno = <span class="number">40</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-3-删除数据"><a href="#2-4-3-删除数据" class="headerlink" title="2.4.3 删除数据"></a>2.4.3 删除数据</h2><h3 id="1-DELETE语句"><a href="#1-DELETE语句" class="headerlink" title="1. DELETE语句"></a>1. DELETE语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"> [ <span class="keyword">WHERE</span> &lt;条件&gt; ];</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<p>（1）DELETE 是按行删除数据，不是删除行中某些列的数据；</p>
<p>（2）如果不用WHERE子句限定要删除的数据行，则会删除整个表的数据行。</p>
<p>（也可以用截断表的语句实现，格式为 <code>TRUNCATE TABLE 表名</code> )</p>
<h3 id="2-利用子查询删除行"><a href="#2-利用子查询删除行" class="headerlink" title="2. 利用子查询删除行"></a>2. 利用子查询删除行</h3><h1 id="2-5-索引和视图"><a href="#2-5-索引和视图" class="headerlink" title="2.5 索引和视图"></a>2.5 索引和视图</h1><p><strong>索引</strong>可以帮助用户提高查询数据的效率，类似于书中的目录。</p>
<p><strong>视图</strong>是一张虚拟表，是基于一个或几个数据表生成的逻辑表；</p>
<h2 id="2-5-1-索引的创建与删除"><a href="#2-5-1-索引的创建与删除" class="headerlink" title="2.5.1 索引的创建与删除"></a>2.5.1 索引的创建与删除</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><p>创建索引有两种办法：</p>
<p>（1）系统自动建立：当用户在一个表上建立主键（PRIMARY KEY）或唯一（UNIQUE）约束时，系统会自动创建唯一索引（UNIQUE INDEX）；</p>
<p>（2）手工建立：用户在一个表中的一列或多列上用CREATE INDEX语句来创建非唯一索引（NONUNIQUE INDEX）。</p>
<p><strong>创建索引的语句格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> ] <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名(列名[ ,列名 ]···);</span><br></pre></td></tr></table></figure>
<p>【例】为 emp_c 表按员工的名字建立索引，索引名为emp_ename_idx;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> emp_ename_idx</span><br><span class="line">	<span class="keyword">ON</span> emp_c(ename);</span><br></pre></td></tr></table></figure>
<p>【例】为 emp_c 表按工作和工资建立索引，索引名为<code>emp_job_sal_idx</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> emp_job_sal_idx</span><br><span class="line">	<span class="keyword">ON</span> emp_c(job,sal);</span><br></pre></td></tr></table></figure>
<p>索引名的命名一般采用 <code>表名_列名_idx</code> 方式；</p>
<h3 id="2-查看索引"><a href="#2-查看索引" class="headerlink" title="2. 查看索引"></a>2. 查看索引</h3><p>查看索引的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure>
<p>【例】查看emp_c的索引信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> emp_c;</span><br></pre></td></tr></table></figure>
<h3 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3. 删除索引"></a>3. 删除索引</h3><p>当一个索引不再需要时，应该删除它；</p>
<p><strong>删除索引的语句格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名</span><br></pre></td></tr></table></figure>
<h3 id="4-使用索引时应注意的问题"><a href="#4-使用索引时应注意的问题" class="headerlink" title="4. 使用索引时应注意的问题"></a>4. 使用索引时应注意的问题</h3><p>一条DML只要涉及到索引关键字，DBMS就得调整索引；</p>
<p>索引是需要消耗磁盘空间的；如果表很大，其索引消耗磁盘空间的量也会很大。</p>
<p>满足以下条件之一，<strong>就可以为该列建立索引</strong></p>
<p>（1）表上的 <code>INSERT</code> , <code>DELETE</code>， <code>UPDATE</code>操作较少；</p>
<p>（2）一列或多列经常出现在<code>WHERE</code>子句或连接条件中；</p>
<p>（3）一列或多列经常出现在 <code>GROUP BY</code> 或 <code>ORDER BY</code> 操作中；</p>
<p>（4）如果表很大，但大多数查询返回的数据量很少。因为如果返回数据量很大，就不如顺序地扫描这个表了；</p>
<p>（5）刺裂的取值范围很广，一般为随机分布；</p>
<p>（6）表中包含了大量的NULL值；</p>
<h2 id="2-5-2-视图"><a href="#2-5-2-视图" class="headerlink" title="2.5.2 视图"></a>2.5.2 视图</h2><p><strong>视图（View）</strong>是由 <code>SELECT</code> 子查询语句定义的一个逻辑表；只有定义没有数据，是一个“虚表”；</p>
<p>视图的使用和管理是可以被创建、更改和删除；</p>
<p>视图是查看和操作表中数据的一种方法。除了 <code>SELECT</code> 之外，视图在 <code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>方面受到某些限制；</p>
<h3 id="1-为什么建立视图"><a href="#1-为什么建立视图" class="headerlink" title="1. 为什么建立视图"></a>1. 为什么建立视图</h3><p>1）提供各种数据表现形式，隐藏数据的逻辑复杂性并简化查询语句；</p>
<p>​    可以使用各种不同的方式将基础表的数据展现在数据面前，以便符合用户的使用习惯；（比如提供多表查询视图。让用户在视图上操作，隐藏了多表数据的复杂逻辑，简化了用户查询语句）</p>
<p>2）提供某些安全性保证，简化用户权限管理</p>
<p>​    视图可以实现让不同的用户看见不同的列，从而保证某些敏感数据不被某些用户看到；可以面向视图的对象权限授予用户，简化用户的权限定义；</p>
<p>3）对重构数据库提供了一定的逻辑独立性</p>
<p>​    视图是数据库三级模式中外模式在具体 <code>DBMS</code> 中的体现；概念模式发生改变，外模式具有逻辑独立性；</p>
<h3 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2. 创建视图"></a>2. 创建视图</h3><p>通过 <code>CREATE VIEW</code> 语句创建视图，创建视图的语句格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">VIEW</span> 视图名[ (别名 [ ,别名 ] ) ]</span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 语句</span><br><span class="line">	[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<p>（1）<code>OR REPLACE</code> : 创建的视图已存在，MySQL系统会重建这个视图。</p>
<p>（2）<strong>别名</strong> ：为视图所产生的列定义的列名</p>
<p>（3）<code>WITH CHECK OPTION</code> ： 所插入或修改的数据行必须满足视图所定义的约束条件；</p>
<p>（4）在子查询语句中不能包含 <code>ORDER BY</code> 子句</p>
<p>【例】创建带有 <code>WITH CHECK OPTION</code> 选项的视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_dept</span><br><span class="line">  <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  	<span class="keyword">WHERE</span> deptno = <span class="number">10</span></span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure>
<p>这个条件的限制了只能插入<code>deptno</code>为10的；</p>
<h3 id="3-修改视图"><a href="#3-修改视图" class="headerlink" title="3. 修改视图"></a>3. 修改视图</h3><p>MySQL中可以通过 <code>CREATE OR REPLACE VIEW</code> 语句和 <code>ALTER</code>语句来修改视图；</p>
<p><code>CREATE OR REPLACE VIEW</code> 是用创建视图的语句将原来的视图覆盖掉；</p>
<p>【例】修改上一例中的视图。取消约束条件检查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> v_dept</span><br><span class="line">  <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  	<span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>ALTER</code> 语句修改视图，语句格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名[ (别名 [ ,别名 ]···) ] </span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> 语句</span><br><span class="line">	[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<p>【例】修改上上一例中的视图。取消约束条件检查</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> v_dept_chk</span><br><span class="line">	<span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  	<span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-删除视图"><a href="#4-删除视图" class="headerlink" title="4. 删除视图"></a>4. 删除视图</h3><p>使用 <code>DROP VIEW</code> 语句删除视图，删除视图对创建该视图的基础表或视图没有任何影响。其语句格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名 [, 视图,···]</span><br></pre></td></tr></table></figure>
<h3 id="5-使用视图进行DML操作"><a href="#5-使用视图进行DML操作" class="headerlink" title="5. 使用视图进行DML操作"></a>5. 使用视图进行DML操作</h3><p>用户通过视图对基本表中的数据进行 <code>DML</code> 的<code>UPDATE</code>、 <code>INSERT</code>、 <code>DELETE</code> 操作。</p>
<p>视图分为 <strong>简单视图</strong> 和 <strong>复杂视图</strong> 它们的区别如下：</p>
<p>1）简单视图</p>
<p>（1）数据是仅从一个表中提取的</p>
<p>（2）不包含函数和分组数据</p>
<p>（3）可以通过该视图进行DML操作</p>
<p>2）复杂视图</p>
<p>（1）数据是从多个表中提取的</p>
<p>（2）包含函数和分组数据</p>
<p>（3）不一定能够通过该视图进行DML操作</p>
<p>下面给出通过视图进行 DML 操作的规则</p>
<p>（1）可以在简单视图上执行 <code>DML</code> 操作</p>
<p>（2）如果在一个视图中包含了分组函数，<code>GROUP BY</code>子句，或 <code>DISTINCT</code>关键字，则不能通过该视图进行增删改操作；</p>
<p>（3）如果在一个视图中包含了由表达式组成的列，则不能通过该视图进行 <code>UPDATE</code>、<code>INSERT</code>操作</p>
<p>（4）如果在一个视图中没有包含引用表中那些不能为空的列，则不能通过该视图进行 <code>INSERT</code> 操作</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理及应用</category>
        <category>数据库基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 数据库编程</title>
    <url>/2020/11/09/database-principle-and-application-chapter-03/</url>
    <content><![CDATA[<p>标准SQL是非过程化的查询语言，具有操作统一，面向集合、功能丰富、使用简单等多项优点；</p>
<p>但它的缺点在于——缺少流程控制能力，难以实现应用业务中的逻辑控制；所以引入了SQL编程；</p>
<h1 id="3-1-MySQL编程基础"><a href="#3-1-MySQL编程基础" class="headerlink" title="3.1 MySQL编程基础"></a>3.1 MySQL编程基础</h1><p>需要将频繁使用的业务逻辑封装成存储程序；</p>
<p>MySQL提供了用于编写结构化程序的数据类型、常量、变量、运算符和表达式等；</p>
<h2 id="3-1-1-常量与变量"><a href="#3-1-1-常量与变量" class="headerlink" title="3.1.1 常量与变量"></a>3.1.1 常量与变量</h2><p>程序本身不能改变的数据成为常量；程序运行中可以改变其值的数据成为变量；</p>
<h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1. 常量"></a>1. 常量</h3><p>常量的格式取决于其数据类型，常用的常量包括字符串常量、数值常量、日期和时间常量、布尔值常量和<code>NULL</code>值；</p>
<p>1）字符串常量</p>
<p>​    用单引号与双引号括起来的字符序列。推荐使用单引号；</p>
<p>2）数值常量<a id="more"></a></p>
<p>​    可以分为整数常量和小数常量；</p>
<p>3）日期和时间常量</p>
<p>​    使用特定格式的字符日期值表示，单引号括起来。例如：’2018/0717’、’2018-07-17 10:30:20’</p>
<p>4）布尔值常量</p>
<p>​    只有 <code>true</code> 和 <code>false</code> 两个值，SQL命令的运行结果用1代表 <code>true</code> ，用0代表 <code>false</code> </p>
<p>5）<code>NULL</code> 值</p>
<p>​    适用于各种字段类型，表示“不确定的值”。<code>NULL</code>值参与的运算，结果仍为 <code>NULL</code> 值；</p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>变量有名字和数据类型两个属性。MySQL中存在两种变量，一种是系统定义和维护的全局变量，通常名称前加 <code>@@</code> 符号；另一种是用户定义的用来存放中间结果的局部变量，通常在名称前加 <code>@</code> 符号；</p>
<p>1）局部变量</p>
<p>​    局部变量作用范围限制在程序内部</p>
<p>​    （1）局部变量的定义与赋值：使用 <code>SET</code> 语句定义局部变量，并为其赋值；语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @局部变量名 = 表达式<span class="number">1</span>[, @局部变量名 = 表达式<span class="number">2</span>，··· ];</span><br></pre></td></tr></table></figure>
<p>​        <strong>注意</strong>：可同时定义多个变量；</p>
<p>​    （2）局部变量的显示：使用 <code>SELECT</code> 语句显示局部变量。语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @局部变量名 [ ,@局部变量名,··· ];</span><br></pre></td></tr></table></figure>
<p>【例】查询emp中雇员SMITH的sal值赋给变量salary，并显示其值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @salary = (<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename = <span class="string">'SMITH'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @salary;</span><br></pre></td></tr></table></figure>
<p>【例】查询emp中雇员SMITH的job和hiredate值赋给变量<code>job_v</code>，<code>hiredate_v</code>并显示两个变量的值；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job,hiredate <span class="keyword">INTO</span> @job_v, @hiredate_v</span><br><span class="line">	<span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename = <span class="string">'SMITH'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @job_v, @hiredate_v;</span><br></pre></td></tr></table></figure>
<p>2）全局变量</p>
<p>全局变量是MySQL系统提供并赋值的变量。用户不能定义全局变量，只能使用。</p>
<p>常用系统全局变量及说明如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">全局变量名称</th>
<th style="text-align:center">说    明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@@back_log</code></td>
<td style="text-align:center">返回MySQL主要连接请求的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>@@basedir</code></td>
<td style="text-align:center">返回MySQL安装基准目录</td>
</tr>
<tr>
<td style="text-align:center"><code>@@license</code></td>
<td style="text-align:center">返回服务器的许可类型</td>
</tr>
<tr>
<td style="text-align:center"><code>@@port</code></td>
<td style="text-align:center">返回服务器侦听TCP/IP连接所用的端口</td>
</tr>
<tr>
<td style="text-align:center"><code>@@storage_engine</code></td>
<td style="text-align:center">返回存储引擎</td>
</tr>
<tr>
<td style="text-align:center"><code>@@version</code></td>
<td style="text-align:center">返回服务器版本号</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-1-2-常用系统函数"><a href="#3-1-2-常用系统函数" class="headerlink" title="3.1.2 常用系统函数"></a>3.1.2 常用系统函数</h2><p>函数是一组编译好的SQL语句，定义了一组操作，返回数值、数值集合，或执行一些操作；</p>
<p>MySQL 的系统函数包括：字符串函数、数学函数、日期和时间函数、系统信息函数等；</p>
<h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h3><p>1）计算字符串字符数和字符串长度的函数</p>
<ul>
<li><code>CHAR_LENGTH(str)</code> ：返回字符串 <code>str</code> 所包含的字符个数；</li>
<li><code>LENGTH(str)</code> ：返回字符串的字节长度。一个汉字是3个字节，一个数字或字母是1个字节；</li>
</ul>
<p>【例】计算字符串字符数和字符串长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`CHAR_LENGTH('CHINA'), LENGTH('CHINA');</span></span><br><span class="line"><span class="string">%  5   5  %</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SELECT `</span><span class="keyword">CHAR_LENGTH</span>(<span class="string">'中国'</span>), <span class="keyword">LENGTH</span>(<span class="string">'中国'</span>);</span><br><span class="line">%  2   6  %</span><br></pre></td></tr></table></figure>
<p>2）合并字符串函数</p>
<ul>
<li><code>CONCAT(s1,s2,···)</code> ：返回连接参数产生的字符串，若任一参数为NULL，则返回NULL；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'MySQL版本： '</span>, @@<span class="keyword">version</span>);</span><br></pre></td></tr></table></figure>
<p>3）字符串大小写转换函数</p>
<ul>
<li><code>LOWER(str)</code> ：把<code>str</code>中字母字符串全转换成小写字母</li>
<li><code>UPPER(str)</code> ：把<code>str</code>中字母字符串全转换成大写字母</li>
</ul>
<p>4）删除空格函数</p>
<ul>
<li><p><code>LTRIM(str)</code> ：返回删除前导空格的字符串</p>
</li>
<li><p><code>RTRIM(str)</code> ：返回删除后导空格的字符串</p>
</li>
<li><p><code>TRIM(str)</code> ：返回删除两侧空格的字符串</p>
</li>
</ul>
<p>5）取子串函数</p>
<ul>
<li><code>SUBSTRING(str, start, length)</code> </li>
</ul>
<h3 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2. 数学函数"></a>2. 数学函数</h3><ul>
<li><code>ABS(x)</code></li>
<li><code>PI()</code></li>
<li><code>SQRT()</code> ：非复数的二次方根</li>
<li><code>mod(m,n)</code> ：返回<code>m</code>被<code>n</code>除后的余数</li>
<li><code>ROUND(x,y)</code> ：把 <code>x</code> 四舍五入到 <code>y</code> 指定的精度返回。<code>y</code> 为负数，则将保留  <code>x</code> 值到小数点左边 <code>y</code> 位；</li>
</ul>
<h3 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3. 日期和时间函数"></a>3. 日期和时间函数</h3><p>1）获取当前系统的日期及取日期的年、月、日的函数；</p>
<ul>
<li><code>CURDDATE</code></li>
<li><code>year(d)</code>、<code>MONTH(d)</code>、<code>DAY(d)</code> ：分别返回日期或日期时间 <code>d</code> 的年、月、日的值；</li>
</ul>
<p>2）获取当前系统的日期时间的函数；</p>
<ul>
<li><code>CURRENT_TIMESTAMP()</code></li>
<li><code>LOCALTIME()</code></li>
<li><code>NOW()</code></li>
<li><code>SYSDATE()</code></li>
</ul>
<p>上面几个函数作用相同，均返回当前系统的日期时间；格式为：<code>YYYY-MM-DD HH:MM:SS</code> ；</p>
<h3 id="4-系统信息函数"><a href="#4-系统信息函数" class="headerlink" title="4. 系统信息函数"></a>4. 系统信息函数</h3><ul>
<li><code>USER()</code> ：返回当前登录的用户名</li>
<li><code>DATABASE()</code> ：返回当前所使用数据库的名</li>
<li><code>VERSION()</code> ：返回 <code>MySQL</code> 服务器版本号</li>
</ul>
<h3 id="5-条件控制函数"><a href="#5-条件控制函数" class="headerlink" title="5. 条件控制函数"></a>5. 条件控制函数</h3><p>1）<code>IF()</code>函数：格式为 <code>IF(条件表达式, v1, v2)</code> ，如果表达式为真，则函数返回 <code>v1</code> 值，否则返回 <code>v2</code> 值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, <span class="keyword">IF</span>(comm <span class="keyword">IS</span> <span class="literal">NULL</span>, <span class="number">0</span>, comm) 奖金</span><br><span class="line">	<span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>2）<code>CASE()</code>函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE 表达式</span><br><span class="line">	WHEN v1 THEN r1</span><br><span class="line">	WHEN v2 THEN r2</span><br><span class="line">	...</span><br><span class="line">	[ ELSE rn ]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h3 id="6-数据类型转换函数"><a href="#6-数据类型转换函数" class="headerlink" title="6. 数据类型转换函数"></a>6. 数据类型转换函数</h3><p><code>CASE(x AS 新类型)</code> 和 <code>CONVERT(x 新类型)</code> 两个函数作用相同，都是把一种类型的值转换为另一种类型的值；</p>
<h1 id="3-2-程序控制流语句"><a href="#3-2-程序控制流语句" class="headerlink" title="3.2 程序控制流语句"></a>3.2 程序控制流语句</h1><p>MySQL有编写过程化代码的语法结构，可进行顺序、分支、循环、存储过程、存储函数、触发器等程序设计；</p>
<h2 id="3-2-1-语句块、注释和重置命令结束标记"><a href="#3-2-1-语句块、注释和重置命令结束标记" class="headerlink" title="3.2.1 语句块、注释和重置命令结束标记"></a>3.2.1 语句块、注释和重置命令结束标记</h2><h3 id="1-语句块"><a href="#1-语句块" class="headerlink" title="1. 语句块"></a>1. 语句块</h3><p>​    <code>BEGIN ··· END</code> 用于定义SQL语句块，语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SQL</span>语句 | <span class="keyword">SQL</span>语句块</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>（1）<code>BEGIN ··· END</code> 语句块包含了该程序块的所有处理操作，允许语法块嵌套</p>
<p>（2）单独使用 <code>BEGIN ··· END</code> 语法块没有任何意义，主要用于<strong>存储过程</strong>、<strong>存储函数</strong>、<strong>触发器</strong>等存储程序内部才有意义；</p>
<h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>单行注释和多行注释</p>
<p>1）单行注释 ：使用 “ # ” 符号</p>
<p>2）多行注释： <code>/*</code> 和 <code>*/</code> 括起来是多行注释</p>
<h3 id="3-重置命令结束标记"><a href="#3-重置命令结束标记" class="headerlink" title="3. 重置命令结束标记"></a>3. 重置命令结束标记</h3><p><strong>为什么要重置命令结束标记？</strong></p>
<p>因为MySQL中，服务器处理的语句是以分号为结束标记的；但在创建存储函数、存储过程的时候，在函数体或存储过程体中可以包含多个SQL语句，每个SQL语句都是以分号为结尾的，而服务器处理程序遇到分号则结束程序的执行；所以需要重置命令结束标记；</p>
<p><strong>MySQL使用 DELIMITER 语句将MySQL语句的结束标记修改为其他符号</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER 符号</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>（1）符号可以是一些特殊符号，例如两个“#”、两个“@”、两个“$”、两个“%”等。</p>
<p>（2）恢复使用分号为结束标记，执行 “ <code>DELIMITER ;</code> ” 即可；</p>
<h2 id="3-2-2-存储函数"><a href="#3-2-2-存储函数" class="headerlink" title="3.2.2 存储函数"></a>3.2.2 存储函数</h2><p>用MySQL编写程序可以根据应用程序的需要创建<strong>存储函数</strong></p>
<h3 id="1-存储函数的创建"><a href="#1-存储函数的创建" class="headerlink" title="1. 存储函数的创建"></a>1. 存储函数的创建</h3><p>创建存储函数的，要用到 <code>CREATE FUNCTION</code> 语句， 语法为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名 ( [ 参数名 参数数据类型 [ ,··· ] ] )</span><br><span class="line"><span class="keyword">RETURNS</span> 函数返回值的数据类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	函数体;</span><br><span class="line">	RETURN 语句;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h3 id="2-调用存储函数"><a href="#2-调用存储函数" class="headerlink" title="2. 调用存储函数"></a>2. 调用存储函数</h3><p>对新创建的存储函数，调用方法与调用系统函数相同，语法格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名 ( [ 参数值 [ ,··· ] ] )</span><br></pre></td></tr></table></figure>
<p>接下来的例子涉及了 <code>delimeter</code> 在定义存储函数时的使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> name_fn(dno <span class="built_in">DECIMAL</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">14</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept</span><br><span class="line">			<span class="keyword">WHERE</span> deptno = dno );</span><br><span class="line"><span class="keyword">END</span>@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> name_fn(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-删除存储函数"><a href="#3-删除存储函数" class="headerlink" title="3. 删除存储函数"></a>3. 删除存储函数</h3><p>用 <code>DROP FUNCTION</code> 语句删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-3-条件判断语句"><a href="#3-2-3-条件判断语句" class="headerlink" title="3.2.3 条件判断语句"></a>3.2.3 条件判断语句</h2><h3 id="1-程序中变量的使用"><a href="#1-程序中变量的使用" class="headerlink" title="1. 程序中变量的使用"></a>1. 程序中变量的使用</h3><p>局部变量可在程序中声明并使用，这些变量的作用范围是 <code>BEGIN···END</code> 语法块</p>
<p>1） 声明变量</p>
<p>在存储程序（例如存储函数、存储过程、触发器等）中需要使用 <code>DECLARE</code> 语句声明局部变量，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 局部变量名 [ ,局部变量名,··· ] 数据类型 [ DEFAULT 默认值 ];</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>（1）<code>DECLARE</code> 声明的局部变量，变量名前不能加 <code>@</code></p>
<p>（2）<code>DEFAULT</code> 子句提供了一个默认值，如果没有给默认值，则局部变量的初始值默认为 <code>NULL</code> ；</p>
<p>2）为变量赋值</p>
<p>变量声明后，用 <code>SET</code> 命令为变量赋值；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> 局部变量名 = 表达式<span class="number">1</span> [, 局部变量名 = 表达式<span class="number">2</span>,··· ];</span><br></pre></td></tr></table></figure>
<h3 id="2-IF语句"><a href="#2-IF语句" class="headerlink" title="2. IF语句"></a>2. IF语句</h3><p><code>IF</code> 有两种形式：</p>
<p>1）形式一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF &lt;条件&gt; THEN</span><br><span class="line">	SQL语句块 1;</span><br><span class="line">[ELSE</span><br><span class="line">	SQL语句块 2; ]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<p>2）形式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF &lt;条件1&gt; THEN</span><br><span class="line">	SQL语句块 1;</span><br><span class="line">ELSEIF &lt;条件2&gt; THEN</span><br><span class="line">	SQL语句块 2;</span><br><span class="line">···</span><br><span class="line">ELSE</span><br><span class="line">	SQL语句块n;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<h3 id="3-CASE语句"><a href="#3-CASE语句" class="headerlink" title="3. CASE语句"></a>3. CASE语句</h3><p>1）形式一</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CASE &lt;表达式&gt;</span><br><span class="line">	WHEN &lt;表达式1&gt; THEN SQL语句块1;</span><br><span class="line">	WHEN &lt;表达式2&gt; THEN SQL语句块2；</span><br><span class="line">	···</span><br><span class="line">	WHEN &lt;表达式n&gt; THEN SQL语句块n;</span><br><span class="line">	[ ELSE SQL语句块n+1; ]</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>2）形式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">	WHEN &lt;条件1&gt; THEN SQL语句1;</span><br><span class="line">	WHEN &lt;条件2&gt; THEN SQL语句2;</span><br><span class="line">	···</span><br><span class="line">	WHEN &lt;条件n&gt; THEN SQL语句n;</span><br><span class="line">	ELSE SQL语句块 n+1;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-4-循环语句"><a href="#3-2-4-循环语句" class="headerlink" title="3.2.4 循环语句"></a>3.2.4 循环语句</h2><h3 id="1-LOOP循环"><a href="#1-LOOP循环" class="headerlink" title="1. LOOP循环"></a>1. LOOP循环</h3><p>LOOP循环为无条件循环，如果没有指定 <code>LEAVE</code> 语句，循环将一直运行，成为死循环；通常是结合条件语句使用；条件语句里嵌入 <code>LEAVE</code> 语句；条件为真，跳出循环；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签: LOOP		# # 标签 是自定义的</span><br><span class="line">	SQL语句块;</span><br><span class="line">	IF &lt;条件表达式&gt; THEN	</span><br><span class="line">		LEAVE 标签;	# # 通过自己定义的标签结束 LOOP 循环</span><br><span class="line">	END IF;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure>
<h3 id="2-WHILE循环"><a href="#2-WHILE循环" class="headerlink" title="2. WHILE循环"></a>2. WHILE循环</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE &lt;条件表达式&gt; DO</span><br><span class="line">	SQL语句块</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-REPEAT循环"><a href="#3-REPEAT循环" class="headerlink" title="3. REPEAT循环"></a>3. REPEAT循环</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">	SQL语句块;</span><br><span class="line">	UNTIL &lt;条件表达式&gt;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure>
<h1 id="3-3-存储过程"><a href="#3-3-存储过程" class="headerlink" title="3.3 存储过程"></a>3.3 存储过程</h1><p>概念：<strong>存储过程</strong>就是一条或多条SQL语句的集合；利用这些SQL语句完成一个或多个逻辑功能；</p>
<p>环境：存储过程可以被赋予参数，存储在数据库中，可以被用户调用，也可以被JAVA 或 C# 等调用；</p>
<p>特性：并且存储过程都是编译好的，调用时不用再次编译，提高了程序的运行效率；</p>
<h2 id="3-3-1-创建存储过程"><a href="#3-3-1-创建存储过程" class="headerlink" title="3.3.1 创建存储过程"></a>3.3.1 创建存储过程</h2><p>要用 <code>CREATE PROCEDURE</code> 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名()</span><br><span class="line">BEGIN</span><br><span class="line">	过程体;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h2 id="3-3-2-调用存储过程"><a href="#3-3-2-调用存储过程" class="headerlink" title="3.3.2 调用存储过程"></a>3.3.2 调用存储过程</h2><p>使用 <code>CALL</code> 语句直接调用存储过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名();</span><br></pre></td></tr></table></figure>
<h2 id="3-3-3-存储过程的参数"><a href="#3-3-3-存储过程的参数" class="headerlink" title="3.3.3 存储过程的参数"></a>3.3.3 存储过程的参数</h2><p>存储过程可以接受和返回 0 到多个参数，使程序变得灵活； MySQL 有3种参数模式，即 <code>IN</code>、 <code>OUT</code>、 <code>INOUT</code>。</p>
<blockquote>
<p>创建带参数的存储过程的语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(</span><br><span class="line">	[ <span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT ] 参数<span class="number">1</span> 数据类型</span><br><span class="line">	[ <span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT ] 参数<span class="number">2</span> 数据类型</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	过程体;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-IN参数"><a href="#1-IN参数" class="headerlink" title="1. IN参数"></a>1. IN参数</h3><p><code>IN</code> 参数作为输入参数，该参数值由<strong>调用者</strong>传入，并且只能够被存储过程读取；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE dept_pl(</span><br><span class="line">	IN p_deptno DECIMAL(2,0),</span><br><span class="line">	IN p_dname VARCHAR(14),</span><br><span class="line">	IN p_loc VARCHAR(13)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO dept</span><br><span class="line">	VALUES (p_deptno, p_name, p_loc);</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL dept_pl(50, &#39;HR&#39;, &#39;CHINA&#39;);</span><br><span class="line">SELECT * FROM dept WHERE deptno &#x3D; 50;</span><br></pre></td></tr></table></figure>
<h3 id="2-OUT参数"><a href="#2-OUT参数" class="headerlink" title="2. OUT参数"></a>2. OUT参数</h3><p><code>OUT</code>参数为输出参数，该类型的参数值由存储过程写入；</p>
<p>比较适合于向调用者返回多条信息的过程；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE dept_p2(</span><br><span class="line">	IN i_no DECIMAL(2,0),</span><br><span class="line">	OUT o_name VARCHAR(14),</span><br><span class="line">	OUT o_loc VARCHAR(13)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT dname, loc INTO o_name, o_loc FROM dept</span><br><span class="line">	WHERE deptno &#x3D; i_no;</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL dept_p2(10, @v_name, @v_loc);</span><br><span class="line">SELECT @v_dname, @v_loc;</span><br></pre></td></tr></table></figure>
<h3 id="3-INOUT参数"><a href="#3-INOUT参数" class="headerlink" title="3. INOUT参数"></a>3. INOUT参数</h3><p><code>INOUT</code> 类型得参数同时具有 <code>IN</code> , <code>OUT</code> 的特性，在过程中可以读取和写入该类型参数；</p>
<p><code>IN</code> 参数可以接收一个值，但不能修改这个值；</p>
<p><code>OUT</code>参数被调用时为空，在执行过程中将这个参数指定一个值，过程执行结束后返回；</p>
<p><strong>使用 <code>INOUT</code> 参数实现两个数的交换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE swap(</span><br><span class="line">	INOUT p_num1 int,</span><br><span class="line">	INOUT p_num2 int</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE var_temp int;</span><br><span class="line">	SET var_temp &#x3D; p_num1;</span><br><span class="line">	SET p_num1 &#x3D; p_num2;</span><br><span class="line">	SET p_num2 &#x3D; var_temp;</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">SET @v_num1 &#x3D; 1;</span><br><span class="line">SET @v_num2 &#x3D; 2;</span><br><span class="line">CALL swap(@V_num1, @v_num2);</span><br><span class="line">SELECT @v_num1, @v_num2;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-4-删除存储过程"><a href="#3-3-4-删除存储过程" class="headerlink" title="3.3.4 删除存储过程"></a>3.3.4 删除存储过程</h2><p>指删除数据库中已存在的存储过程；使用 <code>DROP PROCEDUER</code> 语句来删除存储过程；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE 存储过程名;</span><br></pre></td></tr></table></figure>
<h1 id="3-4-游标"><a href="#3-4-游标" class="headerlink" title="3.4 游标"></a>3.4 游标</h1><p>当通过 <code>SELECT</code> 语句查询时，返回的是一个由多行记录组成的集合；而程序设计语言不能处理以集合形式返回的数据，为此SQL提供了游标机制；</p>
<p>游标充当指针使用，使应用程序设计语言一次只能处理查询结果中的一行；</p>
<h2 id="3-4-1-游标的定义和使用"><a href="#3-4-1-游标的定义和使用" class="headerlink" title="3.4.1 游标的定义和使用"></a>3.4.1 游标的定义和使用</h2><p>游标是在存储程序中使用包含 <code>SELECT</code> 语句</p>
<h3 id="1-声明游标"><a href="#1-声明游标" class="headerlink" title="1. 声明游标"></a>1. 声明游标</h3><p>使用 <code>DECLARE</code> 语句；<strong>语法形式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名 CURSOR</span><br><span class="line">	FOR SELECT 语句;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<p>（1）声明游标的作用是得到一个 <code>SELECT</code> 查询结果集。游标为用户提供逐行处理的途径；</p>
<p>（2）<code>SELECT</code> 语句是对表或视图的擦汗寻语句；可以带 <code>WHERE</code>，<code>ORDER BY</code>，<code>GROUP BY</code> 等子句；但不能使用<code>INTO</code></p>
<h3 id="2-打开游标"><a href="#2-打开游标" class="headerlink" title="2. 打开游标"></a>2. 打开游标</h3><p>打开游标使用<code>OPEN</code>语句，语句形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPEN 游标名;</span><br></pre></td></tr></table></figure>
<p><strong>游标必须先声明后打开</strong>，在打开游标时，<code>SELECT</code>语句的查询结果被传送到了游标工具区，供用户读取；</p>
<h3 id="3-提取数据"><a href="#3-提取数据" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><p>打开游标后，使用 <code>FETCH</code> 语句将游标工作区中的数据读取到变量中，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FETCH 游标名 INTO 变量名1[, 变量名2···];</span><br></pre></td></tr></table></figure>
<p>成功打开游标时，游标指针在第一行之前，而 <code>FETCH</code> 语句使游标指向下一行。</p>
<p>可以在循环中使用 <code>FETCH</code> 语句，每次循环都会从表中读取一行数据；</p>
<h3 id="4-关闭游标"><a href="#4-关闭游标" class="headerlink" title="4. 关闭游标"></a>4. 关闭游标</h3><p>游标使用完后，需要用 <code>CLOSE</code> 语句关闭，<strong>语法形式</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-2-异常处理"><a href="#3-4-2-异常处理" class="headerlink" title="3.4.2 异常处理"></a>3.4.2 异常处理</h2><p>在存储过程中出现错误可能导致程序终止。</p>
<p>错误发生时希望不要终止执行，而是通过MySQL的错误处理机制帮助控制程序流程；</p>
<p>存储过程中的错误处理通过 <strong><code>DECLARE HANDLER</code> 语句</strong>实现，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DECLARE 错误处理类型 HANDLER FOR 错误触发条件 自定义错误处理程序;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>（1）一般情况下，异常处理语句置于存储程序中才有意义；</p>
<p>（2）异常处理语句必须放在所有变量和游标定义之后，所有MySQL表达式之前；</p>
<p>（3）<strong>错误处理类型</strong>：错误处理类型只有 <code>CONTINUE</code> 和 <code>EXIT</code> 两种；</p>
<ul>
<li><strong><code>CONTINUE</code></strong> 表示错误发生后MySQL立即执行自定义错误处理程序，然后忽略该错误继续执行其他的程序；</li>
<li><strong><code>EXIT</code></strong> 表示错误发生后 MySQL 立即执行自定义错误处理程序，然后立即停止其他MySQL语句的执行；</li>
</ul>
<p>（4）<strong>错误触发条件</strong>：错误除法条件定义了自定义错误处理程序运行的时机；错误触发条件的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLSTATE &#39;ANSI标准错误代码&#39;</span><br><span class="line">|MySQL错误代码</span><br><span class="line">|SQLWARNING</span><br><span class="line">|NOT FOUND</span><br><span class="line">|SQLEXCEPTION</span><br></pre></td></tr></table></figure>
<ul>
<li>错误触发条件支持标准的SQLSTATE定义，也支持MySQL的错误代码；</li>
<li><code>SQLWARNING</code>表示对所有以01开头的SQLSTATE代码的速记；</li>
<li><code>NOT FOUND</code>表示对所有以02开头的SQLSTATE代码的速记</li>
<li><code>SQLEXCEPTION</code> 表示对所有没有被 <code>SQLWARNING</code> 或 <code>NOT FOUND</code> 捕获的 <code>SQLSTATE</code> 代码的速记；</li>
</ul>
<p>（5）自定义错误处理程序    错误发生后，MySQL会立即执行自定义错误处理程序中的 MySQL 语句；</p>
<p>// 这个过程比较抽象；我觉得需要结合代码来认识；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE emp_up_pro()</span><br><span class="line">	BEGIN</span><br><span class="line">		DECLARE v_empno DECIMAL(4,0);</span><br><span class="line">		DECLARE v_sal DECIMAL(7,2);</span><br><span class="line">		DECLARE v_comm DECIMAL(7,2);</span><br><span class="line">		DECLARE flag BOOLEAN DEFAULT TRUE;</span><br><span class="line">		DECLARE comm_cur CURSOR</span><br><span class="line">			FOR SELECT empno, sal FROM emp_c;</span><br><span class="line">		DECLARE CONTINUE HANDLER FOR NOT FOUND</span><br><span class="line">			SET flag &#x3D; FALSE;</span><br><span class="line">		OPEN comm_cur;</span><br><span class="line">		WHILE flag DO</span><br><span class="line">			FETCH comm_cur INTO v_empno, v_sal;</span><br><span class="line">			IF v_sal &lt; 500 THEN SET v_comm &#x3D; v_sal * 0.25;</span><br><span class="line">			ELSEIF v_sal &lt; 1000 THEN SET v_comm &#x3D; v_sal * 0.2;</span><br><span class="line">			ELSEif v_sal &lt; 3000 THEN SET v_comm &#x3D; v_sal * 0.15;</span><br><span class="line">			ELSE SET v_comm &#x3D; v_sal * 0.12;</span><br><span class="line">			END IF;</span><br><span class="line">			UPDATE emp_c SET comm &#x3D; v_comm</span><br><span class="line">				WHERE empno &#x3D; v_empno;</span><br><span class="line">		END WHILE;</span><br><span class="line">		CLOSE comm_cur;</span><br><span class="line">	END@@</span><br></pre></td></tr></table></figure>
<p>这里面的异常处理用于处理在游标到达空指针时使得程序正常结束；</p>
<h1 id="3-5-嵌入式SQL"><a href="#3-5-嵌入式SQL" class="headerlink" title="3.5 嵌入式SQL"></a>3.5 嵌入式SQL</h1><p>被嵌入的程序设计语言被称为宿主语言，简称主语言；</p>
<h2 id="3-5-1-SQL与宿主语言接口"><a href="#3-5-1-SQL与宿主语言接口" class="headerlink" title="3.5.1 SQL与宿主语言接口"></a>3.5.1 SQL与宿主语言接口</h2><p>嵌入式SQL语句一般采用预编译方法处理，由RDBMS的预处理程序对源程序进行扫描，识别出ESQL语句，把他们转换成主语言调用语句，以使主语言编译程序能够识别它们，最后由主语言的编译程序将整个源程序编译成目标码；（SQL语句被转为了一种供主语言调用的语句）</p>
<h3 id="1-区分主语言语句与SQL语句"><a href="#1-区分主语言语句与SQL语句" class="headerlink" title="1. 区分主语言语句与SQL语句"></a>1. 区分主语言语句与SQL语句</h3><p>在嵌入式SQL中需要区分主语言语句与SQL语句；所以需要把所有的SQL语句加前缀；C语言时的形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXEC SQL SQL语句;</span><br></pre></td></tr></table></figure>
<h3 id="2-嵌入式SQL语句与主语言的通信"><a href="#2-嵌入式SQL语句与主语言的通信" class="headerlink" title="2. 嵌入式SQL语句与主语言的通信"></a>2. 嵌入式SQL语句与主语言的通信</h3><p>程序执行过程中，主语言需要与SQL语句进行信息交换，其间的通信过程如下：</p>
<ul>
<li><p>SQL语句将执行状态信息传递给主语言；</p>
<ul>
<li>主语言得到状态信息后，可以根据这个状态信息来控制程序流程；</li>
<li>向主语言传递SQL执行信息，主要用SQL通信区实现；</li>
</ul>
</li>
<li><p>主语言需要提供一些变量参数给SQL语句；</p>
<ul>
<li>在主语言中定义主变量，在SQL语句中使用主变量，将参数值传递给SQL语句；</li>
</ul>
</li>
<li>将SQL语句查询数据库的结果返回给主语言做进一步处理；<ul>
<li>如果SQL语句返回的时一条数据库记录，可使用主变量；若返回值为多条记录的集合，则使用游标；</li>
</ul>
</li>
</ul>
<h2 id="3-5-2-SQL通信区"><a href="#3-5-2-SQL通信区" class="headerlink" title="3.5.2 SQL通信区"></a>3.5.2 SQL通信区</h2><p>SQL语句执行后要返回给应用程序若干信息，主要包括描述系统当前状态和运行环境的各种参数；这些信息被送到SQL通信区——SQLCA中。</p>
<p>主语言的应用程序从SQLCA中取出这些状态信息，据此决定后面语句的执行；</p>
<p>SQLCA是一个数据结构，其中有一个系统变量SQLCODE，用来存放每次执行SQL语句后返回的代码；</p>
<p>应用程序每执行一条SQL语句后均测试一下SQLCODE的值，了解SQL语句的执行情况并作相应的处理；如果SQLCODE等于预定义的常量SUCCESS，则表示成功，否则在SQLCODE中存放错误代码。</p>
<h2 id="3-5-3-主变量的定义与使用"><a href="#3-5-3-主变量的定义与使用" class="headerlink" title="3.5.3 主变量的定义与使用"></a>3.5.3 主变量的定义与使用</h2><p>在嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据。在SQL语句中使用的主语言程序变量简称为主变量。</p>
<p>主变量根据作用不同，分为输入变量和输出变量；</p>
<ul>
<li>在 <code>SELECT INTO</code> 和 <code>FETCH</code> 语句之后的主变量称为“输出主变量”</li>
<li>除了<code>SELECT INTO</code> 和 <code>FETCH</code> 语句以外的其他SQL语句称为“输入主变量”</li>
</ul>
<h3 id="1-主变量的定义"><a href="#1-主变量的定义" class="headerlink" title="1. 主变量的定义"></a>1. 主变量的定义</h3><p>在使用主变量之前，必须在SQL语句 <code>BEGIN DECLARE SECTION</code> 与 <code>END DECLARE SECTION</code> 之间声明；</p>
<p>声明后可以在SQL语句中任何一个能够使用表达式的地方出现，为了与数据库对象名区别，应在SQL语句中的主变量名前加冒号（:）；</p>
<p><strong>注意</strong></p>
<p>（1）主变量使用前，必须在嵌入SQL语句的说明部分明确定义；</p>
<p>（2）主变量定义时，所用的数据类型为主语言提供的数据类型；注意大小写；</p>
<p>（3）在SQL语句中使用主变量时，必须在主变量前加一个冒号（:），在主语言语句中不需要加冒号</p>
<p>（4）主变量不能是SQL命令的关键字；</p>
<p>（5）在一条SQL语句中，主变量只能使用一次；</p>
<h3 id="2-在SELECT语句中使用主变量"><a href="#2-在SELECT语句中使用主变量" class="headerlink" title="2. 在SELECT语句中使用主变量"></a>2. 在SELECT语句中使用主变量</h3><p>在嵌入式SQL中，如果查询结果为单记录，则 <code>SELECT</code> 语句需要用 <code>INTO</code> 子句指定查询结果的存放地点——主变量；</p>
<h3 id="3-在INSERT语句中使用主变量"><a href="#3-在INSERT语句中使用主变量" class="headerlink" title="3. 在INSERT语句中使用主变量"></a>3. 在INSERT语句中使用主变量</h3><p>在 <code>INSERT</code> 语句的 <code>VALUES</code> 子句中，可以使用主变量指定插入的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXEC SQL INSERT INTO grade(学号,课号,分数)</span><br><span class="line">	VALUES(:hsno, :hcno, :hgrade);</span><br></pre></td></tr></table></figure>
<h3 id="4-在UPDATE语句中使用主变量"><a href="#4-在UPDATE语句中使用主变量" class="headerlink" title="4. 在UPDATE语句中使用主变量"></a>4. 在UPDATE语句中使用主变量</h3><p>在 <code>UPDATE</code> 语句的 <code>SET</code> 子句和 <code>WHERE</code> 子句中，均可使用主变量；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> grade</span><br><span class="line">	<span class="keyword">SET</span> 分数 = :mgrade</span><br><span class="line">	<span class="keyword">WHERE</span> 学号 = :msno <span class="keyword">AND</span> 课号 = :mcno;</span><br></pre></td></tr></table></figure>
<h3 id="5-在DELETE语句中使用主变量"><a href="#5-在DELETE语句中使用主变量" class="headerlink" title="5. 在DELETE语句中使用主变量"></a>5. 在DELETE语句中使用主变量</h3><p>在 <code>DELETE</code> 语句的 <code>WHERE</code> 子句中，可以使用主变量指定删除条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> grade</span><br><span class="line">	<span class="keyword">WHERE</span> 学号 = :msno;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-4-嵌入式SQL中游标的定义与使用"><a href="#3-5-4-嵌入式SQL中游标的定义与使用" class="headerlink" title="3.5.4 嵌入式SQL中游标的定义与使用"></a>3.5.4 嵌入式SQL中游标的定义与使用</h2><p>用嵌入式 SQL 语句查询数据分为两类情况：一类是多行结果，一类是多行结果；</p>
<p>对于单行结果，可以使用 <code>SELECT INTO</code> 语句；</p>
<p>对于多行结果，必须使用游标来完成；</p>
<p>包括四步：声明游标，打开游标，提取数据，关闭游标；</p>
<h3 id="1-声明游标-1"><a href="#1-声明游标-1" class="headerlink" title="1. 声明游标"></a>1. 声明游标</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span></span><br><span class="line">	<span class="keyword">FOR</span> <span class="keyword">SELECT</span> 语句;</span><br></pre></td></tr></table></figure>
<h3 id="2-打开游标-1"><a href="#2-打开游标-1" class="headerlink" title="2. 打开游标"></a>2. 打开游标</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL OPEN 游标名;</span><br></pre></td></tr></table></figure>
<h3 id="3-提取数据-1"><a href="#3-提取数据-1" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL FETCH 游标名 INTO 主变量[,主变量，···];</span><br></pre></td></tr></table></figure>
<h3 id="4-关闭游标-1"><a href="#4-关闭游标-1" class="headerlink" title="4. 关闭游标"></a>4. 关闭游标</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL CLOSE 游标名;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-5-动态SQL语句"><a href="#3-5-5-动态SQL语句" class="headerlink" title="3.5.5 动态SQL语句"></a>3.5.5 动态SQL语句</h2><p>动态SQL技术主要有以下两个SQL语句；</p>
<p>1）动态SQL预备语句；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXEC SQL PREPARE 动态 SQL 语句名 FROM 共享变量或字符串;</span><br></pre></td></tr></table></figure>
<p>2）动态SQL执行语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXEC SQL EXECUTE 动态 SQL 语句名;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理及应用</category>
        <category>数据库基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 关系模型介绍</title>
    <url>/2020/11/09/database-system-conception-2/</url>
    <content><![CDATA[<h1 id="2-1-关系数据库的结构"><a href="#2-1-关系数据库的结构" class="headerlink" title="2.1 关系数据库的结构"></a>2.1 关系数据库的结构</h1><ul>
<li><p>关系数据库由<strong>表</strong>（table）的集合构成，每个表有唯一的名字；</p>
</li>
<li><p>关系模型的术语中，<strong>关系</strong>用来指代<strong>表</strong>，而<strong>元组</strong>用来指代<strong>行</strong>。属性指代的是表中的<strong>列</strong>；</p>
</li>
<li><p>用<strong>关系实例</strong>来表示一个关系的特性实例，也就是所包含的一组特定的行；</p>
</li>
<li><p>对于关系的每个属性，都存在一个允许取值的集合，成为这个属性的<strong>域</strong>；如果域中元素被看作不可再分的单元，则域是<strong>原子的</strong>；（就是一个属性不能再被多个属性表示）</p>
</li>
<li><p><strong>空</strong> （null）指是一个特殊的值，表示值未知或不存在；空值会给数据库访问和更新带来很多困难。</p>
</li>
</ul>
<h1 id="2-2-关系数据库模式"><a href="#2-2-关系数据库模式" class="headerlink" title="2.2 关系数据库模式"></a>2.2 关系数据库模式</h1><p>​    需区分 <strong>数据库模式</strong> 和 <strong>数据库实例</strong>；前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照；</p>
<p>​    <strong>关系</strong>对应于程序设计语言中变量的概念；</p>
<p>​    <strong>关系模式</strong> 的概念对应于程序设计语言中类型定义的概念；关系模式由属性序列及各属性对应域组成；</p>
<p>​    当关系被更新时，关系实例的内容也随时间发生了变化。相反，关系的模式是不常变化的；</p>
<a id="more"></a>
<h1 id="2-3-码"><a href="#2-3-码" class="headerlink" title="2.3 码"></a>2.3 码</h1><p>我们必须有一种能区分给定关系中的不同元组的方法。一个关系中没有两个元组在所有属性上的取值都相同；</p>
<blockquote>
<p><font color="red"><strong>超码</strong></font> 是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组；</p>
<p>形式化地描述，设 $R$ 表示关系 $r$ 模式中的属性集合。如果我们说 $R$ 的一个子集 $K$ 是 $r$ 的一个超码，则限制了关系 $r$ 中任意两个不同元组不会在 $K$ 的所有属性上取值完全相等，即如果 $t_1$ 和 $t_2$ 在 $r$ 中且 $t_1\neq t_2$ , 则  $t_1.K \neq t_2.K$ </p>
<p>超码可能包含无关紧要的属性。则如果 $K$ 是一个超码，那么 $K$ 的任意超集也是超码；</p>
<p><strong>任意真子集都不能成为超码的最小超码被称为<font color="red">候选码</font>( candidate key)</strong></p>
<p>几个不同的属性集都可以做候选码的情况是<span color="red">存在的</span>；</p>
<p><font color="red"><strong>主码</strong></font>这个术语代表被数据库设计者选中的、主要用来在一个关系中区分不同元组的候选码；</p>
<ul>
<li>主码的选择必须慎重：有的候选码不适合做主码</li>
<li>主码应选择那些值从不或极少变化的属性；（地址、电话号码等就不应该作为主码）</li>
<li>习惯上把主码放在其他属性前面</li>
</ul>
</blockquote>
<p>关系中的任意两个不同的元组都不允许同时在码属性上具有相同的值。码的指定代表了被建模的事物在现实世界中的约束；</p>
<p>一个关系模式（如 $r_1$）可能在它的属性中包括另一个关系模式（如 $r_2$）的主码。这个属性在 $r_1$ 上称作参照 $r_2$ 的<font color="red"><strong>外码</strong></font> ;</p>
<p>关系 $r_1$ 称为外码依赖的<strong>参照关系</strong>，关系 $r_2$ 叫做外码的<strong>被参照关系</strong> ；</p>
<p><strong>参照完整性</strong>要求在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值；</p>
<p>也就是在参照关系中出现的一些属性，我们也希望他们出现在被参照关系中，但是这些属性可能不能够成被参照关系的主键，而此时还需要达成这样的约束就叫做<strong>参照完整性</strong>；</p>
<h1 id="2-4-模式图"><a href="#2-4-模式图" class="headerlink" title="2.4 模式图"></a>2.4 模式图</h1><p>一个含有主码和外码依赖的数据库模式可以用<strong>模式图</strong>（schema diagram）来表示。</p>
<p>每一个关系用一个矩形来表示，关系的名字显示在矩形上方，矩形内列出各属性。</p>
<p>主码属性用下划线标注。</p>
<p>外码依赖用从参照关系的外码属性到被参照关系的主码属性之间的箭头来表示。</p>
<p><img src="/2020/11/09/database-system-conception-2/image-20201124155008889.png" alt="image-20201124155008889"></p>
<p>除外码约束外，模式图没有显示出参照完整性约束；（后面学的实体-联系图的图形化表示有助于我们表示几种约束）</p>
<h1 id="2-5-关系查询语言"><a href="#2-5-关系查询语言" class="headerlink" title="2.5 关系查询语言"></a>2.5 关系查询语言</h1><p><strong>查询语言</strong>是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化的和非过程化的。</p>
<p>在 <strong>过程化语言</strong> 中，用户指导系统对数据库执行一系列操作以计算出所需结果；</p>
<p>在 <strong>非过程化语言</strong> 中，用户只需描述所需信息，而不用给出获取该信息的具体过程；</p>
<p>实际使用的查询语言两种方式都有。</p>
<p>有一些”纯“查询语言：<strong>关系代数</strong>是过程化的，而 <strong>元组关系演算</strong> 和 <strong>域关系演算</strong> 是非过程化的。</p>
<p><strong>关系代数</strong> 包括一个运算的集合，这些运算以一个或两个关系为输入，产生一个新的关系作为结果。</p>
<p><strong>关系演算</strong> 使用谓词逻辑来定义所需的结果，但不需给出获取结果的特定代数过程。</p>
<h1 id="2-6-关系运算"><a href="#2-6-关系运算" class="headerlink" title="2.6 关系运算"></a>2.6 关系运算</h1><p>所有的过程化关系查询语言都提供了一组运算；这些运算要么施加于单个关系上，要么施加于一对关系上，并且<strong>运算结果总是单个关系</strong>。</p>
<ul>
<li>最常用的关系运算是 从单个关系（如 instructor）种选出满足一些特定谓词（如 salary &gt; 85000美元）的特殊元组；其结果是一个新关系，它是原始关系（instructor）的一个子集；</li>
<li>另一个常用的运算是 从一个关系中选出特定的属性（列）。其结果是一个只包含那些被选择属性的新关系；</li>
<li>连接运算：把分别来自两个关系的元组对合并成单个元组；<ul>
<li>自然连接：对于两个关系中的分别两个元组，如果他们在某一属性上取值相同，那么它们就是匹配的；</li>
</ul>
</li>
<li>笛卡尔积：结果是包含来自两个关系元组的所有对，无论它们的属性值是否匹配；</li>
<li>集合运算：包括 并、交、集合差；</li>
</ul>
<p>查询结果中可能包含重复值。有的查询语言严格遵守集合的数学定义，取出了重复，有的没有；</p>
<blockquote>
<p><strong>关系代数</strong> ： 关系代数定义了在关系上的一组运算，通常以一个或两个关系为输入，返回一个关系作为返回；</p>
</blockquote>
<p><img src="/2020/11/09/database-system-conception-2/image-20201125171819866.png" alt="image-20201125171819866"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库系统概念</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 引言</title>
    <url>/2020/11/09/databaseSystemConcepts-1/</url>
    <content><![CDATA[<h1 id="1-2-数据库系统的目标"><a href="#1-2-数据库系统的目标" class="headerlink" title="1.2 数据库系统的目标"></a>1.2 数据库系统的目标</h1><p>文件处理系统中存储组织信息的主要弊端包括：</p>
<ul>
<li>数据的冗余和不一致</li>
<li>数据访问困难</li>
<li>数据孤立</li>
<li>完整性问题</li>
<li>原子性问题</li>
<li>并发访问异常</li>
<li>安全性问题</li>
</ul>
<h1 id="1-3-数据视图"><a href="#1-3-数据视图" class="headerlink" title="1.3 数据视图"></a>1.3 数据视图</h1><p>​    数据库系统的一个主要目的是给用户提供数据的抽象视图，就是说，系统隐藏关于数据存储和维护的某些细节；</p>
<h2 id="1-3-1-数据抽象"><a href="#1-3-1-数据抽象" class="headerlink" title="1.3.1 数据抽象"></a>1.3.1 数据抽象</h2><p><img src="/2020/11/09/databaseSystemConcepts-1/image-20201109160321098.png" alt="image-20201109160321098"></p>
<p>系统要能高效地检索数据。而这促使设计者再数据库中使用复杂的数据结构来表示数据；</p>
<p>许多用户不懂计算机，需要系统开发人员通过如下几个层次对用户屏蔽复杂性：</p>
<a id="more"></a>
<ul>
<li><p>物理层：最低层次的抽象，描述数据实际上是怎样存储的。</p>
<p>​    详细描述复杂的底层数据结构；</p>
</li>
<li><p>逻辑层：比物理层稍高一层。描述数据库存储什么数据，及数据间存在什么关系。</p>
<ul>
<li>虽然逻辑层的简单结的实现可能涉及复杂的物理层结构。但逻辑层用户不必知道这样的复杂性；这叫做<strong>物理独立性</strong></li>
<li>数据库管理员使用抽象的逻辑层。</li>
</ul>
</li>
<li><p>视图层：最高层，只描述数据库的某个部分；</p>
<ul>
<li>大型数据库信息的多样性使得其仍存在一定程度的复杂性；</li>
<li>数据库系统的很多用户并不关心所有的信息，只需要访问数据库的一部分；</li>
<li>视图层的定义正是为了使用户和系统交互更简单。</li>
<li>系统可以为同一数据库提供多个视图；</li>
</ul>
</li>
</ul>
<h2 id="1-3-2-实例和模式"><a href="#1-3-2-实例和模式" class="headerlink" title="1.3.2 实例和模式"></a>1.3.2 实例和模式</h2><p>存储在数据库中的信息的集合称作数据库的一个 <strong>实例</strong> 。而数据库的总体设计称作数据库<strong>模式</strong>（schema）；</p>
<p>不同的抽象层次，数据库系统可以分为几种不同的模式：<strong>物理模式</strong>在物理层描述数据库的设计、而<strong>逻辑模式</strong>则在逻辑层描述数据库的设计。数据库在视图层可以有几种模式，成为 <strong>子模式</strong>；</p>
<p><strong>物理数据独立性</strong>：物理层可以在应用程序（视图层）丝毫不受影响的情况下被轻易地改变；应用程序不依赖于物理模式；</p>
<h2 id="1-3-3-数据模型"><a href="#1-3-3-数据模型" class="headerlink" title="1.3.3 数据模型"></a>1.3.3 数据模型</h2><p>数据库结构的基础是<strong>数据模型</strong>；</p>
<p>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。</p>
<p>数据模型可被划分为四类：</p>
<ul>
<li><strong>关系模型</strong>（relational model）：关系模型用<strong>表的集合</strong>来表示数据和数据间的联系；</li>
<li><strong>实体-联系模型</strong>（entity-relationship model）：实体-联系（E-R）数据模型基于对现实世界的这样一种认识：现实世界由一组称为实体的基本对象以及这些对象间的联系构成；</li>
<li><strong>基于对象的数据模型</strong>（object-based data model）：面对对象的数据模型可以看成是E-R模型增加了封装、方法（函数）和对象标识等概念后的扩展；</li>
<li><strong>半结构化数据模型</strong>：半结构化数据模型允许那些相同类型的数据项含有不同的属性集的数据定义。<strong>可扩展标记语言</strong>被广泛地用来表示半结构化数据；</li>
</ul>
<h1 id="1-4-数据库语言"><a href="#1-4-数据库语言" class="headerlink" title="1.4 数据库语言"></a>1.4 数据库语言</h1><p><strong>数据库定义语言</strong>，<strong>数据库操纵语言</strong>；（不限于关系型数据库）</p>
<h2 id="1-4-1-数据操纵语言"><a href="#1-4-1-数据操纵语言" class="headerlink" title="1.4.1 数据操纵语言"></a>1.4.1 数据操纵语言</h2><p>要实现：增删改查</p>
<p>有两类基本的数据操纵语言：</p>
<ul>
<li><strong>过程化DML</strong>：要求用户指定需要什么数据以及如何获得这些数据；</li>
<li><strong>声明式DML</strong>：只要求用户指定需要什么数据，不知名如何获得这些数据；</li>
</ul>
<h2 id="1-4-2-数据定义语言"><a href="#1-4-2-数据定义语言" class="headerlink" title="1.4.2 数据定义语言"></a>1.4.2 数据定义语言</h2><p><strong>数据存储和定义语言</strong>规定了数据库系统所使用地存储结构和访问方式；这些语句定义了数据库模式的实现细节，而这些细节对用户来说通常不可见；</p>
<p>存储在数据库的数据值必须满足某些<strong>一致性约束</strong>。约束可以是关于数据库的任意谓词；测试任意谓词的代价比较高。因此数据库系统要以最小代价测试的完整性约束；</p>
<ul>
<li><strong>域约束</strong>（domain constraint）：每个属性都必须对应于一个所有可能的取值构成的域；声明一种属性属于某种具体的域就相当于约束它可以取的值。域约束是完整性约束的最基本形式；</li>
<li><strong>参照完整性</strong>（referential integrity）：一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现；当参照完整性约束被违反时，通常的处理是拒绝执行导致完整性被破坏的操作；</li>
<li><strong>断言</strong>（assertion）：一个断言就是数据库需要时刻满足的某一条件；<ul>
<li>可以定义涉及多个表或聚集操作的比较复杂的完整性约束。断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。</li>
</ul>
</li>
<li><strong>授权</strong>（authorization）：对不同的用户在数据库中的不同数据值上允许不同的访问类型。<ul>
<li>这些区别以 <strong>授权</strong> 来表达：<ul>
<li><strong>读授权</strong>：允许读不允许修改；</li>
<li><strong>插入授权</strong>：允许插入新数据，不允许修改已有数据；</li>
<li><strong>更新授权</strong>：</li>
<li><strong>删除授权</strong>：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>DDL的输出放在数据字典中，数据字典包含了<strong>元数据</strong>；元数据是关于数据的数据；可以把数据字典看成之恩那个有数据库系统本身来访问和修改的特殊表；</p>
<h1 id="1-5-关系数据库"><a href="#1-5-关系数据库" class="headerlink" title="1.5 关系数据库"></a>1.5 关系数据库</h1><h2 id="1-5-1-表"><a href="#1-5-1-表" class="headerlink" title="1.5.1 表"></a>1.5.1 表</h2><p>关系模型是基于记录的模型的一个实例。基于记录的模型是因为数据库的结构是几种固定格式的记录。每个表包含一种特定类型的记录。每个记录类型定义固定数目的字段或属性。表的列对应记录类型的属性；</p>
<p>在关系模型中可能创建一些有问题的模式，比如出现不必要的冗余信息；</p>
<h2 id="1-5-2-数据操纵语言"><a href="#1-5-2-数据操纵语言" class="headerlink" title="1.5.2 数据操纵语言"></a>1.5.2 数据操纵语言</h2><p>SQL语言是非过程的；</p>
<h2 id="1-5-3-数据定义语言"><a href="#1-5-3-数据定义语言" class="headerlink" title="1.5.3 数据定义语言"></a>1.5.3 数据定义语言</h2><p>SQL提供了丰富的DDL，通过它可以定义表、完整性约束、断言等；</p>
<h2 id="1-5-4-来自应用程序的数据库访问"><a href="#1-5-4-来自应用程序的数据库访问" class="headerlink" title="1.5.4 来自应用程序的数据库访问"></a>1.5.4 来自应用程序的数据库访问</h2><ul>
<li>通过提供应用程序接口，它可以用来将 DML 和 DDL 的语句发送给数据库，再取回结果。（ODBC、JDBC等）</li>
<li>通过扩展宿主语言的语法，在宿主语言中嵌入DML调用。通常用一个特殊字符作为DML调用的开始，并且通过预处理器，称为<strong>DML预编译器</strong>，来将DML语句转变成宿主语言中的过程调用；</li>
</ul>
<h1 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6 数据库设计"></a>1.6 数据库设计</h1><p>数据库设计的主要内容是数据库模式的设计；</p>
<h2 id="1-6-1-设计过程"><a href="#1-6-1-设计过程" class="headerlink" title="1.6.1 设计过程"></a>1.6.1 设计过程</h2><ol>
<li><p>数据库设计初始阶段是全面刻画预期的数据库用户的数据需求；这阶段的成果是制定出用户需求的规格文档；</p>
</li>
<li><p>下一步，设计者选择一个数据模型，并运用该选定的数据模型的概念把那些需求转换成一个数据库的概念模式。在 <strong>概念设计</strong> 阶段开发出来的模式提供了企业的详细概述。</p>
<ul>
<li>确保所有数据需求都满足并且相互之间没有冲突；也可去掉一些冗余特性；</li>
</ul>
</li>
<li><p>从关系模型的角度来看，概念设计阶段设计决定数据库中应该包括哪些属性（商业决策），以及如何将这些属性组织到多个表中（计算机科学问题）。</p>
<ul>
<li>解决问题的主要方法：<ul>
<li>使用<strong>实体-联系模型</strong></li>
<li>引入一套算法(称为规范化)，这套算法将所有属性集作为输入，生成一组关系表；</li>
</ul>
</li>
</ul>
</li>
<li><p>一个开发完全的概念模式还将指出企业的功能需求。在 <strong>功能需求说明</strong> 中，用户描述数据之上的各种操作。</p>
</li>
<li>最后两个阶段<ul>
<li><strong>逻辑设计阶段</strong> ：设计者将高层的概念模式映射到要使用的数据库系统的实现数据模式上；</li>
<li><strong>物理设计阶段</strong> ：这阶段指定数据库的物理特性，特性包括文件组织的形式以及内部的存储结构；</li>
</ul>
</li>
</ol>
<h2 id="1-6-2-大学机构的数据库设计"><a href="#1-6-2-大学机构的数据库设计" class="headerlink" title="1.6.2 大学机构的数据库设计"></a>1.6.2 大学机构的数据库设计</h2><h2 id="1-6-3-实体-联系模型"><a href="#1-6-3-实体-联系模型" class="headerlink" title="1.6.3 实体-联系模型"></a>1.6.3 实体-联系模型</h2><p>实体-联系（E-R）数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p>
<blockquote>
<p><strong>实体</strong>是现实世界中可区别于其他对象的一件”事情“或一个”物体“。</p>
<p>数据库中实体通过属性集合来描述</p>
<p><strong>联系</strong> 是几个实体之间的关联。</p>
<p>同一类型的所有实体称为<strong>实体集</strong>。</p>
<p>同一类型的所有联系称为联系集。</p>
</blockquote>
<p>数据库的总体逻辑结构可以用实体-联系图来表示：</p>
<ul>
<li>实体集用矩形框表示，实体名在头部，属性名在下面；</li>
<li>联系集用联系一对相关的实体集的菱形表示，联系名放在菱形内部。</li>
</ul>
<p><img src="/2020/11/09/databaseSystemConcepts-1/image-20201116112941078.png" alt="image-20201116112941078"></p>
<p>除了实体和联系外，E-R模型还描述了数据库必须描述的对其内容的某些约束。</p>
<h2 id="1-6-4-规范化"><a href="#1-6-4-规范化" class="headerlink" title="1.6.4 规范化"></a>1.6.4 规范化</h2><p><strong>规范化</strong>的目标是生成一个关系模式集合，使存储信息时没有不必要的冗余，同时又能很轻易地检索数据；</p>
<p>规范化是设计一种符合适当的范式的模式；最常用的方法是使用<strong>函数依赖</strong></p>
<p>不好的设计可能会包括如下特性：</p>
<ul>
<li><strong>信息重复</strong> ：重复信息的修改也是个问题</li>
<li><strong>缺乏表达某些信息的能力</strong> </li>
</ul>
<h1 id="1-7-数据存储和查询"><a href="#1-7-数据存储和查询" class="headerlink" title="1.7 数据存储和查询"></a>1.7 数据存储和查询</h1><p>数据库系统功能部件大致可分为 <strong>存储管理器</strong> 和 <strong>存储处理</strong>部件 ； </p>
<p><strong>存储管理</strong>：要在大量存储空间组织数据，使其满足和主存之间数据的移动最小化；</p>
<p><strong>查询处理</strong>：帮助数据库系统简化和方便数据的访问。使得用户获得高性能，同时在视图的层次上工作。不必了解系统实现物理层次细节的负担。</p>
<p>将在逻辑层编写的更新和查询转变成物理层的高效操作序列，这是数据库系统的任务；</p>
<h2 id="1-7-1-存储管理器"><a href="#1-7-1-存储管理器" class="headerlink" title="1.7.1 存储管理器"></a>1.7.1 存储管理器</h2><p><strong>存储管理器</strong> 是 数据库系统中负责在【数据库中存储的底层数据】与【应用程序】以及【向系统提交的查询】之间提供接口的部件；它负责与文件管理器进行交互；</p>
<p>​    存储管理器将各种 <code>DML</code> 语句翻译为底层文件系统命令。而原始数据通过操作系统提供的文件系统存储在硬盘上。</p>
<p>因此存储管理器负责数据库中数据的存储、检索和更新；</p>
<p>存储管理部件包括：</p>
<ul>
<li><strong>权限及完整性管理器</strong>(authorization and integrity manager)：检测是否满足完整性约束，并检查试图访问数据的用户的权限；</li>
<li><strong>事务管理器</strong>( transaction manager )：保证数据库及事故障时也保持在一致的状态，保证并发事务的执行不发生冲突；</li>
<li><strong>文件管理器</strong>( file manager )：它管理磁盘存储空间的分配，管理用于表示磁盘上存储信息的数据结构；</li>
<li><strong>缓存处理器</strong>( buffer manager )：负责将数据从磁盘上取到内存中，决定哪些数据应被缓存。</li>
</ul>
<p>存储管理器实现了几种数据结构，作为系统物理实现的一部分：</p>
<ul>
<li><strong>数据文件</strong> 存储数据库自身</li>
<li><strong>数据字典</strong> ：存储关于数据库结构的元数据，尤其是数据库模式；</li>
<li><strong>索引</strong>：提供对数据项的快速访问。</li>
</ul>
<h2 id="1-7-2-查询处理器"><a href="#1-7-2-查询处理器" class="headerlink" title="1.7.2 查询处理器"></a>1.7.2 查询处理器</h2><p>查询处理器组件包括：</p>
<ul>
<li><strong>DDL解释器（DDL interpreter）</strong>：他解释DDL语句并将这些定义记录在数据字典中。</li>
<li><strong>DML编译器（DML compiler）</strong>：将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。<ul>
<li>一个查询通常可翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行<strong>查询优化</strong>，也就是从几种选择中选出代价最小的一种。</li>
</ul>
</li>
<li><strong>查询执行引擎（query evaluation engine）</strong>：执行由DML编译器产生的低级指令；</li>
</ul>
<h1 id="1-8-事务管理"><a href="#1-8-事务管理" class="headerlink" title="1.8 事务管理"></a>1.8 事务管理</h1><p>对数据库的几个操作合起来形成一个逻辑单元；</p>
<ul>
<li><strong>原子性（atomicity）</strong>：要求这些操作要么全部完成要么不发生的；</li>
<li><strong>一致性（consistency）</strong>：要求结果这种正确性；例如转账后两账户余额之和不变；</li>
<li><strong>持久性（durability）</strong>：要求即使发生系统故障，事务完成后的结果依然保持不变；</li>
</ul>
<p><strong>事务</strong> 是数据库应用中完成单一逻辑功能的操作集合；</p>
<blockquote>
<p>每个事务是既具有原子性又具有一致性的单元；因此要求事务不违反任何的数据库一致性约束；</p>
<ul>
<li>如果事务启动时数据库是一致的，那么事务完成结束时也应该时一致的。</li>
<li>而事务执行过程中，必要时允许暂时的不一致；（转账总有转出与转入总得有个顺序）</li>
<li>虽然暂时的不一致时必需的，但故障发生时，很可能导致问题产生；</li>
</ul>
</blockquote>
<p><strong>事务管理器</strong> 包括 <strong>并发控制管理器</strong> 和 <strong>恢复管理器</strong>；</p>
<p>原子性和持久性的保证是 <strong>恢复管理器</strong> 的职责；使得系统故障时保证数据的原子性和持久性；</p>
<p><strong>并发控制管理器</strong> 控制并发事务间的相互影响， 保证数据库一致性；</p>
<h1 id="1-9-数据库体系结构"><a href="#1-9-数据库体系结构" class="headerlink" title="1.9 数据库体系结构"></a>1.9 数据库体系结构</h1><p><img src="/2020/11/09/databaseSystemConcepts-1/image-20201118102051536.png" alt="image-20201118102051536"></p>
<p>数据库系统可以是集中式的、客户/服务器式的（一台服务器为多个客户机执行任务）；也可以针对<strong>并行计算机体系结构</strong>设计数据库系统；<strong>分布式数据库</strong>包含地理上分离的多台计算机；</p>
<p>在一个 <strong>两层体系结构</strong> 中，应用程序驻留在客户机上，通过查询语言表达式来调用服务器上的数据库系统功能；</p>
<p>在一个 <strong>三层体系结构</strong> 中，客户机只作为一个前端并且不包含任何直接的数据库调用。客户端通常通过一个表单界面与应用服务器进行通信。应用服务器与数据库系统通信以访问数据。</p>
<p><img src="/2020/11/09/databaseSystemConcepts-1/image-20201118103122320.png" alt="image-20201118103122320"></p>
<h1 id="1-10-数据挖掘与信息检索"><a href="#1-10-数据挖掘与信息检索" class="headerlink" title="1.10 数据挖掘与信息检索"></a>1.10 数据挖掘与信息检索</h1><p><strong>数据挖掘（data mining）</strong>指半自动地分析大型数据库并从中找出有用的模式的过程；从数据库中找到的发现的某些类型地只是可以用一套 <strong>规则</strong> 表示。</p>
<h1 id="1-11-特种数据库"><a href="#1-11-特种数据库" class="headerlink" title="1.11 特种数据库"></a>1.11 特种数据库</h1><p>数据库系统的一些应用领域收到关系数据库的限制。<strong>基于对象的数据模型</strong>和<strong>半结构化数据模型</strong>；</p>
<h1 id="1-12-数据库用户和管理员"><a href="#1-12-数据库用户和管理员" class="headerlink" title="1.12 数据库用户和管理员"></a>1.12 数据库用户和管理员</h1>]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库系统概念</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>python和java的垃圾回收机制</title>
    <url>/2020/08/31/garbage_Collection/</url>
    <content><![CDATA[<h1 id="Python垃圾回收机制详解"><a href="#Python垃圾回收机制详解" class="headerlink" title="Python垃圾回收机制详解"></a><a href="https://blog.csdn.net/xiongchengluo1129/article/details/80462651" target="_blank" rel="noopener">Python垃圾回收机制详解</a></h1><h2 id="一、引用计数"><a href="#一、引用计数" class="headerlink" title="一、引用计数"></a>一、引用计数</h2><p>Python垃圾回收主要以引用计数为主，分代回收为辅。</p>
<h3 id="1-引用计数增加的情况"><a href="#1-引用计数增加的情况" class="headerlink" title="1.引用计数增加的情况"></a>1.引用计数增加的情况</h3><p>当发生以下四种情况的时候，该对象的引用计数器<strong>+1</strong></p>
<ol>
<li><strong>对象被创建  a=14</strong></li>
<li><strong>对象被引用  b=a</strong></li>
<li><strong>对象被作为参数,传到函数中   func(a)</strong></li>
<li><strong>对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}</strong></li>
</ol>
<h3 id="2-引用计数减少的情况"><a href="#2-引用计数减少的情况" class="headerlink" title="2. 引用计数减少的情况"></a>2. 引用计数减少的情况</h3><p>与上述情况相对应，当发生以下四种情况时，该对象的引用计数器<strong>-1</strong></p>
<ol>
<li><strong>当该对象的别名被显式销毁时  del a</strong></li>
<li><strong>当该对象的引别名被赋予新的对象，   a=26</strong></li>
<li><strong>一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）</strong></li>
<li><strong>将该元素从容器中删除时，或者容器被销毁时。</strong></li>
</ol>
<p>当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁</p>
<a id="more"></a>
<h3 id="3-引用计数法有很明显的优点："><a href="#3-引用计数法有很明显的优点：" class="headerlink" title="3.引用计数法有很明显的优点："></a>3.<strong>引用计数法有很明显的优点：</strong></h3><ol>
<li>高效</li>
<li>运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li>
<li>对象有确定的生命周期</li>
<li>易于实现</li>
</ol>
<h3 id="4-原始的引用计数法也有明显的缺点："><a href="#4-原始的引用计数法也有明显的缺点：" class="headerlink" title="4. 原始的引用计数法也有明显的缺点："></a>4. 原始的引用计数法也有明显的缺点：</h3><ol>
<li>维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。</li>
<li>无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。<br>循环引用的示例：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; []</span><br><span class="line">list2 &#x3D; []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<h2 id="二、标记-清除"><a href="#二、标记-清除" class="headerlink" title="二、标记-清除"></a>二、标记-清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p><img src="/2020/08/31/garbage_Collection/mark-sweep.svg" alt="laji"></p>
<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>
<h2 id="三、分代回收"><a href="#三、分代回收" class="headerlink" title="三、分代回收"></a>三、分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p>
<h1 id="深入理解java垃圾回收机制"><a href="#深入理解java垃圾回收机制" class="headerlink" title="深入理解java垃圾回收机制"></a><a href="https://www.cnblogs.com/sunniest/p/4575144.html" target="_blank" rel="noopener">深入理解java垃圾回收机制</a></h1><h2 id="一、垃圾回收机制的意义"><a href="#一、垃圾回收机制的意义" class="headerlink" title="一、垃圾回收机制的意义"></a>一、垃圾回收机制的意义</h2><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p>
<p>　　<em>ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</em></p>
<h2 id="二、垃圾回收机制中的算法"><a href="#二、垃圾回收机制中的算法" class="headerlink" title="二、垃圾回收机制中的算法"></a>二、垃圾回收机制中的算法</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。　　</p>
<h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1.引用计数法(Reference Counting Collector)"></a>1.引用计数法(Reference Counting Collector)</h3><h4 id="1-1算法分析"><a href="#1-1算法分析" class="headerlink" title="1.1算法分析　"></a>1.1算法分析　</h4><p>　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p>
<h4 id="1-2优缺点"><a href="#1-2优缺点" class="headerlink" title="1.2优缺点"></a>1.2优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>　　引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>　　无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<h4 id="1-3引用计数算法无法解决循环引用问题"><a href="#1-3引用计数算法无法解决循环引用问题" class="headerlink" title="1.3引用计数算法无法解决循环引用问题"></a>1.3引用计数算法无法解决循环引用问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">         </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">         </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <span style="color:red">最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</span></p>
<h3 id="2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><a href="#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep" class="headerlink" title="2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)"></a>2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h3><h4 id="2-1-根搜索算法"><a href="#2-1-根搜索算法" class="headerlink" title="2.1 根搜索算法"></a>2.1 根搜索算法</h4><p><img src="/2020/08/31/garbage_Collection/141050566294022.jpg" alt="img"></p>
<p>　根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<p>java中可作为GC Root的对象有</p>
<div style="color:red">
    1.虚拟机栈中引用的对象（本地变量表）<br>
    2.方法区中静态属性引用的对象<br>
    3. 方法区中常量引用的对象<br>
    4.本地方法栈中引用的对象（Native对象）<br>
　</div>



<h4 id="2-2-tracing算法的示意图"><a href="#2-2-tracing算法的示意图" class="headerlink" title="2.2 tracing算法的示意图"></a>2.2 tracing算法的示意图</h4><p><img src="/2020/08/31/garbage_Collection/141048430359736.jpg" alt="img"></p>
<h4 id="2-3标记-清除算法分析"><a href="#2-3标记-清除算法分析" class="headerlink" title="2.3标记-清除算法分析"></a>2.3标记-清除算法分析</h4><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
<h3 id="3-compacting算法-或-标记-整理算法"><a href="#3-compacting算法-或-标记-整理算法" class="headerlink" title="3.compacting算法 或 标记-整理算法"></a>3.compacting算法 或 标记-整理算法</h3><p><img src="/2020/08/31/garbage_Collection/141120037076681.jpg" alt="img"></p>
<p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<h3 id="4-copying算法-Compacting-Collector"><a href="#4-copying算法-Compacting-Collector" class="headerlink" title="4.copying算法(Compacting Collector)"></a>4.copying算法(Compacting Collector)</h3><p><img src="/2020/08/31/garbage_Collection/141112115351233.jpg" alt="img"></p>
<p>　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。</p>
<p>它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>
<p>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<h3 id="5-generation算法-Generational-Collector"><a href="#5-generation算法-Generational-Collector" class="headerlink" title="5.generation算法(Generational Collector)"></a>5.generation算法(Generational Collector)</h3><p><img src="/2020/08/31/garbage_Collection/141332429573819.jpg" alt="img"></p>
<p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p>
<p><span style="color:red"><strong>年轻代（Young Generation）</strong></span></p>
<ol>
<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>
<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>
<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</li>
<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</li>
</ol>
<p><span style="color:red"><strong>年老代（Old Generation）</strong></span></p>
<p>1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>
<p><span style="color:red"><strong>持久代（Permanent Generation）</strong></span></p>
<p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>
<h2 id="三-GC（垃圾收集器）"><a href="#三-GC（垃圾收集器）" class="headerlink" title="三.GC（垃圾收集器）"></a>三.GC（垃圾收集器）</h2><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>
<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>
<p><img src="/2020/08/31/garbage_Collection/141513122384006.jpg" alt="img"></p>
<p><span style="color:red"><strong>Serial收集器（复制算法)</strong></span></p>
<p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
<p><span style="color:red"><strong>Serial Old收集器(标记-整理算法)</strong></span></p>
<p>老年代单线程收集器，Serial收集器的老年代版本。</p>
<p><span style="color:red"><strong>ParNew收集器(停止-复制算法)</strong></span></p>
<p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>
<p><span style="color:red"><strong>Parallel Scavenge收集器(停止-复制算法)</strong></span></p>
<p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
<p><span style="color:red"><strong>Parallel Old收集器(停止-复制算法)</strong></span></p>
<p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
<p><span style="color:red"><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></span></p>
<p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>
<h2 id="四、GC的执行机制"><a href="#四、GC的执行机制" class="headerlink" title="四、GC的执行机制"></a>四、GC的执行机制</h2><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<span style="color:red">Scavenge GC</span>和<span style="color:red">Full GC</span>。</p>
<p><span style="color:red"><strong>Scavenge GC</strong></span></p>
<p>   一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<p><span style="color:red"><strong>Full GC</strong></span></p>
<p>   对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<pre><code>&lt;div style=color:red&gt;
    1.年老代（Tenured）被写满&lt;br&gt;
    2.持久代（Perm）被写满 &lt;br&gt;
    3.System.gc()被显示调用 &lt;br&gt;
    4.上一次GC之后Heap的各域分配策略动态变化
 &lt;/div&gt;
</code></pre><h2 id="五、Java有了GC同样会出现内存泄露问题"><a href="#五、Java有了GC同样会出现内存泄露问题" class="headerlink" title="五、Java有了GC同样会出现内存泄露问题"></a>五、Java有了GC同样会出现内存泄露问题</h2><p><span style="color:red">1. 静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Static Vector v &#x3D; new Vector(); </span><br><span class="line">for (int i &#x3D; 1; i&lt;100; i++) </span><br><span class="line">&#123; </span><br><span class="line">    Object o &#x3D; new Object(); </span><br><span class="line">    v.add(o); </span><br><span class="line">    o &#x3D; null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。</p>
<p><span style="color:red">2. 各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</span></p>
<p><span style="color:red">3. 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</span></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/03/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>javascript</title>
    <url>/2020/07/20/javascript/</url>
    <content><![CDATA[<h1 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h1><h1 id="一、JavaScript简述"><a href="#一、JavaScript简述" class="headerlink" title="一、JavaScript简述"></a>一、JavaScript简述</h1><pre><code>* 概念：    一门客户端脚本语言
    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎
    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了

* 功能：
    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。
</code></pre><a id="more"></a>
<h1 id="二-、JavaScript发展史："><a href="#二-、JavaScript发展史：" class="headerlink" title="二 、JavaScript发展史："></a>二 、JavaScript发展史：</h1><pre><code>    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase
    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript
    3. 1996年，微软抄袭JavaScript开发出JScript语言
    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。

    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)

* ECMAScript：客户端脚本语言的标准
</code></pre><h1 id="三、-ECMAScript：客户端脚本语言的标准"><a href="#三、-ECMAScript：客户端脚本语言的标准" class="headerlink" title="三、 ECMAScript：客户端脚本语言的标准"></a>三、 ECMAScript：客户端脚本语言的标准</h1><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><h4 id="1-与html结合方式"><a href="#1-与html结合方式" class="headerlink" title="(1) 与html结合方式"></a>(1) 与html结合方式</h4><pre><code>            1. 内部JS：
                * 定义&lt;script&gt;，标签体内容就是js代码
            2. 外部JS：
                * 定义&lt;script&gt;，通过src属性引入外部的js文件

            * 注意：
                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。
                2. &lt;script&gt;可以定义多个。
</code></pre><h4 id="2-注释"><a href="#2-注释" class="headerlink" title="(2) 注释"></a>(2) 注释</h4><pre><code>            1. 单行注释：//注释内容
            2. 多行注释：/*注释内容*/
</code></pre><h4 id="3-数据类型："><a href="#3-数据类型：" class="headerlink" title="(3) 数据类型："></a>(3) 数据类型：</h4><pre><code>            1. 原始数据类型(基本数据类型)：
                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)
                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;
                3. boolean: true和false
                4. null：一个对象为空的占位符
                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined

            2. 引用数据类型：对象
</code></pre><h4 id="4-变量"><a href="#4-变量" class="headerlink" title="(4) 变量"></a>(4) 变量</h4><pre><code>        * 变量：一小块存储数据的内存空间
        * Java语言是强类型语言，而JavaScript是弱类型语言。
                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据
                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。
        * 语法：
                * var 变量名 = 初始化值;
                * var 变量名;

        * typeof运算符：获取变量的类型。
                * 注：null运算后得到的是object
</code></pre><h4 id="5-运算符"><a href="#5-运算符" class="headerlink" title="(5) 运算符"></a>(5) 运算符</h4><h5 id="a-一元运算符：只有一个运算数的运算符"><a href="#a-一元运算符：只有一个运算数的运算符" class="headerlink" title="a. 一元运算符：只有一个运算数的运算符"></a>a. 一元运算符：只有一个运算数的运算符</h5><pre><code>                ++，-- ， +(正号)  
                * ++ --: 自增(自减)
                    * ++(--) 在前，先自增(自减)，再运算
                    * ++(--) 在后，先运算，再自增(自减)
                * +(-)：正负号
                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换
                    * 其他类型转number：
                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）;
                        * NaN和任何数做运算都是NaN
                        * boolean转number：true转为1，false转为0
</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a = num ++ ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(num);<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">document</span>.write(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;hr&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a = ++ num ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(num);<span class="comment">// 4</span></span><br><span class="line"><span class="built_in">document</span>.write(a); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;hr&gt;"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="b-算数运算符"><a href="#b-算数运算符" class="headerlink" title="b. 算数运算符"></a>b. 算数运算符</h5><pre><code>                + - * / % ...
</code></pre><h5 id="c-赋值运算符"><a href="#c-赋值运算符" class="headerlink" title="c. 赋值运算符"></a>c. 赋值运算符</h5><pre><code>                = += -+....
</code></pre><h5 id="d-比较运算符"><a href="#d-比较运算符" class="headerlink" title="d. 比较运算符"></a>d. 比较运算符</h5><pre><code>                &gt; &lt; &gt;= &lt;= == ===(全等于)
                * 比较方式
                  1. 类型相同：直接比较
                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。
                  2. 类型不同：先进行类型转换，再比较:     &quot;123&quot;==123:true
                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false
</code></pre><h5 id="e-逻辑运算符"><a href="#e-逻辑运算符" class="headerlink" title="e. 逻辑运算符"></a>e. 逻辑运算符</h5><pre><code>                &amp;&amp; || !
                * 其他类型转boolean：
                   1. number：0或NaN为假，其他为真
                   2. string：除了空字符串(&quot;&quot;)，其他都是true
                   3. null&amp;undefined:都是false
                   4. 对象：所有对象都为true
</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.length &gt; <span class="number">0</span>)&#123;<span class="comment">//防止空指针异常</span></span><br><span class="line">    alert(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//js中可以这样定义，简化书写。</span></span><br><span class="line"><span class="keyword">if</span>(obj)&#123;<span class="comment">//防止空指针异常	// 这样写是可以同时判断多种类型的,包括null,"";</span></span><br><span class="line">    alert(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="f-三元运算符"><a href="#f-三元运算符" class="headerlink" title="f. 三元运算符"></a>f. 三元运算符</h5><pre><code>                ? : 表达式
                var a = 3;
                var b = 4;

                var c = a &gt; b ? 1:0;
                * 语法：
                    * 表达式? 值1:值2;
                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；
</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a &gt; b ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">alert(c);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-流程控制语句："><a href="#6-流程控制语句：" class="headerlink" title="(6) 流程控制语句："></a>(6) 流程控制语句：</h4><pre><code>            1. if...else...
            2. switch:
                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)
                    * switch(变量):
                        case 值:
                * 在JS中,switch语句可以接受任意的原始数据类型 
            3. while
            4. do...while
            5. for
</code></pre><h4 id="7-JS特殊语法："><a href="#7-JS特殊语法：" class="headerlink" title="(7) JS特殊语法："></a>(7) JS特殊语法：</h4><pre><code>            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)
            2. 变量的定义使用var关键字，也可以不使用
                * 用： 定义的变量是局部变量
                * 不用：定义的变量是全局变量(不建议)
</code></pre><h4 id="8-练习：99乘法表"><a href="#8-练习：99乘法表" class="headerlink" title="(8) 练习：99乘法表"></a>(8) 练习：99乘法表</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>99乘法表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            td&#123;</span><br><span class="line">                border: 1px solid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;table  align='center'&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//1.完成基本的for循环嵌套，展示乘法表</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span> ; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"&lt;tr&gt;"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;=i ; j++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.write(<span class="string">"&lt;td&gt;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">                    <span class="comment">//输出  1 * 1 = 1</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.write(i + <span class="string">" * "</span> + j + <span class="string">" = "</span> + ( i*j) +<span class="string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.write(<span class="string">"&lt;/td&gt;"</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">                /*//输出换行</span><br><span class="line"><span class="javascript">			            <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);*<span class="regexp">/</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"&lt;/tr&gt;"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">//2.完成表格嵌套</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;/table&gt;"</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-基本对象："><a href="#2-基本对象：" class="headerlink" title="2. 基本对象："></a>2. 基本对象：</h3><h4 id="1-Function：函数-方法-对象"><a href="#1-Function：函数-方法-对象" class="headerlink" title="(1) Function：函数(方法)对象"></a>(1) Function：函数(方法)对象</h4><pre><code>            1. 创建：
                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧
                2. 
                    function 方法名称(形式参数列表){
                        方法体
                    }

                3. 
                   var 方法名 = function(形式参数列表){
                        方法体
                   }
            2. 方法：

            3. 属性：
                length:代表形参的个数
            4. 特点：
                1. 方法定义是，形参的类型不用写,返回值类型也不写。
                2. 方法是一个对象，如果定义名称相同的方法，会覆盖
                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关
                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数
            5. 调用：
                方法名称(实际参数列表);
</code></pre><h4 id="2-Array-数组对象"><a href="#2-Array-数组对象" class="headerlink" title="(2) Array:数组对象"></a>(2) Array:数组对象</h4><pre><code>            1. 创建：
                1. var arr = new Array(元素列表);
                2. var arr = new Array(默认长度);
                3. var arr = [元素列表];
            2. 方法
                join(参数):将数组中的元素按照指定的分隔符拼接为字符串
                push()    向数组的末尾添加一个或更多元素，并返回新的长度。
            3. 属性
                length:数组的长度
            4. 特点：
                1. JS中，数组元素的类型可变的。
                2. JS中，数组长度可变的。
</code></pre><h4 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="(3) Boolean"></a>(3) Boolean</h4><h4 id="4-Date：日期对象"><a href="#4-Date：日期对象" class="headerlink" title="(4) Date：日期对象"></a>(4) Date：日期对象</h4><pre><code>            1. 创建：
                var date = new Date();

            2. 方法：
                toLocaleString()：返回当前date对象对应的时间本地字符串格式
                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差
</code></pre><h4 id="5-Math：数学对象"><a href="#5-Math：数学对象" class="headerlink" title="(5) Math：数学对象"></a>(5) Math：数学对象</h4><pre><code>            1. 创建：
                * 特点：Math对象不用创建，直接使用。  Math.方法名();

            2. 方法：
                random():返回 0 ~ 1 之间的随机数。 含0不含1
                ceil(x)：对数进行上舍入。
                floor(x)：对数进行下舍入。
                round(x)：把数四舍五入为最接近的整数。
            3. 属性：
                PI
</code></pre><h4 id="6-Number"><a href="#6-Number" class="headerlink" title="(6) Number"></a>(6) Number</h4><h4 id="7-String"><a href="#7-String" class="headerlink" title="(7) String"></a>(7) String</h4><h4 id="8-RegExp：正则表达式对象"><a href="#8-RegExp：正则表达式对象" class="headerlink" title="(8) RegExp：正则表达式对象"></a>(8) RegExp：正则表达式对象</h4><pre><code>            1. 正则表达式：定义字符串的组成规则。
                1. 单个字符:[]
                    如： [a] [ab] [a-zA-Z0-9_]
                    * 特殊符号代表特殊含义的单个字符:
                        \d:单个数字字符 [0-9]
                        \w:单个单词字符[a-zA-Z0-9_]
                2. 量词符号：
                    ?：表示出现0次或1次
                    *：表示出现0次或多次
                    +：出现1次或多次
                    {m,n}:表示 m&lt;= 数量 &lt;= n
                        * m如果缺省： {,n}:最多n次
                        * n如果缺省：{m,} 最少m次
                3. 开始结束符号
                    * ^:开始
                    * $:结束
            2. 正则对象：
                1. 创建
                    1. var reg = new RegExp(&quot;正则表达式&quot;);
                    2. var reg = /正则表达式/;
                2. 方法    
                    1. test(参数):验证指定的字符串是否符合正则定义的规范    
</code></pre><h4 id="9-Global"><a href="#9-Global" class="headerlink" title="(9) Global"></a>(9) Global</h4><pre><code>            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();
            2. 方法：
                encodeURI():url编码
                decodeURI():url解码

                encodeURIComponent():url编码,能够编码的字符更多,比如各种//,.,在encodeURL中都没有
                decodeURIComponent():url解码

                parseInt():将字符串转为数字
                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number
                isNaN():判断一个值是否是NaN
                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false

                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。
            3. URL编码
               传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2

* BOM

* DOM
</code></pre><h1 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h1><pre><code>* 功能：控制html文档的内容
* 获取页面标签(元素)对象：Element
    * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象

* 操作Element对象：
    1. 修改属性值：
        1. 明确获取的对象是哪一个？
        2. 查看API文档，找其中有哪些属性可以设置
    2. 修改标签体内容：
        * 属性：innerHTML
        1. 获取元素对象
        2. 使用innerHTML属性修改标签体内容
</code></pre><h1 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h1><ul>
<li><p>功能： 某些组件被执行了某些操作后，触发某些代码的执行。</p>
<ul>
<li>造句：  xxx被xxx,我就xxx<pre><code>  * 我方水晶被摧毁后，我就责备对友。
</code></pre><ul>
<li>敌方水晶被摧毁后，我就夸奖自己。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何绑定事件</p>
<pre><code>  1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码
      1. 事件：onclick--- 单击事件
  2. 通过js获取元素对象，指定事件属性，设置一个函数
</code></pre></li>
</ul>
<ul>
<li>代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img id=<span class="string">"light"</span> src=<span class="string">"img/off.gif"</span>  onclick=<span class="string">"fun();"</span>&gt;</span><br><span class="line">    &lt;img id=<span class="string">"light2"</span> src=<span class="string">"img/off.gif"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            	alert(<span class="string">'我被点了'</span>);</span><br><span class="line">            	alert(<span class="string">'我又被点了'</span>);</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">'咋老点我？'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.获取light2对象</span></span><br><span class="line">            <span class="keyword">var</span> light2 = <span class="built_in">document</span>.getElementById(<span class="string">"light2"</span>);</span><br><span class="line">            <span class="comment">//2.绑定事件</span></span><br><span class="line">            light2.onclick = fun2;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="案例1：电灯开关"><a href="#案例1：电灯开关" class="headerlink" title="案例1：电灯开关"></a>案例1：电灯开关</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">            &lt;title&gt;电灯开关&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">		&lt;/</span>head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;img id=<span class="string">"light"</span> src=<span class="string">"img/off.gif"</span>&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    分析：</span></span><br><span class="line"><span class="comment">                        1.获取图片对象</span></span><br><span class="line"><span class="comment">                        2.绑定单击事件</span></span><br><span class="line"><span class="comment">                        3.每次点击切换图片</span></span><br><span class="line"><span class="comment">                            * 规则：</span></span><br><span class="line"><span class="comment">                                * 如果灯是开的 on,切换图片为 off</span></span><br><span class="line"><span class="comment">                                * 如果灯是关的 off,切换图片为 on</span></span><br><span class="line"><span class="comment">                            * 使用标记flag来完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//1.获取图片对象</span></span><br><span class="line">                <span class="keyword">var</span> light = <span class="built_in">document</span>.getElementById(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> flag = <span class="literal">false</span>;<span class="comment">//代表灯是灭的。 off图片</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.绑定单击事件</span></span><br><span class="line">                light.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag)&#123;<span class="comment">//判断如果灯是开的，则灭掉</span></span><br><span class="line">                        light.src = <span class="string">"img/off.gif"</span>;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//如果灯是灭的，则打开</span></span><br><span class="line"></span><br><span class="line">                        light.src = <span class="string">"img/on.gif"</span>;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                    &#125;		</span><br><span class="line">                &#125;		    </span><br><span class="line">		&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><h2 id="1-概念：Browser-Object-Model-浏览器对象模型"><a href="#1-概念：Browser-Object-Model-浏览器对象模型" class="headerlink" title="1. 概念：Browser Object Model 浏览器对象模型"></a>1. 概念：Browser Object Model 浏览器对象模型</h2><pre><code>    * 将浏览器的各个组成部分封装成对象。
</code></pre><h2 id="2-组成："><a href="#2-组成：" class="headerlink" title="2. 组成："></a>2. 组成：</h2><pre><code>    * Window：窗口对象
        * History：历史记录对象
        * Location：地址栏对象
    * Navigator：浏览器对象
    * Screen：显示器屏幕对象
</code></pre><p><img src="/2020/07/20/javascript/image-20200725153251736.png" alt="image-20200725153251736"></p>
<h2 id="3-Window：窗口对象"><a href="#3-Window：窗口对象" class="headerlink" title="3. Window：窗口对象"></a>3. Window：窗口对象</h2><pre><code>    1. 创建
    2. 方法
         1. 与弹出框有关的方法：
            alert()    显示带有一段消息和一个确认按钮的警告框。
            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。
                * 如果用户点击确定按钮，则方法返回true
                * 如果用户点击取消按钮，则方法返回false
            prompt()    显示可提示用户输入的对话框。
                * 返回值：获取用户输入的值
         2. 与打开关闭有关的方法：
            close()    关闭浏览器窗口。
                * 谁调用我 ，我关谁
            open()    打开一个新的浏览器窗口
                * 返回新的Window对象
         3. 与定时器有关的方式
            setTimeout()    在指定的毫秒数后调用函数或计算表达式。
                * 参数：
                    1. js代码或者方法对象
                    2. 毫秒值
                * 返回值：唯一标识，用于取消定时器
            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。

            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。
            clearInterval()    取消由 setInterval() 设置的 timeout。

    3. 属性：
        1. 获取其他BOM对象：
            history
            location
            Navigator
            Screen:
        2. 获取DOM对象
            document
    4. 特点
        * Window对象不需要创建可以直接使用 window使用。 window.方法名();
        * window引用可以省略。  方法名();
</code></pre><h2 id="4-Location：地址栏对象"><a href="#4-Location：地址栏对象" class="headerlink" title="4. Location：地址栏对象"></a>4. Location：地址栏对象</h2><pre><code>    1. 创建(获取)：
        1. window.location
        2. location

    2. 方法：
        * reload()    重新加载当前文档。刷新
        * assign()    加载新的文档。
        * replace()    用新的文档替换当前文档。
    3. 属性
        * href    设置或返回完整的 URL。
</code></pre><h2 id="5-History：历史记录对象"><a href="#5-History：历史记录对象" class="headerlink" title="5. History：历史记录对象"></a>5. History：历史记录对象</h2><pre><code>    1. 创建(获取)：
        1. window.history
        2. history

    2. 方法：
        * back()    加载 history 列表中的前一个 URL。
        * forward()    加载 history 列表中的下一个 URL。
        * go(参数)    加载 history 列表中的某个具体页面。
            * 参数：
                * 正数：前进几个历史记录
                * 负数：后退几个历史记录
    3. 属性：
        * length    返回当前窗口历史列表中的 URL 数量。
</code></pre><h1 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><pre><code>    Document Object Model 文档对象模型
    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作
</code></pre><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><pre><code>* W3C DOM 标准被分为 3 个不同的部分：

    * 核心 DOM - 针对任何结构化文档的标准模型
        * Document：文档对象
        * Element：元素对象
        * Attribute：属性对象
        * Text：文本对象
        * Comment:注释对象

        * Node：节点对象，其他5个的父对象
    * XML DOM - 针对 XML 文档的标准模型
    * HTML DOM - 针对 HTML 文档的标准模型
</code></pre><h2 id="核心DOM模型："><a href="#核心DOM模型：" class="headerlink" title="核心DOM模型："></a>核心DOM模型：</h2><h3 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h3><pre><code>        1. 创建(获取)：在html dom模型中可以使用window对象来获取
            1. window.document
            2. document
        2. 方法：
            1. 获取Element对象：
                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一
                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组
                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组
                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组
            2. 创建其他DOM对象：
                createAttribute(name)
                createComment()
                createElement()
                createTextNode()
        3. 属性 
</code></pre><h3 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a>Element：元素对象</h3><pre><code>        1. 获取/创建：通过document来获取和创建
        2. 方法：
            1. removeAttribute()：删除属性
            2. setAttribute()：设置属性
</code></pre><h3 id="Node：节点对象，其他5个的父对象"><a href="#Node：节点对象，其他5个的父对象" class="headerlink" title="Node：节点对象，其他5个的父对象"></a>Node：节点对象，其他5个的父对象</h3><pre><code>        * 特点：所有dom对象都可以被认为是一个节点
        * 方法：
            * CRUD dom树：
                * appendChild()：向节点的子节点列表的结尾添加新的子节点。
                * removeChild()    ：删除（并返回）当前节点的指定子节点。
                * replaceChild()：用新节点替换一个子节点。
        * 属性：
            * parentNode 返回节点的父节点。
</code></pre><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><pre><code>    1. 标签体的设置和获取：innerHTML
</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</span><br><span class="line"><span class="keyword">var</span> innerHTML = div.innerHTML;</span><br><span class="line"><span class="comment">//alert(innerHTML);</span></span><br><span class="line"><span class="comment">//div标签中替换一个文本输入框</span></span><br><span class="line">div.innerHTML = <span class="string">"&lt;input type='text'&gt;"</span>;</span><br><span class="line"><span class="comment">//div标签中追加一个文本输入框</span></span><br><span class="line">div.innerHTML += <span class="string">"&lt;input type='text'&gt;"</span>;</span><br></pre></td></tr></table></figure>
<pre><code>    2. 使用html元素对象的属性
    3. 控制元素样式
        1. 使用元素的style属性来设置
            如：
                 //修改样式方式1
                div1.style.border = &quot;1px solid red&quot;;
                div1.style.width = &quot;200px&quot;;
                //font-size--&gt; fontSize
                div1.style.fontSize = &quot;20px&quot;;
        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。
</code></pre><h1 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h1><h2 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h2><pre><code>某些组件被执行了某些操作后，触发某些代码的执行。

    * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了
    * 事件源：组件。如： 按钮 文本输入框...
    * 监听器：代码。
    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。
</code></pre><h2 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h2><pre><code>            1. 点击事件：
                1. onclick：单击事件
                2. ondblclick：双击事件
            2. 焦点事件
                1. onblur：失去焦点。
                    * 一般用于表单验证
                2. onfocus:元素获得焦点。

            3. 加载事件：
                1. onload：一张页面或一幅图像完成加载。

            4. 鼠标事件：
                1. onmousedown    鼠标按钮被按下。
                    * 定义方法时，定义一个形参，接受event对象。
                    * event对象的button属性可以获取鼠标按钮键被点击了。
                2. onmouseup    鼠标按键被松开。
                3. onmousemove    鼠标被移动。
                4. onmouseover    鼠标移到某元素之上。
                5. onmouseout    鼠标从某元素移开。
</code></pre><p>​    </p>
<pre><code>            5. 键盘事件：
                1. onkeydown    某个键盘按键被按下。
                2. onkeyup        某个键盘按键被松开。
                3. onkeypress    某个键盘按键被按下并松开。

            6. 选择和改变
                1. onchange    域的内容被改变。
                2. onselect    文本被选中。

            7. 表单事件：
                1. onsubmit    确认按钮被点击。
                    * 可以阻止表单的提交
                        * 方法返回false则表单被阻止提交。
                2. onreset    重置按钮被点击。
</code></pre>]]></content>
      <categories>
        <category>web</category>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title>http 和 request</title>
    <url>/2020/07/30/http/</url>
    <content><![CDATA[<h1 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Hyper Text Transfer Protocol 超文本传输协议</p>
<pre><code>    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式
    * 特点：
        1. 基于TCP/IP的高级协议
        2. 默认端口号:80
        3. 基于请求/响应模型的:一次请求对应一次响应
        4. 无状态的：每次请求之间相互独立，不能交互数据

    * 历史版本：
        * 1.0：每一次请求响应都会建立新的连接
        * 1.1：复用连接,对缓存的支持
</code></pre><a id="more"></a>
<h2 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h2><pre><code>    1. 请求行
        请求方式 请求url 请求协议/版本
        GET /login.html    HTTP/1.1

        * 请求方式：
            * HTTP协议有7中请求方式，常用的有2种
                * GET：
                    1. 请求参数在请求行中，在url后。
                    2. 请求的url长度有限制的
                    3. 不太安全
                * POST：
                    1. 请求参数在请求体中
                    2. 请求的url长度没有限制的
                    3. 相对安全
    2. 请求头：客户端浏览器告诉服务器一些信息
        请求头名称: 请求头值
        * 常见的请求头：
            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题

            2. Referer：http://localhost/login.html
                * 告诉服务器，我(当前请求)从哪里来？
                    * 作用：
                        1. 防盗链：
</code></pre><p><img src="http/image-20200730085104422.png" alt="image-20200730085104422"></p>
<pre><code>                        2. 统计工作：
    3. 请求空行
        空行，就是用于分割POST请求的请求头，和请求体的。
    4. 请求体(正文)：
        * 封装POST请求消息的请求参数的

    * 字符串格式：
        POST /login.html    HTTP/1.1
        Host: localhost
        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
        Accept-Encoding: gzip, deflate
        Referer: http://localhost/login.html
        Connection: keep-alive
        Upgrade-Insecure-Requests: 1

        username=zhangsan    


* 响应消息数据格式
</code></pre><h1 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h1><h2 id="一-request对象和response对象的原理"><a href="#一-request对象和response对象的原理" class="headerlink" title="一. request对象和response对象的原理"></a>一. request对象和response对象的原理</h2><pre><code>    1. request和response对象是由服务器创建的。我们来使用它们
    2. request对象是来获取请求消息，response对象是来设置响应消息
</code></pre><p><img src="http/image-20200730090455727.png" alt="image-20200730090455727"></p>
<h2 id="二-request对象继承体系结构："><a href="#二-request对象继承体系结构：" class="headerlink" title="二. request对象继承体系结构："></a>二. request对象继承体系结构：</h2><pre><code>    ServletRequest        --    接口
        |    继承
    HttpServletRequest    -- 接口
        |    实现
    org.apache.catalina.connector.RequestFacade 类(tomcat)
</code></pre><h2 id="三-request功能："><a href="#三-request功能：" class="headerlink" title="三. request功能："></a>三. request功能：</h2><h3 id="1-获取请求消息数据"><a href="#1-获取请求消息数据" class="headerlink" title="1. 获取请求消息数据"></a>1. 获取请求消息数据</h3><h4 id="（1）-获取请求行数据"><a href="#（1）-获取请求行数据" class="headerlink" title="（1） 获取请求行数据"></a>（1） 获取请求行数据</h4><pre><code>            * GET /day14/demo1?name=zhangsan HTTP/1.1
            * 方法：
                1. 获取请求方式 ：GET
                    * String getMethod()  
                2. (*)获取虚拟目录：/day14
                    * String getContextPath()
                3. 获取Servlet路径: /demo1
                    * String getServletPath()
                4. 获取get方式请求参数：name=zhangsan
                    * String getQueryString()
                5. (*)获取请求URI：/day14/demo1
                    * String getRequestURI():        /day14/demo1
                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1

                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国
                    * URI：统一资源标识符 : /day14/demo1                    共和国

                6. 获取协议及版本：HTTP/1.1
                    * String getProtocol()

                7. 获取客户机的IP地址：
                    * String getRemoteAddr()
</code></pre><p><strong>演示</strong>：获取请求行数据</p>
<p>在新建文件时可以选择：<code>create new servlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zenner.web.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Request对象获取请求行数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/requestDemo1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 获取请求方式 ：GET</span></span><br><span class="line"><span class="comment">                * String getMethod()</span></span><br><span class="line"><span class="comment">            2. (*)获取虚拟目录：/day14</span></span><br><span class="line"><span class="comment">                * String getContextPath()</span></span><br><span class="line"><span class="comment">            3. 获取Servlet路径: /requestDemo1</span></span><br><span class="line"><span class="comment">                * String getServletPath()</span></span><br><span class="line"><span class="comment">            4. 获取get方式请求参数：name=zhangsan</span></span><br><span class="line"><span class="comment">                * String getQueryString()</span></span><br><span class="line"><span class="comment">            5. (*)获取请求URI：/day14/demo1</span></span><br><span class="line"><span class="comment">                * String getRequestURI():		/day14/requestDemo1</span></span><br><span class="line"><span class="comment">                * StringBuffer getRequestURL()  :http://localhost/day14/requestDemo1</span></span><br><span class="line"><span class="comment">            6. 获取协议及版本：HTTP/1.1</span></span><br><span class="line"><span class="comment">                * String getProtocol()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            7. 获取客户机的IP地址：</span></span><br><span class="line"><span class="comment">                * String getRemoteAddr()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1. 获取请求方式 ：GET</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        <span class="comment">//2.(*)获取虚拟目录：/day14</span></span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        <span class="comment">//3. 获取Servlet路径: /demo1</span></span><br><span class="line">        String servletPath = request.getServletPath();</span><br><span class="line">        System.out.println(servletPath);</span><br><span class="line">        <span class="comment">//4. 获取get方式请求参数：name=zhangsan</span></span><br><span class="line">        String queryString = request.getQueryString();</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">        <span class="comment">//5.(*)获取请求URI：/day14/demo1</span></span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        StringBuffer requestURL = request.getRequestURL();</span><br><span class="line">        System.out.println(requestURI);</span><br><span class="line">        System.out.println(requestURL);</span><br><span class="line">        <span class="comment">//6. 获取协议及版本：HTTP/1.1</span></span><br><span class="line">        String protocol = request.getProtocol();</span><br><span class="line">        System.out.println(protocol);</span><br><span class="line">        <span class="comment">//7. 获取客户机的IP地址：</span></span><br><span class="line">        String remoteAddr = request.getRemoteAddr();</span><br><span class="line">        System.out.println(remoteAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）-获取请求头数据"><a href="#（2）-获取请求头数据" class="headerlink" title="（2） 获取请求头数据"></a>（2） 获取请求头数据</h4><pre><code>            * 方法：
                * (*)String getHeader(String name):通过请求头的名称获取请求头的值
                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称
</code></pre><h4 id="（3）-获取请求体数据"><a href="#（3）-获取请求体数据" class="headerlink" title="（3） 获取请求体数据:"></a>（3） 获取请求体数据:</h4><pre><code>            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
            * 步骤：
                1. 获取流对象
                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据
                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
                        * 在文件上传知识点后讲解

                2. 再从流对象中拿数据
</code></pre><p>​                </p>
<h3 id="2-其他功能："><a href="#2-其他功能：" class="headerlink" title="2. 其他功能："></a>2. 其他功能：</h3><h4 id="（1）-获取请求参数通用方式"><a href="#（1）-获取请求参数通用方式" class="headerlink" title="（1） 获取请求参数通用方式"></a>（1） 获取请求参数通用方式</h4><pre><code>            不论get还是post请求方式都可以使用下列方法来获取请求参数
            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123
            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game
                hobby可能有好几个，所以返回数组
            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称
            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合

            * 中文乱码问题：
                * get方式：tomcat 8 已经将get方式乱码问题解决了
                * post方式：会乱码
                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre><p>​                    </p>
<h4 id="（2）-请求转发：一种在服务器内部的资源跳转方式"><a href="#（2）-请求转发：一种在服务器内部的资源跳转方式" class="headerlink" title="（2） 请求转发：一种在服务器内部的资源跳转方式"></a>（2） 请求转发：一种在服务器内部的资源跳转方式</h4><p><img src="http/image-20200730153456924.png" alt="image-20200730153456924"></p>
<pre><code>            1. 步骤：
                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 

            2. 特点：
                1. 浏览器地址栏路径不发生变化
                2. 只能转发到当前服务器内部资源中。
                3. 转发是一次请求
</code></pre><h4 id="（3）-共享数据："><a href="#（3）-共享数据：" class="headerlink" title="（3） 共享数据："></a>（3） 共享数据：</h4><pre><code>            * 域对象：一个有作用范围的对象，可以在范围内共享数据
            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
            * 方法：
                1. void setAttribute(String name,Object obj):存储数据
                2. Object getAttitude(String name):通过键获取值
                3. void removeAttribute(String name):通过键移除键值对
</code></pre><h4 id="（4）-获取ServletContext："><a href="#（4）-获取ServletContext：" class="headerlink" title="（4） 获取ServletContext："></a>（4） 获取ServletContext：</h4><pre><code>            * ServletContext getServletContext()
</code></pre><h1 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h1><h2 id="一、-用户登录案例需求："><a href="#一、-用户登录案例需求：" class="headerlink" title="一、 用户登录案例需求："></a>一、 用户登录案例需求：</h2><pre><code>    1.编写login.html登录页面
        username &amp; password 两个输入框
    2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表
    3.使用JdbcTemplate技术封装JDBC
    4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您
    5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误


* 分析
</code></pre><h2 id="二、-开发步骤"><a href="#二、-开发步骤" class="headerlink" title="二、 开发步骤"></a>二、 开发步骤</h2><h3 id="1-创建项目，导入html页面，配置文件，jar包"><a href="#1-创建项目，导入html页面，配置文件，jar包" class="headerlink" title="1. 创建项目，导入html页面，配置文件，jar包"></a>1. 创建项目，导入html页面，配置文件，jar包</h3><h3 id="2-创建数据库环境"><a href="#2-创建数据库环境" class="headerlink" title="2. 创建数据库环境"></a>2. 创建数据库环境</h3><pre><code>        CREATE DATABASE day14;
        USE day14;
        CREATE TABLE USER(

            id INT PRIMARY KEY AUTO_INCREMENT,
            username VARCHAR(32) UNIQUE NOT NULL,
            PASSWORD VARCHAR(32) NOT NULL
        );
</code></pre><h3 id="3-创建包cn-itcast-domain-创建类User"><a href="#3-创建包cn-itcast-domain-创建类User" class="headerlink" title="3. 创建包cn.itcast.domain,创建类User"></a>3. 创建包cn.itcast.domain,创建类User</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 用户的实体类</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;			</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">            <span class="string">"id="</span> + id +</span><br><span class="line">            <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-创建包cn-itcast-util-编写工具类JDBCUtils"><a href="#4-创建包cn-itcast-util-编写工具类JDBCUtils" class="headerlink" title="4. 创建包cn.itcast.util,编写工具类JDBCUtils"></a>4. 创建包cn.itcast.util,编写工具类JDBCUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * JDBC工具类 使用Durid连接池</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//使用ClassLoader加载配置文件，获取字节输入流</span></span><br><span class="line">            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");</span><br><span class="line">            pro.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.初始化连接池对象</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接池对象</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;		</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">			     * 获取连接Connection对象</span></span><br><span class="line"><span class="comment">			     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-创建包cn-itcast-dao-创建类UserDao-提供login方法"><a href="#5-创建包cn-itcast-dao-创建类UserDao-提供login方法" class="headerlink" title="5. 创建包cn.itcast.dao,创建类UserDao,提供login方法"></a>5. 创建包cn.itcast.dao,创建类UserDao,提供login方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.util.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作数据库中User表的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明JDBCTemplate对象共用</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginUser 只有用户名和密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user包含用户全部数据,没有查询到，返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User loginUser)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.编写sql</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username = ? and password = ?"</span>;</span><br><span class="line">            <span class="comment">//2.调用query方法</span></span><br><span class="line">            User user = template.queryForObject(sql,</span><br><span class="line">                    <span class="keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">                    <span class="title">loginUser</span>.<span class="title">getUsername</span>(), <span class="title">loginUser</span>.<span class="title">getPassword</span>())</span>;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();<span class="comment">//记录日志</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-编写cn-itcast-web-servlet-LoginServlet类"><a href="#6-编写cn-itcast-web-servlet-LoginServlet类" class="headerlink" title="6. 编写cn.itcast.web.servlet.LoginServlet类"></a>6. 编写cn.itcast.web.servlet.LoginServlet类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/loginServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//2.获取请求参数</span></span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        <span class="comment">//3.封装user对象</span></span><br><span class="line">        User loginUser = <span class="keyword">new</span> User();</span><br><span class="line">        loginUser.setUsername(username);</span><br><span class="line">        loginUser.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.调用UserDao的login方法</span></span><br><span class="line">        UserDao dao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        User user = dao.login(loginUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断user</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//登录失败</span></span><br><span class="line">            req.getRequestDispatcher(<span class="string">"/failServlet"</span>).forward(req,resp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            <span class="comment">//存储数据</span></span><br><span class="line">            req.setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">            <span class="comment">//转发</span></span><br><span class="line">            req.getRequestDispatcher(<span class="string">"/successServlet"</span>).forward(req,resp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-编写FailServlet和SuccessServlet类"><a href="#7-编写FailServlet和SuccessServlet类" class="headerlink" title="7. 编写FailServlet和SuccessServlet类"></a>7. 编写FailServlet和SuccessServlet类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/successServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取request域中共享的user对象</span></span><br><span class="line">        User user = (User) request.getAttribute(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//给页面写一句话</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置编码</span></span><br><span class="line">            response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            response.getWriter().write(<span class="string">"登录成功！"</span>+user.getUsername()+<span class="string">",欢迎您"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ​			</span><br><span class="line"></span><br><span class="line">    &#125;		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@WebServlet</span>(<span class="string">"/failServlet"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            <span class="comment">//给页面写一句话</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置编码</span></span><br><span class="line">            response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            response.getWriter().write(<span class="string">"登录失败，用户名或密码错误"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-login-html中form表单的action路径的写法"><a href="#8-login-html中form表单的action路径的写法" class="headerlink" title="8. login.html中form表单的action路径的写法"></a>8. login.html中form表单的action路径的写法</h3><pre><code>        * 虚拟目录+Servlet的资源路径
</code></pre><h3 id="9-BeanUtils工具类，简化数据封装"><a href="#9-BeanUtils工具类，简化数据封装" class="headerlink" title="9. BeanUtils工具类，简化数据封装"></a>9. BeanUtils工具类，简化数据封装</h3><pre><code>        * 用于封装JavaBean的
        1. JavaBean：标准的Java类
            1. 要求：
                1. 类必须被public修饰
                2. 必须提供空参的构造器
                3. 成员变量必须使用private修饰
                4. 提供公共setter和getter方法
            2. 功能：封装数据


        2. 概念：
            成员变量：
            属性：setter和getter方法截取后的产物
                例如：getUsername() --&gt; Username--&gt; username


        3. 方法：
                # 这两个方法是按照setter和getter方法名上的name来进行设置。
            1. setProperty()
            2. getProperty()
            3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中
</code></pre>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 42. 接雨水</title>
    <url>/2020/07/26/leetcode-0042/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h4><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/2020/07/26/leetcode-0042/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        首先这个题目让我想起了之前做过的一些题目的感觉</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        好像是股票那个题目。  求得收益</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        分析这个题目：首先是要接水。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            思路：</span></span><br><span class="line"><span class="string">                    事实上要是有两个最高的柱子，就可以支起一个水池子。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    但是在遍历过程中一般都是走到这山望得那山高这个山柱子担当水柱子，在下一个池子里也可以担当水池子。</span></span><br><span class="line"><span class="string">                    但是，一旦在后面遇到了一个更高的山可能就把这个山头给淹没了。</span></span><br><span class="line"><span class="string">                    这里计算得到的结果就没用了。</span></span><br><span class="line"><span class="string">                        所以用一个列表把这些水柱子的位置都记住。然后计算了盛的水后，可以把它给填了。</span></span><br><span class="line"><span class="string">                        在后面遇到更高的山时就不会计算两边</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            也想到可以用栈来实现：</span></span><br><span class="line"><span class="string">                如果要入栈的柱子比栈顶高就出栈：</span></span><br><span class="line"><span class="string">                    如果碰到栈底则直接弹出把当前要入栈的入栈就好了。</span></span><br><span class="line"><span class="string">                    出栈一次后，如果此时栈顶与之前栈顶相等接着出栈</span></span><br><span class="line"><span class="string">                    如果（此时栈顶大于之前栈顶）并且（此时栈顶小于等于要入栈的柱子）就在接的雨水值加上 ：</span></span><br><span class="line"><span class="string">                        （此时栈顶- 之前栈顶）*他们的距离，然后出栈，再把要入栈的入栈</span></span><br><span class="line"><span class="string">                    如果（此时栈顶大于之前栈顶）并且（此时栈顶大于要入栈的柱子）就在接的雨水值加上 ：</span></span><br><span class="line"><span class="string">                        （要入栈的柱子-之前栈顶）*他们的距离，然后要入栈的入栈</span></span><br><span class="line"><span class="string">                    直到可以蓄水也就是比中间的值大一点（入栈是非递增的:增减+持续相等）</span></span><br><span class="line"><span class="string">                如果比栈顶低或者等于栈底就入栈</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="comment"># 在栈中保存的是柱子的索引</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span>     <span class="comment"># 储存的水量</span></span><br><span class="line">        flag = <span class="literal">True</span> <span class="comment"># 栈为空表示为真</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                stack.append(i)</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> height[i] &lt;= height[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> height[i] &gt; height[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    temp = stack[<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">while</span> height[stack[<span class="number">-1</span>]] == height[temp]:</span><br><span class="line">                        print(temp)</span><br><span class="line">                        temp = stack.pop()</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> stack:   <span class="comment"># 到栈底了  （因为已经出来了一个了，此时也很有可能为空的）</span></span><br><span class="line">                            <span class="comment"># 这时也就是要进来的这个水柱在之前是无法储水的</span></span><br><span class="line">                            flag = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 直到栈顶和之前出栈的不相等时,计算中间能存多少水</span></span><br><span class="line">                    <span class="comment"># 此时有两种情况：</span></span><br><span class="line">                    <span class="comment">#       1. 栈空了</span></span><br><span class="line">                    <span class="comment">#       2. 值更大了。</span></span><br><span class="line">                    <span class="comment">#           a. 此时栈顶小于等于要入栈的柱子</span></span><br><span class="line">                    <span class="comment">#           b. 此时栈顶大于要入栈的柱子</span></span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> height[stack[<span class="number">-1</span>]] &lt;= height[i]:</span><br><span class="line">                            res += (i - stack[<span class="number">-1</span>] <span class="number">-1</span>) * (height[stack[<span class="number">-1</span>]] - height[temp])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res += (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * (height[i] - height[temp])</span><br><span class="line">                stack.append(i)</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    flag = <span class="literal">False</span>;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.trap([<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_0064：最小路径和</title>
    <url>/2020/07/23/leetcode-0064/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 7</span><br><span class="line"></span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题是之前做过的一道。现在当时用了回溯法。但是这里只是求数字总和最小。所以回溯法还是有点浪费这里应该还是能用动态规划的。</p>
<p>看一下他要的是从左上到右下的路径的数字总和最小。也就是针对最后一格而言他只能从他的上面或者左边来。右下角的代价是确定的。只需要求得相对应的最小值就好了。这个应该是一个比较简单的动态规划问题了。</p>
<p>应该用一个<code>dp[m][n]</code>来保存中间结果。</p>
<p>从左上角出发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + (i!=<span class="number">0</span> ? dp[i-<span class="number">1</span>][<span class="number">0</span>]:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_0104</title>
    <url>/2020/07/28/leetcode-0104/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<p>返回它的最大深度 3 。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    	用来从数组中得到整个树的方法</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTreeFromList</span><span class="params">(self, L, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; len(L) <span class="keyword">and</span> L[index] != <span class="literal">None</span>:</span><br><span class="line">            root = TreeNode(L[index])</span><br><span class="line">            root.right = self.getTreeFromList(L, (index+<span class="number">1</span>)*<span class="number">2</span>)</span><br><span class="line">            root.left = self.getTreeFromList(L, (index+<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    	主要的方法，其实很简单</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.right),self.maxDepth(root.left))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    L = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    T = Tree()</span><br><span class="line">    root = T.getTreeFromList(L,<span class="number">0</span>)</span><br><span class="line">    print(root)</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.maxDepth(root))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>每日一题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-0209:长度最小的子数组</title>
    <url>/2020/07/22/leetcode-0209/</url>
    <content><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><h2 id="leetcode-0209-长度最小的子数组"><a href="#leetcode-0209-长度最小的子数组" class="headerlink" title="leetcode-0209:长度最小的子数组"></a>leetcode-0209:长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力法直接给整出来了。"><a href="#暴力法直接给整出来了。" class="headerlink" title="暴力法直接给整出来了。"></a>暴力法直接给整出来了。</h2><p>明天想想别的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution0209</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 题目：209. 长度最小的子数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *       给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 思考过程：</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *       因为这个数组因为是不确定的。要求的其中满足和大于等于s的连续子数组。所以这么说来直接的想法就是针对每个点都往前计算它刚好大于s的长度。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution0209 solution0209 = <span class="keyword">new</span> Solution0209();</span><br><span class="line">        System.out.println(solution0209.minSubArrayLen(<span class="number">7</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;));</span><br><span class="line">        System.out.println(solution0209.minSubArrayLen(<span class="number">4</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>&#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_length = nums.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 以这个节点向左边出发找刚好大于s的长度</span></span><br><span class="line">            cur_sum = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (cur_sum &gt;= s)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j&gt;-<span class="number">1</span>;j--)&#123;</span><br><span class="line">                cur_sum +=nums[j];</span><br><span class="line">                <span class="keyword">if</span> (cur_sum &gt;= s)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-j+<span class="number">1</span>&lt;min_length)&#123;</span><br><span class="line">                        min_length = i-j+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min_length == nums.length+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>这个方法也是刚开始也就能够想到的，其实和滑窗也是类似。</p>
<p>但是这里它写的更为巧妙地里外两个循环，分别控制left和right；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = nums.length+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; nums.length)&#123;</span><br><span class="line">        sum += nums[left++];</span><br><span class="line">        <span class="keyword">while</span> (sum&gt;=s)&#123;</span><br><span class="line">            min = Math.min(min, left - right);</span><br><span class="line">            sum -= nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == nums.length+<span class="number">1</span> ? -<span class="number">1</span>:min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>暴力法</tag>
        <tag>队列</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_0329 矩阵中的最长递增路径</title>
    <url>/2020/07/26/leetcode-0329/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># 设置一个矩阵 每个元素表示由该节点出发最远到别的地方的长度 先把初始值都为一个空字符串"；表示这个是没有被检测过的位置</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = len(matrix)</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="string">""</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这个函数用来得到一个元素点最远所能达到的距离。</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getDPElement</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="comment">#   1. 如果再dp矩阵中已经有了的就直接返回</span></span><br><span class="line">            <span class="comment">#   2. 如果没有的现场算一下</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] != <span class="string">""</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 此时矩阵中这个位置的值还没求出，想要外延展，则需要要那周围四个位置的值要大于（i，j）的值为前提才可以</span></span><br><span class="line">                D_x = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">                D_y = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">                res = <span class="number">0</span>     <span class="comment"># 用这个值获取周围有比它大的数字的最大长度。</span></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(D_x,D_y):</span><br><span class="line">                    <span class="comment"># 判断边界，再比较大小，同时满足后对邻居调用本函数</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (i+x &lt; <span class="number">0</span> <span class="keyword">or</span> i+x &gt;= m <span class="keyword">or</span> j+y &lt; <span class="number">0</span> <span class="keyword">or</span> j+y &gt;= n):</span><br><span class="line">                        <span class="keyword">if</span> matrix[i][j] &lt; matrix[i+x][j+y]:</span><br><span class="line">                            res = max(res, getDPElement(i+x,j+y))</span><br><span class="line"></span><br><span class="line">                dp[i][j] = res + <span class="number">1</span>  <span class="comment">#    此时包括了该位置</span></span><br><span class="line">                <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 主函数里调用</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                temp = getDPElement(i,j)</span><br><span class="line">                <span class="keyword">if</span> res &lt; temp:</span><br><span class="line">                    res = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nums_1 =[</span><br><span class="line">    [<span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line">    nums_2 =[</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br><span class="line">    a = Solution()</span><br><span class="line">    print(a.longestIncreasingPath(nums_1))</span><br><span class="line">    print(a.longestIncreasingPath(nums_2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
        <category>困难</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_0392</title>
    <url>/2020/07/27/leetcode-0392/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br></pre></td></tr></table></figure>
<p>返回 true.</p>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br></pre></td></tr></table></figure>
<p>返回 false.</p>
<a id="more"></a>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = len(t)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>官方题解里给出了一个动态规划的解法。</p>
<p><strong>思路</strong>：</p>
<p>每个位置之后遇到26个小写字母的情况是如何的？</p>
<p>位置是<code>0 ~ m-1</code>​ ; 最后再加上一个全 m 的向量（26个小写字母）表示在 m  这个越界位置，遇到某个字母是不可能的。</p>
<p>那么对于 <code>m-1</code> 位置上的表示 <code>m-1</code>开始往后某个字母的位置，因为<code>m-1</code>  开始只有一个字母，其他的都不可能出现了，所以这一列只有有的那个字母表示为 <code>m-1</code>，其他的都是<code>m</code>；以此往前完成 $f[i][j]$ 最终得到一个转换表。</p>
<p>后来不论来什么字符串在第一个位置查，从第一个位置开始出现那这个字符串第一个字符的位置。所以这个方法虽然复杂了一点，但是完全适用于问题中的后续挑战。</p>
<p><strong>题解</strong>：</p>
<p><strong>思路及算法</strong></p>
<p>考虑前面的双指针的做法，我们注意到我们有大量的时间用于在 tt 中找到下一个匹配字符。</p>
<p>这样我们可以预处理出对于 tt 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。</p>
<p>我们可以使用动态规划的方法实现预处理，令 $f[i][j]$ 表示字符串 tt 中从位置 $i$ 开始往后字符 $j$ 第一次出现的位置。在进行状态转移时，如果 $t$ 中位置 $i$ 的字符就是 $j$，那么 $f[i][j]=if[i][j]=i$，否则 $j$ 出现在位置 i+1i+1 开始往后，即 $f[i][j]=f[i+1][j]$，因此我们要倒过来进行动态规划，从后往前枚举 $i$。</p>
<p>这样我们可以写出状态转移方程：</p>
<script type="math/tex; mode=display">
f[i][j]=\left\{
\begin{aligned}
i, &    &t[i]=j\\
f[i+1][j],& & t[i]\neq j\\
\end{aligned}
\right.</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        n, m = len(s), len(t)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        f.append([m] * <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                f[i][j] = i <span class="keyword">if</span> ord(t[i]) == j + ord(<span class="string">'a'</span>) <span class="keyword">else</span> f[i + <span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line">        add = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> f[add][ord(s[i]) - ord(<span class="string">'a'</span>)] == m:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            add = f[add][ord(s[i]) - ord(<span class="string">'a'</span>)] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
        <category>容易</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 410. 分割数组的最大值</title>
    <url>/2020/07/25/leetcode-0410/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">Split Array Largest Sum</a></p>
<p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p>
<p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p>
<ul>
<li>1 ≤ <em>n</em> ≤ 1000</li>
<li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li>
</ul>
<p><strong>示例:</strong></p>
<blockquote>
<p><strong>输入</strong>:<br>nums = [7,2,5,10,8]<br>m = 2</p>
<p><strong>输出</strong>:<br>18</p>
<p>解释:<br>一共有四种方法将<strong>nums</strong>分割为2个子数组。<br>其中最好的方式是将其分为<strong>[7,2,5]</strong> 和 <strong>[10,8]</strong>，<br>因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</p>
</blockquote>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/" target="_blank" rel="noopener">题解</a></h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>通过看答案看到了这样的动态规划转移公式：</p>
<script type="math/tex; mode=display">
f[i][j]=\min_{k = 0}^{i-1}\{\max(f[k][j−1],sub(k+1,i))\}</script><p>$f[i][j]$ 表示在前i个节点分为j个子数组时的最小值；要得到他就得是遍历 $0-i$ 中的所有情况；然而在 $ k &lt; j-1 $ 的情况下也就是k个节点不够 $j-1$ 个子数组分。这种情况下的值属于不可能的情况，一般给他一个很大的值。它给$min$提供了一个不可能的选项，所以不会选到它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        f = [[<span class="number">10</span>**<span class="number">18</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        sub = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> nums:</span><br><span class="line">            sub.append(sub[<span class="number">-1</span>] + elem)</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i, m) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i):</span><br><span class="line">                    f[i][j] = min(f[i][j], max(f[k][j<span class="number">-1</span>], sub[i] - sub[k]))</span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>这里想要找到一个值x，这个值是分成的cnt个子数组和的最大值，所以每一个子数组都不大于他。</p>
<p>我们先不管能分成几个子数组。就先用数组中的最大值x来卡，来把数组分开</p>
<script type="math/tex; mode=display">
A = [a_1, a_2, ... , a_3 ]</script><p>如果连续数组不大于x， 如果$n$个连续元素的和不大于x，那么他们就可以分到一个子数组中，如果再往后，$n+1$个元素之和大于x。那么从第$n+1$个元素分开，另放入一个子数组。由于最大值x在数组中前后加起来都一定大于x，所以他单独一个在一个子数组里。如果此时分成的子数组的数量大于所想要的m个子数组。那么我们就需要提高x的值，来使得子数组数量减少到刚好m。或者x值太高了，使得子数组的数量太少了。我们就需要减少x的值，使得子数组增多到m。之前这是贪心算法的思想。而后面调节x则可以用二分查找的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: List[int], m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(x: int)</span> -&gt; bool:</span></span><br><span class="line">            total, cnt = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> total + num &gt; x:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    total = num</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    total += num</span><br><span class="line">            <span class="keyword">return</span> cnt &lt;= m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        left = max(nums)</span><br><span class="line">        right = sum(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>动态规划</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>map</title>
    <url>/2020/07/14/map/</url>
    <content><![CDATA[<h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<p><img src="/2020/07/14/map/Collection与Map.bmp" alt></p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。<a id="more"></a></li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>
<ul>
<li><strong>HashMap<K,V></K,V></strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li><strong>LinkedHashMap<K,V></K,V></strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量<K,V>,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量<K,V>的数据类型可以相同，也可以不同。</K,V></K,V></p>
</blockquote>
<h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Map接口的方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Map&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">    Map集合的特点:</span></span><br><span class="line"><span class="comment">        1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value)</span></span><br><span class="line"><span class="comment">        2.Map集合中的元素,key和value的数据类型可以相同,也可以不同</span></span><br><span class="line"><span class="comment">        3.Map集合中的元素,key是不允许重复的,value是可以重复的</span></span><br><span class="line"><span class="comment">        4.Map集合中的元素,key和value是一一对应</span></span><br><span class="line"><span class="comment">    java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口</span></span><br><span class="line"><span class="comment">    HashMap集合的特点:</span></span><br><span class="line"><span class="comment">        1.HashMap集合底层是哈希表:查询的速度特别的快</span></span><br><span class="line"><span class="comment">            JDK1.8之前:数组+单向链表</span></span><br><span class="line"><span class="comment">            JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度</span></span><br><span class="line"><span class="comment">        2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致</span></span><br><span class="line"><span class="comment">   java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">   LinkedHashMap的特点:</span></span><br><span class="line"><span class="comment">        1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)</span></span><br><span class="line"><span class="comment">        2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Demo01Map</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show04();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        boolean containsKey(Object key) 判断集合中是否包含指定的键。</span></span><br><span class="line"><span class="comment">        包含返回true,不包含返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b1 = map.containsKey(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1:"</span>+b1);<span class="comment">//b1:true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = map.containsKey(<span class="string">"赵颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2:"</span>+b2);<span class="comment">//b2:false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</span></span><br><span class="line"><span class="comment">            返回值:</span></span><br><span class="line"><span class="comment">                key存在,返回对应的value值</span></span><br><span class="line"><span class="comment">                key不存在,返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        Integer v1 = map.get(<span class="string">"杨颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:165</span></span><br><span class="line"></span><br><span class="line">        Integer v2 = map.get(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:null</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></span><br><span class="line"><span class="comment">            返回值:V</span></span><br><span class="line"><span class="comment">                key存在,v返回被删除的值</span></span><br><span class="line"><span class="comment">                key不存在,v返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        Integer v1 = map.remove(<span class="string">"林志玲"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:178</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//int v2 = map.remove("林志颖");//自动拆箱：可能发生  NullPointerException</span></span><br><span class="line">        Integer v2 = map.remove(<span class="string">"林志颖"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;赵丽颖=168, 杨颖=165&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public V put(K key, V value):  把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="comment">            返回值:v</span></span><br><span class="line"><span class="comment">                存储键值对的时候,key不重复,返回值V是null</span></span><br><span class="line"><span class="comment">                存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象,多态</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String v1 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span>+v1);<span class="comment">//v1:null</span></span><br><span class="line"></span><br><span class="line">        String v2 = map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"v2:"</span>+v2);<span class="comment">//v2:范冰冰1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;李晨=范冰冰2&#125;</span></span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"冷锋"</span>,<span class="string">"龙小云"</span>);</span><br><span class="line">        map.put(<span class="string">"杨过"</span>,<span class="string">"小龙女"</span>);</span><br><span class="line">        map.put(<span class="string">"尹志平"</span>,<span class="string">"小龙女"</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h2 id="1-4-Map集合遍历键找值方式-（keyset方法）"><a href="#1-4-Map集合遍历键找值方式-（keyset方法）" class="headerlink" title="1.4   Map集合遍历键找值方式 （keyset方法）"></a>1.4   Map集合遍历键找值方式 （keyset方法）</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map集合的第一种遍历方式:通过键找值的方式</span></span><br><span class="line"><span class="comment">    Map集合中的方法:</span></span><br><span class="line"><span class="comment">         Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历set集合,获取Map集合中的每一个key</span></span><br><span class="line"><span class="comment">        3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02KeySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历set集合,获取Map集合中的每一个key</span></span><br><span class="line">        <span class="comment">//使用迭代器遍历Set集合</span></span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            String key = it.next();</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String key : set)&#123;</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历Set集合</span></span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="comment">//3.通过Map集合中的方法get(key),通过key找到value</span></span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历图解：</p>
<p><img src="/2020/07/14/map/Map集合遍历方式一.bmp" alt></p>
<h2 id="1-5-Entry键值对对象-（entrySet方法）"><a href="#1-5-Entry键值对对象-（entrySet方法）" class="headerlink" title="1.5  Entry键值对对象 （entrySet方法）"></a>1.5  Entry键值对对象 （entrySet方法）</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map集合遍历的第二种方式:使用Entry对象遍历</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Map集合中的方法:</span></span><br><span class="line"><span class="comment">        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中</span></span><br><span class="line"><span class="comment">        2.遍历Set集合,获取每一个Entry对象</span></span><br><span class="line"><span class="comment">        3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03EntrySet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"赵丽颖"</span>,<span class="number">168</span>);</span><br><span class="line">        map.put(<span class="string">"杨颖"</span>,<span class="number">165</span>);</span><br><span class="line">        map.put(<span class="string">"林志玲"</span>,<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历Set集合,获取每一个Entry对象</span></span><br><span class="line">        <span class="comment">//使用迭代器遍历Set集合</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">            <span class="comment">//3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:set)&#123;</span><br><span class="line">            <span class="comment">//3.使用Entry对象中的方法getKey()和getValue()获取键与值</span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"="</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历图解：</p>
<p><img src="/2020/07/14/map/Map集合遍历方式二.bmp" alt></p>
<blockquote>
<p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p>
<blockquote>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
</blockquote>
<p>编写学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">    Map集合保证key是唯一的:</span></span><br><span class="line"><span class="comment">        作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01HashMapSavePerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">        key:Person类型</span></span><br><span class="line"><span class="comment">            Person类就必须重写hashCode方法和equals方法,以保证key唯一</span></span><br><span class="line"><span class="comment">        value:String类型</span></span><br><span class="line"><span class="comment">            可以重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建HashMap集合</span></span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//往集合中添加元素</span></span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"英国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"秦始皇"</span>,<span class="number">18</span>),<span class="string">"秦国"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"普京"</span>,<span class="number">30</span>),<span class="string">"俄罗斯"</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">"女王"</span>,<span class="number">18</span>),<span class="string">"毛里求斯"</span>);</span><br><span class="line">        <span class="comment">//使用entrySet和增强for遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Person, String&gt; entry : set) &#123;</span><br><span class="line">            Person key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">"--&gt;"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">        key:String类型</span></span><br><span class="line"><span class="comment">            String类重写hashCode方法和equals方法,可以保证key唯一</span></span><br><span class="line"><span class="comment">        value:Person类型</span></span><br><span class="line"><span class="comment">            value可以重复(同名同年龄的人视为同一个)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建HashMap集合</span></span><br><span class="line">        HashMap&lt;String,Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//往集合中添加元素</span></span><br><span class="line">        map.put(<span class="string">"北京"</span>,<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">"上海"</span>,<span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">19</span>));</span><br><span class="line">        map.put(<span class="string">"广州"</span>,<span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">20</span>));</span><br><span class="line">        map.put(<span class="string">"北京"</span>,<span class="keyword">new</span> Person(<span class="string">"赵六"</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//使用keySet加增强for遍历Map集合</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            Person value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"--&gt;"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo03.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt;</span></span><br><span class="line"><span class="comment">    Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。</span></span><br><span class="line"><span class="comment">    底层原理:</span></span><br><span class="line"><span class="comment">        哈希表+链表(记录元素的顺序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">// key不允许重复,无序 &#123;a=d, b=b, c=c&#125;</span></span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String,String&gt; linked = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"a"</span>);</span><br><span class="line">        linked.put(<span class="string">"c"</span>,<span class="string">"c"</span>);</span><br><span class="line">        linked.put(<span class="string">"b"</span>,<span class="string">"b"</span>);</span><br><span class="line">        linked.put(<span class="string">"a"</span>,<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(linked);<span class="comment">// key不允许重复,有序 &#123;a=d, c=c, b=b&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;a&#x3D;d, b&#x3D;b, c&#x3D;c&#125;</span><br><span class="line">&#123;a&#x3D;d, c&#x3D;c, b&#x3D;b&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-9-HashTable"><a href="#1-9-HashTable" class="headerlink" title="1.9 HashTable"></a>1.9 HashTable</h2><p>实现一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用作键或值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo03.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢</span></span><br><span class="line"><span class="comment">    HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    HashMap集合(之前学的所有的集合):可以存储null值,null键</span></span><br><span class="line"><span class="comment">    Hashtable集合,不能存储null值,null键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了</span></span><br><span class="line"><span class="comment">    Hashtable的子类Properties依然活跃在历史舞台</span></span><br><span class="line"><span class="comment">    Properties集合是一个唯一和IO流相结合的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Hashtable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;null=null, b=null&#125;</span></span><br><span class="line"></span><br><span class="line">        Hashtable&lt;String,String&gt; table = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line">        <span class="comment">//table.put(null,"a");//NullPointerException</span></span><br><span class="line">        <span class="comment">//table.put("b",null);//NullPointerException</span></span><br><span class="line">        table.put(<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//NullPointerException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-10-Map集合练习"><a href="#1-10-Map集合练习" class="headerlink" title="1.10 Map集合练习"></a>1.10 Map集合练习</h2><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，键代表字符，值代表次数。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">"请录入一个字符串:"</span>);</span><br><span class="line">        String line = <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findChar</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                Integer count = map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"def"</span>);</span><br><span class="line">        list.add(<span class="string">"ghi"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);  </span><br><span class="line">        <span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意以下两点：</p>
<blockquote>
<p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p>
<p>2:返回的集合是不可变的；</p>
</blockquote>
<h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Debug调试程序:</span></span><br><span class="line"><span class="comment">        可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug</span></span><br><span class="line"><span class="comment">    使用方式:</span></span><br><span class="line"><span class="comment">        在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里)</span></span><br><span class="line"><span class="comment">        右键,选择Debug执行程序</span></span><br><span class="line"><span class="comment">        程序就会停留在添加的第一个断点处</span></span><br><span class="line"><span class="comment">    执行程序:</span></span><br><span class="line"><span class="comment">        f8:逐行执行程序</span></span><br><span class="line"><span class="comment">        f7:进入到方法中</span></span><br><span class="line"><span class="comment">        shift+f8:跳出方法</span></span><br><span class="line"><span class="comment">        f9:跳到下一个断点,如果没有下一个断点,那么就结束程序</span></span><br><span class="line"><span class="comment">        ctrl+f2:退出debug模式,停止程序</span></span><br><span class="line"><span class="comment">        Console:切换到控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Debug</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">        int b = 20;</span></span><br><span class="line"><span class="comment">        int sum = a + b;</span></span><br><span class="line"><span class="comment">        System.out.println(sum);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt;3 ; i++) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(i);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p>
<p>   <img src="/2020/07/14/map/debug1.png" alt></p>
</li>
<li><p>点击Debug运行模式       <img src="/2020/07/14/map/debug2.png" alt>                                                                                                                                                                      </p>
</li>
<li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p>
<p> <img src="/2020/07/14/map/debug3.png" alt><img src="/2020/07/14/map/debug4.png" alt></p>
</li>
<li><p>Debug调试窗口介绍</p>
<p> <img src="/2020/07/14/map/debug5.png" alt></p>
</li>
<li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p>
<p><img src="/2020/07/14/map/debug6.png" alt></p>
</li>
<li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p>
<p><img src="/2020/07/14/map/debug7.png" alt></p>
</li>
<li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p>
<p><img src="/2020/07/14/map/debug8.png" alt></p>
<p>回车之后效果：<img src="/2020/07/14/map/debug9.png" alt></p>
<p>调试界面效果：<img src="/2020/07/14/map/debug0.png" alt></p>
</li>
<li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p>
<p><img src="/2020/07/14/map/debug11.png" alt></p>
</li>
<li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p>
<p><img src="/2020/07/14/map/debug12.png" alt></p>
</li>
<li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p>
<p><img src="/2020/07/14/map/debug13.png" alt></p>
</li>
<li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p>
<p><img src="/2020/07/14/map/debug14.png" alt></p>
</li>
<li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p>
<p><img src="/2020/07/14/map/debug15.png" alt></p>
</li>
<li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p>
<p><img src="/2020/07/14/map/debug16.png" alt></p>
</li>
<li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p>
<p><img src="/2020/07/14/map/debug17.png" alt></p>
</li>
</ol>
<h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p>
<p><img src="/2020/07/14/map/斗地主.png" alt></p>
<p>具体规则：</p>
<ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><p><img src="/2020/07/14/map/image-20200715095605335.png" alt="image-20200715095605335"></p>
<ol>
<li>准备牌：</li>
</ol>
<p>完成数字与纸牌的映射关系：</p>
<p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol>
<li>洗牌：</li>
</ol>
<p>通过数字完成洗牌发牌</p>
<ol>
<li>发牌：</li>
</ol>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</String></p>
<p>存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol>
<li>看牌：</li>
</ol>
<p>通过Map集合找到对应字符展示。</p>
<p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
<p><img src="/2020/07/14/map/斗地主分析.png" alt></p>
<h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1组装54张扑克牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.1 创建Map集合存储</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pokerMap = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 1.2 创建 花色集合 与 数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 存储 花色 与数字</span></span><br><span class="line">        Collections.addAll(colors, <span class="string">"♦"</span>, <span class="string">"♣"</span>, <span class="string">"♥"</span>, <span class="string">"♠"</span>);</span><br><span class="line">        Collections.addAll(numbers, <span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 设置 存储编号变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        pokerMap.put(count++, <span class="string">"大王"</span>);</span><br><span class="line">        pokerMap.put(count++, <span class="string">"小王"</span>);</span><br><span class="line">        <span class="comment">// 1.4 创建牌 存储到map集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                String card = color + number;</span><br><span class="line">                pokerMap.put(count++, card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2 将54张牌顺序打乱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 取出编号 集合</span></span><br><span class="line">        Set&lt;Integer&gt; numberSet = pokerMap.keySet();</span><br><span class="line">        <span class="comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span></span><br><span class="line">        ArrayList&lt;Integer&gt; numberList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        numberList.addAll(numberSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打乱顺序</span></span><br><span class="line">        Collections.shuffle(numberList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span></span><br><span class="line">        <span class="comment">// 3.1 发牌的编号</span></span><br><span class="line">        <span class="comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; noP1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipaiNo = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2发牌的编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取该编号</span></span><br><span class="line">            Integer no = numberList.get(i);</span><br><span class="line">            <span class="comment">// 发牌</span></span><br><span class="line">            <span class="comment">// 留出底牌</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipaiNo.add(no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    noP1.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    noP2.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    noP3.add(no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span></span><br><span class="line">        <span class="comment">// 4.1 对手中编号进行排序</span></span><br><span class="line">        Collections.sort(noP1);</span><br><span class="line">        Collections.sort(noP2);</span><br><span class="line">        Collections.sort(noP3);</span><br><span class="line">        Collections.sort(dipaiNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 进行牌面的转换</span></span><br><span class="line">        <span class="comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3转换</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP1) &#123;</span><br><span class="line">            <span class="comment">// 4.4 根据编号找到 牌面 pokerMap</span></span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            <span class="comment">// 添加到对应的 牌面集合中</span></span><br><span class="line">            player1.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP2) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player2.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP3) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player3.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : dipaiNo) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            dipai.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.5 查看</span></span><br><span class="line">        System.out.println(<span class="string">"令狐冲："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"石破天："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"鸠摩智："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"底牌："</span>+dipai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    斗地主综合案例:有序版本</span></span><br><span class="line"><span class="comment">    1.准备牌</span></span><br><span class="line"><span class="comment">    2.洗牌</span></span><br><span class="line"><span class="comment">    3.发牌</span></span><br><span class="line"><span class="comment">    4.排序</span></span><br><span class="line"><span class="comment">    5.看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备牌</span></span><br><span class="line">        <span class="comment">//创建一个Map集合,存储牌的索引和组装好的牌</span></span><br><span class="line">        HashMap&lt;Integer,String&gt; poker = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建一个List集合,存储牌的索引</span></span><br><span class="line">        ArrayList&lt;Integer&gt; pokerIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义两个集合,存储花色和牌的序号</span></span><br><span class="line">        List&lt;String&gt; colors = List.of(<span class="string">"♠"</span>, <span class="string">"♥"</span>, <span class="string">"♣"</span>, <span class="string">"♦"</span>);</span><br><span class="line">        List&lt;String&gt; numbers = List.of(<span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">//把大王和小王存储到集合中</span></span><br><span class="line">        <span class="comment">//定义一个牌的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        poker.put(index,<span class="string">"大王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        poker.put(index,<span class="string">"小王"</span>);</span><br><span class="line">        pokerIndex.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//循环嵌套遍历两个集合,组装52张牌,存储到集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                poker.put(index,color+number);</span><br><span class="line">                pokerIndex.add(index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(poker);</span></span><br><span class="line">        <span class="comment">//System.out.println(pokerIndex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2.洗牌</span></span><br><span class="line"><span class="comment">            使用Collections中的方法shuffle(List)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.shuffle(pokerIndex);</span><br><span class="line">        <span class="comment">//System.out.println(pokerIndex);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3.发牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//定义4个集合,存储玩家牌的索引,和底牌的索引</span></span><br><span class="line">        ArrayList&lt;Integer&gt; player01 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player02 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; player03 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; diPai = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历存储牌索引的List集合,获取每一个牌的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;pokerIndex.size() ; i++) &#123;</span><br><span class="line">            Integer in = pokerIndex.get(i);</span><br><span class="line">            <span class="comment">//先判断底牌</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;</span><br><span class="line">                <span class="comment">//给底牌发牌</span></span><br><span class="line">                diPai.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家1发牌</span></span><br><span class="line">                player01.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家2发牌</span></span><br><span class="line">                player02.add(in);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//给玩家3发牌</span></span><br><span class="line">                player03.add(in);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            4.排序</span></span><br><span class="line"><span class="comment">            使用Collections中的方法sort(List)</span></span><br><span class="line"><span class="comment">            默认是升序排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Collections.sort(player01);</span><br><span class="line">        Collections.sort(player02);</span><br><span class="line">        Collections.sort(player03);</span><br><span class="line">        Collections.sort(diPai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            5.看牌</span></span><br><span class="line"><span class="comment">            调用看牌的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lookPoker(<span class="string">"刘德华"</span>,poker,player01);</span><br><span class="line">        lookPoker(<span class="string">"周润发"</span>,poker,player02);</span><br><span class="line">        lookPoker(<span class="string">"周星驰"</span>,poker,player03);</span><br><span class="line">        lookPoker(<span class="string">"底牌"</span>,poker,diPai);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个看牌的方法,提高代码的复用性</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            String name:玩家名称</span></span><br><span class="line"><span class="comment">            HashMap&lt;Integer,String&gt; poker:存储牌的poker集合</span></span><br><span class="line"><span class="comment">            ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合</span></span><br><span class="line"><span class="comment">        查表法:</span></span><br><span class="line"><span class="comment">             遍历玩家或者底牌集合,获取牌的索引</span></span><br><span class="line"><span class="comment">             使用牌的索引,去Map集合中,找到对应的牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输出玩家名称,不换行</span></span><br><span class="line">        System.out.print(name+<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//遍历玩家或者底牌集合,获取牌的索引</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : list) &#123;</span><br><span class="line">            <span class="comment">//使用牌的索引,去Map集合中,找到对应的牌</span></span><br><span class="line">            String value = poker.get(key);</span><br><span class="line">            System.out.print(value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//打印完每一个玩家的牌,换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1025. 除数博弈</title>
    <url>/2020/07/24/leetcode-1025/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p>
<ul>
<li><p>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。</p>
</li>
<li><p>用 N - x 替换黑板上的数字 N 。</p>
</li>
</ul>
<p>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">    输入：2</span><br><span class="line">    输出：true</span><br><span class="line">    解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">    输入：3</span><br><span class="line">    输出：false</span><br><span class="line">    解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>貌似又是一个动态规划问题；</p>
<p>那么首先就要看N到底能被谁整除。把它减掉后，它又能被谁整除？他肯定还能被它减去的那个值整除。也就是记住中间值就可以。也可以用递归。</p>
<p>不论对爱丽丝而言还是对bob；只要形势一致，比如对他们都是3时那么他们都会输。所以他能赢还是有一定的依赖性的。</p>
<p>每个人的策略有减去一个除数后的值对对方而言是不是输；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Boolean&gt; dp = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        dp.put(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">        dp.put(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.containsKey(N))&#123;</span><br><span class="line">            <span class="keyword">return</span> dp.get(N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找可以整除N的数字（小于N）</span></span><br><span class="line">        ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=N/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (N % i == <span class="number">0</span>)&#123;</span><br><span class="line">                integers.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        Boolean res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object j:integers.toArray())&#123;</span><br><span class="line">            res = res || !divisorGame(N-(<span class="keyword">int</span>)j);</span><br><span class="line">        &#125;</span><br><span class="line">        dp.put(N,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql多表&amp;事务</title>
    <url>/2020/07/18/mysql-multiTable-transaction/</url>
    <content><![CDATA[<h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><h3 id="查询语法："><a href="#查询语法：" class="headerlink" title="查询语法："></a>查询语法：</h3><pre><code>select
    列名列表
from
    表名列表
where....
</code></pre><h3 id="准备sql"><a href="#准备sql" class="headerlink" title="准备sql"></a>准备sql</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);</span><br><span class="line"># 创建员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(10),</span><br><span class="line">	gender CHAR(1), -- 性别</span><br><span class="line">	salary DOUBLE, -- 工资</span><br><span class="line">	join_date DATE, -- 入职日期</span><br><span class="line">	dept_id INT,</span><br><span class="line">	FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)</span><br><span class="line">);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);</span><br></pre></td></tr></table></figure>
<h3 id="笛卡尔积："><a href="#笛卡尔积：" class="headerlink" title="笛卡尔积："></a>笛卡尔积：</h3><pre><code>* 有两个集合A,B .取这两个集合的所有组成情况。
* 要完成多表查询，需要消除无用的数据
</code></pre><h3 id="多表查询的分类："><a href="#多表查询的分类：" class="headerlink" title="多表查询的分类："></a>多表查询的分类：</h3><h4 id="1-内连接查询："><a href="#1-内连接查询：" class="headerlink" title="1. 内连接查询："></a>1. 内连接查询：</h4><pre><code>    1. 隐式内连接：使用where条件消除无用数据
        * 例子：
        -- 查询所有员工信息和对应的部门信息

        SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

        -- 查询员工表的名称，性别。部门表的名称
        SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;

        SELECT 
            t1.name, -- 员工表的姓名
            t1.gender,-- 员工表的性别
            t2.name -- 部门表的名称
        FROM
            emp t1,
            dept t2
        WHERE 
            t1.`dept_id` = t2.`id`;
        2. 显式内连接：
            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件
            * 例如：
                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;    
                * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;    

        3. 内连接查询：
            1. 从哪些表中查询数据
            2. 条件是什么
            3. 查询哪些字段
</code></pre><h4 id="2-外链接查询："><a href="#2-外链接查询：" class="headerlink" title="2. 外链接查询："></a>2. 外链接查询：</h4><pre><code>        1. 左外连接：
            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；
            * 查询的是左表所有数据以及其交集部分。
            * 例子：
                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称
                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;
        2. 右外连接：
            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；
            * 查询的是右表所有数据以及其交集部分。
            * 例子：
                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;
</code></pre><h4 id="3-子查询："><a href="#3-子查询：" class="headerlink" title="3. 子查询："></a>3. 子查询：</h4><h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>查询中嵌套查询，称嵌套查询为子查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询工资最高的员工信息</span><br><span class="line">-- 1 查询最高的工资是多少 9000</span><br><span class="line">SELECT MAX(salary) FROM emp;</span><br><span class="line"></span><br><span class="line">-- 2 查询员工信息，并且工资等于9000的</span><br><span class="line">SELECT * FROM emp WHERE emp.&#96;salary&#96; &#x3D; 9000;</span><br><span class="line"></span><br><span class="line">-- 一条sql就完成这个操作。子查询</span><br><span class="line">SELECT * FROM emp WHERE emp.&#96;salary&#96; &#x3D; (SELECT MAX(salary) FROM emp);</span><br></pre></td></tr></table></figure>
<h5 id="子查询不同情况"><a href="#子查询不同情况" class="headerlink" title="子查询不同情况"></a>子查询不同情况</h5><h6 id="1-子查询的结果是单行单列的："><a href="#1-子查询的结果是单行单列的：" class="headerlink" title="(1) 子查询的结果是单行单列的："></a>(1) 子查询的结果是单行单列的：</h6><pre><code>                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =
                * 
                -- 查询员工工资小于平均工资的人
                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);
</code></pre><h6 id="2-子查询的结果是多行单列的："><a href="#2-子查询的结果是多行单列的：" class="headerlink" title="(2) 子查询的结果是多行单列的："></a>(2) 子查询的结果是多行单列的：</h6><pre><code>                * 子查询可以作为条件，使用运算符in来判断
                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息
                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;
                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;
                -- 子查询
                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);
</code></pre><h6 id="3-子查询的结果是多行多列的："><a href="#3-子查询的结果是多行多列的：" class="headerlink" title="(3) 子查询的结果是多行多列的："></a>(3) 子查询的结果是多行多列的：</h6><pre><code>                * 子查询可以作为一张虚拟表参与查询
                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息
                -- 子查询
                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2
                WHERE t1.id = t2.dept_id;

                -- 普通内连接
                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;
</code></pre><h3 id="多表查询练习"><a href="#多表查询练习" class="headerlink" title="多表查询练习"></a>多表查询练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">			-- 部门表</span><br><span class="line">			CREATE TABLE dept (</span><br><span class="line">			  id INT PRIMARY KEY PRIMARY KEY, -- 部门id</span><br><span class="line">			  dname VARCHAR(50), -- 部门名称</span><br><span class="line">			  loc VARCHAR(50) -- 部门所在地</span><br><span class="line">			);</span><br><span class="line">			</span><br><span class="line">			-- 添加4个部门</span><br><span class="line">			INSERT INTO dept(id,dname,loc) VALUES </span><br><span class="line">			(10,&#39;教研部&#39;,&#39;北京&#39;),</span><br><span class="line">			(20,&#39;学工部&#39;,&#39;上海&#39;),</span><br><span class="line">			(30,&#39;销售部&#39;,&#39;广州&#39;),</span><br><span class="line">			(40,&#39;财务部&#39;,&#39;深圳&#39;);</span><br><span class="line"></span><br><span class="line">			-- 职务表，职务名称，职务描述</span><br><span class="line">			CREATE TABLE job (</span><br><span class="line">			  id INT PRIMARY KEY,</span><br><span class="line">			  jname VARCHAR(20),</span><br><span class="line">			  description VARCHAR(50)</span><br><span class="line">			);</span><br><span class="line">			</span><br><span class="line">			-- 添加4个职务</span><br><span class="line">			INSERT INTO job (id, jname, description) VALUES</span><br><span class="line">			(1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),</span><br><span class="line">			(2, &#39;经理&#39;, &#39;管理部门员工&#39;),</span><br><span class="line">			(3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),</span><br><span class="line">			(4, &#39;文员&#39;, &#39;使用办公软件&#39;);</span><br><span class="line">			</span><br><span class="line">			-- 员工表</span><br><span class="line">			CREATE TABLE emp (</span><br><span class="line">			  id INT PRIMARY KEY, -- 员工id</span><br><span class="line">			  ename VARCHAR(50), -- 员工姓名</span><br><span class="line">			  job_id INT, -- 职务id</span><br><span class="line">			  mgr INT , -- 上级领导</span><br><span class="line">			  joindate DATE, -- 入职日期</span><br><span class="line">			  salary DECIMAL(7,2), -- 工资</span><br><span class="line">			  bonus DECIMAL(7,2), -- 奖金</span><br><span class="line">			  dept_id INT, -- 所在部门编号</span><br><span class="line">			  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),</span><br><span class="line">			  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)</span><br><span class="line">			);</span><br><span class="line">			</span><br><span class="line">			-- 添加员工</span><br><span class="line">			INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES </span><br><span class="line">			(1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),</span><br><span class="line">			(1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),</span><br><span class="line">			(1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),</span><br><span class="line">			(1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),</span><br><span class="line">			(1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),</span><br><span class="line">			(1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),</span><br><span class="line">			(1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),</span><br><span class="line">			(1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),</span><br><span class="line">			(1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),</span><br><span class="line">			(1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),</span><br><span class="line">			(1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),</span><br><span class="line">			(1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),</span><br><span class="line">			(1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),</span><br><span class="line">			(1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);</span><br><span class="line"></span><br><span class="line">			-- 工资等级表</span><br><span class="line">			CREATE TABLE salarygrade (</span><br><span class="line">			  grade INT PRIMARY KEY,   -- 级别</span><br><span class="line">			  losalary INT,  -- 最低工资</span><br><span class="line">			  hisalary INT -- 最高工资</span><br><span class="line">			);</span><br><span class="line">			</span><br><span class="line">			-- 添加5个工资等级</span><br><span class="line">			INSERT INTO salarygrade(grade,losalary,hisalary) VALUES </span><br><span class="line">			(1,7000,12000),</span><br><span class="line">			(2,12010,14000),</span><br><span class="line">			(3,14010,20000),</span><br><span class="line">			(4,20010,30000),</span><br><span class="line">			(5,30010,99990);</span><br><span class="line">			</span><br><span class="line">			-- 需求：</span><br><span class="line">			</span><br><span class="line">			-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</span><br><span class="line">			&#x2F;*</span><br><span class="line">				分析：</span><br><span class="line">					1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表</span><br><span class="line">					2.查询条件 emp.job_id &#x3D; job.id</span><br><span class="line"></span><br><span class="line">			*&#x2F;</span><br><span class="line">			SELECT </span><br><span class="line">				t1.&#96;id&#96;, -- 员工编号</span><br><span class="line">				t1.&#96;ename&#96;, -- 员工姓名</span><br><span class="line">				t1.&#96;salary&#96;,-- 工资</span><br><span class="line">				t2.&#96;jname&#96;, -- 职务名称</span><br><span class="line">				t2.&#96;description&#96; -- 职务描述</span><br><span class="line">			FROM </span><br><span class="line">				emp t1, job t2</span><br><span class="line">			WHERE </span><br><span class="line">				t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96;;</span><br><span class="line">				-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</span><br><span class="line">				&#x2F;*</span><br><span class="line">					分析：</span><br><span class="line">						1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept</span><br><span class="line">						2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id</span><br><span class="line">				*&#x2F;</span><br><span class="line">				</span><br><span class="line">				SELECT </span><br><span class="line">					t1.&#96;id&#96;, -- 员工编号</span><br><span class="line">					t1.&#96;ename&#96;, -- 员工姓名</span><br><span class="line">					t1.&#96;salary&#96;,-- 工资</span><br><span class="line">					t2.&#96;jname&#96;, -- 职务名称</span><br><span class="line">					t2.&#96;description&#96;, -- 职务描述</span><br><span class="line">					t3.&#96;dname&#96;, -- 部门名称</span><br><span class="line">					t3.&#96;loc&#96; -- 部门位置</span><br><span class="line">				FROM </span><br><span class="line">					emp t1, job t2,dept t3</span><br><span class="line">				WHERE </span><br><span class="line">					t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96; AND t1.&#96;dept_id&#96; &#x3D; t3.&#96;id&#96;;</span><br><span class="line">				   </span><br><span class="line">				-- 3.查询员工姓名，工资，工资等级</span><br><span class="line">				&#x2F;*</span><br><span class="line">					分析：</span><br><span class="line">						1.员工姓名，工资 emp  工资等级 salarygrade</span><br><span class="line">						2.条件 emp.salary &gt;&#x3D; salarygrade.losalary and emp.salary &lt;&#x3D; salarygrade.hisalary</span><br><span class="line">							emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><br><span class="line">				*&#x2F;</span><br><span class="line">				SELECT </span><br><span class="line">					t1.ename ,</span><br><span class="line">					t1.&#96;salary&#96;,</span><br><span class="line">					t2.*</span><br><span class="line">				FROM emp t1, salarygrade t2</span><br><span class="line">				WHERE t1.&#96;salary&#96; BETWEEN t2.&#96;losalary&#96; AND t2.&#96;hisalary&#96;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​				</span><br><span class="line">​				</span><br><span class="line"></span><br><span class="line">				-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</span><br><span class="line">				&#x2F;*</span><br><span class="line">					分析：</span><br><span class="line">						1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade</span><br><span class="line">						2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><br><span class="line">							</span><br><span class="line">				*&#x2F;</span><br><span class="line">				SELECT </span><br><span class="line">					t1.&#96;ename&#96;,</span><br><span class="line">					t1.&#96;salary&#96;,</span><br><span class="line">					t2.&#96;jname&#96;,</span><br><span class="line">					t2.&#96;description&#96;,</span><br><span class="line">					t3.&#96;dname&#96;,</span><br><span class="line">					t3.&#96;loc&#96;,</span><br><span class="line">					t4.&#96;grade&#96;</span><br><span class="line">				FROM </span><br><span class="line">					emp t1,job t2,dept t3,salarygrade t4</span><br><span class="line">				WHERE </span><br><span class="line">					t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96; </span><br><span class="line">					AND t1.&#96;dept_id&#96; &#x3D; t3.&#96;id&#96;</span><br><span class="line">					AND t1.&#96;salary&#96; BETWEEN t4.&#96;losalary&#96; AND t4.&#96;hisalary&#96;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​				</span><br><span class="line">​				</span><br><span class="line"></span><br><span class="line">				-- 5.查询出部门编号、部门名称、部门位置、部门人数</span><br><span class="line">				</span><br><span class="line">				&#x2F;*</span><br><span class="line">					分析：</span><br><span class="line">						1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表</span><br><span class="line">						2.使用分组查询。按照emp.dept_id完成分组，查询count(id)</span><br><span class="line">						3.使用子查询将第2步的查询结果和dept表进行关联查询</span><br><span class="line">						</span><br><span class="line">				*&#x2F;</span><br><span class="line">				SELECT </span><br><span class="line">					t1.&#96;id&#96;,t1.&#96;dname&#96;,t1.&#96;loc&#96; , t2.total</span><br><span class="line">				FROM </span><br><span class="line">					dept t1,</span><br><span class="line">					(SELECT</span><br><span class="line">						dept_id,COUNT(id) total</span><br><span class="line">					FROM </span><br><span class="line">						emp</span><br><span class="line">					GROUP BY dept_id) t2</span><br><span class="line">				WHERE t1.&#96;id&#96; &#x3D; t2.dept_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​				</span><br><span class="line"></span><br><span class="line">				-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询</span><br><span class="line">				</span><br><span class="line">				&#x2F;*</span><br><span class="line">					分析：</span><br><span class="line">						1.姓名 emp， 直接上级的姓名 emp</span><br><span class="line">							* emp表的id 和 mgr 是自关联</span><br><span class="line">						2.条件 emp.id &#x3D; emp.mgr</span><br><span class="line">						3.查询左表的所有数据，和 交集数据</span><br><span class="line">							* 使用左外连接查询 </span><br><span class="line">					</span><br><span class="line">				*&#x2F;</span><br><span class="line">				&#x2F;*</span><br><span class="line">				select</span><br><span class="line">					t1.ename,</span><br><span class="line">					t1.mgr,</span><br><span class="line">					t2.&#96;id&#96;,</span><br><span class="line">					t2.ename</span><br><span class="line">				from emp t1, emp t2</span><br><span class="line">				where t1.mgr &#x3D; t2.&#96;id&#96;;</span><br><span class="line">				</span><br><span class="line">				*&#x2F;</span><br><span class="line">				</span><br><span class="line">				SELECT </span><br><span class="line">					t1.ename,</span><br><span class="line">					t1.mgr,</span><br><span class="line">					t2.&#96;id&#96;,</span><br><span class="line">					t2.&#96;ename&#96;</span><br><span class="line">				FROM emp t1</span><br><span class="line">				LEFT JOIN emp t2</span><br><span class="line">				ON t1.&#96;mgr&#96; &#x3D; t2.&#96;id&#96;;</span><br></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="一-事务的基本介绍"><a href="#一-事务的基本介绍" class="headerlink" title="一. 事务的基本介绍"></a>一. 事务的基本介绍</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><pre><code>        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
</code></pre><h4 id="2-操作："><a href="#2-操作：" class="headerlink" title="2. 操作："></a>2. 操作：</h4><pre><code>        1. 开启事务： start transaction;
        2. 回滚：rollback;
        3. 提交：commit;
</code></pre><h4 id="3-例子："><a href="#3-例子：" class="headerlink" title="3. 例子："></a>3. 例子：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(10),</span><br><span class="line">	balance DOUBLE</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);</span><br><span class="line">SELECT * FROM account;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000;		</span><br><span class="line">	-- 张三给李四转账 500 元</span><br><span class="line">	</span><br><span class="line">	-- 0. 开启事务</span><br><span class="line">	START TRANSACTION;</span><br><span class="line">	-- 1. 张三账户 -500</span><br><span class="line">	</span><br><span class="line">	UPDATE account SET balance &#x3D; balance - 500 WHERE NAME &#x3D; &#39;zhangsan&#39;;</span><br><span class="line">	-- 2. 李四账户 +500</span><br><span class="line">	-- 出错了...</span><br><span class="line">	UPDATE account SET balance &#x3D; balance + 500 WHERE NAME &#x3D; &#39;lisi&#39;;</span><br><span class="line">	</span><br><span class="line">	-- 发现执行没有问题，提交事务</span><br><span class="line">	COMMIT;</span><br><span class="line">	</span><br><span class="line">	-- 发现出问题了，回滚事务</span><br><span class="line">	ROLLBACK;</span><br></pre></td></tr></table></figure>
<h4 id="4-MySQL数据库中事务默认自动提交"><a href="#4-MySQL数据库中事务默认自动提交" class="headerlink" title="4. MySQL数据库中事务默认自动提交"></a>4. MySQL数据库中事务默认自动提交</h4><pre><code>        * 事务提交的两种方式：
            * 自动提交：
                * mysql就是自动提交的
                * 一条DML(增删改)语句会自动提交一次事务。
            * 手动提交：
                * Oracle 数据库默认是手动提交事务
                * 需要先开启事务，再提交
        * 修改事务的默认提交方式：
            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
            * 修改默认提交方式： set @@autocommit = 0;
</code></pre><h3 id="二-事务的四大特征："><a href="#二-事务的四大特征：" class="headerlink" title="二. 事务的四大特征："></a>二. 事务的四大特征：</h3><pre><code>    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
    3. 隔离性：多个事务之间。相互独立。
    4. 一致性：事务操作前后，数据总量不变
</code></pre><h3 id="三-事务的隔离级别（了解）"><a href="#三-事务的隔离级别（了解）" class="headerlink" title="三. 事务的隔离级别（了解）"></a>三. 事务的隔离级别（了解）</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p>
<h4 id="2-存在问题："><a href="#2-存在问题：" class="headerlink" title="2. 存在问题："></a>2. 存在问题：</h4><pre><code>        1. 脏读：一个事务，读取到另一个事务中没有提交的数据
        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
</code></pre><h4 id="3-隔离级别："><a href="#3-隔离级别：" class="headerlink" title="3. 隔离级别："></a>3. 隔离级别：</h4><pre><code>        1. read uncommitted：读未提交
            * 产生的问题：脏读、不可重复读、幻读
        2. read committed：读已提交 （Oracle）
            * 产生的问题：不可重复读、幻读
        3. repeatable read：可重复读 （MySQL默认）
            * 产生的问题：幻读
        4. serializable：串行化
            * 可以解决所有的问题

        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
        * 数据库查询隔离级别：
            * select @@tx_isolation;
        * 数据库设置隔离级别：
            * set global transaction isolation level  级别字符串;
</code></pre><h4 id="4-演示"><a href="#4-演示" class="headerlink" title="4. 演示"></a>4. 演示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	set global transaction isolation level read uncommitted;</span><br><span class="line">	start transaction;</span><br><span class="line">-- read uncommitted： 这里开了两个start transaction; 其中一个运行了以下语句（未提交），另一个进行读取，发现能读到修改。</span><br><span class="line">-- read committed：  这里开了两个start transaction; 其中一个运行了以下语句（未提交），另一个进行读取，发现未能到修改。等提交后，另一方读取时才能读到修改。</span><br><span class="line">-- repeatable read: 和上一个不同的是，运行转账的提交后，另一方读取未能读到修改。直到它也提交后，再查询时，才能读到修稿。</span><br><span class="line">-- serializable： 两个开了start transaction，其中一个运行了转账语句（未提交），另一个进行读取，发现读取不到，被阻塞了。直到转账方提交后，这一方会显示先前的那个读取操作的结果，而此时的结果就是转账后的结果。</span><br><span class="line">	-- 转账操作</span><br><span class="line">	update account set balance &#x3D; balance - 500 where id &#x3D; 1;</span><br><span class="line">	update account set balance &#x3D; cccbalance + 500 where id &#x3D; 2;</span><br></pre></td></tr></table></figure>
<h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><h3 id="SQL分类："><a href="#SQL分类：" class="headerlink" title="SQL分类："></a>SQL分类：</h3><pre><code>    1. DDL：操作数据库和表
    2. DML：增删改表中数据
    3. DQL：查询表中数据
    4. DCL：管理用户，授权
</code></pre><h3 id="DBA：数据库管理员"><a href="#DBA：数据库管理员" class="headerlink" title="DBA：数据库管理员"></a>DBA：数据库管理员</h3><h3 id="DCL：管理用户，授权"><a href="#DCL：管理用户，授权" class="headerlink" title="DCL：管理用户，授权"></a>DCL：管理用户，授权</h3><h4 id="一-管理用户"><a href="#一-管理用户" class="headerlink" title="一. 管理用户"></a>一. 管理用户</h4><h5 id="1-添加用户："><a href="#1-添加用户：" class="headerlink" title="1. 添加用户："></a>1. 添加用户：</h5><pre><code>            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
</code></pre><h5 id="2-删除用户："><a href="#2-删除用户：" class="headerlink" title="2. 删除用户："></a>2. 删除用户：</h5><pre><code>            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;
</code></pre><h5 id="3-修改用户密码："><a href="#3-修改用户密码：" class="headerlink" title="3. 修改用户密码："></a>3. 修改用户密码：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 两种方式</span><br><span class="line">UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;新密码&#39;) WHERE USER &#x3D; &#39;用户名&#39;;</span><br><span class="line">         UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;abc&#39;) WHERE USER &#x3D; &#39;lisi&#39;;</span><br><span class="line"></span><br><span class="line">         SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; &#x3D; PASSWORD(&#39;新密码&#39;);</span><br><span class="line">         SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;);</span><br></pre></td></tr></table></figure>
<h6 id="mysql中忘记了root用户的密码？"><a href="#mysql中忘记了root用户的密码？" class="headerlink" title="mysql中忘记了root用户的密码？"></a>mysql中忘记了root用户的密码？</h6><pre><code>                1. cmd -- &gt; net stop mysql 停止mysql服务
                    * 需要管理员运行该cmd

                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
                4. use mysql;
                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
                6. 关闭两个窗口
                7. 打开任务管理器，手动结束mysqld.exe 的进程
                8. 启动mysql服务
                9. 使用新密码登录。
</code></pre><h5 id="4-查询用户："><a href="#4-查询用户：" class="headerlink" title="4. 查询用户："></a>4. 查询用户：</h5><pre><code>            -- 1. 切换到mysql数据库
            USE myql;
            -- 2. 查询user表
            SELECT * FROM USER;

            * 通配符： % 表示可以在任意主机使用用户登录数据库
</code></pre><h4 id="二-权限管理："><a href="#二-权限管理：" class="headerlink" title="二. 权限管理："></a>二. 权限管理：</h4><h5 id="1-查询权限："><a href="#1-查询权限：" class="headerlink" title="1. 查询权限："></a>1. 查询权限：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询权限</span><br><span class="line">SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; </span><br><span class="line">SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>
<h5 id="2-授予权限："><a href="#2-授予权限：" class="headerlink" title="2. 授予权限："></a>2. 授予权限：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 授予权限</span><br><span class="line">grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">-- 给张三用户授予所有权限，在任意数据库任意表上</span><br><span class="line">GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;</span><br></pre></td></tr></table></figure>
<h5 id="3-撤销权限："><a href="#3-撤销权限：" class="headerlink" title="3. 撤销权限："></a>3. 撤销权限：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 撤销权限：</span><br><span class="line">revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">REVOKE UPDATE ON db3.&#96;account&#96; FROM &#39;lisi&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>python闭包</title>
    <url>/2020/08/31/python-closure/</url>
    <content><![CDATA[<p>​    </p>
<h1 id="python-闭包"><a href="#python-闭包" class="headerlink" title="python 闭包"></a><a href="https://blog.csdn.net/u013380694/article/details/90019571" target="_blank" rel="noopener">python 闭包</a></h1><p>如果在一个函数的内部定义了另一个函数，外部的函数叫它外函数，内部的函数叫它内函数。</p>
<h2 id="1-闭包条件"><a href="#1-闭包条件" class="headerlink" title="1.  闭包条件"></a>1.  闭包条件</h2><ol>
<li><p>在一个外函数中定义了一个内函数。</p>
</li>
<li><p>内函数里运用了外函数的临时变量。</p>
</li>
<li><p>并且外函数的返回值是内函数的引用。</p>
</li>
</ol>
<p>一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#闭包函数的实例</span></span><br><span class="line"><span class="comment"># outer是外部函数 a和b都是外函数的临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">( a )</span>:</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    <span class="comment"># inner是内函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment">#在内函数中 用到了外函数的临时变量</span></span><br><span class="line">        print(a+b)</span><br><span class="line">    <span class="comment"># 外函数的返回值是内函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 在这里我们调用外函数传入参数5</span></span><br><span class="line">    <span class="comment">#此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span></span><br><span class="line">    <span class="comment"># 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span></span><br><span class="line">    demo = outer(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span></span><br><span class="line">    <span class="comment"># demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span></span><br><span class="line">    demo() <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">    demo2 = outer(<span class="number">7</span>)</span><br><span class="line">    demo2()<span class="comment">#17</span></span><br></pre></td></tr></table></figure>
<h3 id="A-外函数返回了内函数的引用"><a href="#A-外函数返回了内函数的引用" class="headerlink" title="A 外函数返回了内函数的引用"></a><strong>A 外函数返回了内函数的引用</strong></h3><p>返回内函数，对于闭包，在外函数outer中 最后return inner，在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来再进行使用demo() 的时候，相当于使用了inner函数。</p>
<p>一个函数，如果函数名后紧跟一对括号，说明现在就要调用这个函数，如果不跟括号，只是一个函数的名字，里面存了函数所在位置的引用。</p>
<h3 id="B-外函数把临时变量绑定给内函数"><a href="#B-外函数把临时变量绑定给内函数" class="headerlink" title="B 外函数把临时变量绑定给内函数"></a><strong>B 外函数把临时变量绑定给内函数</strong></h3><p>一个函数结束的时候，会把自己的临时变量都释放给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量和内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。</p>
<h2 id="2-闭包中内函数修改外函数局部变量"><a href="#2-闭包中内函数修改外函数局部变量" class="headerlink" title="2. 闭包中内函数修改外函数局部变量"></a>2. 闭包中内函数修改外函数局部变量</h2><p>在闭包内函数中，可以随意使用外函数绑定来的临时变量，但是如果想修改外函数临时变量数值的时候发现出问题了！</p>
<p>在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:</p>
<ol>
<li><p>global 声明全局变量</p>
</li>
<li><p>全局变量是可变类型数据的时候可以修改</p>
</li>
</ol>
<p>在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：</p>
<ol>
<li><p>在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</p>
</li>
<li><p>在python2中，没有nonlocal这个关键字，可以把闭包变量改成可变类型数据进行修改，比如列表。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改闭包变量的实例</span></span><br><span class="line"><span class="comment"># outer是外部函数 a和b都是外函数的临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">( a )</span>:</span></span><br><span class="line">    b = <span class="number">10</span>  <span class="comment"># a和b都是闭包变量</span></span><br><span class="line">    c = [a] <span class="comment">#这里对应修改闭包变量的方法2</span></span><br><span class="line">    <span class="comment"># inner是内函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment">#内函数中想修改闭包变量</span></span><br><span class="line">        <span class="comment"># 方法1 nonlocal关键字声明</span></span><br><span class="line">        <span class="keyword">nonlocal</span>  b</span><br><span class="line">        b+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 方法二，把闭包变量修改成可变数据类型 比如列表</span></span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        print(c[<span class="number">0</span>])</span><br><span class="line">        print(b)</span><br><span class="line">    <span class="comment"># 外函数的返回值是内函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    demo = outer(<span class="number">5</span>)</span><br><span class="line">    demo() <span class="comment"># 6  11</span></span><br></pre></td></tr></table></figure>
<p>从上面代码中能看出来，在内函数中，分别对闭包变量进行了修改，打印出来的结果也确实是修改之后的结果。以上两种方法就是内函数修改闭包变量的方法。</p>
<p>还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x+=y</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = outer(<span class="number">10</span>)</span><br><span class="line">print(a(<span class="number">1</span>)) //<span class="number">11</span></span><br><span class="line">print(a(<span class="number">3</span>)) //<span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>外部函数的变量会跟着变</p>
<h2 id="3-闭包用途"><a href="#3-闭包用途" class="headerlink" title="3. 闭包用途"></a>3. 闭包用途</h2><p><strong>3.1 装饰器</strong>！装饰器是做什么的？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。</p>
<p> <strong>3.2 面向对象！</strong>经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程</p>
<p><strong>3.3 实现单利模式！</strong> 其实这也是装饰器的应用。单利模式毕竟比较高大，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/07/16/network-prigramming/</url>
    <content><![CDATA[<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<p><img src="/2020/07/16/network-prigramming/1_cs.jpg" alt></p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><img src="/2020/07/16/network-prigramming/2_bs.jpg" alt></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。<a id="more"></a></p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="/2020/07/16/network-prigramming/3_tcp_ip.jpg" alt></p>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
</li>
</ul>
<p><img src="/2020/07/16/network-prigramming/UDP通信图解.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/16/network-prigramming/4_tcp.jpg" alt></p>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>
<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计 算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<p><img src="/2020/07/16/network-prigramming/image-20200716163717691.png" alt="image-20200716163717691"></p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<p><img src="/2020/07/16/network-prigramming/image-20200716165020707.png" alt="image-20200716165020707"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s1 = server.accecpt();</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/07/16/network-prigramming/image-20200716165440575.png" alt="image-20200716165440575"></p>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><code>public void close()</code> ：关闭此套接字。<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   <ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
</li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/2020/07/16/network-prigramming/5_简单通信.jpg" alt></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol>
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="/2020/07/16/network-prigramming/6_upload.jpg" alt></p>
<p><img src="/2020/07/16/network-prigramming/image-20200716172158094.png" alt="image-20200716172158094"></p>
<p><img src="/2020/07/16/network-prigramming/image-20200716172335744.png" alt="image-20200716172335744">    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol>
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="/2020/07/16/network-prigramming/6_upload2.jpg" alt></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="/2020/07/16/network-prigramming/复制.png" alt></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    	Socket socket = server.accept();</span><br><span class="line">    	InputStream in = socket.getInputStream();</span><br><span class="line">   	    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/16/network-prigramming/无法访问.jpg" alt></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="/2020/07/16/network-prigramming/读取访问信息.jpg" alt></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="/2020/07/16/network-prigramming/效果图1.png" alt></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问效果：</strong></p>
<p><img src="/2020/07/16/network-prigramming/效果图2.png" alt>图解：</p>
<p><img src="/2020/07/16/network-prigramming/05_模拟BS服务器分析.bmp" alt="05_模拟BS服务器分析"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>python装饰器</title>
    <url>/2020/08/31/python-decorator/</url>
    <content><![CDATA[<h1 id="1-装饰器的原型"><a href="#1-装饰器的原型" class="headerlink" title="1. 装饰器的原型"></a>1. 装饰器的原型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">foo = showtime(foo)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>对<code>foo</code>函数进行增强；</p>
<a id="more"></a>
<h1 id="2-不带参数的装饰器-装饰器-被装饰函数都不带参数"><a href="#2-不带参数的装饰器-装饰器-被装饰函数都不带参数" class="headerlink" title="2. 不带参数的装饰器:(装饰器,被装饰函数都不带参数)"></a>2. 不带参数的装饰器:(装饰器,被装饰函数都不带参数)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #doo = showtime(doo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    foo()</span><br><span class="line">    doo()</span><br></pre></td></tr></table></figure>
<h1 id="3-带参数的被装饰的函数"><a href="#3-带参数的被装饰的函数" class="headerlink" title="3. 带参数的被装饰的函数"></a>3. 带参数的被装饰的函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(a,b)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #add = showtime(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #sub = showtime(sub)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(a-b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    add(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">    sub(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">spend is 1.0008258819580078</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">spend is 1.0002799034118652	</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h1 id="4-带参数的装饰器-装饰函数"><a href="#4-带参数的装饰器-装饰函数" class="headerlink" title="4. 带参数的装饰器(装饰函数)"></a>4. 带参数的装饰器(装饰函数)</h1><p>实际是对原有装饰器的一个函数的封装,并返回一个装饰器(一个含有参数的闭包函数),<br>当使用@time_logger(3)调用的时候,Python能发现这一层封装,并将参数传递到装饰器的环境去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_logger</span><span class="params">(flag = <span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            start_time = time.time()</span><br><span class="line">            func(a,b)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                print(<span class="string">'将此操作保留至日志'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> showtime</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_logger(2)  #得到闭包函数showtime,add = showtime(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>多加一层闭包，把参数传进去</p>
<h1 id="5-类装饰器-一般依靠类内部的call方法"><a href="#5-类装饰器-一般依靠类内部的call方法" class="headerlink" title="5. 类装饰器:一般依靠类内部的call方法"></a>5. 类装饰器:一般依靠类内部的<strong>call</strong>方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        self._func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo  #bar = Foo(bar)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'bar..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bar()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bar..</span></span><br><span class="line"><span class="string">spend is 2.000215768814087</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h1 id="6-使用装饰器的缺点"><a href="#6-使用装饰器的缺点" class="headerlink" title="6. 使用装饰器的缺点"></a>6. 使用装饰器的缺点</h1><p>1.位置错误的代码 不能在装饰器之外添加逻辑功能<br>2.不能装饰@staticmethod 或者 @classmethod已经装饰过的方法<br>3.装饰器会对原函数的元信息进行更改,比如函数的docstring,<strong>name</strong>,参数列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(foo.__name__)</span><br><span class="line">    print(doo.__name__)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    wrapper</span></span><br><span class="line"><span class="string">    doo</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出,装饰器会对原函数的元信息进行更改,可以使用wraps,进行原函数信息的添加</p>
<p>注解:wraps本身也是一个装饰器,他能把函数的元信息拷贝到装饰器函数中使得装饰器函数与原函数有一样的元信息</p>
<p>以下是一个wraps的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#6.4. 使用wraps把被装饰的函数信息绑定进装饰器</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(foo.__name__)</span><br><span class="line">    print(doo.__name__)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">doo</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h1 id="常用的内置装饰器"><a href="#常用的内置装饰器" class="headerlink" title="常用的内置装饰器"></a>常用的内置装饰器</h1><ol>
<li><p><strong>staticmethod</strong>: 类似实现了静态方法 注入以后,可以直接 : 类名.方法</p>
</li>
<li><p><strong>property</strong>: 经过property装饰过的函数 不再是一个函数,而是一个property, <strong>类似实现get,set方法</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property</span><br><span class="line">def width(self):</span><br><span class="line">    return self.__width</span><br><span class="line"></span><br><span class="line">@width.setter</span><br><span class="line">def width(self, newWidth):</span><br><span class="line">    self.__width &#x3D; newWidth</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>classmethod</strong>: 与<strong>staticmethod</strong>很相似,貌似就只有这一点区别:<pre><code>第一个参数需要是表示自身类的 cls 参数，
可以来调用类的属性，类的方法，实例化对象等。
</code></pre></li>
</ol>
<p><a href="https://www.cnblogs.com/cicaday/p/python-decorator.html#_caption_0" target="_blank" rel="noopener">详解Python的装饰器</a></p>
<p><a href="https://www.jianshu.com/p/ee82b941772a" target="_blank" rel="noopener">理解Python装饰器(Decorator)</a></p>
<p><a href="https://blog.csdn.net/u013380694/article/details/90019571" target="_blank" rel="noopener">python 闭包，装饰器</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的锁</title>
    <url>/2020/08/31/python_GIL/</url>
    <content><![CDATA[<h1 id="Python中的锁"><a href="#Python中的锁" class="headerlink" title="Python中的锁"></a>Python中的锁</h1><h2 id="一、全局解释器锁（GIL）"><a href="#一、全局解释器锁（GIL）" class="headerlink" title="一、全局解释器锁（GIL）"></a>一、全局解释器锁（GIL）</h2><h3 id="1、什么是全局解释器锁"><a href="#1、什么是全局解释器锁" class="headerlink" title="1、什么是全局解释器锁"></a>1、什么是全局解释器锁</h3><p>在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才能使用全局解释器（cpu）, 即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。</p>
<ul>
<li>GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU 上运行该进程的一个线程。</li>
<li>CPython中<ol>
<li><strong>IO密集型</strong>，某个线程阻塞，就会调度其他就绪线程；</li>
<li><strong>CPU密集型</strong>，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。</li>
</ol>
</li>
<li>在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL。</li>
<li><strong>Python中绝大多数内置数据结构的读、写操作都是原子操作。</strong></li>
<li><strong>由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是 线程安全类型。</strong></li>
</ul>
<a id="more"></a>
<h3 id="2、全局解释器锁的好处"><a href="#2、全局解释器锁的好处" class="headerlink" title="2、全局解释器锁的好处"></a>2、全局解释器锁的好处</h3><p>1、避免了大量的加锁解锁的好处</p>
<p>2、使数据更加安全，解决多线程间的数据完整性和状态同步</p>
<h3 id="3、全局解释器的缺点"><a href="#3、全局解释器的缺点" class="headerlink" title="3、全局解释器的缺点"></a>3、全局解释器的缺点</h3><p>多核处理器退化成单核处理器，只能并发不能并行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同一时刻的某个进程下的某个线程只能被一个cpu所处理，所以在GIL锁下的线程只能被并发，不能被并行。</span><br></pre></td></tr></table></figure>
<h2 id="二、同步锁"><a href="#二、同步锁" class="headerlink" title="二、同步锁"></a>二、同步锁</h2><h3 id="1、什么是同步锁？"><a href="#1、什么是同步锁？" class="headerlink" title="1、什么是同步锁？"></a>1、什么是同步锁？</h3><p>　　　　同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。</p>
<h3 id="2、为什么用同步锁？"><a href="#2、为什么用同步锁？" class="headerlink" title="2、为什么用同步锁？"></a>2、为什么用同步锁？</h3><p>　　　　因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程　　序结果的完整性。</p>
<h3 id="3、怎么使用同步锁？"><a href="#3、怎么使用同步锁？" class="headerlink" title="3、怎么使用同步锁？"></a>3、怎么使用同步锁？</h3><p>　　　　只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。</p>
<h3 id="4、实例："><a href="#4、实例：" class="headerlink" title="4、实例："></a>4、实例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">R = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    R.acquire() <span class="comment"># 加锁，保证同一时刻只有一个线程可以修改数据</span></span><br><span class="line">    num -= <span class="number">1</span></span><br><span class="line">    R.release() <span class="comment"># 修改完成就可以解锁</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 定义一个全局变量</span></span><br><span class="line">l = []  <span class="comment"># 定义一个空列表，用来存放所有的列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  <span class="comment"># for循环100次</span></span><br><span class="line">    t = threading.Thread(target=sub)  <span class="comment"># 每次循环开启一个线程</span></span><br><span class="line">    t.start()  <span class="comment"># 开启线程</span></span><br><span class="line">    l.append(t)  <span class="comment"># 将线程加入列表l</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    i.join()  <span class="comment"># 这里加上join保证所有的线程结束后才运行下面的代码</span></span><br><span class="line">print(num)</span><br><span class="line"><span class="comment"># 输出结果为0</span></span><br></pre></td></tr></table></figure>
<h3 id="5、扩展知识"><a href="#5、扩展知识" class="headerlink" title="5、扩展知识"></a>5、扩展知识</h3><p>　1、GIL的作用：多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。</p>
<p>　2、同步锁的作用：为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。</p>
<h2 id="三、递归锁和死锁"><a href="#三、递归锁和死锁" class="headerlink" title="三、递归锁和死锁"></a>三、递归锁和死锁</h2><h3 id="1、什么是死锁？"><a href="#1、什么是死锁？" class="headerlink" title="1、什么是死锁？"></a>1、什么是死锁？</h3><p>指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源而相互等待的一个现象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">A = threading.Lock()</span><br><span class="line">B = threading.Lock()</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a()   <span class="comment"># 如果两个锁同时被多个线程运行，就会出现死锁现象</span></span><br><span class="line">        self.b()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(<span class="string">'123'</span>)</span><br><span class="line">        B.acquire()</span><br><span class="line">        print(<span class="number">456</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        B.release()</span><br><span class="line">        print(<span class="string">'qweqwe'</span>)</span><br><span class="line">        A.release()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(self)</span>:</span></span><br><span class="line">        B.acquire()</span><br><span class="line">        print(<span class="string">'asdfaaa'</span>)</span><br><span class="line">        A.acquire()</span><br><span class="line">        print(<span class="string">'(⊙o⊙)哦(⊙v⊙)嗯'</span>)</span><br><span class="line">        A.release()</span><br><span class="line">        B.release()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  <span class="comment"># 循环两次，运行四个线程，第一个线程成功处理完数据，第二个和第三个就会出现死锁</span></span><br><span class="line">    t = obj()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>这是python里写一个死锁的标准写法了吧；当b获取了B锁，a获取了A锁，a想要B锁继续，b想要A锁继续，于是就产生了死锁；</p>
<h3 id="2、什么是递归锁？"><a href="#2、什么是递归锁？" class="headerlink" title="2、什么是递归锁？"></a>2、什么是递归锁？</h3><p>​        在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">A = threading.RLock()  <span class="comment"># 这里设置锁为递归锁</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a()</span><br><span class="line">        self.b()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span>  <span class="comment"># 递归锁，就是将多个锁的钥匙放到一起，要拿就全拿，要么一个都拿不到</span></span><br><span class="line">        <span class="comment"># 以实现锁</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(str(threading.currentThread().name) + <span class="string">'  123'</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">"  456"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  qweqwe'</span>)</span><br><span class="line">        A.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  asdfaaa'</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  (⊙o⊙)哦(⊙v⊙)嗯'</span>)</span><br><span class="line">        A.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        t = obj()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">有锁时的输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thread-1  123</span></span><br><span class="line"><span class="string">Thread-1  456</span></span><br><span class="line"><span class="string">Thread-1  qweqwe</span></span><br><span class="line"><span class="string">Thread-1  asdfaaa</span></span><br><span class="line"><span class="string">Thread-1  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string">Thread-2  123</span></span><br><span class="line"><span class="string">Thread-2  456</span></span><br><span class="line"><span class="string">Thread-2  qweqwe</span></span><br><span class="line"><span class="string">Thread-2  asdfaaa</span></span><br><span class="line"><span class="string">Thread-2  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">去掉锁的输出</span></span><br><span class="line"><span class="string">Thread-1  123</span></span><br><span class="line"><span class="string">Thread-1  456</span></span><br><span class="line"><span class="string">Thread-2  123</span></span><br><span class="line"><span class="string">Thread-2  456</span></span><br><span class="line"><span class="string">Thread-2  qweqweThread-1  qweqwe    # 这里说明，线程2把数据写入了输出缓冲区，还没来得及输出呢，就被线程1给抢了，随着线程1一起输出了；</span></span><br><span class="line"><span class="string">Thread-1  asdfaaa</span></span><br><span class="line"><span class="string">Thread-1  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string">                                    # 这一个空行就是线程2为打印出来的，它回来接着这里打印 </span></span><br><span class="line"><span class="string">Thread-2  asdfaaa</span></span><br><span class="line"><span class="string">Thread-2  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">之所以能被抢还是因为这是IO操作，释放了全局解释器锁</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="四、信号量（semaphore）"><a href="#四、信号量（semaphore）" class="headerlink" title="四、信号量（semaphore）"></a>四、信号量（semaphore）</h2><h3 id="1、什么是信号量？"><a href="#1、什么是信号量？" class="headerlink" title="1、什么是信号量？"></a>1、什么是信号量？</h3><p>同进程的一样，semaphore管理一个内置的计数器，每当调用acquire()时内置函数-1，每当调用release()时内置函数+1。</p>
<p>计数器不能为0，当计数器为0时acquire（）将阻塞线程，直到其他线程调用release（）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mysf = threading.Semaphore(<span class="number">5</span>)  <span class="comment"># 创建信号量对象,(5表示这个锁同时支持的个数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> mysf.acquire():  <span class="comment"># 因为使用了信号量，下面的输出就会5个5个的同时输出</span></span><br><span class="line">        print(threading.currentThread().getName() + <span class="string">'  get semaphore'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        mysf.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        t = threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h1 id="为什么在python中推荐使用多进程而不是多线程"><a href="#为什么在python中推荐使用多进程而不是多线程" class="headerlink" title="为什么在python中推荐使用多进程而不是多线程"></a><a href="https://www.cnblogs.com/raind/p/10078873.html" target="_blank" rel="noopener">为什么在python中推荐使用多进程而不是多线程</a></h1><h2 id="每个CPU在同一时间只能执行一个线程"><a href="#每个CPU在同一时间只能执行一个线程" class="headerlink" title="每个CPU在同一时间只能执行一个线程"></a>每个CPU在同一时间只能执行一个线程</h2><p>在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生</p>
<h2 id="在Python多线程下，每个线程的执行方式"><a href="#在Python多线程下，每个线程的执行方式" class="headerlink" title="在Python多线程下，每个线程的执行方式"></a>在Python多线程下，每个线程的执行方式</h2><p>1、获取GIL</p>
<p> 2、执行代码直到sleep或者是python虚拟机将其挂起。</p>
<p> 3、释放GIL   </p>
<p> 可见，某个线程想要执行，必须先拿到GIL，GIL会根据执行的字节码行数以及时间片释放，并且在遇到io操作的时候会主动释放。我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。 而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</p>
<h2 id="那么是不是python的多线程就完全没用了呢？"><a href="#那么是不是python的多线程就完全没用了呢？" class="headerlink" title="那么是不是python的多线程就完全没用了呢？"></a>那么是不是python的多线程就完全没用了呢？</h2><p>在这里我们进行分类讨论：        </p>
<p> 1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。         </p>
<p>2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。                 </p>
<p>而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。                                         </p>
<p>请注意：多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低                                          </p>
<p>回到最开始的问题：经常我们会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？         </p>
<p>原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。   </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>全局解释器锁</tag>
        <tag>同步锁</tag>
        <tag>递归锁</tag>
        <tag>死锁</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2020/08/07/redis/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、-概念"><a href="#一、-概念" class="headerlink" title="一、 概念"></a>一、 概念</h2><pre><code>redis是一款高性能的NOSQL系列的非关系型数据库
</code></pre><h3 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1.什么是NOSQL"></a>1.1.什么是NOSQL</h3><pre><code>        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。
</code></pre><h4 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1.    NOSQL和关系型数据库比较"></a>1.1.1.    NOSQL和关系型数据库比较</h4><pre><code>            优点：
                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。
                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。
                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。

            缺点：
                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。
                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。
                3）不提供关系型数据库对事务的处理。
</code></pre><p><img src="/2020/08/07/redis/1.关系型和非关系型数据库比较.bmp" alt="1.关系型和非关系型数据库比较"></p>
<a id="more"></a>
<h4 id="1-1-2-非关系型数据库的优势："><a href="#1-1-2-非关系型数据库的优势：" class="headerlink" title="1.1.2.    非关系型数据库的优势："></a>1.1.2.    非关系型数据库的优势：</h4><pre><code>            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
</code></pre><h4 id="1-1-3-关系型数据库的优势："><a href="#1-1-3-关系型数据库的优势：" class="headerlink" title="1.1.3.    关系型数据库的优势："></a>1.1.3.    关系型数据库的优势：</h4><pre><code>            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
</code></pre><h4 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4.    总结"></a>1.1.4.    总结</h4><pre><code>            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，
            让NoSQL数据库对关系型数据库的不足进行弥补。
            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据
</code></pre><h3 id="1-2-主流的NOSQL产品"><a href="#1-2-主流的NOSQL产品" class="headerlink" title="1.2.主流的NOSQL产品"></a>1.2.主流的NOSQL产品</h3><pre><code>        •    键值(Key-Value)存储数据库
                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
                数据模型： 一系列键值对
                优势： 快速查询
                劣势： 存储的数据缺少结构化
        •    列存储数据库
                相关产品：Cassandra, HBase, Riak
                典型应用：分布式的文件系统
                数据模型：以列簇式存储，将同一列数据存在一起
                优势：查找速度快，可扩展性强，更容易进行分布式扩展
                劣势：功能相对局限
        •    文档型数据库
                相关产品：CouchDB、MongoDB
                典型应用：Web应用（与Key-Value类似，Value是结构化的）
                数据模型： 一系列键值对
                优势：数据结构要求不严格
                劣势： 查询性能不高，而且缺乏统一的查询语法
        •    图形(Graph)数据库
                相关数据库：Neo4J、InfoGrid、Infinite Graph
                典型应用：社交网络
                数据模型：图结构
                优势：利用图结构相关算法。
                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。
</code></pre><h3 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h3><pre><code>        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：
            1) 字符串类型 string
            2) 哈希类型 hash
            3) 列表类型 list
            4) 集合类型 set
            5) 有序集合类型 sortedset
</code></pre><h4 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h4><pre><code>            •    缓存（数据查询、短连接、新闻内容、商品内容等等）
            •    聊天室的在线好友列表
            •    任务队列。（秒杀、抢购、12306等等）
            •    应用排行榜
            •    网站访问统计
            •    数据过期处理（可以精确到毫秒
            •    分布式集群架构中的session分离
</code></pre><h2 id="二、下载安装"><a href="#二、下载安装" class="headerlink" title="二、下载安装"></a>二、下载安装</h2><pre><code>    1. 官网：https://redis.io
    2. 中文网：http://www.redis.net.cn/
    3. 解压直接可以使用：
        * redis.windows.conf：配置文件
        * redis-cli.exe：redis的客户端
        * redis-server.exe：redis服务器端
</code></pre><h2 id="三、命令操作"><a href="#三、命令操作" class="headerlink" title="三、命令操作"></a>三、命令操作</h2><h3 id="1-redis的数据结构："><a href="#1-redis的数据结构：" class="headerlink" title="1. redis的数据结构："></a>1. redis的数据结构：</h3><pre><code>        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构
            * value的数据结构：
                1) 字符串类型 string
                2) 哈希类型 hash ： map格式  
                3) 列表类型 list ： linkedlist格式。支持重复元素
                4) 集合类型 set  ： 不允许重复元素
                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
</code></pre><p><img src="/2020/08/07/redis/2.redis数据结构.bmp" alt="2.redis数据结构"></p>
<h3 id="2-字符串类型-string"><a href="#2-字符串类型-string" class="headerlink" title="2. 字符串类型 string"></a>2. 字符串类型 string</h3><pre><code>        1. 存储： set key value
            127.0.0.1:6379&gt; set username zhangsan
            OK
        2. 获取： get key
            127.0.0.1:6379&gt; get username
            &quot;zhangsan&quot;
        3. 删除： del key
            127.0.0.1:6379&gt; del age
            (integer) 1
</code></pre><h3 id="3-哈希类型-hash"><a href="#3-哈希类型-hash" class="headerlink" title="3. 哈希类型 hash"></a>3. 哈希类型 hash</h3><pre><code>        1. 存储： hset key field value
            127.0.0.1:6379&gt; hset myhash username lisi
            (integer) 1
            127.0.0.1:6379&gt; hset myhash password 123
            (integer) 1
        2. 获取： 
            * hget key field: 获取指定的field对应的值
                127.0.0.1:6379&gt; hget myhash username
                &quot;lisi&quot;
            * hgetall key：获取所有的field和value
                127.0.0.1:6379&gt; hgetall myhash
                1) &quot;username&quot;
                2) &quot;lisi&quot;
                3) &quot;password&quot;
                4) &quot;123&quot;

        3. 删除： hdel key field
            127.0.0.1:6379&gt; hdel myhash username
            (integer) 1
</code></pre><h3 id="4-列表类型-list"><a href="#4-列表类型-list" class="headerlink" title="4. 列表类型 list"></a>4. 列表类型 list</h3><p><strong>可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong></p>
<pre><code>        1. 添加：
            1. lpush key value: 将元素加入列表左表

            2. rpush key value：将元素加入列表右边

                127.0.0.1:6379&gt; lpush myList a
                (integer) 1
                127.0.0.1:6379&gt; lpush myList b
                (integer) 2
                127.0.0.1:6379&gt; rpush myList c
                (integer) 3
        2. 获取：
            * lrange key start end ：范围获取
                127.0.0.1:6379&gt; lrange myList 0 -1
                1) &quot;b&quot;
                2) &quot;a&quot;
                3) &quot;c&quot;
        3. 删除：
            * lpop key： 删除列表最左边的元素，并将元素返回
            * rpop key： 删除列表最右边的元素，并将元素返回
</code></pre><h3 id="5-集合类型-set-：-不允许重复元素"><a href="#5-集合类型-set-：-不允许重复元素" class="headerlink" title="5. 集合类型 set ： 不允许重复元素"></a>5. 集合类型 set ： 不允许重复元素</h3><pre><code>        1. 存储：sadd key value
            127.0.0.1:6379&gt; sadd myset a
            (integer) 1
            127.0.0.1:6379&gt; sadd myset a
            (integer) 0
        2. 获取：smembers key:获取set集合中所有元素
            127.0.0.1:6379&gt; smembers myset
            1) &quot;a&quot;
        3. 删除：srem key value:删除set集合中的某个元素    
            127.0.0.1:6379&gt; srem myset a
            (integer) 1
</code></pre><h3 id="6-有序集合类型"><a href="#6-有序集合类型" class="headerlink" title="6. 有序集合类型"></a>6. 有序集合类型</h3><p>sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<pre><code>        1. 存储：zadd key score value
            127.0.0.1:6379&gt; zadd mysort 60 zhangsan
            (integer) 1
            127.0.0.1:6379&gt; zadd mysort 50 lisi
            (integer) 1
            127.0.0.1:6379&gt; zadd mysort 80 wangwu
            (integer) 1
        2. 获取：zrange key start end [withscores]
            127.0.0.1:6379&gt; zrange mysort 0 -1
            1) &quot;lisi&quot;
            2) &quot;zhangsan&quot;
            3) &quot;wangwu&quot;

            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores
            1) &quot;zhangsan&quot;
            2) &quot;60&quot;
            3) &quot;wangwu&quot;
            4) &quot;80&quot;
            5) &quot;lisi&quot;
            6) &quot;500&quot;
        3. 删除：zrem key value
            127.0.0.1:6379&gt; zrem mysort lisi
            (integer) 1
</code></pre><h3 id="7-通用命令"><a href="#7-通用命令" class="headerlink" title="7. 通用命令"></a>7. 通用命令</h3><pre><code>        1. keys * : 查询所有的键
        2. type key ： 获取键对应的value的类型
        3. del key：删除指定的key value
</code></pre><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><pre><code>    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。
    2. redis持久化机制：
        1. RDB：默认方式，不需要进行配置，默认就使用这种机制
            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据
            1. 编辑redis.windwos.conf文件
                #   after 900 sec (15 min) if at least 1 key changed
                save 900 1
                #   after 300 sec (5 min) if at least 10 keys changed
                save 300 10
                #   after 60 sec if at least 10000 keys changed
                save 60 10000

            2. 重新启动redis服务器，并指定配置文件名称
                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf    

        2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
            1. 编辑redis.windwos.conf文件
                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）

                # appendfsync always ： 每一次操作都进行持久化
                appendfsync everysec ： 每隔一秒进行一次持久化
                # appendfsync no     ： 不进行持久化
</code></pre><h2 id="五、Java客户端-Jedis"><a href="#五、Java客户端-Jedis" class="headerlink" title="五、Java客户端 Jedis"></a>五、Java客户端 Jedis</h2><h3 id="一、Jedis"><a href="#一、Jedis" class="headerlink" title="一、Jedis"></a>一、Jedis</h3><p>一款java操作redis数据库的工具.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 使用步骤：</span><br><span class="line">	<span class="number">1</span>. 下载jedis的jar包</span><br><span class="line">	<span class="number">2</span>. 使用</span><br><span class="line">		<span class="comment">//1. 获取连接</span></span><br><span class="line">   		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">  			<span class="comment">//2. 操作</span></span><br><span class="line">  			jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">   		<span class="comment">//3. 关闭连接</span></span><br><span class="line">   		jedis.close();</span><br></pre></td></tr></table></figure>
<h3 id="二、Jedis操作各种redis中的数据结构"><a href="#二、Jedis操作各种redis中的数据结构" class="headerlink" title="二、Jedis操作各种redis中的数据结构"></a>二、Jedis操作各种redis中的数据结构</h3><h4 id="1-字符串类型-string"><a href="#1-字符串类型-string" class="headerlink" title="1) 字符串类型 string"></a>1) 字符串类型 string</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set</span><br><span class="line">get</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">//存储</span></span><br><span class="line">      jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">      <span class="comment">//获取</span></span><br><span class="line">      String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">      System.out.println(username);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">      jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="2-哈希类型-hash-：-map格式"><a href="#2-哈希类型-hash-：-map格式" class="headerlink" title="2) 哈希类型 hash ： map格式"></a>2) 哈希类型 hash ： map格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hset</span><br><span class="line">hget</span><br><span class="line">hgetAll</span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// 存储hash</span></span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// 获取hash</span></span><br><span class="line">      String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">      System.out.println(name);</span><br><span class="line">      <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">      Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// keyset</span></span><br><span class="line">      Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line">      <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">          <span class="comment">//获取value</span></span><br><span class="line">          String value = user.get(key);</span><br><span class="line">          System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="3-列表类型-list-：-linkedlist格式。支持重复元素"><a href="#3-列表类型-list-：-linkedlist格式。支持重复元素" class="headerlink" title="3) 列表类型 list ： linkedlist格式。支持重复元素"></a>3) 列表类型 list ： linkedlist格式。支持重复元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lpush / rpush</span><br><span class="line">lpop / rpop</span><br><span class="line">lrange start end : 范围获取</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// list 存储</span></span><br><span class="line">      jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">      jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// list 弹出</span></span><br><span class="line">      String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element1);</span><br><span class="line">	</span><br><span class="line">      String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element2);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist2);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="4-集合类型-set-：-不允许重复元素"><a href="#4-集合类型-set-：-不允许重复元素" class="headerlink" title="4) 集合类型 set  ： 不允许重复元素"></a>4) 集合类型 set  ： 不允许重复元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sadd</span><br><span class="line">smembers:获取所有元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// set 存储</span></span><br><span class="line">      jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// set 获取</span></span><br><span class="line">      Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">      System.out.println(myset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="5-有序集合类型-sortedset：不允许重复元素，且元素有顺序"><a href="#5-有序集合类型-sortedset：不允许重复元素，且元素有顺序" class="headerlink" title="5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序"></a>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zadd</span><br><span class="line">zrange</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// sortedset 存储</span></span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// sortedset 获取</span></span><br><span class="line">      Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mysortedset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h3 id="三、jedis连接池：-JedisPool"><a href="#三、jedis连接池：-JedisPool" class="headerlink" title="三、jedis连接池： JedisPool"></a>三、jedis连接池： JedisPool</h3><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 创建JedisPool连接池对象</span><br><span class="line"><span class="number">2</span>. 调用方法 getResource()方法获取Jedis连接</span><br><span class="line">	<span class="comment">//0.创建一个配置对象</span></span><br><span class="line">       JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">       config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">       config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">       <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">       JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">		</span><br><span class="line">       <span class="comment">//2.获取连接</span></span><br><span class="line">       Jedis jedis = jedisPool.getResource();</span><br><span class="line">       <span class="comment">//3. 使用</span></span><br><span class="line">       jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line">       <span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">       jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：
    1. 提供index.html页面，页面中有一个省份 下拉列表
    2. 当 页面加载完成后 发送ajax请求，加载所有省份


* 注意：使用redis缓存一些不经常发生变化的数据。
    * 数据库的数据一旦发生改变，则需要更新缓存。
        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入
        * 在service对应的增删改方法中，将redis数据删除。
</code></pre><p>​    </p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>request</title>
    <url>/2020/07/30/request/</url>
    <content><![CDATA[<h1 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h1><pre><code>1. 请求消息：客户端发送给服务器端的数据
    * 数据格式：
        1. 请求行
        2. 请求头
        3. 请求空行
        4. 请求体
2. 响应消息：服务器端发送给客户端的数据
    * 数据格式：
        1. 响应行
            1. 组成：协议/版本 响应状态码 状态码描述
            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。
                1. 状态码都是3位数字 
                2. 分类：
                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
                    2. 2xx：成功。代表：200
                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)
                    4. 4xx：客户端错误。
                        * 代表：
                            * 404（请求路径没有对应的资源） 
                            * 405：请求方式没有对应的doXxx方法
                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)
</code></pre><a id="more"></a>
<pre><code>        2. 响应头：
            1. 格式：头名称： 值
            2. 常见的响应头：
                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据
                    * 值：
                        * in-line:默认值,在当前页面内打开
                        * attachment;filename=xxx：以附件形式打开响应体。文件下载
        3. 响应空行
        4. 响应体:传输的数据


    * 响应字符串格式
        HTTP/1.1 200 OK
        Content-Type: text/html;charset=UTF-8
        Content-Length: 101
        Date: Wed, 06 Jun 2018 07:08:42 GMT

        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;$Title$&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
          hello , response
          &lt;/body&gt;
        &lt;/html&gt;
</code></pre><h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><h2 id="一、功能：设置响应消息"><a href="#一、功能：设置响应消息" class="headerlink" title="一、功能：设置响应消息"></a>一、功能：设置响应消息</h2><h3 id="1-设置响应行"><a href="#1-设置响应行" class="headerlink" title="1. 设置响应行"></a>1. 设置响应行</h3><pre><code>        1. 格式：HTTP/1.1 200 ok
        2. 设置状态码：setStatus(int sc) 
</code></pre><h3 id="2-设置响应头："><a href="#2-设置响应头：" class="headerlink" title="2. 设置响应头："></a>2. 设置响应头：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setHeader(String name, String value)</span><br></pre></td></tr></table></figure>
<h3 id="3-设置响应体："><a href="#3-设置响应体：" class="headerlink" title="3. 设置响应体："></a>3. 设置响应体：</h3><pre><code>        * 使用步骤：
            1. 获取输出流
                * 字符输出流：PrintWriter getWriter()

                * 字节输出流：ServletOutputStream getOutputStream()

            2. 使用输出流，将数据输出到客户端浏览器
</code></pre><h2 id="二、案例："><a href="#二、案例：" class="headerlink" title="二、案例："></a>二、案例：</h2><h3 id="1-完成重定向"><a href="#1-完成重定向" class="headerlink" title="1. 完成重定向"></a>1. 完成重定向</h3><h4 id="重定向：资源跳转的方式"><a href="#重定向：资源跳转的方式" class="headerlink" title="重定向：资源跳转的方式"></a>重定向：资源跳转的方式</h4><p><img src="/2020/07/30/request/image-20200731154135769.png" alt="image-20200731154135769"><br> <strong>代码实现：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 设置状态码为302</span></span><br><span class="line">      response.setStatus(<span class="number">302</span>);</span><br><span class="line">      <span class="comment">//2.设置响应头location</span></span><br><span class="line">      response.setHeader(<span class="string">"location"</span>,<span class="string">"/day15/responseDemo2"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//简单的重定向方法</span></span><br><span class="line">      response.sendRedirect(<span class="string">"/day15/responseDemo2"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="重定向的特点-redirect"><a href="#重定向的特点-redirect" class="headerlink" title="重定向的特点:redirect"></a>重定向的特点:redirect</h4><pre><code>            1. 地址栏发生变化
            2. 重定向可以访问其他站点(服务器)的资源
            3. 重定向是两次请求。不能使用request对象来共享数据
</code></pre><h4 id="转发的特点：forward"><a href="#转发的特点：forward" class="headerlink" title="转发的特点：forward"></a>转发的特点：forward</h4><pre><code>            1. 转发地址栏路径不变
            2. 转发只能访问当前服务器下的资源
            3. 转发是一次请求，可以使用request对象来共享数据
</code></pre><p>上面这两个遇到面试题就可能被问到：forward 和  redirect 区别</p>
<h4 id="路径写法："><a href="#路径写法：" class="headerlink" title="路径写法："></a>路径写法：</h4><pre><code>        1. 路径分类
                1. 相对路径：通过相对路径不可以确定唯一资源
                    * 如：./index.html
                    * 不以/开头，以.开头路径

                    * 规则：找到当前资源和目标资源之间的相对位置关系
                        * ./：当前目录
                        * ../:后退一级目录
                2. 绝对路径：通过绝对路径可以确定唯一资源
                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2
                    * 以/开头的路径

                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                        * 给客户端浏览器使用：（重定向是给浏览器用）
                            需要加虚拟目录(项目的访问路径)
                            * 建议虚拟目录动态获取：request.getContextPath()
                            * &lt;a&gt; , &lt;form&gt; 重定向...
                        * 给服务器使用：（请求转发是给服务器端使用的）
                            不需要加虚拟目录
                            * 转发路径
</code></pre><p>​<br>​                        </p>
<h3 id="2-服务器输出字符数据到浏览器"><a href="#2-服务器输出字符数据到浏览器" class="headerlink" title="2. 服务器输出字符数据到浏览器"></a>2. 服务器输出字符数据到浏览器</h3><pre><code>        * 步骤：
            1. 获取字符输出流
            2. 输出数据

        * 注意：
            * 乱码问题：
                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
                2. 设置该流的默认编码
                3. 告诉浏览器响应体使用的编码

                //简单的形式，设置编码，是在获取流之前设置
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/responseDemo4"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取流对象之前，设置流的默认编码，ISO-8859-1 设置为GBK</span></span><br><span class="line"><span class="comment">//        resp.setCharacterEncoding("utf-8");</span></span><br><span class="line">        <span class="comment">// 告诉浏览器，服务器发送的消息数据的编码。建议浏览器使用该编码解码</span></span><br><span class="line">        <span class="comment">//resp.setHeader("content-type","text/html;charset=utf-8");   // 这一行不但设置了浏览器的编码而且也设置了流的编码，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单形式，设置编码</span></span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        <span class="comment">// 1. 获取字符输出流</span></span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        <span class="comment">// 2. 输出数据</span></span><br><span class="line">        <span class="comment">//pw.write("&lt;h1&gt;Hello response&lt;/h1&gt;");</span></span><br><span class="line">        pw.write(<span class="string">"&lt;h1&gt;你好啊 response&lt;/h1&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-服务器输出字节数据到浏览器"><a href="#3-服务器输出字节数据到浏览器" class="headerlink" title="3. 服务器输出字节数据到浏览器"></a>3. 服务器输出字节数据到浏览器</h3><pre><code>        * 步骤：
            1. 获取字节输出流
            2. 输出数据
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">    <span class="comment">// 获取字节输出流</span></span><br><span class="line">    ServletOutputStream sos = resp.getOutputStream();</span><br><span class="line">    <span class="comment">// 输出数据</span></span><br><span class="line">    sos.write(<span class="string">"霓虹呀"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-验证码"><a href="#4-验证码" class="headerlink" title="4. 验证码"></a>4. 验证码</h3><pre><code>        1. 本质：图片
        2. 目的：防止恶意表单注册
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zenner.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/checkCodeServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建一个对象能在内存画图（验证码图片对象）</span></span><br><span class="line">        BufferedImage Image = <span class="keyword">new</span> BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="comment">// 2. 美化图片</span></span><br><span class="line">        <span class="comment">// 2.1 填充背景色</span></span><br><span class="line">        Graphics g = Image.getGraphics();</span><br><span class="line">        g.setColor(Color.pink);</span><br><span class="line">        g.fill3DRect(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 2.2 画边框</span></span><br><span class="line">        g.setColor(Color.BLUE);</span><br><span class="line">        g.drawRect(<span class="number">0</span>, <span class="number">0</span>, width-<span class="number">1</span>, height-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2.3 写验证码</span></span><br><span class="line">        String str = <span class="string">"ABCDEFGHIGKLMNOPQRSTUVWXYabcdefghigklmnopqrstuvwxyz0123456789"</span>;</span><br><span class="line">        <span class="comment">// 生成随机角标</span></span><br><span class="line">        Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = ran.nextInt(str.length());</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(j);</span><br><span class="line">            g.drawString(c+<span class="string">""</span>, width/<span class="number">5</span>*(i+<span class="number">1</span>), height/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.4 画干扰线</span></span><br><span class="line">        g.setColor(Color.GREEN);</span><br><span class="line">        <span class="comment">// 2.4.1 随机生成坐标点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = ran.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> x2 = ran.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y1 = ran.nextInt(height);</span><br><span class="line">            <span class="keyword">int</span> y2 = ran.nextInt(height);</span><br><span class="line">            g.drawLine(x1,y1,x2,y2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将图片输出到页面展示</span></span><br><span class="line">        ImageIO.write(Image,<span class="string">"jpg"</span>, resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        /*</span><br><span class="line">            分析：</span><br><span class="line">                点击超链接或者图片，需要换一张验证码图片</span><br><span class="line">                1.给超链接和图片绑定单击事件</span><br><span class="line"></span><br><span class="line">                2. 重新设置图片的src属性值</span><br><span class="line">        */</span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"checkCode"</span>);</span></span><br><span class="line"><span class="actionscript">            img.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 加时间戳</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="actionscript">                img.src = <span class="string">"/day15/checkCodeServlet?"</span>+date;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"check"</span>);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"checkCode"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="actionscript">            img.src = <span class="string">"/day15/checkCodeServlet?"</span>+date;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"checkCode"</span> <span class="attr">src</span>=<span class="string">"/day15/checkCodeServlet"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"change"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"b()"</span>&gt;</span>看不清换一张？<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="ServletContext对象："><a href="#ServletContext对象：" class="headerlink" title="ServletContext对象："></a>ServletContext对象：</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><pre><code>    代表整个web应用，可以和程序的容器(服务器)来通信
</code></pre><h2 id="2-获取："><a href="#2-获取：" class="headerlink" title="2. 获取："></a>2. 获取：</h2><pre><code>    1. 通过request对象获取
        request.getServletContext();
    2. 通过HttpServlet获取
        this.getServletContext();
</code></pre><h2 id="3-功能："><a href="#3-功能：" class="headerlink" title="3. 功能："></a>3. 功能：</h2><h3 id="1-获取MIME类型："><a href="#1-获取MIME类型：" class="headerlink" title="(1) 获取MIME类型："></a>(1) 获取MIME类型：</h3><pre><code>        * MIME类型:在互联网通信过程中定义的一种文件数据类型
            * 格式： 大类型/小类型   text/html        image/jpeg

        * 获取：String getMimeType(String file)  
</code></pre><h3 id="2-域对象：共享数据"><a href="#2-域对象：共享数据" class="headerlink" title="(2) 域对象：共享数据"></a>(2) 域对象：共享数据</h3><pre><code>        1. setAttribute(String name,Object value)
        2. getAttribute(String name)
        3. removeAttribute(String name)

        * ServletContext对象范围：所有用户所有请求的数据
</code></pre><h3 id="3-获取文件的真实-服务器-路径"><a href="#3-获取文件的真实-服务器-路径" class="headerlink" title="(3) 获取文件的真实(服务器)路径"></a>(3) 获取文件的真实(服务器)路径</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 方法：<span class="function">String <span class="title">getRealPath</span><span class="params">(String path)</span>  </span></span><br><span class="line"><span class="function">	 String b </span>= context.getRealPath(<span class="string">"/b.txt"</span>);<span class="comment">//web目录下资源访问</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">	</span><br><span class="line">       String c = context.getRealPath(<span class="string">"/WEB-INF/c.txt"</span>);<span class="comment">//WEB-INF目录下的资源访问</span></span><br><span class="line">       System.out.println(c);</span><br><span class="line">	</span><br><span class="line">       String a = context.getRealPath(<span class="string">"/WEB-INF/classes/a.txt"</span>);<span class="comment">//src目录下的资源访问</span></span><br><span class="line">       System.out.println(a);</span><br></pre></td></tr></table></figure>
<h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 文件下载需求：
    1. 页面显示超链接
    2. 点击超链接后弹出下载提示框
    3. 完成图片文件下载


* 分析：
    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
    2. 任何资源都必须弹出下载提示框
    3. 使用响应头设置资源的打开方式：
        * content-disposition:attachment;filename=xxx


* 步骤：
    1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename
    2. 定义Servlet
        1. 获取文件名称
        2. 使用字节输入流加载文件进内存
        3. 指定response的响应头： content-disposition:attachment;filename=xxx
        4. 将数据写出到response输出流
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zenner.web.download;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/downloadServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求参数，文件名称</span></span><br><span class="line">        String filename = req.getParameter(<span class="string">"filename"</span>);</span><br><span class="line">        <span class="comment">// 2. 使用字节输入流加载文件进内存</span></span><br><span class="line">        <span class="comment">// 2.1 找到文件服务器路径</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String realPath = servletContext.getRealPath(<span class="string">"/img/"</span>+filename);</span><br><span class="line">        <span class="comment">// 2.2 使用字节输入流关联</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="comment">// 3. 设置response响应头</span></span><br><span class="line">        <span class="comment">// 3.1 设置响应头类型：content-type</span></span><br><span class="line">        String mimeType = servletContext.getMimeType(filename);</span><br><span class="line">        resp.setHeader(<span class="string">"content-type"</span>,<span class="string">"mimeType"</span>);</span><br><span class="line">        <span class="comment">// 3.2 设置响应头打开方式: content-disposition</span></span><br><span class="line">        resp.setHeader(<span class="string">"content-disposition"</span>,<span class="string">"attachment;filename="</span>+filename);</span><br><span class="line">        <span class="comment">// 3. 将输入流的数据写出到输出流中</span></span><br><span class="line">        ServletOutputStream sos = resp.getOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            sos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>* 问题：
    * 中文文件问题
        * 解决思路：
            1. 获取客户端使用的浏览器版本信息
            2. 根据不同的版本信息，设置filename的编码方式不同
</code></pre>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>http</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab竟有这种特性！</title>
    <url>/2020/07/18/surprise-bug/</url>
    <content><![CDATA[<p>matlab竟然可以对一个从未声明过的变量的索引进行赋值。很明显是一种很自由，开放的数据操作模式。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">A =</span><br><span class="line">	<span class="number">0</span>	<span class="number">1</span></span><br><span class="line">	</span><br><span class="line">&gt;&gt; A(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">A = </span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>我写的一个算AUC的代码中，有一个变量未注意大小写。对其进行的赋值导致未起作用。这个bug一直存在。而程序也未提醒。他就当作了一个新变量的赋值。而我认为它对我的数据进行了处理。哎，心累。</p>
]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <url>/2020/07/24/slash-offer-04/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<a id="more"></a>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这里可以看到对角的性质。</p>
<p>比如二维数组中的(2,2),也就是9的位置。行（0，2）及列（0，2）没有一个大于9的；也就是（x,y）位置上的值，（x,y）矩阵内的值都比（x,y）位置上的值小。但这之外的不一定全都大。虽然上的矩阵是这么弄得。所以target只要一直找到刚好大于的值，再确定范围。</p>
<p>但是还是要考虑一下不同的情况：</p>
<ul>
<li>m == n ：这个情况下就可以顺着对角线一路找下去</li>
<li>m &gt; n :  行多于列。那么顺着对角线找下去：1. 小于对角线上最后一个值。那么他就在那个矩阵里。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力法走一波</span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span>)&#123;</span><br><span class="line">            n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="看答案"><a href="#看答案" class="headerlink" title="看答案"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener">看答案</a></h1><ul>
<li><p>标志数引入： 此类矩阵中左下角和右上角元素有特殊性，称为标志数。</p>
<ul>
<li>左下角元素： 为所在列最大元素，所在行最小元素。</li>
<li>右上角元素： 为所在行最大元素，所在列最小元素。</li>
</ul>
</li>
<li><p>标志数性质： 将 matrix 中的左下角元素（标志数）记作 flag ，则有:</p>
<ol>
<li><p>若 flag &gt; target ，则 target 一定在 flag 所在行的上方，即 flag 所在行可被消去。</p>
</li>
<li><p>若 flag &lt; target ，则 target 一定在 flag 所在列的右方，即 flag 所在列可被消去。</p>
</li>
</ol>
</li>
</ul>
<p>本题解以左下角元素为例，同理，右上角元素 也具有行（列）消去的性质。</p>
<p><img src="https://pic.leetcode-cn.com/443c0751fbc3ee40930f04231dcd03e3462243c6dbd3d77a72714c8273ecbe4a-Picture1.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/23d65449566ff8f128938b41bb46a636dd417200b8a04ac9677731c475f862e1-Picture2.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length-<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[i][j])&#123;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[i][j])&#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>xml</title>
    <url>/2020/07/27/xml/</url>
    <content><![CDATA[<h1 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><pre><code>Extensible Markup Language 可扩展标记语言
    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;

    * 功能
        * 存储数据
            1. 配置文件
            2. 在网络中传输
    * xml与html的区别
        1. xml标签都是自定义的，html标签是预定义。
        2. xml的语法严格，html语法松散
        3. xml是存储数据的，html是展示数据

    * w3c:万维网联盟
</code></pre><a id="more"></a>
<h2 id="2-语法："><a href="#2-语法：" class="headerlink" title="2. 语法："></a>2. 语法：</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><pre><code>1. xml文档的后缀名 .xml
2. xml第一行必须定义为文档声明
3. xml文档中有且仅有一个根标签
4. 属性值必须使用引号(单双都可)引起来
5. 标签必须正确关闭： 也可以定义自闭合标签
6. xml标签名称区分大小写
</code></pre><h3 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">'2'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组成部分："><a href="#组成部分：" class="headerlink" title="组成部分："></a>组成部分：</h3><pre><code>        1. 文档声明
            1. 格式：&lt;?xml 属性列表 ?&gt;
            2. 属性列表：
                * version：版本号，必须的属性
                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1
                * standalone：是否独立
                    * 取值：
                        * yes：不依赖其他文件
                        * no：依赖其他文件
        2. 指令(了解)：结合css的
            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;
        3. 标签：标签名称自定义的
            * 规则：
                * 名称可以包含字母、数字以及其他的字符 
                * 名称不能以数字或者标点符号开始 
                * 名称不能以字母 xml（或者 XML、Xml 等等）开始 
                * 名称不能包含空格 

        4. 属性：
            id属性值唯一
        5. 文本：
            * CDATA 区：在该区域中的数据会被原样展示
                * 格式：  &lt;![CDATA[ 数据 ]]&gt;
</code></pre><p>​    </p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><img src="/2020/07/27/xml/image-20200727173344612.png" alt="image-20200727173344612"></p>
<pre><code>规定xml文档的书写规则
        * 作为框架的使用者(程序员)：
            1. 能够在xml中引入约束文档
            2. 能够简单的读懂约束文档

        * 分类：
            1. DTD:一种简单的约束技术
            2. Schema:一种复杂的约束技术


        * DTD：
            * 引入dtd文档到xml文档中
                * 内部dtd：将约束规则定义在xml文档中
                * 外部dtd：将约束的规则定义在外部的dtd文件中
                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;
                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;


        * Schema:
            * 引入：
                1.填写xml文档的根元素
                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;
                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; 

            &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xmlns=&quot;http://www.itcast.cn/xml&quot;
                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;
</code></pre><p>​    </p>
<h2 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h2><p>操作xml文档，将文档中的数据读取到内存中</p>
<pre><code>    * 操作xml文档
        1. 解析(读取)：将文档中的数据读取到内存中
        2. 写入：将内存中的数据保存到xml文档中。持久化的存储

    * 解析xml的方式：
        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树
            * 优点：操作方便，可以对文档进行CRUD的所有操作
            * 缺点：占内存
        2. SAX：逐行读取，基于事件驱动的。
            * 优点：不占内存。
            * 缺点：只能读取，不能增删改
</code></pre><p>​        </p>
<pre><code>    * xml常见的解析器：
        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
        2. DOM4J：一款非常优秀的解析器
        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
        4. PULL：Android操作系统内置的解析器，sax方式的。
</code></pre><h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><p>jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p>
<h4 id="快速入门：-1"><a href="#快速入门：-1" class="headerlink" title="快速入门："></a>快速入门：</h4><pre><code>            * 步骤：
                1. 导入jar包
                2. 获取Document对象
                3. 获取对应的标签Element对象
                4. 获取数据
</code></pre><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.1获取student.xml的path</span></span><br><span class="line">String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();</span><br><span class="line"><span class="comment">//2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document</span></span><br><span class="line">Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//3.获取元素对象 Element</span></span><br><span class="line">Elements elements = document.getElementsByTag(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(elements.size());</span><br><span class="line"><span class="comment">//3.1获取第一个name的Element对象</span></span><br><span class="line">Element element = elements.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//3.2获取数据</span></span><br><span class="line">String name = element.text();</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>
<h3 id="对象的使用："><a href="#对象的使用：" class="headerlink" title="对象的使用："></a>对象的使用：</h3><h4 id="1-Jsoup：工具类，可以解析html或xml文档，返回Document"><a href="#1-Jsoup：工具类，可以解析html或xml文档，返回Document" class="headerlink" title="1. Jsoup：工具类，可以解析html或xml文档，返回Document"></a>1. Jsoup：工具类，可以解析html或xml文档，返回Document</h4><pre><code>            * parse：解析html或xml文档，返回Document
                * parse​(File in, String charsetName)：解析xml或html文件的。
                * parse​(String html)：解析xml或html字符串
                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
</code></pre><h4 id="2-Document：文档对象。代表内存中的dom树"><a href="#2-Document：文档对象。代表内存中的dom树" class="headerlink" title="2. Document：文档对象。代表内存中的dom树"></a>2. Document：文档对象。代表内存中的dom树</h4><pre><code>            * 获取Element对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
</code></pre><h4 id="3-Elements"><a href="#3-Elements" class="headerlink" title="3. Elements"></a>3. Elements</h4><p>元素Element对象的集合。可以当做 ArrayList<Element>来使用</Element></p>
<h4 id="4-Element：元素对象"><a href="#4-Element：元素对象" class="headerlink" title="4. Element：元素对象"></a>4. Element：元素对象</h4><pre><code>            1. 获取子元素对象
                * getElementById​(String id)：根据id属性值获取唯一的element对象
                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

            2. 获取属性值
                * String attr(String key)：根据属性名称获取属性值，不区分大小写
            3. 获取文本内容
                * String text():获取文本内容
                * String html():获取标签体的所有内容(包括子标签的字符串内容)
</code></pre><h4 id="5-Node：节点对象"><a href="#5-Node：节点对象" class="headerlink" title="5. Node：节点对象"></a>5. Node：节点对象</h4><pre><code>            * 是Document和Element的父类
</code></pre><p>​            </p>
<h3 id="快捷查询方式："><a href="#快捷查询方式：" class="headerlink" title="快捷查询方式："></a>快捷查询方式：</h3><h4 id="1-selector-选择器"><a href="#1-selector-选择器" class="headerlink" title="1. selector:选择器"></a>1. selector:选择器</h4><pre><code>            * 使用的方法：Elements    select​(String cssQuery)
                * 语法：参考Selector类中定义的语法
</code></pre><h4 id="2-XPath"><a href="#2-XPath" class="headerlink" title="2. XPath"></a>2. XPath</h4><p>XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</p>
<pre><code>            * 使用Jsoup的Xpath需要额外导入jar包。
            * 查询w3cshool参考手册，使用xpath的语法完成查询
</code></pre><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取student.xml的path</span></span><br><span class="line">      String path = JsoupDemo6.class.getClassLoader().getResource("student.xml").getPath();</span><br><span class="line">      <span class="comment">//2.获取Document对象</span></span><br><span class="line">      Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">"utf-8"</span>);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//3.根据document对象，创建JXDocument对象</span></span><br><span class="line">      JXDocument jxDocument = <span class="keyword">new</span> JXDocument(document);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//4.结合xpath语法查询</span></span><br><span class="line">      <span class="comment">//4.1查询所有student标签</span></span><br><span class="line">      List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">"//student"</span>);</span><br><span class="line">      <span class="keyword">for</span> (JXNode jxNode : jxNodes) &#123;</span><br><span class="line">          System.out.println(jxNode);</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">      System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//4.2查询所有student标签下的name标签</span></span><br><span class="line">      List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="string">"//student/name"</span>);</span><br><span class="line">      <span class="keyword">for</span> (JXNode jxNode : jxNodes2) &#123;</span><br><span class="line">          System.out.println(jxNode);</span><br><span class="line">      &#125;</span><br><span class="line">		</span><br><span class="line">      System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//4.3查询student标签下带有id属性的name标签</span></span><br><span class="line">      List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="string">"//student/name[@id]"</span>);</span><br><span class="line">      <span class="keyword">for</span> (JXNode jxNode : jxNodes3) &#123;</span><br><span class="line">          System.out.println(jxNode);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">      <span class="comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span></span><br><span class="line">		</span><br><span class="line">      List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="string">"//student/name[@id='itcast']"</span>);</span><br><span class="line">      <span class="keyword">for</span> (JXNode jxNode : jxNodes4) &#123;</span><br><span class="line">          System.out.println(jxNode);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>xml</category>
      </categories>
  </entry>
  <entry>
    <title>左神算法-基础课-01-笔记</title>
    <url>/2020/10/07/zuoshen-basic-class-1/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>每次把当前数组最大值通过交换放到最后；时间复杂度：$O(N^2)$</p>
<p>对这个算法描述分为三个层面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宏观： 用end控制前面数组中的最大值存放的位置；它的初始值为N-1，结束值为1；</span><br><span class="line">中层： 把0 ~ end里的最大值传递到end位置；</span><br><span class="line">微观： 从&#96;0 ~ end-1&#96; 针对于相邻两个元素进行比较（位置0 和 位置1 比较； 然后位置1 和 位置2 比较；直到位置end-1 和 位置end 比较；）；</span><br><span class="line">	  前面的大于后面的则交换;</span><br></pre></td></tr></table></figure>
<p>微观层面的算法是对中层的具体实现；中层又是宏观中的一部分；</p>
<a id="more"></a>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><code>0 ~ N-1</code>范围内找到最小的放在 <code>0</code> 位置</p>
<p><code>1 ~ N-1</code>范围内找到最小的放在 <code>1</code> 位置</p>
<p><code>2 ~ N-1</code>范围内找到最小的放在 <code>2</code> 位置</p>
<p>每次找到<code>i ~ N-1</code>位置里的最小值的下标，与<code>i</code>位置进行交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1： 第 i 位置后的最小值放在 i 位置；于是 i 取值范围为 0 ~ N-2 ； （因为 N - 1 之后没有数了， 也就是它自己了）</span><br><span class="line">2： 需要一个变量 minIndex 来保存最小值的下标；在 i ~ N-1 范围里找最小值；</span><br><span class="line">3： 交换 i 位置上的数和 minIndex 上的数；</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><code>0 ~ 0</code>范围内的数只有一个，认为是已排序的；</p>
<p><code>0 ~ 1</code> 范围里的数，如果判断 <code>1</code> 位置上的数小于  <code>0</code> 位置上数则进行交换， 否则不交换；</p>
<p><code>0 ~ 2</code> 范围里的数，把 <code>2</code> 位置上的数从后往前依次比较，如果小于则，交换，如果大于则停止；</p>
<p>从已排序的部分最大值往前比较，如果大与它前一个值就不交换。如果小于则与他前一个值交换。</p>
<p>差不多已经排序了的数组可以用插入排序。这个和数据状况有关系。完全有序<code>O(N)</code> ；完全逆序就是 <code>O(N^2)</code> ;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1： 变量 i 表示要插入数的位置； i 的范围是 1 ~ N-1</span><br><span class="line">2： 要把 i 位置数插入到 0 ~ i-1 范围里面去；</span><br><span class="line">3： 变量 j 表示要插入值目前的位置： 如果 j 大于 0 且 j 位置上的数小于 j-1 位置上的数， 则交换， j--； 否则停止；</span><br><span class="line">    j 的范围是 1 ~ i</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong></p>
<p>​    最好情况 <code>O(N)</code>    最差情况 <code>O(N^2)</code>    平均情况 <code>O(N)</code> ~  <code>O(N^2)</code></p>
<p>​    </p>
<h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="对数器的作用"><a href="#对数器的作用" class="headerlink" title="对数器的作用"></a>对数器的作用</h3><p><strong>1. 无测试样例时可以用对数器测试代码</strong></p>
<p><strong>2. 小样本测试过了，但是面对大样本测试出错，可以用对数器帮助修改bug</strong></p>
<p><strong>3.  如何证明贪心策略是对的？这是很难的。所以用对数器可以试贪心策略是对是错。</strong></p>
<h3 id="对数器的构成"><a href="#对数器的构成" class="headerlink" title="对数器的构成"></a>对数器的构成</h3><p><strong>1. 产生随机样本的函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	生成随机长度， 随机内容的数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> size, <span class="keyword">int</span> maxValue)</span><br></pre></td></tr></table></figure>
<p>  <img src="/2020/10/07/zuoshen-basic-class-1/image-20200927100143765.png" alt="image-20200927100143765"></p>
<p><strong>2. 一个绝对正确的方法</strong></p>
<p>那么这个方法可能是来自于系统提供的；</p>
<p>或者是自己写的一个绝对正确但是时间复杂度过不了的方法；</p>
<p><strong>3. 大样本测试</strong></p>
<p>我们把自动生成的测试样例输入进 <code>绝对正确的方法</code> 和 <code>想要测得方法</code> ； 然后判断他们的输出是否一致；把这个过程重复很多次，可以是很大的值，也就是说可以也许穷尽所有的可能性；</p>
<p><img src="/2020/10/07/zuoshen-basic-class-1/image-20200927100804767.png" alt=" "></p>
<p><img src="/2020/10/07/zuoshen-basic-class-1/image-20200927100836217.png" alt="image-20200927100836217"></p>
<p><img src="/2020/10/07/zuoshen-basic-class-1/image-20200927100948115.png" alt="image-20200927100948115"></p>
<h3 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h3><ol>
<li>有一个你想要测的方法a，</li>
<li>实现一个绝对正确但是复杂度不好的方法b，</li>
<li>实现一个随机样本产生器</li>
<li>实现比对的方法</li>
<li>把方法a和方法b比对很多次来验证方法a是否正确。</li>
<li>如果有一个样本使得比对出错，打印样本分析是哪个方法出错；</li>
<li>当样本数量很多时比对测试依然正确，可以确定方法a已经 正确。</li>
</ol>
<h3 id="笔试的时候要准备对数器"><a href="#笔试的时候要准备对数器" class="headerlink" title="笔试的时候要准备对数器"></a>笔试的时候要准备对数器</h3><p>我大概想到要写一个类；然后由各种继承得到；要覆写的东西也是很多；</p>
<p>python的话，有使输入格式规范的包；</p>
<h2 id="剖析递归行为和递归行为时间复杂度的估算"><a href="#剖析递归行为和递归行为时间复杂度的估算" class="headerlink" title="剖析递归行为和递归行为时间复杂度的估算"></a>剖析递归行为和递归行为时间复杂度的估算</h2><p><strong>剖析递归行为</strong></p>
<p>​    把当前运行函数压进系统栈中，保留当前函数的所有信息。调用的函数就在栈顶。</p>
<p>​    任何递归行为都可以改为非递归；</p>
<p><strong>递归行为时间复杂度的估算</strong></p>
<p>​    大部分的递归过程都可以用这个公式来表示</p>
<script type="math/tex; mode=display">
T(N) = aT( \frac{N}{b} ) + O(N^d)</script><p>$N$表示样本量，$T(N)$表示时间复杂度；那么这个复杂度分成了$a$个$T(N/b)$个子问题的过程加上一个$O(N^d)$剩余时间过程的时间；</p>
<p>满足这个公式的递归过程的时间复杂度的计算如下：</p>
<script type="math/tex; mode=display">
T(N) = 
    \begin{cases}
    O(N^{log_ba}), & {log_ba} > d \\
    O(N^d*{logN}), & {log_ba} = d \\
    O(N^d), & {log_ba} < d
    \end{cases}</script><p>但是像$T(N)=T(\frac{N}{5})+T(\frac{2}{3}N)+O(N^2)$这样的公式就不符合上面的这个过程；</p>
<p><strong>补充阅读</strong>：<a href="https://blog.gocalf.com/algorithm-complexity-and-master-theorem" target="_blank" rel="noopener">算法的复杂度与 Master 定理</a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把一个数组分为左右两个部分。先把左侧的排好序，再把右侧的排好序。最后用外排的方式排好序。这个过程的时间复杂度是下式：</p>
<script type="math/tex; mode=display">
T(N) = 2 *T(\frac{N}{2})+O(N)</script><p>把这个公式带入到上一节，就可以查到它的时间复杂度为 $O(N*logN)$ 。并且归并排序的过程仅仅需要用到一个和原数组长度一样的数组，那么它的空间复杂度为$O(N)$</p>
<h3 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h3><p>针对一个数组将其分为两个部分，分别对这两个部分用归并排序。然后对整个数组进行一个外部排序。</p>
<p>外部排序：针对有序的两个数组；分别用两个指针指向他们的头部。然后依次往一个辅助数组里填入两个指针中更小的值；直到两个部分都填入了辅助数组后，再把已排序好的填回原数组。</p>
<h3 id="归并排序的组成部分"><a href="#归并排序的组成部分" class="headerlink" title="归并排序的组成部分"></a>归并排序的组成部分</h3><ol>
<li><p>主函数用来对整个数组进行排序，它调用第二个组成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对未排序的数组<code>L</code>到<code>R</code>部分的排序过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果L==R则范围里只有一个数，那么直接返回就好了。可以认定他是有序的；</span></span><br><span class="line"><span class="comment">  如果有多余一个的数则把它分为前后两部分，分别进行归并排序。然后再对这两部分进行外部排序；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并<code>L</code>到<code>mid</code> 和 <code>mid+1</code>到<code>R</code>两个排序好的部分：把她两排序整合到一个辅助数组里，然后再拷贝回去；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	外部排序需要：一个辅助数组（大小为：R-L+1），两个指针（分别指向已排序好的两部分的头部），辅助数组下标；</span></span><br><span class="line"><span class="comment">	过程：</span></span><br><span class="line"><span class="comment">		1. 谁小填谁：进行一个循环（两个指针都不超过他们的边界的情况下），谁小就把谁填进辅助数组中；</span></span><br><span class="line"><span class="comment">		2. 谁没了把另一个剩下的全部填入辅助数组中：因为上一个循环已经破除则一定有且只有一个指针越界（因为每次只填入一个数，一次只可能有一个越界）</span></span><br><span class="line"><span class="comment">			所以这里会分别对两个指针进行判断是否到边界。他们是非此即彼的关系，即只会执行一个。</span></span><br><span class="line"><span class="comment">		3. 最后需要把 辅助数组拷贝回 L到R之间的位置；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="归并排序的应用：小和问题和逆序对问题"><a href="#归并排序的应用：小和问题和逆序对问题" class="headerlink" title="归并排序的应用：小和问题和逆序对问题"></a>归并排序的应用：小和问题和逆序对问题</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子</span><br><span class="line"></span><br><span class="line">[1,3,4,2,5] </span><br><span class="line"></span><br><span class="line">1左边比1小的数，没有； </span><br><span class="line"></span><br><span class="line">3左边比3小的数，1； </span><br><span class="line"></span><br><span class="line">4左边比4小的数，1、3； </span><br><span class="line"></span><br><span class="line">2左边比2小的数，1； </span><br><span class="line"></span><br><span class="line">5左边比5小的数，1、3、4、2； </span><br><span class="line"></span><br><span class="line">所以小和为1+1+3+1+1+3+4+2&#x3D;16</span><br></pre></td></tr></table></figure>
<p><strong>注意这个题不是算一个数之前有多少比它小的个数，而是算比它小的数的和。</strong></p>
<h4 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h4><p>这个笨办法就是进行遍历看这个数之前有几个数比它小；可以把它做对数器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序的思路"><a href="#归并排序的思路" class="headerlink" title="归并排序的思路"></a>归并排序的思路</h4><pre class="mermaid">graph TD
A[1,3,4,2,5] --> B[1,3,4]
B --> D[1,3]
D --> H[1]
D --> I[3]
B --> E[4]
A --> C[2,5]
C --> F[2]
C --> G[5]
H -->|产生一个小和| J[1,3]
I -->|数字1*后面长度1| J
J -->| 数字1*长度1| K[1,3,4]
E -->| 数字3*长度1| K
F -->| 数字2*长度1| L[2,5]
G --> L
K -->|数字1*长度2 + 不产生小和| M[1,2,3,4,5]
L -->|数字3*长度1 + 数字4*长度1| M</pre>



<h4 id="归并排序求小和的组成部分"><a href="#归并排序求小和的组成部分" class="headerlink" title="归并排序求小和的组成部分"></a>归并排序求小和的组成部分</h4><ol>
<li><p>主函数，主要就是判断输入进来的数组是否符合规定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序求得数组小范围内的小和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure>
<p>这里代码与归并排序都是一样的不过在比较时多了一句算小和的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + <span class="number">1</span>) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>对数器</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-01-代码</title>
    <url>/2020/10/07/zuoshen-basic-class-1-code/</url>
    <content><![CDATA[<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>常用的获取随机数组的技巧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random()*(n-m)+m 	<span class="comment">//生成大于等于m小于n的随机数；</span></span><br></pre></td></tr></table></figure>
<p>因为这个课程开始针对对数器的认识就是排序。它有自身的输入输出的特点。所以对数器是这样写的。但是针对不同的数据结构类型，对数器的写法是不同的。</p>
<a id="more"></a>
<h1 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h1><p><code>i==j</code>时这个交换功能会出错；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span> ; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i-<span class="number">1</span>] &gt; arr[i])&#123;</span><br><span class="line">                swap(arr,i-<span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>] ; j--) &#123;</span><br><span class="line">            swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[minIndex] &gt; arr[j] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);   <span class="comment">// 位运算优先级低于加减，所以一定要加上括号</span></span><br><span class="line">    sortProcess(arr, L, mid);</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[i + L] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, l, m) + mergeSort(arr, m + <span class="number">1</span>, r) + merge(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + <span class="number">1</span>) : <span class="number">0</span>;	<span class="comment">// 最重要的一句</span></span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>对数器</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-02-代码</title>
    <url>/2020/10/19/zuoshen-basic-class-2-code/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        swap(arr, l + (<span class="keyword">int</span>)(Math.random() * (r - l + <span class="number">1</span>)), r);   <span class="comment">// 随机找一个数作为分割的数字；</span></span><br><span class="line">        <span class="keyword">int</span>[] p = partition(arr,l, r);  <span class="comment">// 返回less部分后一位和more部分前一位组成的数组；</span></span><br><span class="line">        quickSort(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;    <span class="comment">// 荷兰国旗式的partition</span></span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">            swap(arr, ++less, l++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;</span><br><span class="line">            swap(arr, --more, l);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">        swap(arr, index, (index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = arr[index] &lt; arr[largest] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, index, largest);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-03</title>
    <url>/2020/12/01/zuoshen-basic-class-3/</url>
    <content><![CDATA[<h1 id="题目一：用数组结构实现大小固定的队列和栈"><a href="#题目一：用数组结构实现大小固定的队列和栈" class="headerlink" title="题目一：用数组结构实现大小固定的队列和栈"></a>题目一：用数组结构实现大小固定的队列和栈</h1><p>栈与队列的数据结构都是很熟悉的了；</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>具体在这里他们的实现：栈的实现涉及：压栈，出栈，返回栈顶元素，返回栈元素个数等等；在栈满时压栈会报错；在栈空时出栈会报错；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer [] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The Stack is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[size++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[--size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="队"><a href="#队" class="headerlink" title="队"></a>队</h2><p>另外的是队列的实现；一般普通的方法是维护队头和队尾两个变量。左神在这里引入了第三个变量：size，也就是队列中元素的个数；</p>
<p>如果size是数组的大小的话，那么就不能从队尾入队了，如果小于数组的大小，则可以入队；</p>
<p>如果size是0的话，就不能从队头出队；如果大于0，就可以从队头入队；</p>
<p>这样对于入队与出队的操作就只需要看size就可以；队头和队尾两个变量就没有关系了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer [] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> Integer first;</span><br><span class="line">    <span class="keyword">private</span> Integer last;   <span class="comment">// 指向队尾的后一格（可能空，也可能不空）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        first = last = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[first];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[last] = obj;</span><br><span class="line">        last = last == arr.length - <span class="number">1</span> ? <span class="number">0</span> : last + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">int</span> tmp = first;</span><br><span class="line">        first = first == arr.length - <span class="number">1</span> ? <span class="number">0</span> : first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【思考】如果没有size该如何实现</p>
<p>如果没有size则在队为空时，队头 <code>start</code> 和队尾 <code>end</code> 都指向一个位置；</p>
<p>入队时要判断是否还有空间，则就是 <code>end</code> 的下一个位置如果不是<code>start</code> 就说明可以入队；这里 <code>end</code> 的下一个位置分为两种情况，<code>end</code>到达数组尾部，他的下一个位置是0，<code>end</code>未到达数组尾部，他的下一个位置是 <code>end + 1</code>；</p>
<p>出队时要判断是否队为空，则就是 <code>start</code> 和 <code>end</code>相等；</p>
<h1 id="题目二：实现栈，并且实现返回栈中最小元素的操作"><a href="#题目二：实现栈，并且实现返回栈中最小元素的操作" class="headerlink" title="题目二：实现栈，并且实现返回栈中最小元素的操作"></a>题目二：实现栈，并且实现返回栈中最小元素的操作</h1><p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201024110123120.png" alt="image-20201024110123120"></p>
<p>【实现】：这个栈有两个数组，一个数组是 <code>data</code> 数组，另一个数组是 <code>min</code>最小值数组；</p>
<p>在往<code>data</code>和<code>min</code>是两个同步运作的数组；</p>
<p><code>data</code>入栈，<code>min</code>也入栈：<code>data</code>入栈一个数字 <code>x</code>，则把这个数字与<code>min</code>的栈顶比较，把较小值入<code>min</code>栈；当然如果<code>min</code>为空，则直接入栈就好了；</p>
<p><code>data</code>出栈，<code>min</code>也出栈：这个没得说，他们的个数是一样的；</p>
<h2 id="实现一：最小栈与数据栈同步"><a href="#实现一：最小栈与数据栈同步" class="headerlink" title="实现一：最小栈与数据栈同步"></a>实现一：最小栈与数据栈同步</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newMin = <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现二：最小栈与数据栈不一定同步"><a href="#实现二：最小栈与数据栈不一定同步" class="headerlink" title="实现二：最小栈与数据栈不一定同步"></a>实现二：最小栈与数据栈不一定同步</h2><p>之前两个栈是同步的过程；而当进来的数大于当前最小值时的过程可以通过判断不用往最小栈里添加。弹出栈时，当当前栈中最小值被弹出了，最小栈才做改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目三：用队列实现栈，用栈实现队列"><a href="#题目三：用队列实现栈，用栈实现队列" class="headerlink" title="题目三：用队列实现栈，用栈实现队列"></a>题目三：用队列实现栈，用栈实现队列</h1><p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201024112244638.png" alt="image-20201024112244638"></p>
<h2 id="用队列实现栈结构"><a href="#用队列实现栈结构" class="headerlink" title="用队列实现栈结构"></a>用队列实现栈结构</h2><p>需要两个队列；</p>
<p>一个数据队列 <code>data</code>，一个辅助队列 <code>help</code> ；</p>
<p>入队就把数据放进 <code>data</code>；</p>
<p>弹出时需要弹出进入 <code>data</code> 的最后一个元素；所以需要把队列前面的元素出队放入 <code>help</code> 当中；得到和栈一样的结果；</p>
<p>但此时的 <code>help</code> 成了 <code>data</code> 的作用，所以把他们的引用交换一下就可以；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueuesStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueuesStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        queue.add(pushInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; tmp = help;</span><br><span class="line">        help = queue;</span><br><span class="line">        queue = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>需要两个栈；</p>
<p><code>push</code> 栈 和 <code>pop</code> 栈</p>
<p>往 <code>push</code> 栈里加入数据；若想得到该队列的出队。则需要从 <code>push</code> 栈中把所有数据倒到 <code>pop</code> 栈中；从<code>pop</code> 栈栈顶返回；</p>
<p>倒数据有两个规则：</p>
<p>1）<code>push</code> 栈往 <code>pop</code> 栈里倒数据要一次性倒完；不要有剩余；</p>
<p>2）如果 <code>pop</code> 栈不为空，那么<code>push</code> 栈一定不要倒；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackpush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackpop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacksQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackpush = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stackpop = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        stackpush.push(pushInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackpush.empty() &amp;&amp; stackpop.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackpop.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.empty()) &#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackpush.empty() &amp;&amp; stackpop.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackpop.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.empty()) &#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackpop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目四-猫狗队列"><a href="#题目四-猫狗队列" class="headerlink" title="题目四 猫狗队列"></a>题目四 猫狗队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>宠物、狗和猫的类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现一种狗猫队列的结构，要求如下：</p>
<ol>
<li>用户可以调用add方法将cat类或dog类的 实例放入队列中；</li>
<li>用户可以调用pollAll方法，将队列中所有的实例按照进队列 的先后顺序依次弹出；</li>
<li>用户可以调用pollDog方法，将队列中dog类的实例按照 进队列的先后顺序依次弹出；</li>
<li>用户可以调用pollCat方法，将队列中cat类的实 例按照进队列的先后顺序依次弹出；</li>
<li>用户可以调用isEmpty方法，检查队列中是 否还有dog或cat的实例；</li>
<li>用户可以调用isDogEmpty方法，检查队列中是否有dog 类的实例；</li>
<li>用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>两个队列分别保存狗和猫；需要最早进的狗与猫这两个操作可以得以解决；</p>
<p>在这两个队列里保存的是包装后的狗和猫，另外包装的信息是他们进入队列的时间戳；这样对比两个队列的头部来返回最早进入队列的宠物；</p>
<p><strong>对Pet的包装</strong></p>
<p>有添加进入队列的时间戳；获取宠物的方法，获取时间戳的方法，获取宠物类型的方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PetEnterQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQueue</span><span class="params">(Pet pet, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEnterPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pet.getPetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>猫狗队列的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DogCatQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQ;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogCatQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dogQ = <span class="keyword">new</span> LinkedList&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="keyword">this</span>.catQ = <span class="keyword">new</span> LinkedList&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pet pet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"dog"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dogQ.add(<span class="keyword">new</span> PetEnterQueue(pet, count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"cat"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.catQ.add(<span class="keyword">new</span> PetEnterQueue(pet, count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, not dog or cat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty() &amp;&amp; !<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dogQ.peek().getCount() &lt; <span class="keyword">this</span>.catQ.peek().getCount()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.poll().getPet();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.catQ.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">pollDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Dog) dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">pollCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Cat) catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.isEmpty() &amp;&amp; <span class="keyword">this</span>.catQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目五-转圈打印矩阵"><a href="#题目五-转圈打印矩阵" class="headerlink" title="题目五 转圈打印矩阵"></a>题目五 转圈打印矩阵</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个整形矩阵matrix，请按照转圈的方式打印它；</p>
<blockquote>
<p>1     2     3     4 </p>
<p>5     6     7     8 </p>
<p>9    10    11    12</p>
</blockquote>
<p>转圈打印的结果为： <code>1，2，3，4，8，12，11，10，9，5，6，7</code></p>
<p><strong>要求</strong>：额外空间复杂度为 <code>O(1)</code></p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201106091549670.png" alt="image-20201106091549670"></p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_PrintMatrixSpiralOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123;</span><br><span class="line">            printEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (tR == dR)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tC; i &lt;= dC ; i++) &#123;</span><br><span class="line">                System.out.println(m[tR][i] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tR; i &lt;= dR ; i++) &#123;</span><br><span class="line">                System.out.println(m[i][tC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> curC = tC;</span><br><span class="line">            <span class="keyword">int</span> curR = tR;</span><br><span class="line">            <span class="keyword">while</span> (curC != dC)&#123;</span><br><span class="line">                System.out.println(m[curR][curC++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != dR)&#123;</span><br><span class="line">                System.out.println(m[curR++][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">                System.out.println(m[curR][curC--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != tR)&#123;</span><br><span class="line">                System.out.println(m[curR--][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,<span class="number">12</span> &#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>,<span class="number">16</span>&#125; &#125;;</span><br><span class="line">        spiralOrderPrint(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目六-旋转正方形矩阵"><a href="#题目六-旋转正方形矩阵" class="headerlink" title="题目六 旋转正方形矩阵"></a>题目六 旋转正方形矩阵</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 </p>
<p>【要求】 额外空间复杂度为O(1)。</p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_RotateMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tR &lt; dR)&#123;</span><br><span class="line">            rotateEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = dC - tC;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != times; i++) &#123;</span><br><span class="line">            tmp = m[tR][tC + i];</span><br><span class="line">            m[tR][tC + i] = m[dR - i][tC];</span><br><span class="line">            m[dR - i][tC] = m[dR][dC - i];</span><br><span class="line">            m[dR][dC - i] = m[tR + i][dC];</span><br><span class="line">            m[tR + i][dC] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;,</span><br><span class="line">                &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        rotate(matrix);</span><br><span class="line">        System.out.println(<span class="string">"========="</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目七-反转单向和双向链表"><a href="#题目七-反转单向和双向链表" class="headerlink" title="题目七 反转单向和双向链表"></a>题目七 反转单向和双向链表</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>【题目】分别实现反转单向链表和反转双向链表的函数；</p>
<p>【要求】如果链表长度为<strong>N</strong>，时间复杂度要求为 $O(N)$ , 额外空间复杂度要求为 $O(1)$ ;</p>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点类；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// tmp指向头节点</span></span><br><span class="line">            tmp = head;</span><br><span class="line">            <span class="comment">// tmp拿着头节点，head向后走</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            tmp.next = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向链表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转双向链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseList</span><span class="params">(DoubleNode head)</span></span>&#123;</span><br><span class="line">        DoubleNode p = head;</span><br><span class="line">        DoubleNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.last = p.next;</span><br><span class="line">            p.next = tmp;</span><br><span class="line">            tmp = p;</span><br><span class="line">            p = p.last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Linked List: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印双向链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDoubleLinkedList</span><span class="params">(DoubleNode head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double Linked List "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        printLinkedList(head1);</span><br><span class="line">        head1 = reverseList(head1);</span><br><span class="line">        printLinkedList(head1);</span><br><span class="line"></span><br><span class="line">        DoubleNode head2 = <span class="keyword">new</span> DoubleNode(<span class="number">1</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> DoubleNode(<span class="number">2</span>);</span><br><span class="line">        head2.next.last = head2;</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> DoubleNode(<span class="number">3</span>);</span><br><span class="line">        head2.next.next.last = head2.next;</span><br><span class="line">        head2.next.next.next = <span class="keyword">new</span> DoubleNode(<span class="number">4</span>);</span><br><span class="line">        head2.next.next.next.last = head2.next.next;</span><br><span class="line">        printDoubleLinkedList(head2);</span><br><span class="line">        printDoubleLinkedList(reverseList(head2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目八-“之”字形打印矩阵"><a href="#题目八-“之”字形打印矩阵" class="headerlink" title="题目八 “之”字形打印矩阵"></a>题目八 “之”字形打印矩阵</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110092314568.png" alt="image-20201110092314568"></p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110092351277.png" alt="image-20201110092351277"></p>
<h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>在矩阵中设计两个初始位置相同的点；</p>
<p>A和B分别有着不同的运动轨迹；A每次往右移动直到到矩阵的边缘再往下移动；B每次往下移动直到矩阵的边缘再往右移动</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110092711246.png" alt="image-20201110092711246"></p>
<p>经历过一次移动之后，A和B分别到达的位置，可以看出A和B总是处在一条线的两端：</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110092941055.png" alt="image-20201110092941055"></p>
<p>此时B到达矩阵的边缘，开始往右走了；此时A和B仍处于一个对角线上；</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110093044928.png" alt="image-20201110093044928"></p>
<p>依次类推，按顺序打印A和B所在的线，不过按照 “之” 字型打印，就需要看好是从A到B还是从B到A；需要一个布尔类型的变量来设定这件事情；</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110093542635.png" alt="image-20201110093542635"></p>
<p>接下来就是实现一个打印函数，这个函数需要被告知矩阵的A点和B点，然后还需要告知打印的方向；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrixZigZag</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aR = <span class="number">0</span>, bR = <span class="number">0</span>, aC = <span class="number">0</span>, bC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (aR != endR) &#123;</span><br><span class="line">            printLevel(matrix, aR, aC, bR, bC, fromUp);</span><br><span class="line">            aR = aC == endC ? aR + <span class="number">1</span> : aR;</span><br><span class="line">            aC = aC == endC ? aC : aC + <span class="number">1</span>;</span><br><span class="line">            bC = bR == endR ? bC + <span class="number">1</span> : bC;  <span class="comment">// 这里需要注意这几个语句的顺序；被判断的值一定是最后才修改的；</span></span><br><span class="line">            bR = bR == endR ? bR : bR + <span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLevel</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC, <span class="keyword">boolean</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f)&#123;</span><br><span class="line">            <span class="keyword">while</span> (tR != dR + <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(m[tR++][tC--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(dR != tR - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(m[dR--][dC++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125; &#125;;</span><br><span class="line">        printMatrixZigZag(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目九-在行和列都排好序的矩阵中找数"><a href="#题目九-在行和列都排好序的矩阵中找数" class="headerlink" title="题目九 在行和列都排好序的矩阵中找数"></a>题目九 在行和列都排好序的矩阵中找数</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>在行列都排好序的矩阵中找数；</p>
<p>给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110104951864.png" alt="image-20201110104951864"></p>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>从左上角或右下角开始找，每次都能排除一行或一列的数据；</p>
<p>【思路】从数据状况考虑出发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_09_FindNumInSortedMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; value) &#123;</span><br><span class="line">                col --;</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                row ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,<span class="comment">// 0</span></span><br><span class="line">                &#123; <span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span> &#125;,<span class="comment">// 1</span></span><br><span class="line">                &#123; <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span> &#125;,<span class="comment">// 2</span></span><br><span class="line">                &#123; <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span> &#125;,<span class="comment">// 3</span></span><br><span class="line">                &#123; <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span> &#125;,<span class="comment">// 4</span></span><br><span class="line">                &#123; <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">122</span> &#125;,<span class="comment">// 5</span></span><br><span class="line">                &#123; <span class="number">166</span>, <span class="number">176</span>, <span class="number">186</span>, <span class="number">187</span>, <span class="number">190</span>, <span class="number">195</span>, <span class="number">200</span> &#125;,<span class="comment">// 6</span></span><br><span class="line">                &#123; <span class="number">233</span>, <span class="number">243</span>, <span class="number">321</span>, <span class="number">341</span>, <span class="number">356</span>, <span class="number">370</span>, <span class="number">380</span> &#125; <span class="comment">// 7</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">233</span>;</span><br><span class="line">        System.out.println(isContains(matrix, K));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目十-打印两个有序链表的公共部分"><a href="#题目十-打印两个有序链表的公共部分" class="headerlink" title="题目十 打印两个有序链表的公共部分"></a>题目十 打印两个有序链表的公共部分</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给定两个有序链表的头指针<strong>head1</strong>和<strong>head2</strong>，打印两个链表的公共部分</p>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_10_PrintCommonPart</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要一个节点类；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Common Part:  "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head1.value &lt; head2.value) &#123;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(head1.value + <span class="string">" "</span>);</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Linked List: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node1.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        node1.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node1.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        node2.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node2.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node2.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        node2.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        printLinkedList(node1);</span><br><span class="line">        printLinkedList(node2);</span><br><span class="line">        printCommonPart(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目十一-判断一个链表是否为回文结构"><a href="#题目十一-判断一个链表是否为回文结构" class="headerlink" title="题目十一 判断一个链表是否为回文结构"></a>题目十一 判断一个链表是否为回文结构</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201110110900046.png" alt="image-20201110110900046"></p>
<h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><p><strong>思路一</strong>：一个长度与链表一样长的栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// need n extra space 一个长度与链表一样长的栈；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; nodes = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.pop().value != head.value)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong>：快慢指针 + 栈 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// need n/2 extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next != <span class="keyword">null</span> ? fast.next.next : fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; nodes = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.push(slow);</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.pop().value != head.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong>三：快慢指针，快指针走两步，慢指针走一步；（其实这个方法也是找到链表中心点的方法）</p>
<ul>
<li>快指针每次走两步直到末尾，此时慢指针指向中心<ul>
<li>当链表节点个数为偶数时，慢指针刚好指向第 $\frac{N}{2}$ 的位置</li>
<li>当链表节点个数为奇数时，快指针会移动 $\frac{N+1}{2}$ 次，慢指针也会移动 $\frac{N+1}{2}$ 次（比被2整数结果后面的一个，例如：N=5，那么移动三次指向第4个节点；N=9，移动5次指向第6个节点）；</li>
</ul>
</li>
<li>然后把慢指针之后的链表逆序；</li>
<li>与头节点开始与慢指针比较是否是回文结构；</li>
<li>然后恢复原链表结构；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// need O(1) extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> ( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node tmp = <span class="keyword">null</span>;</span><br><span class="line">    fast = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        tmp.next = fast;</span><br><span class="line">        fast = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别从head 和 fast出发查看是否一样</span></span><br><span class="line">    slow = head;    <span class="comment">//  保存头节点</span></span><br><span class="line">    tmp = fast; <span class="comment">// 保存最后一个节点</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.value != slow.value)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复原链表</span></span><br><span class="line">    fast = tmp.next;    <span class="comment">// 保存最后一个节点最后一个值</span></span><br><span class="line">    tmp.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = fast;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow.next = tmp;</span><br><span class="line">        tmp = slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目十二-将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#题目十二-将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="题目十二 将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>题目十二 将单向链表按某值划分成左边小、中间相等、右边大的形式</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p><strong>【题目】</strong> 给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。 除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9-&gt;0-&gt;4-&gt;5- &gt;1，pivot=3。调整后链表可以是1-&gt;0-&gt;4-&gt;9-&gt;5，也可以是0-&gt;1-&gt;9-&gt;5-&gt;4。总 之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部 分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做要求。</p>
<p><strong>【进阶】</strong>在原问题的要求之上再增加如下两个要求。 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的 顺序与原链表中节点的先后次序一致。 例如：链表9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。 调整后的链表是0-&gt;1-&gt;9-&gt;4-&gt;5。 在满足原问题要求的同时，左部分节点从左到 右为0、1。在原链表中也 是先出现0，后出现1；中间部分在本例中为空，不再 讨论；右部分节点 从左到右为9、4、5。在原链表中也是先出现9，然后出现4， 最后出现5。 如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。</p>
<h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><p><strong>思路一</strong>：把链表套进一个数组当中；数组的元素就是链表的节点；然后用荷兰国旗问题进行解决；这样子的解决方案是不能达到稳定性要求的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodearr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodearr.length ; i++) &#123;</span><br><span class="line">        nodearr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodearr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nodearr.length; i++) &#123;</span><br><span class="line">        nodearr[i-<span class="number">1</span>].next = nodearr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodearr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodearr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, index++, ++small);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot)&#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr,index, --big);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node tmp = nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong>：</p>
<ul>
<li><p>用分别准备三个链表变量分别保存小于，等于和大于的组；</p>
<p>每个链表需要两个变量保存头和尾</p>
</li>
<li><p>然后把三个链表串起来就可以实现；</p>
<p>需要判断每个链表是否存在，涉及一个较为复杂的编程过程；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node bH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node bT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node cur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = cur;</span><br><span class="line">                sT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = cur;</span><br><span class="line">                sT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = cur;</span><br><span class="line">                eT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = cur;</span><br><span class="line">                eT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bH = cur;</span><br><span class="line">                bT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bT.next = cur;</span><br><span class="line">                bT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// small and equal reconnect</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目十三-复制含有随机指针的链表"><a href="#题目十三-复制含有随机指针的链表" class="headerlink" title="题目十三 复制含有随机指针的链表"></a>题目十三 复制含有随机指针的链表</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>【题目】 一种特殊的链表节点类描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node next; </span><br><span class="line">    <span class="keyword">public</span> Node rand; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node类中的value是节点值，<strong>next</strong>指针和正常单链表中<strong>next</strong>指针的意义 一 样，都指向下一个节点，<strong>rand</strong>指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向<strong>null</strong>。给定一个由 Node节点类型组成的无环单链表的头节点<strong>head</strong>，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。</p>
<p>进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 $O(N)$ 内完成原问题要实现的函数。</p>
<h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><p>【我的考虑】：直接复制相对应的节点把他们的节点的值和<strong>next</strong> 指针复制好。接着问题出现了 <strong>rand</strong> 是无法复制的。要找到第一个节点的 <strong>rand</strong> 指针需要和原始链表一样去同步遍历才能找到。这样无疑会有很大的时间复杂度；</p>
<p>【解法一】把原始链表与新链表通过哈希表的方式来建立联系</p>
<p>哈希表中的 <strong>key</strong> 是原始链表中的节点，相对应的 <strong>value</strong> 是它复制后的节点。要找到新链表节点的 <strong>next</strong> 和 <strong>rand</strong>，可以通过哈希表查找原始链表节点相对应节点来完成赋值；</p>
<p>【解法二】原地把原始链表与新链表关联起来：</p>
<p>用 $i’$ 来表示 $i$ 节点的复制节点 ，那么把它关联起来的方式是 ：</p>
<script type="math/tex; mode=display">
1  -> 1'  ->  2  -> 2'  ->  3  ->  3' -> null</script><p>把原来的链表组织成这样的形式；每次从链表中去取出两个节点 $1  -&gt; 1’$ ；先复制 <strong>rand</strong> 指针，$1$ 的 <strong>rand</strong> 指针可以直接找到。 而复制的新的 $1’$ 的 <strong>rand</strong> 指针可以从 $1$ 的 <strong>rand</strong> 指针找到对应节点的下一个就是 $1’$ 的 <strong>rand</strong> 指针的对应节点；</p>
<p>最后再把 <strong>next</strong> 指针复原组织好。即可完成；</p>
<h1 id="题目十四-两个单链表相交的一系列问题"><a href="#题目十四-两个单链表相交的一系列问题" class="headerlink" title="题目十四 两个单链表相交的一系列问题"></a>题目十四 两个单链表相交的一系列问题</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>【题目】 在本题中，单链表可能有环，也可能无环。</p>
<p>给定两个 单链表的头节点 head1和head2，这两个链表可能相交，也可能 不相交。</p>
<p>请实现一个函数， 如果两个链表相交，请返回相交的 第一个节点；</p>
<p>如果不相交，返回null 即可。 </p>
<p>要求：如果链表1 的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外 空间复杂度请达到O(1)。</p>
<h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><p>【我的考虑】</p>
<ol>
<li><p>先分类考虑</p>
<p>有环相交，有环不相交，无环相交，无环不相交</p>
<p>然后发现任何一个都很复杂；</p>
</li>
</ol>
<p><strong>问题一 如何判断链表有没有环</strong> </p>
<p>​    【方法一】哈希表</p>
<p>​    通过一个哈希表，遍历链表节点；每遍历一个节点如果它不在集合中就把它放集合当中；如果第一个发现在集合中的节点，那就说明这是链表的环的入口；如果判断到节点为空，则说明不存在环；</p>
<p>​    <strong>实现</strong> : 判断一个链表是否有环，如果有，则返回环的第一个节点；没有则返回空；</p>
<p>​    【方法二】快慢指针</p>
<ul>
<li><p>快指针走两步，慢指针走一步；</p>
</li>
<li><p>直到相遇；</p>
</li>
<li><p>如果相遇，快指针回到开头，由一次走两步变为一次走一步，【结论】<strong>快指针与慢指针一定会在入环节点处相遇</strong>；</p>
</li>
</ul>
<p><strong>问题二 如何判断一个无环单链表第一个相交的节点 </strong> </p>
<p>   由问题一我们可以知道是否有环，则可以考虑两个链表调用了判断是否有环函数后都返回为空，这个情况下他们是否有相交的节点</p>
<p>​    【方法一】哈希表</p>
<p>​    同样是用一个哈希表；遍历第一个链表节点，都放入哈希表当中去。</p>
<p>​    然后依次遍历第二个链表，在哈希表中查。如果都没有，说明它们不相交；如果第二个链表的节点在哈希表中出现了，则说明这个节点是相交节点；</p>
<p>​    【方法二】</p>
<p>​    遍历第一个链表，得到他的长度与最后一个节点的指针；同样的遍历第二个链表，得到他的长度和最后一个节点的指针；</p>
<ul>
<li>显而易见：判断 两个链表的最后一个节点是否是一个节点即可判断他们是否相交；</li>
<li>如果它们相交，根据链表长度去遍历；<ul>
<li>让长的链表先走，走到与短的一样长时它们一起走。</li>
<li>然后判断两个链表当下节点是否一样，直到它们指向节点一样也就是找到了相交的第一个节点；</li>
</ul>
</li>
</ul>
<p><strong>问题三 如何判断一个有环单链表与无环单链表第一个相交的节点</strong> </p>
<p>​    不可能相交；</p>
<p><strong>问题四 如何判断两个有环单链表第一个相交的节点 </strong></p>
<p>三种情况：</p>
<p><img src="/2020/12/01/zuoshen-basic-class-3/image-20201119153209312.png" alt="image-20201119153209312"></p>
<ul>
<li>如果判断是有环并且得到的入环节点位置相同，他就是结构2：<ul>
<li>此时也就等同于无环链表相交，此时相交位置与入环节点没有关系；</li>
</ul>
</li>
<li>如果入环节点不相同，他可能是结构1也可能是结构2：<ul>
<li>此时从链表一的入环节点出发，遍历链表；<ul>
<li>如果碰到链表二的入环节点：则说明是第三种结构<ul>
<li>此时返回链表一的入环节点和链表二的入环节点都是对的；</li>
</ul>
</li>
<li>如果链表一的入环节点遍历回去了，还没碰到说明是结构一；<ul>
<li>不存在相交节点；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head.next;</span><br><span class="line">    Node n2 = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = head;</span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n ++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n --;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// cur1 指向较长的链表</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// cur2 指向另一个</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n --;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur1 和 cur2 同时出发</span></span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n --;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// cur1 指向较长的链表</span></span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// cur2 指向另一个</span></span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n --;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cur1 和 cur2 同时出发</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-02-笔记</title>
    <url>/2020/10/08/zuoshen-basic-class-2-note/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="问题一：partition"><a href="#问题一：partition" class="headerlink" title="问题一：partition"></a>问题一：partition</h2><blockquote>
<p>给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，大于$num$的数放在数组的右边。</p>
<p>要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$;</p>
</blockquote>
<p><strong>解决答案</strong></p>
<p><img src="/2020/10/08/zuoshen-basic-class-2-note/image-20201002124018348.png" alt="image-20201002124018348"><a id="more"></a></p>
<p><img src="/2020/10/08/zuoshen-basic-class-2-note/image-20201002124024185.png" alt="image-20201002124024185"></p>
<p><img src="/2020/10/08/zuoshen-basic-class-2-note/image-20201002124028365.png" alt="image-20201002124028365"></p>
<h2 id="问题二：荷兰国旗问题"><a href="#问题二：荷兰国旗问题" class="headerlink" title="问题二：荷兰国旗问题"></a>问题二：荷兰国旗问题</h2><blockquote>
<p>给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，等于$num$的数放在中间，大于$num$的数放在数组的右边。</p>
<p>要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$;</p>
</blockquote>
<p><strong>解决答案</strong></p>
<p>三个变量$less$, $cur$ 和 $more$;</p>
<p>$less$ 表示 $0$ ~ $less $为小于$num$的区域；初始为 -1；</p>
<p>$cur$ 表示 当前判断的数在数组的下标；初始为0；并且 0 ~ $cur$的数组区域都是小于等于$num$的值；</p>
<p>$more$ 表示 $more$ ~ $arr.length-1$为大于$num$的区域；初始为 $arr.length$；</p>
<pre class="mermaid">graph TD
A[开始] -->B(less初始值为-1)
    A -->F(cur初始值为0)
    A -->G(more初始值为arr.length)
    F -->I{cur是否小于more}
    G -->I
    B --> I
    C{判断arr的cur上的值} -->|小于num| D[cur位置和less+1位置交换 less+=1]
    C -->|等于num| H[cur= cur+1]
    C -->|大于num| E[cur位置和more-1位置交换 more-=1]
    D --> H
    H --> I
    E --> I
    I -->|是| C
    I -->|否| J[结束 返回less+1,more-1]</pre>

<p>要考虑一下一些情况：</p>
<ol>
<li><p>如果等于区域不存在</p>
</li>
<li><p>小于区域不存在</p>
</li>
<li><p>大于区域不存在</p>
</li>
<li><p>小于等于区域不存在</p>
</li>
<li><p>大于等于区域不存在</p>
</li>
<li><p>小于大于不存在（全是等于）</p>
</li>
</ol>
<h2 id="经典快速排序"><a href="#经典快速排序" class="headerlink" title="经典快速排序"></a>经典快速排序</h2><p>原始经典快速排序；</p>
<p>荷兰国旗问题来改进；</p>
<p><strong>经典快排的问题</strong></p>
<p>划分出来的区域不是等规模的：特别在差不多有序情况下进行经典快排则会导致$O(N^2)$；本质上和数据状况是有关系的；</p>
<h2 id="随机快速排序"><a href="#随机快速排序" class="headerlink" title="随机快速排序"></a>随机快速排序</h2><h3 id="随机快速排序的细节和复杂度分析"><a href="#随机快速排序的细节和复杂度分析" class="headerlink" title="随机快速排序的细节和复杂度分析"></a><strong>随机快速排序的细节和复杂度分析</strong></h3><p>和经典快排不同的地方在于选择<code>partition</code>的<code>num</code>值；经典快排都是选择一个确定位置的值（第一个值或者最后一个值）来对整个数组进行划分；而这样就和数据状况存在关系。所以随机快速排序随机选择划分整个过程的<code>num</code>值。虽然这样选择的值也可能出现划分出来的区域不是等规模的。但是这只是一个概率事件，我们不能得知其时间复杂度的最差情况；只能用长期期望的方式算出它的时间复杂度。我们长期期望得到的时间复杂度为：$O(N*log N)$；</p>
<h3 id="随机快速排序的组成"><a href="#随机快速排序的组成" class="headerlink" title="随机快速排序的组成"></a>随机快速排序的组成</h3><ol>
<li><p>主函数：输入一个要排序的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	快排主函数：</span></span><br><span class="line"><span class="comment">		先判断数组需不需要排序</span></span><br><span class="line"><span class="comment">		然后对 0 ~ arr.length-1 区间里调用2函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对区间里进行快速排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果左边界小于右边界</span></span><br><span class="line"><span class="comment">		在数组中随机选一个数作为分割数num，将其交换到l最后一个位置去</span></span><br><span class="line"><span class="comment">		按上一步找的数用 3 partition 把数组分为三部分：[小于num的，等于num的，大于num的]，返回 [等于num的] 的边界，方便后两步</span></span><br><span class="line"><span class="comment">		对 [小于num的] 执行快速排序</span></span><br><span class="line"><span class="comment">		对 [大于num的] 执行快速排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分割数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	partition需要 less = l-1记录小于num的区域的边界，more = r记录大于num区域的边界 cur=l arr[r]保存着分割数num</span></span><br><span class="line"><span class="comment">	这个思想与框图里的一样：</span></span><br><span class="line"><span class="comment">	【l~less：小于num的区域， less+1~cur-1：等于num的区域， cur~more-1：未分类的区域， more~r-1：大于num的区域】</span></span><br><span class="line"><span class="comment">	只要未分类的区域还存在循环不停止：</span></span><br><span class="line"><span class="comment">		如果arr[cur] &lt; arr[r]:要把它换到小于区域的下一个，而这个值是等于num区域的值；交换 ++less 和 cur++；</span></span><br><span class="line"><span class="comment">		如果arr[cur] &gt; arr[r]:把他换到大于区域前一个，交换过来的这个是未知区域的值；则要继续对cur位置做判断；</span></span><br><span class="line"><span class="comment">		如果arr[cur] = arr[r]:当前数要划分进等于num的区域，直接cur++；</span></span><br><span class="line"><span class="comment">	直接结束，交换more与r位置的数；</span></span><br><span class="line"><span class="comment">	返回：[less+1, more]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>规避数据状况对算法的影响的方法</strong></p>
<ol>
<li>随机</li>
<li>哈希函数</li>
</ol>
<p><strong>时间复杂度$O(N*log N)$，额外空间复杂度$O(log N)$</strong></p>
<p>空间复杂度为什么是$O(log N)$？为了记录大于<code>num</code>和小于<code>num</code>的位置，并且需要递归记录。所以额外的空间承了一颗二叉树一样得。所以是$O(log N)$</p>
<p><strong>题外话</strong>：任何递归函数都可以改写为非递归函数；</p>
<p>递归函数的压栈是对函数进行压栈，消耗的常数级空间和资源都比较大。并且系统栈是有限的，深度递归会造成不安全。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆的表示"><a href="#堆的表示" class="headerlink" title="堆的表示"></a>堆的表示</h2><p><strong>堆的数据结构</strong>：完全二叉树</p>
<p><strong>物理表示</strong>：一个数组，分为<strong>以0位置为根节点</strong>和<strong>以1位置为根节点</strong>两种表示方式；</p>
<p><strong>以0位置为根节点</strong>：</p>
<blockquote>
<p><code>i</code>位置的左孩子：$2*i+1$</p>
<p>​               右孩子：$2*i+2$；</p>
<p><code>i</code>位置的父节点： $\frac{i-1}{2}$</p>
</blockquote>
<p><strong>以1位置为根节点</strong>：</p>
<blockquote>
<p><code>i</code>位置的左孩子：$2*i$</p>
<p>​               右孩子：$2*i+1$</p>
<p><code>i</code>位置的父节点：$\frac{i}{2}$</p>
</blockquote>
<h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>分为大顶堆和小顶堆</p>
<p><strong>大根堆</strong>：在这个完全二叉树中任何一个子树的最大值都在子树的根上。</p>
<p><strong>小根堆</strong>：在这个完全二叉树中任何一个子树的最小值都在子树的根上。</p>
<h2 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h2><p>以大顶堆为例；</p>
<p><strong>思想</strong>：给定一个数组把它构建为一个大顶堆；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">宏观：我们认为0 ~ i-1间已构成大顶堆，然后插入第i个数；i初始值为0，不断插入堆中，不断增长，一直到N-1；</span><br><span class="line">中层：</span><br><span class="line">	 把一个数插入进完全二叉树：</span><br><span class="line">	 	循环判断：if i是否有父节点 并且 i位置数大于父节点：</span><br><span class="line">	 				与父结点进行交换</span><br><span class="line">	 			else:</span><br><span class="line">	 				结束；</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">    heapInsert(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>tip</strong>：这里看到左神代码，可以符合<code>i</code>没有父节点和大于父节点两种情况的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断i位置和其父节点</span></span><br><span class="line"><span class="keyword">while</span> (arr[i] &gt; arr[(i-<span class="number">1</span>)/<span class="number">2</span>])&#123;	<span class="comment">// 在i=0时是否合适？</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    经过验证java中的整除除法的整除，如果是负值则会往比较大的方向贴</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span> / <span class="number">4</span> ： <span class="number">0</span></span><br><span class="line">-<span class="number">3</span> / <span class="number">4</span> ： <span class="number">0</span></span><br><span class="line">-<span class="number">4</span> / <span class="number">4</span> ： -<span class="number">1</span></span><br><span class="line">-<span class="number">5</span> / <span class="number">4</span> ： -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​    而python不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span> // <span class="number">4</span> ： <span class="number">-1</span></span><br><span class="line"><span class="number">-3</span> // <span class="number">4</span> ： <span class="number">-1</span></span><br><span class="line"><span class="number">-5</span> // <span class="number">4</span> ： <span class="number">-2</span></span><br></pre></td></tr></table></figure>
<h2 id="插入堆（heapinsert）"><a href="#插入堆（heapinsert）" class="headerlink" title="插入堆（heapinsert）"></a>插入堆（heapinsert）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<p>插入堆就是要不停的与父节点进行比较。如果大于就交换，小于则停止；</p>
<h2 id="调整堆（heapify）"><a href="#调整堆（heapify）" class="headerlink" title="调整堆（heapify）"></a>调整堆（heapify）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>大顶堆中的一个数变小了，要对这样的情况进行调整；把它与他的两个子节点进行比较；如果大于它的左右节点那么就不调整了，如果小于就与较大的子节点进行交换。直到其大于他的左右子节点。当然结束条件不仅仅是大于两个子节点，也有子节点越界的情况。</p>
<blockquote>
<p>已知：堆数组arr，调整数的下标 index，堆大小 heapsize</p>
</blockquote>
<pre class="mermaid">graph TD
A[开始] -->B[左节点下标 left = index * 2 + 1]
B --> C{left < heapsize}
C -->|yes|D[获得左右节点的较大值]
C -->|no|E[结束]
D -->F{index大于子节点}
F -->|yes|G
G -->E
F -->|no|H
H -->I[交换子节点较大值与index]
I -->J[index=较大值]
J -->B</pre>



<h2 id="堆的使用"><a href="#堆的使用" class="headerlink" title="堆的使用"></a>堆的使用</h2><p><strong>例一：一个数据流不停的输出数；求当前输出数字的中位数；</strong></p>
<p><strong>分析</strong>：请求中位数是随时可能出现的；所以用普通线性容器对其进行排序所需的时间复杂度很高。</p>
<p>所以用堆来实现这个过程就很方便：</p>
<blockquote>
<p><strong>题解：</strong></p>
<p>​    <strong>需要</strong>：一个大根堆存放较小的$\frac{N}{2}$个数；用大根堆把他们的最大值放在根部；</p>
<p>​                一个小根堆存放较大的$\frac{N}{2}$个数；用小根堆把他们的最小值放在根部；</p>
<p>​                大根堆和小根堆中元素的个数差不超过1；</p>
<p>​    <strong>分析</strong>：当大根堆和小根堆元素个数相同时：中位数为两个堆顶部元素的均方；</p>
<p>​                当大根堆和小根堆元素个数差1时：中位数为元素较多所在堆的根部；</p>
<p>​    <strong>维护堆</strong>：</p>
<p>​                初始：把元素加入进大顶堆；</p>
<p>​                插入元素：</p>
<p>​                            a. 判断插入元素是否小于大顶堆根部，如果是则插入大顶堆，否则插入小顶堆</p>
<p>​                            b. 再判断大顶堆和小顶堆元素个数的差；如果大于1，则弹出元素数较大的堆的根，再插入元素数较小的堆中；使其平衡；</p>
</blockquote>
<h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><pre class="mermaid">graph TD
A[开始] --> B{数组大小大于1}
B -->|是|H[构建堆] 
H -->C[将堆中最后一个数与根交换]
C --> D[堆大小减1]
D --> F{堆大小不为空}
F --> |是|E[调整堆做一次heapify]
E -->C
F --> |否|G
B -->|否| G[排序完成]</pre>

<h1 id="排序算法的稳定性及其汇总"><a href="#排序算法的稳定性及其汇总" class="headerlink" title="排序算法的稳定性及其汇总"></a>排序算法的稳定性及其汇总</h1><p><strong>稳定性</strong>：相同的值经过排序之后他们在序列中的相对顺序会不会被打乱；不被打乱就是稳定的；</p>
<p><strong>冒泡排序：</strong>可以实现稳定，大数沉底，但是遇到相等的时候不交换就可以实现稳定；</p>
<p><strong>插入排序：</strong>可以实现稳定；从后往前插入，遇到相等的就停止。</p>
<p><strong>选择排序：</strong>不是稳定的；需要与i位置往后最小值交换，使得其相对顺序会变化；</p>
<p><strong>归并排序：</strong>可以实现稳定；元素相等情况下，先把左边数组的相等值优先拷贝进辅助数组，再拷贝右边数组的相等值；</p>
<p><strong>快速排序：</strong>不是稳定的；partition的过程也有随机交换的地方；</p>
<p><strong>堆排序：</strong>不是稳定的；</p>
<p>稳定性有什么意义？ 现实世界有可能需要保证他的原始顺序；</p>
<h1 id="工程中的综合排序算法"><a href="#工程中的综合排序算法" class="headerlink" title="工程中的综合排序算法"></a>工程中的综合排序算法</h1><p>工程中使用的排序算法则不是利用某种排序算法，它是一个综合考虑各种情况各种排序算法优劣的算法；</p>
<ul>
<li><p>如果需要排序的数组长度很长</p>
<p>先判断里面装的是基础类型，还是自定义类型？因为基础类型不需要考虑稳定性；</p>
<ul>
<li>基础类型：用快排</li>
<li>自定义类型：归并排序</li>
</ul>
</li>
<li><p>数组长度很短则直接用插入排序；因为插入排序所需的常数项操作很低。</p>
</li>
</ul>
<h1 id="有关排序问题的补充"><a href="#有关排序问题的补充" class="headerlink" title="有关排序问题的补充"></a>有关排序问题的补充</h1><ul>
<li>归并排序所需的时间复杂度<code>O(n)</code>的可以变成<code>O(1)</code>的，可以学习：“ 归并排序 内部缓存法 ”；非常难；</li>
<li>快速排序可以做到稳定性，可以学习：“ 01 stable sort ”；非常难；</li>
</ul>
<h1 id="认识比较器的使用"><a href="#认识比较器的使用" class="headerlink" title="认识比较器的使用"></a>认识比较器的使用</h1><p><code>Arrays.sort</code> 里有一个比较器接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a,<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> toIndex, Comparator c)</span></span></span><br></pre></td></tr></table></figure>
<p>通过自定义比较类型的比较器可以实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdAscendingComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> 负数;	<span class="comment">// 比较时第一个数o1放在o2前面</span></span><br><span class="line">        <span class="keyword">return</span> 正数；	<span class="comment">// 比较时第二个数o2放在o1前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；	<span class="comment">// 认为这样个数一样大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为自定义类型不告诉排序函数它用什么比较器，那么排序函数就会用内存地址对他们进行比较；</p>
<p>同样的java里还有优先队列；优先队列也就是一个堆；堆是大顶堆还是小顶堆都是需要用比较器来说明的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Student&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> IdAscendingComparator());</span><br></pre></td></tr></table></figure>
<p>还有<code>TreeSet&lt;Student&gt; treeset = new TreeSet&lt;&gt;(new IdAscendingComparator());</code></p>
<h1 id="桶排序、计数排序、基数排序"><a href="#桶排序、计数排序、基数排序" class="headerlink" title="桶排序、计数排序、基数排序"></a>桶排序、计数排序、基数排序</h1><p><strong>【例】</strong>一串数字，他们都是0~60范围里的数。要对这串数字进行排序；</p>
<p>可以实现一个数组用来统计相应位置上的数出现的个数。在利用整个数组得到排序后的结果；</p>
<p>而这里数组中的 <code>i</code> 位置保存数字 <code>i</code> 的个数。这就是一个桶；</p>
<p>桶保存了一种数据状况出现的词频，是容器；</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>而桶排序是一种思想，它不是具体的某一个排序算法。而基数排序与计数排序都是对它的具体实现；</p>
<p>但是可以看到这种排序是有局限性的，它的使用与数据状况关联很大；</p>
<p>计数排序要求被排序的数字在某一个范围里面；不然的话所需的范围极大，所需的桶也极多。这是它不好的地方；</p>
<h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><blockquote>
<p><strong>给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序。</strong></p>
</blockquote>
<p><strong>step-1</strong> : 排序数组有N个数，那么准备N+1个桶</p>
<p><strong>step-2</strong> : 遍历整个数组找到其最大值与最小值</p>
<p><strong>step-3</strong> : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0；</p>
<p><strong>step-4</strong> : 如果不相等则分别把最小值放在0号桶里，把最大值放在N号桶里。</p>
<p><strong>step-5</strong> : 把桶按最小值与最大值之间的范围等分为N+1份</p>
<p><strong>分析</strong>：</p>
<p>​        设一个桶能装的范围是p，它是由 $\frac{最大值 - 最小值}{N-1}$ 计算而来</p>
<p>​        由于有N个数放进N+1个桶里。那么起码会出现一个空桶；</p>
<p>​            相邻的两个数会出现在两个地方：在同一个桶里，在不同的桶里；</p>
<p>​                相邻的两个数在一个桶里他们的差值不会大于桶的范围：$(1, p-1)$；</p>
<p>​                两个数在相邻两个桶，他们的差值范围在 $(1, 2*p-1)$；</p>
<p>​                而两个数中间有一个空桶的相邻数一定大于桶的范围 $(p+1, 3p-1)$；</p>
<p>​            因为起码会出现一个空桶，所以相邻数的差的最大值不会出现在同一个桶里。所以只需要查看桶之间的差值就好了。</p>
<p>对这个过程进行完整的描述：</p>
<p><strong>step-1</strong> : 排序数组有N个数，那么准备N+1个桶；这个桶只保存有没有进来过数，进来数中最大值，最小值，这三样信息；</p>
<p><strong>step-2</strong> : 遍历整个数组找到其最大值与最小值</p>
<p><strong>step-3</strong> : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0； </p>
<p><strong>step-4</strong> : 如果不相等则分别用最小值更新0号桶布尔值，最大值和最小值，用最大值更新N号桶的布尔值，最大值和最小值。</p>
<p><strong>step-5</strong> : 然后依次把数组中的数字填入相对应的桶中；</p>
<p><strong>step-6</strong> : 对桶进行遍历，依次比较当前桶的最小值与上一个非空桶最大值的差，找到其中最大的值；</p>
<p><img src="/2020/10/08/zuoshen-basic-class-2-note/image-20201020174415858.png" alt="image-20201020174415858"></p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-04</title>
    <url>/2020/12/03/zuoshen-basic-class-4/</url>
    <content><![CDATA[<h1 id="题目一-实现二叉树的先序、中序、后序遍历"><a href="#题目一-实现二叉树的先序、中序、后序遍历" class="headerlink" title="题目一 实现二叉树的先序、中序、后序遍历"></a>题目一 实现二叉树的先序、中序、后序遍历</h1><p><strong>包括递归方式和非递归方式</strong></p>
<h2 id="递归方式遍历"><a href="#递归方式遍历" class="headerlink" title="递归方式遍历"></a>递归方式遍历</h2><p><img src="/2020/12/03/zuoshen-basic-class-4/image-20201120112203883.png" alt="image-20201120112203883"></p>
<h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol>
<li>自行准备一个栈，判断头节点非空时，将头节点压入栈中</li>
<li>以下部分循环：直到栈为空；<ol>
<li>弹出节点，输出</li>
<li>判断是否有右孩子，有的话压入栈中</li>
<li>判断是否有左孩子，有的话压入栈中</li>
</ol>
</li>
<li>打印换行，结束</li>
</ol>
<a id="more"></a>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol>
<li>准备一个栈，</li>
<li>循环：当栈为空且当前指针为空时停止<ol>
<li>当前节点不为空：<ul>
<li>当前节点压入栈中，当前节点找到左孩子；</li>
</ul>
</li>
<li>当前节点为空<ul>
<li>从栈中弹出给当前节点，打印；然后当前节点找到右孩子；</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先序遍历是: <code>中右左</code>；</p>
<p>后序遍历是：<code>中左右</code>的逆序；可以用到先序遍历的技巧+栈序打印；</p>
<p>也就是再先序遍历打印的位置把它保存起来；逆序打印；所以用到栈结构保存，再弹出打印就很方便；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    Node tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        tmp = stack.pop();</span><br><span class="line">        System.out.print(tmp.value + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    Stack&lt;Node&gt; stack_p = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        tmp = stack.pop();</span><br><span class="line">        stack_p.push(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack_p.isEmpty()) &#123;</span><br><span class="line">        System.out.print(stack_p.pop().value + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        Node c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1. 左节点为空或者它的孩子节点刚被输出过</span></span><br><span class="line"><span class="comment">                    反过来想，这个节点的左孩子不为空，并且左孩子没有被刚输出（没有右孩子），右孩子也没有被刚输出（左孩子可能被输出过了）</span></span><br><span class="line"><span class="comment">                    这种情况下就需要把左孩子压栈</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; head != c.left &amp;&amp; head != c.right) &#123; </span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                2. 右节点为空或者它的右节点刚被输出过；</span></span><br><span class="line"><span class="comment">                    右孩子不为空，并且栈顶结点的右孩子没有被输出过，满足这个条件即可压入栈</span></span><br><span class="line"><span class="comment">                    因为左孩子被上一个判断了，它可能为空，也可能被输出过了。</span></span><br><span class="line"><span class="comment">                    在这一步判断要不要把右孩子加入到栈中不重要；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; head != c.right) &#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               3. 当前栈顶节点的左右孩子要么为空要么被输出了，那么就把它输出了；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="comment">// 当前栈顶节点，在以上两个条件同时不满足的情况下输出：</span></span><br><span class="line">                System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">                head = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目二-如何直观的打印一颗二叉树"><a href="#题目二-如何直观的打印一颗二叉树" class="headerlink" title="题目二 如何直观的打印一颗二叉树"></a>题目二 如何直观的打印一颗二叉树</h1><p>左神说：从上到下的树很难画出来；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for test -- print tree</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">    printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">    String val = to + head.value + to;</span><br><span class="line">    <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">    <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">    val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height * len) + val);</span><br><span class="line">    printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String space = <span class="string">" "</span>;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        buf.append(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目三-在二叉树中找到一个节点的后继节点"><a href="#题目三-在二叉树中找到一个节点的后继节点" class="headerlink" title="题目三 在二叉树中找到一个节点的后继节点"></a>题目三 在二叉树中找到一个节点的后继节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在有一种新的二叉树节点类型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">	<span class="keyword">public</span> Node right; </span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。</p>
<p>假设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向 自己的父节点，头节点的parent指向null。</p>
<p>只给一个在 二叉树中的某个节点 node，请实现返回node的后继节点的函数。</p>
<p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>针对一个给定节点，要求出它的后继结点；</p>
<p>首先第一步就是判断它是什么节点：它是其父节点的左孩子，他是其父节点的右孩子，它是根节点；</p>
<ul>
<li>它是父节点的左孩子<ul>
<li>如果它的右子树存在：则返回右子树中序遍历的第一个节点；</li>
<li>如果不存在右子树：则返回其父节点</li>
</ul>
</li>
<li>它是父节点的右孩子<ul>
<li>它是父节点的右孩子，那么它的左孩子都已经被中序遍历过了。即只能再看其右孩子；</li>
<li>如果它没有右孩子，那就需要考虑其父节点在树中的位置</li>
</ul>
</li>
<li>它是根节点<ul>
<li>找到其右子树中序遍历的第一个节点；</li>
</ul>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>当前节点有右子树，那么返回其右子树上最左的节点</p>
<p>节点右子树不存在：那么当前节点即可被认为是某一节点的左子树中序遍历的最后一个节点；找到这个节点即可；</p>
<ul>
<li>找到节点的父节点判断节点是其父节点的左孩子或者右孩子：<ul>
<li>左孩子：停止，返回这个父节点</li>
<li>右孩子：继续往上找；</li>
<li>空或者自循环：到树的根节点了，则不存在下一个；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node parent = node.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目四-介绍二叉树的序列化和反序列化"><a href="#题目四-介绍二叉树的序列化和反序列化" class="headerlink" title="题目四 介绍二叉树的序列化和反序列化"></a>题目四 介绍二叉树的序列化和反序列化</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>​    <strong>先序遍历</strong>：节点和节点之间用一个符号（比如 _）分隔。并且遇到空时用另一个符号（比如 #）来表示。</p>
<p><img src="/2020/12/03/zuoshen-basic-class-4/image-20201125155615990.png" alt="image-20201125155615990"></p>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><pre><code> **按照先序遍历序列化的就按照先序遍历反序列化**
</code></pre><p>​    依次取出头节点，再取就是头节点的左节点或者空左孩子；依次完成树的重建；</p>
<h2 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h2><p><strong>先序遍历</strong></p>
<p>通过递归的方式：</p>
<p>如果当前节点为空则直接返回 “ #! ” ;</p>
<p>如果不为空，字符串加入头节点的值和分割符 “ ! ” ；</p>
<p>再把字符串后加上当前节点左节点的返回和右节点的返回；</p>
<p>整个函数返回字符串；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>层序遍历</strong></p>
<p>如果当前节点为空则直接返回 “ #! ” ;</p>
<p>申请一个队列来保存队列的顺序；</p>
<p>给字符串 res 加上根节点的值以及分割符；</p>
<p>再把根节点加入到队列当中；</p>
<p>持续循环——&gt;直到队列为空：</p>
<ul>
<li>从队列中取出一个节点；</li>
<li>判断这个节点的左节点是否为空 ？ 字符串加上这个节点的左节点的值以及分割符，队列加入 这个节点的左节点  :  给字符串加上空节点的符号表示</li>
<li>同样的流程判断右节点是否为空；</li>
</ul>
<p>返回字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += head.left.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.left) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += head.right.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反序列化实现"><a href="#反序列化实现" class="headerlink" title="反序列化实现"></a>反序列化实现</h2><p><strong>前序遍历反序列化</strong></p>
<p>把序列化字符串用分割符分割开成为一个字符串数组；</p>
<p>申请一个保存字符串的队列；</p>
<p>按照前序遍历的方式序列化的，就按照前序遍历的方式反序列化</p>
<p>调用一个从队列反序列化的函数：</p>
<ul>
<li>从队列中取出第一个节点的字符串。判断它是否是空节点的表示，是的话，返回null；</li>
<li>如果不是，创建节点对象，保存这个值；然后再递归调用自身得到接下来的左子树的表示和右子树的表示；</li>
<li>最终返回头节点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span> </span>&#123;</span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length ; i++) &#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>层次遍历反序列化</strong></p>
<p>把序列化字符串用分割符分割开成为一个字符串数组；</p>
<p>把字符川数组的第一个字符串转成根节点；</p>
<p>申请一个保存节点的队列；</p>
<p>如果头节点不为空，则把根节点加入进去；</p>
<p>while 循环 ——&gt; 如果队列不为空</p>
<ul>
<li>从队列中取出一个节点</li>
<li>把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的左节点；</li>
<li>如果左节点不为空则把左节点加入队列</li>
<li>把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的右节点；</li>
<li>如果右节点不为空则把左节点加入队列</li>
</ul>
<p>返回根节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span> </span>&#123;</span><br><span class="line">    String[] values = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Node head = generateNodeByString(values[index++]);</span><br><span class="line">    Queue&lt;Node&gt; quene = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        quene.offer(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!quene.isEmpty()) &#123;</span><br><span class="line">        node = quene.poll();</span><br><span class="line">        node.left = generateNodeByString(values[index ++]);</span><br><span class="line">        node.right = generateNodeByString(values[index ++]);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quene.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quene.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNodeByString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目五-折纸问题"><a href="#题目五-折纸问题" class="headerlink" title="题目五 折纸问题"></a>题目五 折纸问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>【题目】 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次， 请从上到下打印所有折痕的方向。 例如：N=1时，打印： down N=2时，打印： down down up</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把纸折一次，它的中间是凹的；它的上部分再折也是凹的；它的下部分再折是凸的；以此类推，就可以得到这个问题的答案；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    System.out.println(down ? <span class="string">"down "</span> : <span class="string">"up "</span>);</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目六-判断一棵树是否是平衡二叉树（AVL）"><a href="#题目六-判断一棵树是否是平衡二叉树（AVL）" class="headerlink" title="题目六 判断一棵树是否是平衡二叉树（AVL）"></a>题目六 判断一棵树是否是平衡二叉树（AVL）</h1><p><strong>平衡二叉树</strong> ：一颗树的任意节点左子树与右子树的高度差不超过1；</p>
<p> 树算法：递归很好用；因为针对一个节点的递归会返回一个节点三次：他自己，左子树回来，右子树回来；</p>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>判断一个节点 x 是否平衡：</p>
<ol>
<li>左树是否平衡；</li>
<li>右数是否平衡；</li>
<li>左树的高度是什么？</li>
<li>右数的高度是什么？</li>
<li>左树与右数高度差是否平衡；</li>
</ol>
<p>就是需要求左子树与右子树的高度，还要时刻判断当下的树是否平衡：</p>
<p>方法传入了两个值，一个是level表示判断节点的层级，res用了数组。使其能改变自身使值返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    getHeight(head, <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node head, <span class="keyword">int</span> level, <span class="keyword">boolean</span>[] res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lH = getHeight(head.left, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span> (!res[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rH = getHeight(head.right, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span> (!res[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(lH - rH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lH, rH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一个套路化的过程，具体的思想就是把需要求得到信息封装成一个类，然后把这个类打包在每个节点间传递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isB;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isB, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isB = isB;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isB</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData leftData = process(head.left);</span><br><span class="line">    <span class="keyword">if</span> (!leftData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData rightData = process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (!rightData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftData.h-rightData.h) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, Math.max(leftData.h, rightData.h));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目七-判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树"><a href="#题目七-判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树" class="headerlink" title="题目七 判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树"></a>题目七 判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树</h1><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p><strong>搜索二叉树</strong>：这棵树上任何一个节点为头的子树，这个节点的左子树都比这个节点的数小，右子树都比他大；（中序遍历是依次升序的，充分必要条件）</p>
<p>所以看一个树是否是搜索二叉树，可以直接判断它的中序遍历是否是依次升序的；</p>
<p>所以对于非递归版的中序遍历打印那句，就判断要打印的当前节点是否大于本应该打印的上一个节点，不大于就是不是搜索二叉树，大于就直接更新，找下一个中序节点；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isBST(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; null;</span><br><span class="line">    Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();</span><br><span class="line">    while (!stack.isEmpty() || head !&#x3D; null) &#123;</span><br><span class="line">        if (head !&#x3D; null) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head &#x3D; head.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; stack.pop();</span><br><span class="line">            if (node!&#x3D; null &amp;&amp; node.value &gt; head.value) &#123;</span><br><span class="line">                System.out.println(node.value+&quot; &quot;+ head.value);;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; head;</span><br><span class="line">            head &#x3D; head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><strong>完全二叉树</strong>：算法过程需要按层遍历；</p>
<ul>
<li><p>如果一个节点有右孩子，没有左孩子；一定不是完全二叉树；</p>
</li>
<li><p>如果一个节点只有一个左孩子，或者没有孩子，那么它后面遇到的节点都必须是叶节点；否则不是完全二叉树；</p>
</li>
</ul>
<p>（由于情况一违反的话直接就没了，所以判断是否是情况二的情况，右边叶子一定是空；）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    Node node;</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leaf) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leaf) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左神简化版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目八-已知一棵完全二叉树，求其节点的个数"><a href="#题目八-已知一棵完全二叉树，求其节点的个数" class="headerlink" title="题目八 已知一棵完全二叉树，求其节点的个数"></a>题目八 已知一棵完全二叉树，求其节点的个数</h1><p>要求：时间复杂度低于O(N)，N为这棵树的节点个数</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先遍历完全二叉树根节点到它的最左节点；这样可以判断出完全二叉树的高度；然后再判断右子树的最左节点是否存在；</p>
<p>如果存在则说明他的根节点的左子树是满二叉树：左子树可以通过高度求出来；右子树可以通过递归求得；</p>
<p>如果不存在说明右节点也是满二叉树；则可以由递归求得左子树； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(Node node, <span class="keyword">int</span> level, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mostLeftLevel(node.right, level + <span class="number">1</span>) == h)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level)) + bs(node.right, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level - <span class="number">1</span>)) + bs(node.left, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftLevel</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>algorithm</tag>
        <tag>平衡二叉树</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左神算法-基础课-05</title>
    <url>/2020/12/11/zuoshen-basic-class-5/</url>
    <content><![CDATA[<h1 id="题目一-认识哈希函数和哈希表"><a href="#题目一-认识哈希函数和哈希表" class="headerlink" title="题目一 认识哈希函数和哈希表"></a>题目一 认识哈希函数和哈希表</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><strong>一、性质</strong></p>
<ol>
<li>哈希函数的输入域是无限大的；</li>
<li>哈希函数的输出域是有穷尽的；</li>
<li>输入如果一样，输出一定一样；</li>
<li><strong>哈希碰撞：</strong>输入不一样，也可能得到输出一样的值；（因为输入域无穷大，输出域有限大，所以必然会产生冲突；)</li>
<li>哈希函数的离散性：也就是输出域每个值被输出的概率都差不多一样大；</li>
</ol>
<p><strong>二、特征</strong></p>
<ol>
<li>输出的值和输入没有关系；保证它结果是均匀出现的；</li>
</ol>
<p><strong>三、找到一千个独立的哈希函数</strong></p>
<p>独立的意思在于一个哈希函数不会随着一个的变化而变化；</p>
<a id="more"></a>
<p><strong>具体做法</strong>：</p>
<p>一个哈希函数可以生成16位的十六进制的输出集；他们每个位的码都是相互不关联的；</p>
<p>那么可以把它前八位作为一个哈希函数$h_1$，后八位做一个哈希函数$h_2$</p>
<p>紧接着，$h_3 = h_1+1*h_2$ ；这里第三个哈希函数与他们两个是没有关系的；</p>
<p>以此类推： $h_i=h_1+(i-2)*h_2$ 做出很多很多的哈希函数，并且它们相互之间是相互独立的；</p>
<p><strong>四、 粗略介绍哈希函数的内部构造</strong></p>
<p>比如说一个字符串，不管多长，要把它得到一个16位的哈希函数；</p>
<p>就分割16位16位的异或，再错位异或之类的；</p>
<p>实现方法有很多；</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表可以： <code>put(key1, value1)</code>，<code>get(key1)</code>，<code>remote(key1)</code></p>
<p><strong>一、哈希表的存放</strong></p>
<p>比方有一个数组大小是 <code>N</code>，进来一个<code>(key, value)</code> ; </p>
<p>通过计算 <code>key</code>的哈希值，膜上数组的大小 <code>N</code> ;  可以在数组中找到一个存放这个<code>(key, value)</code> 的位置；以节点的形式把它存放在数组中；</p>
<p>再有值进来冲突了某个位置，就在节点后形成链表的形式；</p>
<p><strong>二、哈希表的扩容</strong></p>
<p>某一个位置的链很长了，那么就把它扩容；扩容讲究也很宽泛。可以<strong>成倍扩容</strong>；那么存放N个元素可能就要扩容 $log_2N$次</p>
<p><strong>离线扩容</strong>：指的是在用的哈希表已经很元素很多了，那么想办法先让访问都在目前的哈希表上访问；然后再后台再扩容的空间里把元素放进来。等做好后就把访问引到这个上面来；它扩容过程不占用线上访问时间；</p>
<h2 id="哈希函数的一个使用场景"><a href="#哈希函数的一个使用场景" class="headerlink" title="哈希函数的一个使用场景"></a>哈希函数的一个使用场景</h2><p>【面试题】：给你一个大文件，100T，寸的都是数字；把其中所有数字得到一个新文件，保证每个数不重复；</p>
<p>给1000个机器；为了充分使用这1000个机器，可以用哈希函数来给1000个机器来分流。每从大文件中读书来一个数，就算出它的哈希函数。然后再膜上1000，决定它该由哪个机器处理。这样做有个好处就是相同的数会被分配到同一个机器上去；这样重复的值就可以被找到；</p>
<p>大数据的题目：就用哈希函数，相同输入导致相同输出。不同输入均匀分布；</p>
<h1 id="题目二-设计RandomPool结构"><a href="#题目二-设计RandomPool结构" class="headerlink" title="题目二 设计RandomPool结构"></a>题目二 设计RandomPool结构</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一种结构，在该结构中有如下三个功能： </p>
<ul>
<li><strong>insert(key)</strong>：将某个key加入到该结构，做到不重复加入。 </li>
<li><strong>delete(key)</strong>：将原本在结构中的某个key移除。 </li>
<li><strong>getRandom()</strong>： 等概率随机返回结构中的任何一个key。</li>
</ul>
<p>【要求】<code>Insert</code>、<code>delete</code>和<code>getRandom</code>方法的时间复杂度都是 <code>O(1)</code></p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>前两个方法是可以考虑用一个哈希表来自然实现的；但是第三个单纯用一个哈希表是得不到的；</p>
<p>所以这里除了原本的哈希表还需要另外的结构来辅助完成这个功能；</p>
<ol>
<li><p>在不考虑delete的情况，仅仅往哈希表里的加入元素：</p>
<p>我们要知道加入了几个了</p>
<p>第一个哈希表加入第一个元素<code>(key,value)</code>，另一个哈希表加入（value，key），value表示第几次插入到这个哈希表中；</p>
<p>我们在第一个哈希表中可以根据key找到它是第几个插入的；在第二个可以通过第几个插入的找到key值；</p>
<p>str0 —— 0    0 —— str0</p>
<p>str1 —— 1    1 —— str1</p>
<p>str2 —— 2    2 —— str2</p>
<p>strN —— N    N —— strN</p>
<p>以此类推，加入<code>N</code>个后，可以在 <code>0 ~ N-1</code>之间随机选择一个数在第二个哈希表找到key，再在第二个哈希表中找到相对应的值；这种情况下，可以根据加入元素多少实现等概率返回。</p>
</li>
<li><p>删除情况：</p>
<p>比方要删除 <code>0 ~ N-1</code> 中的某一个数。可以在第一个哈希表中找到它是第几个加入的。相对应的加入的元素数目也减少了；但是在随机的时候就可能随机到 <code>i</code>。另外由于总数变为 <code>N-1</code>了，随机范围是 <code>0 ~ N-2</code>了，所以之前最后一个加入的次序为 <code>N-1</code> 的元素就随机不到了。所以可以用最后一个加入的这个元素补被删除的那个位置。</p>
<p>另外这里的进入哈希表的次序只不过是一个辅助信息。它在接口中，不对外呈现；所以更改它没有多大影响；</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; KeyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; IndexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.IndexKeyMap = <span class="keyword">new</span> HashMap&lt;Integer, K&gt;();</span><br><span class="line">        <span class="keyword">this</span>.KeyIndexMap = <span class="keyword">new</span> HashMap&lt;K, Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.KeyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.put(key, size);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.put(size ++ , key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Already exits!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.KeyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteIndex = <span class="keyword">this</span>.KeyIndexMap.get(key);</span><br><span class="line">            <span class="keyword">int</span> lastIndex = --<span class="keyword">this</span>.size;</span><br><span class="line">            K lastKey = <span class="keyword">this</span>.IndexKeyMap.get(lastIndex);</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SomeThing Wrong!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) (Math.random() * <span class="keyword">this</span>.size); <span class="comment">// 0 ~ size - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.IndexKeyMap.get(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在序列中出现了洞，用最后一个去填是常规操作</strong></p>
<h1 id="题目三-认识布隆过滤器"><a href="#题目三-认识布隆过滤器" class="headerlink" title="题目三 认识布隆过滤器"></a>题目三 认识布隆过滤器</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设有一个需求：100亿个<strong>url</strong>黑名单；每个url是64字节；使用场景是，给一个 url 如果这个 url 属于黑名单，那就返回 true， 否则返回 false；</p>
<p>这种场景用哈希表的话就需要把所有的东西加入到内存当中来；这样子所需的内存资源就很多很多。所以就可以用布隆过滤器；</p>
<p>布隆过滤器有一个缺点：它有一定的失误率（宁可错杀3000不可放过一个；在黑名单的不会弄错，他会返回 True；但是不在黑名单的有一定的概率会搞错。）</p>
<ol>
<li><p>布隆过滤器需要先准备一个长比特数组，它的长度为 $m$ ；使用这个长比特数组的目的就在于我们准备用其中某几个 <code>bit</code> 的位置来组合说明某个url是否存在；</p>
<ul>
<li>长比特数组的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个整数的位数是 32个bit，那么申请的整数数组是 32000 bits</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">30000</span>;  <span class="comment">// 把第 30000 个位置描黑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intIndex = index / <span class="number">32</span>;    <span class="comment">// 它在整数数组里的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitIndex = index % <span class="number">32</span>;  <span class="comment">// 在所在的整数里的哪一个 bit 位；</span></span><br><span class="line"></span><br><span class="line">    arr[intIndex] = (arr[intIndex] | (<span class="number">1</span> &lt;&lt; bitIndex));  <span class="comment">// 把arr[intIndex] 这个整数的 第bitIndex位描黑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对每个 url 我们把它经过 $k$ 个独立的哈希函数，算出 $k$ 个哈希值，再膜上比特数组的长度 $m$ 得到比特数组的 $k$ 个位置 ；分别在数组上把这 $k$ 个位置给描黑（写上1）；</p>
</li>
</ol>
<ol>
<li><p>查询：来了一个 url ，用它经过我们之前的 $k$ 个哈希函数，同样的方法求出来 $k$ 个位置；看比特数组中这 $k$ 个位置是否被描黑了；如果都被描黑了，则我们可以认为这个 url 在黑名单里（有可能有失误，碰巧那几个都被涂黑了。）。如果有一个不是黑的，则它绝对不在黑名单了；</p>
<ul>
<li><p>所以选择哈希函数的 $k$ 的大小，和比特数组长度 $m$ 来控制失误率；</p>
<ul>
<li>$m$ 越大，失误率降低；$m$ 越小，失误率升高；下面是 $m$ 的所需公式 ：$n$ 表示样本量；$p$ 是预期失误率；</li>
</ul>
<script type="math/tex; mode=display">
m = -\frac{n*\ln p}{(\ln 2)^2}</script><ul>
<li>确定哈希函数个数 $k$ 的个数：这个数是小数需要向上取整<script type="math/tex; mode=display">
k=\ln 2 * \frac{m}{n}</script></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>当哈希函数个数 $k$ 和样本数 $m$ 确定时（都向上取整了），预期失误率是：<pre><code>$$
p=(1-e^{-\frac{n*k}{m}})^k
$$
</code></pre></li>
</ul>
<h1 id="题目四-认识一致性哈希"><a href="#题目四-认识一致性哈希" class="headerlink" title="题目四 认识一致性哈希"></a>题目四 认识一致性哈希</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p><strong>经典服务器抗压结构</strong>：后端集群有 $N$ 台机器；前端获取请求后根据请求的 $key$ 来得到一个哈希值。 然后在得到这个哈希值除以 $N$ 的余数；根据这个余数把这个请求分配到相对应位置的机器上。这样会使得几台机器得到的请求压力差不多相同。（<strong>负载均衡</strong>）</p>
<p>但是当需要在这个结构中加机器或者减机器的时候这个结构就需要大范围的改动。因为每一个key的哈希值会根据新的机器数和之前得到的位置是不同的。（<strong>数据归属变化了</strong>）</p>
<p>这种情况下就可以使用一致性哈希。<strong>它可以把数据迁移代价变得很低，又负载均衡</strong>；</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201210152321153.png" alt="image-20201210152321153"></p>
<p><strong>实际服务器集群的结构：</strong></p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201210153820881.png" alt="image-20201210153820881"></p>
<p><strong>此时需要加入新的机器</strong></p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201210160021986.png" alt="image-20201210160021986"></p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul>
<li>在机器数量比较小的时候，他们在哈希值组成的环中的分布不是均分的；使得某个机器可能负载过多；</li>
<li>即使人为的让他分布均匀，但是再加入新机器时；还是会破环原来的均衡；</li>
</ul>
<p>这里我们可以用<strong>虚拟节点技术</strong>来解决这个问题；</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>每个物理机器不再使用自己的ip信息来分配哈希域的区间</p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201210170417902.png" alt="image-20201210170417902"></p>
<h1 id="题目五-岛问题"><a href="#题目五-岛问题" class="headerlink" title="题目五 岛问题"></a>题目五 岛问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？</p>
<p>举例： </p>
<p>0 0 1 0 1 0 </p>
<p>1 1 1 0 1 0 </p>
<p>1 0 0 1 0 0 </p>
<p>0 0 0 0 0 0</p>
<p>这个矩阵中有三个岛。</p>
<h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><p>单任务的想法：</p>
<ul>
<li>遇到岛就深度遍历把遍历过的都给标记起来。之后遇到标记过的，直接跳过，直到遇到未标记的岛，就给岛的数量加一；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = m.length;</span><br><span class="line">    <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                infect(m, i, j, N, M);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = <span class="number">2</span>;</span><br><span class="line">    infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">    infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">    infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">    infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多任务的思想（并行计算）：</p>
<ul>
<li>把矩阵分块处理分别数出其中各自有多少岛屿</li>
<li>然后对矩阵块的边缘进行考虑<ul>
<li>普遍情况下要对矩阵间的边缘也就是 灰色部分进行考察；两个矩阵边缘相连，在不同情况下是不同的，在下图中两个边缘区域相连，他们总岛屿数 - 1；<img src="/2020/12/11/zuoshen-basic-class-5/image-20201211162620873.png" alt="image-20201211162620873"></li>
</ul>
</li>
<li>考虑矩阵块边界相连时，把各个矩阵块里找到的岛屿当作并查集；</li>
<li>搜索边界，如果分属于两个矩阵块里的岛屿（并查集）在边界是相连的但是没有被合并过，那么总岛屿数减一，把他们相连；</li>
</ul>
<h1 id="题目六-并查集"><a href="#题目六-并查集" class="headerlink" title="题目六 并查集"></a>题目六 并查集</h1><p>概念好理解，但是比较难的是在什么场合去应用他。</p>
<h2 id="可应用的地方"><a href="#可应用的地方" class="headerlink" title="可应用的地方"></a>可应用的地方</h2><ul>
<li>检查两个元素是否属于一个集合： <ul>
<li><code>isSameSet(A, B)</code> ：</li>
</ul>
</li>
<li>两个元素各自所在的集合合并在一起：<ul>
<li><code>set union(element A, element B)</code>  </li>
</ul>
</li>
</ul>
<h2 id="并查集的结构"><a href="#并查集的结构" class="headerlink" title="并查集的结构"></a>并查集的结构</h2><p><strong>并查集的初始化</strong></p>
<p>初始化时需要把所有的元素都给出；并每个元素都可以被看成是独立的集合；它有一个自旋指向；</p>
<p>并查集代表一个集合的节点会把指针指向自己；可以通过指针指向自己的节点识别出集合的头。</p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201211095208875.png" alt="image-20201211095208875"></p>
<p><strong>并查集合并</strong></p>
<p>两个集合合并时任意的让其中一个集合的代表节点解除自旋指向，指向另一个并查集中的节点：</p>
<p><strong>一般会让节点数更小的，指向节点多一些的并查集。</strong></p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201211095510716.png" alt="image-20201211095510716"></p>
<p><strong>检查元素是否在一个集合</strong>：就是找到两个节点一直找到他们所在集合的代表节点，看他们是否是一个节点；</p>
<h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h2><p><strong>查询后再优化，仅优化查询路径上的节点</strong></p>
<p>查询 $4$ 节点会路过三个节点，直到找到 $1$ 节点</p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201211100851717.png" alt="image-20201211100851717"></p>
<p>然后再把这个结构进行优化成这个样子：</p>
<p><img src="/2020/12/11/zuoshen-basic-class-5/image-20201211101606972.png" alt="image-20201211101606972"></p>
<p>至于那些指向 $4$ 或者 $3$ 和 $2$ 的都保持原地不动。仅仅把查询 $4$ 到代表节点的路径扁平化，让它们指向 $1$ 节点；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// whatever you like</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">        fatherMap.clear();</span><br><span class="line">        sizeMap.clear();</span><br><span class="line">        <span class="keyword">for</span> (Node node: nodes) &#123;</span><br><span class="line">            fatherMap.put(node, node);</span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node father = fatherMap.get(node);</span><br><span class="line">        <span class="keyword">if</span> (father != node) &#123;</span><br><span class="line">            father = findHead(father);</span><br><span class="line">        &#125;</span><br><span class="line">        fatherMap.put(node, father);</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node aHead = findHead(a);</span><br><span class="line">        Node bHead = findHead(b);</span><br><span class="line">        <span class="keyword">if</span> (aHead != bHead) &#123;</span><br><span class="line">            <span class="keyword">int</span> aSetSize = sizeMap.get(aHead);</span><br><span class="line">            <span class="keyword">int</span> bSetSIze = sizeMap.get(bHead);</span><br><span class="line">            <span class="keyword">if</span> (aSetSize &lt;= bSetSIze) &#123;</span><br><span class="line">                fatherMap.put(aHead, bHead);</span><br><span class="line">                sizeMap.put(bHead, aSetSize + bSetSIze);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fatherMap.put(bHead, aHead);</span><br><span class="line">                sizeMap.put(aHead, aSetSize + bSetSIze);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>所有的操作包括：查询过程 + 合并过程 ——&gt; $O(N)$ 及以上，那么平均每次操作都是常数级别，可以说是：$O(1)$</p>
<h2 id="应用：岛问题"><a href="#应用：岛问题" class="headerlink" title="应用：岛问题"></a>应用：<a href="#题目五 岛问题">岛问题</a></h2>]]></content>
      <categories>
        <category>algorithm</category>
        <category>左神算法</category>
        <category>初级</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>哈希函数</tag>
        <tag>哈希表</tag>
        <tag>布隆过滤器</tag>
        <tag>一致性哈希</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>一些maven操作</title>
    <url>/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/</url>
    <content><![CDATA[<h2 id="一些关于maven的小技巧"><a href="#一些关于maven的小技巧" class="headerlink" title="一些关于maven的小技巧"></a>一些关于maven的小技巧</h2><ul>
<li>如果发现包不在了可以更新一下maven的源</li>
</ul>
<ul>
<li>如果控制台输出中文乱码了，可以在idea的<code>setting</code>-<code>maven</code>-<code>running</code>-<code>VM options</code>里写下参数<code>-Dfile. encoding=gb2312</code>：发现原本的日志输出乱码了。。。所以把字符集改成<code>GBK</code>后，OK了。</li>
</ul>
<h2 id="IDEA的Maven-Projects无法显示"><a href="#IDEA的Maven-Projects无法显示" class="headerlink" title="IDEA的Maven Projects无法显示"></a><a href="https://www.cnblogs.com/new-life/p/10753575.html" target="_blank" rel="noopener">IDEA的Maven Projects无法显示</a></h2><p>idea自带了maven控件，不像Eclipse还需要下载控件，如果你以前有maven在右边，出于某种原因，消失找不到 了，可以试试以下方法.</p>
<p><strong>方法1.</strong>你点击一下你idea界面最左下角的那个小框，maven应该从里面找到</p>
<p><strong>方法2.</strong>点击菜单栏View-&gt;Tool Windows-&gt;Maven projects </p>
<p><strong>方法3.</strong>点击菜单栏Help-&gt;Find Action(Ctrl+Shift+A),输入Maven projects</p>
<p><strong>方法4.在Settings—&gt;Plugins搜索Maven Integration，打勾（原本没打勾的就勾上保存，有打勾就去掉勾保存后再勾上）重启IDEA即可.</strong></p>
<a id="more"></a>
<p>前三个方法都试了还是不行，发现maven控件直接没有了，用上方法4，问题解决</p>
<p><img src="/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/1172444-20170724172834465-2099154620.png" alt="img"></p>
<h2 id="Ideal-导入Maven项目"><a href="#Ideal-导入Maven项目" class="headerlink" title="Ideal 导入Maven项目"></a>Ideal 导入Maven项目</h2><p>选择打开Maven项目</p>
<h5 id="然后先点开-File-gt-Other-Settings-gt-Structure-for-New-Projects…-设置全局-JDK"><a href="#然后先点开-File-gt-Other-Settings-gt-Structure-for-New-Projects…-设置全局-JDK" class="headerlink" title="然后先点开 File -&gt; Other Settings -&gt; Structure for New Projects… 设置全局 JDK"></a>然后先点开 File -&gt; Other Settings -&gt; Structure for New Projects… 设置全局 JDK</h5><p><img src="/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/1039653-20181202164439790-178566506.png" alt="img"></p>
<p><img src="/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/1039653-20181202165035638-1650425818.png" alt="img"></p>
<h5 id="之后点击-Project-应用刚才添加的-JDK"><a href="#之后点击-Project-应用刚才添加的-JDK" class="headerlink" title="之后点击 Project 应用刚才添加的 JDK"></a>之后点击 Project 应用刚才添加的 JDK</h5><p><img src="/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/1039653-20181202165315306-316822270.png" alt="img"></p>
<h5 id="设置-Maven-点击-Other-Settings-gt-Settings-for-new-Projects…"><a href="#设置-Maven-点击-Other-Settings-gt-Settings-for-new-Projects…" class="headerlink" title="设置 Maven 点击 Other Settings -&gt; Settings for new Projects…"></a>设置 Maven 点击 Other Settings -&gt; Settings for new Projects…</h5><p>由于我的项目里配置了Tomcat所以直接在IDEA的Maven Projects里找<code>tomcat7</code>里的<code>tomcat7:run</code>;</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>maven</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>io</title>
    <url>/2020/07/14/io/</url>
    <content><![CDATA[<p>文件操作</p>
<p>在java语言里有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，也就是说整个的<code>Java.io</code>包里面File类是唯一一个与文件本身操作（创建，删除，重命名）有关的类，如果要想进行File类的操作，要必须提供完成的路径，而后才可以调用相应的方法进行处理：</p>
<h2 id="1-File类的基本使用"><a href="#1-File类的基本使用" class="headerlink" title="1. File类的基本使用"></a>1. File类的基本使用</h2><p>打开JDK文档可以发现，File类是Comparable接口的子类，所以File类的对象是可以进行排序处理的；在对File类处理的时候需要为其设置访问路径，那么对于路径的配置主要通过File类的构造方法来处理</p>
<ul>
<li><p>构造方法：设置要操作完整路径；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> File​(String pathname)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>构造方法：设置父路径与子目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> File​(String parent, String child)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在要想进行文件的基本操作可以使用如下的方法：</p>
<ul>
<li><p>创建新的文件<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> createNewFile​() <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断文件是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> exists​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> delete​()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用File类创建一个文件（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"./zenner.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">			file.delete();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(file.createNewFile());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过代码发现，File类本身就是文件本身的处理；</p>
<h2 id="2-File类操作深入"><a href="#2-File类操作深入" class="headerlink" title="2. File类操作深入"></a>2. File类操作深入</h2><p>现在已实现了文件的基础操作，但是对于这个操作里也存在一些问题；下面用之前的代码进行优化处理：</p>
<ol>
<li><p>在实际的软件项目开发和运行的过程之中，往往都会在windows中进行项目开发，而在项目部署的时候基于Linux或Unix系统来进行项目的发布以保证生产环节的安全性；</p>
<p>在不同的操作系统中有不同的路径分割符：Windows分隔符“\”、Linux分隔符“/”；</p>
<p>所以在最初进行开发时就必须考虑到不同系统的路径分隔符的问题；</p>
<p>File类中提供了一个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>范例：正常的路径编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"."</span>+File.separator+<span class="string">"zenner.txt"</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>随着系统的适应性的不断加强，对于当前的路径操作，win风和Linux风也都可以随意使用了；</p>
<ol>
<li><p>在使用File类进行文件处理的时候需要注意的是：程序 → JVM → 操作系统函数 → 文件处理；所以对同一文件进行反复的删除或创建时有可能会出现延迟的问题，所以这个时候最好的方案是别<strong>重名</strong>;</p>
</li>
<li><p>在进行文件创建的时候有一个重要前提：文件的父路径必须首先存在；</p>
<ul>
<li><p>如何获取父路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String getParent​()	<span class="comment">// 返回父路径的字符串</span></span><br><span class="line"><span class="keyword">public</span> File getParentFile​()	<span class="comment">// 返回父路径的File类对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果父路径不存在，需要创建路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> mkdir​()		<span class="comment">// 创建单级目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> mkdirs​()	<span class="comment">// 创建多级目录</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>范例：文件创建的标准形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"."</span>+File.separator+<span class="string">"zenner.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123; 	<span class="comment">// 判断父路径不存在</span></span><br><span class="line">			file.getParentFile().mkdirs();	<span class="comment">// 不存在要创建</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (file.exists()) &#123;	<span class="comment">// 文件是否存在</span></span><br><span class="line">			file.delete();	</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(file.createNewFile());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这种父目录是否存在的判断很多情况下只需要使用一次，但是如果将其留在代码中就可能造成时间复杂度的提升；如果想要提升性能，就先保证目录已经创建。</p>
<h2 id="3-获取文件信息"><a href="#3-获取文件信息" class="headerlink" title="3. 获取文件信息"></a>3. 获取文件信息</h2><p>通过File类获取文件本身的一些信息</p>
<ul>
<li><p>是否可执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> canExecute​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否可读</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> canRead​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否可写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> canWrite​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件大小，返回字节长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> length​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最有一次修改日期时间 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> lastModified​()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"."</span>+File.separator+<span class="string">"Ohwo"</span>+File.separator+<span class="string">"zenner.txt"</span>);</span><br><span class="line">		System.out.println(file.getParent());</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123; 	<span class="comment">// 父路径不存在</span></span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">			file.createNewFile();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"最后修改时间： "</span>+ <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(file.lastModified()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>判断是否是目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="keyword">boolean</span> isDirectory​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否是文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> isFile​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所有文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles​()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"d:"</span>+File.separator);</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">			File result [] = file.listFiles();</span><br><span class="line">			<span class="keyword">for</span> (File f:result) &#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d:\$RECYCLE.BIN</span></span><br><span class="line"><span class="comment">d:\audio</span></span><br><span class="line"><span class="comment">d:\BaiduNetdiskDownload</span></span><br><span class="line"><span class="comment">d:\Download</span></span><br><span class="line"><span class="comment">d:\file</span></span><br><span class="line"><span class="comment">d:\pagefile.sys</span></span><br><span class="line"><span class="comment">d:\Program Files (x86)</span></span><br><span class="line"><span class="comment">d:\software</span></span><br><span class="line"><span class="comment">d:\System Volume Information</span></span><br><span class="line"><span class="comment">d:\technology</span></span><br><span class="line"><span class="comment">d:\Temp</span></span><br><span class="line"><span class="comment">d:\video</span></span><br><span class="line"><span class="comment">d:\迅雷下载</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-综合案例：列出目录结构"><a href="#4-综合案例：列出目录结构" class="headerlink" title="4. 综合案例：列出目录结构"></a>4. 综合案例：列出目录结构</h2><p>任意设置的一个目录路径，然后把这个目录中所有的文件列出，包括子目录中的</p>
<ul>
<li>递归输出目录下的所有文件，并且按层次输出文件目录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator+<span class="string">"technology"</span>+File.separator+<span class="string">"java"</span>+File.separator+<span class="string">"三,高级编程\\note\\java高级编程（上）"</span>);</span><br><span class="line">		listDir(file,<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDir</span><span class="params">(File file,String head)</span> </span>&#123;</span><br><span class="line">		System.out.println(head + file.getName());</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">			File results [] = file.listFiles();</span><br><span class="line">			<span class="keyword">if</span> (results!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				String t = head + <span class="string">"  "</span>;</span><br><span class="line">				<span class="keyword">for</span> (File f : results) &#123;</span><br><span class="line">					listDir(f,t);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java高级编程（上）</span></span><br><span class="line"><span class="comment">  java高级编程</span></span><br><span class="line"><span class="comment">    image-20200620094308218.png</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">    image-20200621114310743.png</span></span><br><span class="line"><span class="comment">  java高级编程.md</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="5-综合案例：文件批量改名"><a href="#5-综合案例：文件批量改名" class="headerlink" title="5. 综合案例：文件批量改名"></a>5. 综合案例：文件批量改名</h2><p>输入目录名称，并把该目录下所有文件名后缀改为txt</p>
<p>对于这类操作必须设置一些假设的约定，能够重命名的文件都是由后缀的；如果没有后缀要为其追加路径，如果由后缀的路径，则必须以最后一个”.”进行截取；</p>
<ul>
<li><p>改名为，参数是一个File类的实例化对象，这个file的名字就是改名为的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean renameTo​(File dest)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\technology\\java\\三,高级编程\\note\\java高级编程（下）\\task"</span>);</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		renameDir(file);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"本次操作花费的时间： "</span>+(end - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameDir</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">			File results [] = file.listFiles();</span><br><span class="line">			<span class="keyword">if</span> (results!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (File f:results) &#123;</span><br><span class="line">					renameDir(f);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">				String filename = file.getName();</span><br><span class="line">				<span class="keyword">if</span> (filename.contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">					filename = file.getName().substring(<span class="number">0</span>,file.getName().lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">				&#125;</span><br><span class="line">				filename = filename + <span class="string">".txt"</span>;</span><br><span class="line">				file.renameTo(<span class="keyword">new</span> File(file.getParent(),filename));	<span class="comment">// 改名的关键步骤</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h1><p>File类只能处理文件本身不能操作文件内容；而开发之中IO的核心意义在于：输入与输出操作；对程序而言，输入与输出可能来自不同的环境。</p>
<h2 id="1-流的基本概念"><a href="#1-流的基本概念" class="headerlink" title="1. 流的基本概念"></a>1. 流的基本概念</h2><p><img src="/2020/07/14/io/image-20200704105240617.png" alt="image-20200704105240617"></p>
<p>对于服务器或者客户端而言实质上传递的就是一种数据流的处理形式，而所谓的数据流指的就是比特数据；而对于这种流的处理形式<code>java.io</code>包里面提供由两种类的支持</p>
<ul>
<li>字节处理流：<code>OutputStream</code>（输出字节流）、 <code>InputStream</code>（输入字节流）；</li>
<li>字符处理流：<code>Writer</code> （输出字符流）、<code>Reader</code>（输入字符流）；</li>
</ul>
<p><img src="/2020/07/14/io/image-20200704110816355.png" alt="image-20200704110816355"></p>
<p>所有的流操作都应该采用如下的统一的步骤进行，下面以文件处理的流程为例：</p>
<ul>
<li>如果要进行的是文件的读写操作，则一定要通过File类找到一个文件路径；</li>
<li>通过字节流或字符流的子类为父类对象进行实例化</li>
<li>利用字节流或字符流中的方法实现数据的输入与输出；</li>
<li>流的操作属于资源操作，资源操作必须进行关闭；</li>
</ul>
<h2 id="2-OutputStream字节输出流"><a href="#2-OutputStream字节输出流" class="headerlink" title="2. OutputStream字节输出流"></a>2. OutputStream字节输出流</h2><p>​    字节的数据是以byte类型为主实现的操作，在进行字节内容输出的时候可以使用 <code>OutputStream</code> 类来完成,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span></span></span><br></pre></td></tr></table></figure>
<p>​    这个类实现了两个接口，于是基本的对应关系如下：</p>
<p><img src="/2020/07/14/io/image-20200704112056495.png" alt="image-20200704112056495"></p>
<ul>
<li><p><code>Closeable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closeable</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flushable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flushable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OutputStream类里定义的是一个公共的输出操作标准，这个标准里定义了三个内容输出的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>public abstract void write(int b) throws IOException</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">输出单个字节数据</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>public void write(byte[] b)  throws IOException</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">输出一组字节数据</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>public void write(byte[] b,  int off,  int len)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">输出部分字节数据</td>
</tr>
</tbody>
</table>
</div>
<p>（第二种方法用的最多）OutputStream类毕竟是一个抽象类，而这个抽象类按传统认识应该通过子类的实例的向上转型完成抽象类的实例化。如果说要进行文件处理操作，则可以使用<code>FileOutputStream</code>子类</p>
<p><img src="/2020/07/14/io/image-20200704113626058.png" alt="image-20200704113626058"></p>
<p>​    因为最终还是要发生向上转型的处理关系，所以此时对于<code>FileOutputStream</code>子类核心关注点就可以放在构造方法上了；</p>
<ul>
<li><p>[覆盖文件】构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileOutputStream​(File file) <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
</li>
<li><p>【可追加文件】构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileOutputStream​(File file, <span class="keyword">boolean</span> append) <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用Output类实现内容的输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);	<span class="comment">// 1. 指定操作路径</span></span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		OutputStream output = <span class="keyword">new</span> FileOutputStream(file);	<span class="comment">// 2. 通过子类实例化</span></span><br><span class="line">		String str = <span class="string">"abcdefg"</span>;</span><br><span class="line">		output.write(str.getBytes());	<span class="comment">// 3. 将字符串变为字节数组并输出</span></span><br><span class="line">		output.close();	<span class="comment">// 4. 关闭输出；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>本程序采用了最为标准的形式实现了输出的操作处理，只是创建了程序的父目录没有创建文件，所以可以看出输出操作可以自动创建文件；</p>
<p>另外，由于OutPutStream类也是AutoCloseable 的接口子类，所以close方法也可以简化使用</p>
<blockquote>
<p>范例：自动关闭处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span>(OutputStream output = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>))&#123;	<span class="comment">// 追加文件</span></span><br><span class="line">			String str = <span class="string">"abcdefg\r\n"</span>;	<span class="comment">// 标准换行</span></span><br><span class="line">			output.write(str.getBytes());</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里的<code>\r\n</code>是标准换行</p>
<h2 id="3-InputStream字节输入流"><a href="#3-InputStream字节输入流" class="headerlink" title="3. InputStream字节输入流"></a>3. InputStream字节输入流</h2><p>​    InputStream类主要实现的就是字节数据读取；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/14/io/image-20200704164549552.png" alt="image-20200704164549552"></p>
<p>​    在<code>InputStream</code>类里面有这么几个核心方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>public abstract int read() throws IOException</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">读取单个字节数据</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>public abstract int read() throws IOException</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">读取一组字节数据</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>public int read(byte[] b,int off, int len)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">读取一组字节数据的部分内容</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>第一种读方法读单个字节数据，读到文件底部会返回-1：</li>
</ol>
<p><img src="/2020/07/14/io/image-20200704162640491.png" alt="image-20200704162640491"></p>
<ol>
<li>第二个方法读取一组字节数据，读取的是读取的个数，如果数据读取到底则返回-1：</li>
</ol>
<p><img src="/2020/07/14/io/image-20200704163130640.png" alt="image-20200704163130640"></p>
<p>InputStream类是一个抽象类，这时应该依靠它的子类来实例化对象，如果要从文件读取一定使用<code>FileInputStream</code>子类；</p>
<p>对子类而言，我们只关心父类对象实例化，构造方法：</p>
<ul>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileInputStream​(File file) <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例： 读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">		<span class="keyword">byte</span> data [] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> Length = input.read(data);</span><br><span class="line">		input.close();</span><br><span class="line">		System.out.println(<span class="string">"【"</span>+<span class="keyword">new</span> String(data,<span class="number">0</span>,Length)+<span class="string">"】 "</span>+Length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">】 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>data的输出需要注意不能全部输出1024个字节；应当按照读进来的个数来读取相应的；</p>
<p>对于字节输入流里最为麻烦的问题在于：使用<code>read()</code>方法读取的时候以字节数组为主进行接收；</p>
<p>JDK 1.9 ，InputStream类里推出了一个新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] readAllBytes​() <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：新方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">		<span class="keyword">byte</span> data [] = input.readAllBytes();</span><br><span class="line">		input.close();</span><br><span class="line">		System.out.println(<span class="string">"【"</span>+<span class="keyword">new</span> String(data)+<span class="string">"】 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">】 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    如果现在想要读的内容很大很大，这个方法可能会搞死程序；</p>
<h2 id="4-Writer字符输出流"><a href="#4-Writer字符输出流" class="headerlink" title="4. Writer字符输出流"></a>4. Writer字符输出流</h2><p>很多情况下用字符串输出是比较方便的。所以推出了<code>Writer</code>，这个类的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span>, <span class="title">Flushable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/14/io/image-20200704165740033.png" alt="image-20200704165740033"></p>
<p>重点看两个Writer类里的输出操作方法：</p>
<ul>
<li><p>输出字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> write​(<span class="keyword">char</span>[] cbuf) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> write​(String str) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用Writer输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Writer out = <span class="keyword">new</span> FileWriter(file,<span class="keyword">true</span>);	<span class="comment">// true打开追加开关</span></span><br><span class="line">		String str = <span class="string">"www.zenner.com\r\n"</span>;</span><br><span class="line">		out.write(str);</span><br><span class="line">		out.append(<span class="string">"What dose the fox say?"</span>);        <span class="comment">// 也可以用append</span></span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用Writer的最大优势在于可以直接利用字符串完成。</p>
<h2 id="5-Reader字符输入流"><a href="#5-Reader字符输入流" class="headerlink" title="5. Reader字符输入流"></a>5. Reader字符输入流</h2><p>Reader是实现字符输入流的一种类型，本身属于一个抽象类，这个类定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/14/io/image-20200704171232544.png" alt="image-20200704171232544"></p>
<p>Reader类里面并没有像Writer类一样提供有整个字符串的输入处理操作，只能通过字符数组来实现我们的接收：</p>
<ul>
<li><p>接收数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> read​(<span class="keyword">char</span>[] cbuf) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：实现数据读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">			Reader in = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">			<span class="keyword">char</span> data[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = in.read(data);</span><br><span class="line">			in.close();</span><br><span class="line">			System.out.println(<span class="string">"读取内容： "</span>+ <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取内容： www.zenner.com</span></span><br><span class="line"><span class="comment">What dose the fox say?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>字符流读取的时候只能够按照数组的形式来实现处理：</p>
<h2 id="6-字节流与字符流的区别"><a href="#6-字节流与字符流的区别" class="headerlink" title="6. 字节流与字符流的区别"></a>6. 字节流与字符流的区别</h2><p>他们的区别重点从输出处理操作来分析；在OutputStream 和 Writer 输出的最后发现都使用了 close() 方法进行了关闭处理。</p>
<p>OutPutStream在未使用close方法关闭后文件内容依然输出了在文件里；</p>
<p>而Writer不使用close方法关闭，内容将无法进行输出，因为Writer使用到了缓冲区；当使用了close的方法的时候实际上会有强制刷新缓冲区的情况，这时会将内容进行输出，没有关闭就不能进行关闭操作；所以此时如果在不关闭的情况下想要实现全部内容的输出可以使用<code>flush()</code>方法强制清空;</p>
<blockquote>
<p>范例：使用writer并强制清空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Writer out = <span class="keyword">new</span> FileWriter(file,<span class="keyword">true</span>);	<span class="comment">// true打开追加开关</span></span><br><span class="line">		String str = <span class="string">"www.zenner.com\r\n"</span>;</span><br><span class="line">		out.write(str);</span><br><span class="line">		out.append(<span class="string">"What dose the fox say?"</span>);        <span class="comment">// 也可以用append</span></span><br><span class="line">		out.flush();	<span class="comment">// 强制刷新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>字节流进行处理时不会使用缓冲区，而字符流会使用到缓冲区；另外使用字符流的缓冲区更加适合中文数据的处理。开发中涉及到中文信息的输出都会用到字符流；</p>
<h2 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7. 转换流"></a>7. 转换流</h2><p>所谓转换是指实现字节流和字符流的功能转换；例如：进行输出的时候OutputStream需要将内容变为字节数组后才可以输出，而writer可以直接输出字符串，所以就需要一种不同流之间的转换操作。</p>
<p>在<code>java.io</code>里提供了两个类：<code>InputStreamReader</code>，<code>OutputStreamWriter</code>;</p>
<ul>
<li><p><code>OutputStreamWriter</code></p>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> OutputStreamWriter​(OutputStream out)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>InputStreamReader</code></p>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> InputStreamReader​(InputStream in)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/14/io/image-20200704175347056.png" alt="image-20200704175347056"></p>
<p>通过类的继承结构可以发现，所谓的转换处理就是将接收到的字节流对象通过向上转型变为字符流对象；</p>
<p><img src="/2020/07/14/io/image-20200704175720608.png" alt="image-20200704175720608"></p>
<blockquote>
<p>范例：观察转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\hello\\a.txt"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">			file.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		OutputStream output = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">		Writer out = <span class="keyword">new</span> OutputStreamWriter(output);	<span class="comment">// 字节流变为字符流</span></span><br><span class="line">		out.write(<span class="string">"www.zenner.com"</span>);</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>讲解转换流的主要目的是进行结构的分析处理;</p>
<p>在<code>InputStream</code>类有他的直接子类<code>FileInputStream</code>，<code>OutputStream</code>有他的直接子类<code>FileOutputStream</code>,而观察<code>FileWriter</code>和<code>FileReader</code>时可以看到的：</p>
<p><img src="/2020/07/14/io/image-20200704180452632.png" alt="image-20200704180452632"></p>
<ul>
<li><p><code>FileWriter</code></p>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriter</span> <span class="keyword">extends</span> <span class="title">OutputStreamWriter</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/14/io/image-20200704180600110.png" alt="image-20200704180600110"></p>
<ul>
<li><p><code>FileReader</code></p>
<ul>
<li>定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/07/14/io/image-20200704181239417.png" alt="image-20200704181239417"></p>
<h2 id="8-综合实战：文件拷贝"><a href="#8-综合实战：文件拷贝" class="headerlink" title="8. 综合实战：文件拷贝"></a>8. 综合实战：文件拷贝</h2><p>模拟拷贝命令：通过初始化参数输入拷贝的源文件路径与拷贝的目标路径实现文件的拷贝处理；</p>
<blockquote>
<p>需求分析：</p>
<ul>
<li>需要实现文件的拷贝，首先文件就可以是各种文件所以肯定使用字节流；</li>
<li>拷贝时应考虑到大文件的拷贝问题；</li>
</ul>
<p>实现方案：</p>
<ul>
<li><p>方案一：使用<code>InputStream</code>将全部要拷贝的内容直接读取到程序里面，而后一次性输出到目标文件</p>
<ul>
<li>缺点：如果拷贝的文件很大，基本程序就死了</li>
</ul>
</li>
<li><p>方案二：采用部分拷贝，读取一部分，输出一部分；</p>
<ul>
<li><p>采用第二种方案核心的方法：</p>
<ul>
<li><p><code>InputStream</code> ： `</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OutputStream</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,  <span class="keyword">int</span> off,  <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>范例：实现文件拷贝处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span></span>&#123;	<span class="comment">// 文件操作工具类</span></span><br><span class="line">	<span class="keyword">private</span> File srcFile;</span><br><span class="line">	<span class="keyword">private</span> File desFile;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(String src,String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">new</span> File(src),<span class="keyword">new</span> File(des));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(File srcFile, File desFile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.srcFile = srcFile;</span><br><span class="line">		<span class="keyword">this</span>.desFile = desFile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException,FileNotFoundException </span>&#123;		<span class="comment">// 文件拷贝处理</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.srcFile.exists()) &#123; 	<span class="comment">// 源文件必须存在！！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"拷贝源文件不存在"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.desFile.getParentFile().exists()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.desFile.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span> data [] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		InputStream input = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.srcFile);</span><br><span class="line">			output = <span class="keyword">new</span> FileOutputStream(<span class="keyword">this</span>.desFile);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				len = input.read(data);	<span class="comment">//</span></span><br><span class="line">				<span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">					output.write(data,<span class="number">0</span>,len);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">while</span> (len != -<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input!= <span class="keyword">null</span>) &#123;</span><br><span class="line">				input.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">				output.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		FileUtil fu = <span class="keyword">new</span> FileUtil(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		System.out.println(fu.copy() ? <span class="string">"文件拷贝成功"</span>:<span class="string">"文件拷贝失败"</span>);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"拷贝完成的时间： "</span> + (end-start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">文件拷贝成功</span></span><br><span class="line"><span class="comment">拷贝完成的时间： 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span></span>&#123;	<span class="comment">// 文件操作工具类</span></span><br><span class="line">	<span class="keyword">private</span> File srcFile;</span><br><span class="line">	<span class="keyword">private</span> File desFile;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(String src,String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">new</span> File(src),<span class="keyword">new</span> File(des));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(File srcFile, File desFile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.srcFile = srcFile;</span><br><span class="line">		<span class="keyword">this</span>.desFile = desFile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException,FileNotFoundException </span>&#123;		<span class="comment">// 文件拷贝处理</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.srcFile.exists()) &#123; 	<span class="comment">// 源文件必须存在！！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"拷贝源文件不存在"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.desFile.getParentFile().exists()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.desFile.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span> data [] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		InputStream input = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.srcFile);</span><br><span class="line">			output = <span class="keyword">new</span> FileOutputStream(<span class="keyword">this</span>.desFile);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 1. 读取数据到数组之中，随后返回读取的个数</span></span><br><span class="line"><span class="comment">//			do &#123;</span></span><br><span class="line"><span class="comment">//				len = input.read(data);	//</span></span><br><span class="line"><span class="comment">//				if (len != -1) &#123;</span></span><br><span class="line"><span class="comment">//					output.write(data,0,len);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125; while (len != -1);</span></span><br><span class="line">			<span class="comment">// 2. 判断个数是否是-1，如果不是则进行读写</span></span><br><span class="line">			<span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				output.write(data,<span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input!= <span class="keyword">null</span>) &#123;</span><br><span class="line">				input.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">				output.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		FileUtil fu = <span class="keyword">new</span> FileUtil(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		System.out.println(fu.copy() ? <span class="string">"文件拷贝成功"</span>:<span class="string">"文件拷贝失败"</span>);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"拷贝完成的时间： "</span> + (end-start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">文件拷贝成功</span></span><br><span class="line"><span class="comment">拷贝完成的时间： 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    以上的实现是拷贝文件的最原始的实现，而从JDK1.9开始<code>InputStream</code>和<code>Reader</code>类中都追加有数据转存的处理操作方法：</p>
<ul>
<li><p><code>InputStream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> transferTo​(OutputStream out) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Reader</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(Writer out)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用转存的方式处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span></span>&#123;	<span class="comment">// 文件操作工具类</span></span><br><span class="line">	<span class="keyword">private</span> File srcFile;</span><br><span class="line">	<span class="keyword">private</span> File desFile;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(String src,String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">new</span> File(src),<span class="keyword">new</span> File(des));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(File srcFile, File desFile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.srcFile = srcFile;</span><br><span class="line">		<span class="keyword">this</span>.desFile = desFile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException,FileNotFoundException </span>&#123;		<span class="comment">// 文件拷贝处理</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.srcFile.exists()) &#123; 	<span class="comment">// 源文件必须存在！！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"拷贝源文件不存在"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.desFile.getParentFile().exists()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.desFile.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		InputStream input = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.srcFile);</span><br><span class="line">			output = <span class="keyword">new</span> FileOutputStream(<span class="keyword">this</span>.desFile);</span><br><span class="line">			input.transferTo(output);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input!= <span class="keyword">null</span>) &#123;</span><br><span class="line">				input.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">				output.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		FileUtil fu = <span class="keyword">new</span> FileUtil(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		System.out.println(fu.copy() ? <span class="string">"文件拷贝成功"</span>:<span class="string">"文件拷贝失败"</span>);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"拷贝完成的时间： "</span> + (end-start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时要注意程序运行环境的版本问题；此时进一步扩展，要实现文件目录的拷贝。拷贝了文件目录还需要拷贝所有的子目录中的文件。</p>
<blockquote>
<p>范例：文件夹拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span></span>&#123;	<span class="comment">// 文件操作工具类</span></span><br><span class="line">	<span class="keyword">private</span> File srcFile;</span><br><span class="line">	<span class="keyword">private</span> File desFile;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(String src,String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">new</span> File(src),<span class="keyword">new</span> File(des));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUtil</span><span class="params">(File srcFile, File desFile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.srcFile = srcFile;</span><br><span class="line">		<span class="keyword">this</span>.desFile = desFile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;		<span class="comment">// 文件拷贝处理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.copyFileImpl(<span class="keyword">this</span>.srcFile, <span class="keyword">this</span>.desFile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">copyFileImpl</span><span class="params">(File srcFile,File desFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!srcFile.exists()) &#123; 	<span class="comment">// 源文件必须存在！！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"拷贝源文件不存在"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!desFile.getParentFile().exists()) &#123;</span><br><span class="line">			desFile.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		InputStream input = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">			output = <span class="keyword">new</span> FileOutputStream(desFile);</span><br><span class="line">			input.transferTo(output);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (input!= <span class="keyword">null</span>) &#123;</span><br><span class="line">				input.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">				output.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copyDir</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.copyImpl(<span class="keyword">this</span>.srcFile);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copyImpl</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">			File results [] = file.listFiles();</span><br><span class="line">			<span class="keyword">if</span> (results!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (File f:results) &#123;</span><br><span class="line">					copyImpl(f);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			String newFilePath = file.getPath().replace(<span class="keyword">this</span>.srcFile.getPath()+File.separator,<span class="string">""</span>);</span><br><span class="line">			File newFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.desFile,newFilePath);</span><br><span class="line">			System.out.println(newFile);</span><br><span class="line">			<span class="keyword">this</span>.copyFileImpl(file, newFile);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		FileUtil fu = <span class="keyword">new</span> FileUtil(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">new</span> File(args[<span class="number">0</span>]).isDirectory()) &#123;</span><br><span class="line">			System.out.println(fu.copy() ? <span class="string">"文件拷贝成功"</span>:<span class="string">"文件拷贝失败"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(fu.copyDir() ? <span class="string">"文件夹拷贝成功"</span>:<span class="string">"文件夹拷贝失败"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ong end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"拷贝完成的时间： "</span> + (end-start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="IO深入操作"><a href="#IO深入操作" class="headerlink" title="IO深入操作"></a>IO深入操作</h1><h2 id="1-字符编码"><a href="#1-字符编码" class="headerlink" title="1. 字符编码"></a>1. 字符编码</h2><p>实际开发中常用的编码有以下几种：</p>
<ul>
<li>GBK/GB2312：国标；GB2312只描述简体中文，而GBK包含有简体中文与繁体中文；</li>
<li>ISO8859-1：国际通用编码，可以用其描述所有的字母信息，如果是象形文字则需要进行编码处理；</li>
<li>UNICODE编码：采用十六进制的方式存储，可以描述所有的文字信息；</li>
<li>UTF 编码：象形文字部分使用十六进制编码，而普通的字母采用的是IOS8859-1编码，优势在于可以快速地传输，节约带宽，也就是开发之中的首选编码，主要使用“UTF-8”</li>
</ul>
<p>如果想知道当前系统中支持的编码规则，则可以采用如下代码列出全部的本机属性：</p>
<blockquote>
<p>范例：列出本机属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.getProperties().list(System.out);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取的部分信息</span></span><br><span class="line"><span class="comment">file.encoding=UTF-8</span></span><br><span class="line"><span class="comment">file.separator=\</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>范例：程序编码与系统编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:"</span>+File.separator+<span class="string">"a.txt"</span>);</span><br><span class="line">		output.write(<span class="string">"中华人民共和国万岁！"</span>.getBytes());</span><br><span class="line">		output.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序编码与系统编码一致都是UTF-8，即使写入了字节流，系统仍可以正确编码</span></span><br><span class="line"><span class="comment">而其他的编码就可能在文件中出现乱码；</span></span><br><span class="line"><span class="comment">当然也是不一定都会出现那乱码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>项目中出现乱码问题就是编码和解码标准不统一，而解决方法就是采用<code>UTF-8</code></p>
<h2 id="2-内存操作流"><a href="#2-内存操作流" class="headerlink" title="2. 内存操作流"></a>2. 内存操作流</h2><p>之前都是文件操作流，文件操作流的特点就是读取文件，写入文件，以文件为终端</p>
<p><img src="/2020/07/14/io/image-20200705111942371.png" alt="image-20200705111942371"></p>
<p>假设需要IO操作又不希望产生文件，就可以以内存为终端进行处理；这个时候的流程</p>
<p><img src="/2020/07/14/io/image-20200705112148358.png" alt="image-20200705112148358"></p>
<p>​    在java里提供有两类的内存操作流：</p>
<ul>
<li>字节内存操作流：<code>ByteArrayOutputStream</code>、<code>ByteArrayInputStream</code>;</li>
<li>字符内存操作流：<code>CharArrayWriter</code>、<code>CharArrayReader</code></li>
</ul>
<p><img src="/2020/07/14/io/image-20200705112530702.png" alt="image-20200705112530702"></p>
<p><img src="/2020/07/14/io/../../../../../study/technology/java/三,高级编程/note/java高级编程（下）/io/image-20200705113450324.png" alt="image-20200705113450324"></p>
<p><img src="/2020/07/14/io/image-20200705113630921.png" alt="image-20200705113630921"></p>
<p><img src="/2020/07/14/io/image-20200705113718364.png" alt="image-20200705113718364"></p>
<p>​    下面以 <code>ByteArrayOutputStream</code> 和 <code>ByteArrayInputStream</code>  类为主进行内存的使用分析，先分析他们各自的构造方法：</p>
<ul>
<li><p><code>ByteArrayInputStream</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteArrayInputStream​(<span class="keyword">byte</span>[] buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ByteArrayOutputStream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteArrayOutputStream​()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 <code>ByteArrayOutputStream</code> 类里面有一个重要的方法，这个方法可以获取全部保存在内存流中的数据信息，该方法为：</p>
<ul>
<li><p>获取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] toByteArray​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用字符串的形式来获取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String toString​()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：利用内存流实现一个小写字母转大写字母的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"www.zenner.com"</span>;</span><br><span class="line">		InputStream input = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()); <span class="comment">// 将数据保存在内存流</span></span><br><span class="line">		OutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((data = input.read())!= -<span class="number">1</span>) &#123;		<span class="comment">// 每次读取一个字节</span></span><br><span class="line">			output.write(Character.toUpperCase((<span class="keyword">char</span>)data));	<span class="comment">// 	保存数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(output);</span><br><span class="line">		input.close();</span><br><span class="line">		output.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    如果不希望只是以字符串的形式返回，因为存放的还可能是二进制数据，那么就可以用子类的扩展功能获取全部字节数据</p>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String str = <span class="string">"www.zenner.com"</span>;</span><br><span class="line">		InputStream input = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()); <span class="comment">// 将数据保存在内存流</span></span><br><span class="line">		<span class="comment">// 必须使用子类来调用子类自己的扩展方法</span></span><br><span class="line">		ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((data = input.read())!= -<span class="number">1</span>) &#123;		<span class="comment">// 每次读取一个字节</span></span><br><span class="line">			output.write(Character.toUpperCase((<span class="keyword">char</span>)data));	<span class="comment">// 	保存数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span> result [] = output.toByteArray();</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(result));</span><br><span class="line">		input.close();</span><br><span class="line">		output.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-管道流"><a href="#3-管道流" class="headerlink" title="3. 管道流"></a>3. 管道流</h2><p>管道流之遥的功能是实现两个线程之间的IO处理操作；</p>
<p><img src="/2020/07/14/io/image-20200705120239190.png" alt="image-20200705120239190"></p>
<p>同样也有两类：</p>
<ul>
<li><p><strong>字节管道流</strong>：<code>PipedOutputStream</code> 、 <code>PipedInputStream</code> ;</p>
<ul>
<li><p>连接操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedInputStream snk)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>字符管道流</strong>：<code>PipedReader</code>、 <code>PipedWriter</code> ;</p>
<ul>
<li><p>连接处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(PipedReader snk)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>范例：实现管道操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedOutputStream output;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SendThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.output.write((<span class="string">"【"</span>+Thread.currentThread().getName()+<span class="string">"信息发送】www.zenner.com"</span>).getBytes());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.output.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedInputStream input;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReceiveThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> len = <span class="keyword">this</span>.input.read(data);</span><br><span class="line">			System.out.println(<span class="string">"&#123;"</span>+Thread.currentThread().getName()+<span class="string">"接收消息&#125;"</span>+<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.input.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> input;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SendThread send = <span class="keyword">new</span> SendThread();</span><br><span class="line">		ReceiveThread receive = <span class="keyword">new</span> ReceiveThread();</span><br><span class="line">		send.getOutput().connect(receive.getInput());</span><br><span class="line">		<span class="keyword">new</span> Thread(send,<span class="string">"消息发送线程"</span>).start()	;</span><br><span class="line">		<span class="keyword">new</span> Thread(receive,<span class="string">"消息接收线程"</span>).start()	;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="输入与输出支持"><a href="#输入与输出支持" class="headerlink" title="输入与输出支持"></a>输入与输出支持</h1><h2 id="1-打印流"><a href="#1-打印流" class="headerlink" title="1. 打印流"></a>1. 打印流</h2><p>要进行数据输出一般都用<code>outputStream</code>类；这个类的数据输出操作功能有限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>所有的输出都要转为字节字节后才能输出；而项目里的输出都是其他类型所以还要再转换为字节的形式来处理，这样比较麻烦；所以为了开发者会开发一些功能类来简化这个过程；不过这些包装起来的输出操作如何进行，核心使用的就是<code>OutputStream</code>；</p>
<blockquote>
<p>范例：自己弄这样一个打印流；打印流的设计思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintUtil</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;	<span class="comment">// 实现一些常用数据的输出</span></span><br><span class="line">	<span class="keyword">private</span> OutputStream output;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintUtil</span><span class="params">(OutputStream output)</span> </span>&#123;	<span class="comment">// 由外部来决定输出的位置</span></span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.output = output;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.output.write(str.getBytes());</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.print(str+ <span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.output.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.println(String.valueOf(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.print(String.valueOf(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"d:"</span>+File.separator + <span class="string">"zenner.txt"</span>);</span><br><span class="line">		PrintUtil pu = <span class="keyword">new</span> PrintUtil(<span class="keyword">new</span> FileOutputStream(file));	<span class="comment">// 通过传递类的类型使得各种类型的输出都能由这个类来输出</span></span><br><span class="line">		pu.println(<span class="string">"姓名啊哈哈哈"</span>);</span><br><span class="line">		pu.print(<span class="string">"年龄："</span>);</span><br><span class="line">		pu.println(<span class="number">78</span>);</span><br><span class="line">		pu.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>打印流的设计思想的本质在于提高已有类的功能；例如：OutputStream类是唯一可以实现输出的操作功能类，所以应该以其为核心根本，但是这个类输出的操作功能有限，所以不方便进行输出各个数据类型，所以为他做出一层包装，此时用到的设计思想就是“装饰设计模式”；</p>
<p><code>java.io</code>包中有两种打印流：<code>printStream</code>、<code>printWriter</code>;</p>
<ul>
<li><p><code>printStream</code></p>
<ul>
<li>继承关系：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrintStream​(OutputStream out)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>printWriter</code></p>
<ul>
<li>继承关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriter</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Writer</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrintWriter​(OutputStream out)</span><br><span class="line"><span class="keyword">public</span> PrintWriter​(Writer out)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/14/io/../../../../../study/technology/java/三,高级编程/note/java高级编程（下）/java高级编程（下）/image-20200707090637650.png" alt="image-20200707090637650"></p>
<p>下面使用PrintWriter来实现数据的输出操作：</p>
</li>
</ul>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"d:"</span>+File.separator + <span class="string">"zenner.txt"</span>);</span><br><span class="line">		PrintWriter pu = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(file));	<span class="comment">// 通过传递类的类型使得各种类型的输出都能由这个类来输出</span></span><br><span class="line">		pu.println(<span class="string">"姓名啊哈哈哈"</span>);</span><br><span class="line">		pu.print(<span class="string">"年龄："</span>);</span><br><span class="line">		pu.println(<span class="number">78</span>);</span><br><span class="line">		pu.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>JDK 1.5开始Printwriter类里面追加有格式化输出的操作支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(String format, Object... args)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：格式化输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"d:"</span>+File.separator + <span class="string">"zenner.txt"</span>);</span><br><span class="line">		PrintWriter pu = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(file));	<span class="comment">// 通过传递类的类型使得各种类型的输出都能由这个类来输出</span></span><br><span class="line">		String name = <span class="string">"小兵吱吱"</span>;</span><br><span class="line">		<span class="keyword">int</span> age = <span class="number">78</span>;</span><br><span class="line">		<span class="keyword">double</span> salary = <span class="number">4324.42</span>;</span><br><span class="line">		pu.printf(<span class="string">"姓名：%s、年龄：%d、收入：%9.2f"</span>, name,age,salary);</span><br><span class="line">		pu.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">姓名：小兵吱吱、年龄：78、收入：  4324.42</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个类输出起来比OutputStream类要简单；以后输出的时候就是用打印流；</p>
<h2 id="2-System类对IO的支持"><a href="#2-System类对IO的支持" class="headerlink" title="2. System类对IO的支持"></a>2. System类对IO的支持</h2><p>System是一个系统类；系统类里有三个和输出输出相关的常量：</p>
<ul>
<li><p>标准输出：显示器输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream err</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>标准输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InputStream in</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer.parseInt(<span class="string">"s"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">			System.err.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>java.lang.NumberFormatException: <span style="color:red">For input string: “s”</span></p>
<p>ava.lang.NumberFormatException: For input string: “s”</p>
<p>System.out和System.err都是同一类型的；</p>
<p>最早这么设置是因为<code>out</code>是希望用户看到信息；<code>err</code>是不希望用户看到的；</p>
<blockquote>
<p>范例：实现键盘输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		InputStream input = System.in;</span><br><span class="line">		System.out.println(<span class="string">"请输出信息:"</span>);</span><br><span class="line">		<span class="keyword">byte</span> [] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = input.read(data);</span><br><span class="line">		System.out.println(<span class="string">"输入内容为："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请输出信息:</span></span><br><span class="line"><span class="comment">fdsafdsafdsa</span></span><br><span class="line"><span class="comment">输入内容为：fdsafdsafdsa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样的键盘输入处理是有缺陷的；如果长度不足只能接收部分数据；在接收的时候可能接受中文造成编码不当；</p>
<h2 id="3-BufferReader缓冲输入流"><a href="#3-BufferReader缓冲输入流" class="headerlink" title="3. BufferReader缓冲输入流"></a>3. BufferReader缓冲输入流</h2><p><code>BufferReader</code>提供的是一个缓冲字符输入流的概念；可以很好的解决输入流数据的读取问题；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in, <span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedReader​<span class="params">(Reader in)</span></span></span><br></pre></td></tr></table></figure>
<p>该类有一个重要的方法：</p>
<ul>
<li><p>读取一行数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用这个类实现键盘输入数据的标准化定义</p>
<p><img src="/2020/07/14/io/../../../../../study/technology/java/三,高级编程/note/java高级编程（下）/java高级编程（下）/image-20200707094310296.png" alt="image-20200707094310296"></p>
<blockquote>
<p>范例：实现键盘数据输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		System.out.println(<span class="string">"请输入信息： "</span>);</span><br><span class="line">		String msg = input.readLine();</span><br><span class="line">		System.out.println(<span class="string">"输入内容为： "</span>+msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2020/07/14/io/../../../../../study/technology/java/三,高级编程/note/java高级编程（下）/java高级编程（下）/image-20200707095136134.png" alt="image-20200707095136134"></p>
<p>这个类是之前最好的，后面 JDK 1.5以后有一个更好的类；</p>
<h2 id="4-Scanner扫描流"><a href="#4-Scanner扫描流" class="headerlink" title="4. Scanner扫描流"></a>4. Scanner扫描流</h2><p><code>java.util.Scanner</code>是为了解决输入流的访问问题；可以理解为<code>BufferedReader</code>的替代功能类，在Scanner类里有如下的几种操作方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(InputStream source)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Scanner​<span class="params">(File source)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Scanner</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">String</span>&gt;, <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>是否有数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取出数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String next​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Scanner <span class="title">useDelimiter</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用<code>Scanner</code>实现键盘数据输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入年龄： "</span>);</span><br><span class="line">		<span class="keyword">if</span> (sc.hasNextInt()) &#123;	<span class="comment">// 是否有整数输入</span></span><br><span class="line">			<span class="keyword">int</span> age = sc.nextInt();</span><br><span class="line">			System.out.println(<span class="string">"您的年龄： "</span> + age);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"输入正确格式"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：持续输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入年龄： "</span>);</span><br><span class="line">		<span class="keyword">while</span>(sc.hasNextInt()) &#123;	<span class="comment">// 是否有整数输入</span></span><br><span class="line">			<span class="keyword">int</span> age = sc.nextInt();</span><br><span class="line">			System.out.println(<span class="string">"您的年龄： "</span> + age);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Scanner实现键盘输入是比较简单的；</p>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入： "</span>);</span><br><span class="line">		<span class="keyword">if</span>(sc.hasNext()) &#123;	<span class="comment">// 是否有整数输入</span></span><br><span class="line">			System.out.println(<span class="string">"您的年龄： "</span> + sc.next());</span><br><span class="line">		&#125;</span><br><span class="line">		sc.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>还有一个特点是可以直接利用正则济宁验证判断；</p>
<blockquote>
<p>范例：验证一个人的生日（yyyy-MM-dd）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入您的生日： "</span>);</span><br><span class="line">		<span class="comment">// 验证一个人的生日（yyyy-MM-dd）</span></span><br><span class="line">		<span class="keyword">if</span>(sc.hasNext(<span class="string">"\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;2&#125;"</span>)) &#123;	<span class="comment">// 是否有整数输入</span></span><br><span class="line">			System.out.println(<span class="string">"您的年龄： "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).parse(sc.next(<span class="string">"\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;2&#125;"</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">		sc.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：用Scanner读文件（我读我自己）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		System.out.println(new File("").getAbsolutePath());</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"./src/cn/jubingyi/Demo/JavaApiDemo.java"</span>));</span><br><span class="line">		sc.useDelimiter(<span class="string">"\n"</span>);</span><br><span class="line">		<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">			System.out.println(sc.next());</span><br><span class="line">		&#125;</span><br><span class="line">		sc.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果程序需要输出数据一定使用打印流，输入数据使用<code>Scanner(BufferedReader)</code></p>
<h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><p>​    几乎只要是java开发就一定存在序列化的概念，而正是因为序列化的概念逐步发展，慢慢也有了更多的序列化标准；</p>
<h2 id="1-对象序列化的基本概念"><a href="#1-对象序列化的基本概念" class="headerlink" title="1. 对象序列化的基本概念"></a>1. 对象序列化的基本概念</h2><p>​    所谓的对象序列化只是将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存或者网络传输；（什么你要把对象发送到远程服务器上？）</p>
<p><img src="/2020/07/14/io/image-20200708171901373-1597218131561.png" alt="image-20200708171901373"></p>
<p>然后并不是所有的对象都可以被序列化，在java里有一个强制性的要求：如果要序列化的对象，那么序列化的类一定要实现 <code>java.io.Serializable</code> 父接口，作为序列化的标记。    但是这个方法没有任何的方法，因为它描述的是一种类的能力；</p>
<blockquote>
<p>范例：定义一个可以被序列化的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;	<span class="comment">// 可以被序列化</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时Person类产生的每一个对象都可以实现二进制的数据传输，属于可以被序列化的程序类；</p>
<h2 id="2-序列化与反序列化"><a href="#2-序列化与反序列化" class="headerlink" title="2. 序列化与反序列化"></a>2. 序列化与反序列化</h2><p>​    有了序列化的支持类之后如果想要实现序列化与反序列化的操作则就可以利用以下的两个类完成</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名称</th>
<th style="text-align:center">序列化：<code>objectOutputStream</code></th>
<th style="text-align:center">反序列化：<code>objectInputStream</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类定义</td>
<td style="text-align:center"><code>public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants</code></td>
<td style="text-align:center"><code>public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</code></td>
</tr>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:center"><code>public ObjectOutputStream(OutputStream out)throws IOException</code></td>
<td style="text-align:center"><code>public ObjectInputStream(InputStream in) throws IOException</code></td>
</tr>
<tr>
<td style="text-align:center">操作方法</td>
<td style="text-align:center"><code>public final void writeObject(Object obj) throws IOException</code></td>
<td style="text-align:center"><code>public final Object readObject() throws IOException,  ClassNotFoundException</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>范例：实现序列化与反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> File SAVE_FILE = <span class="keyword">new</span> File(<span class="string">"./fileOperation/zenner.person"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!SAVE_FILE.getParentFile().exists()) &#123;</span><br><span class="line">			SAVE_FILE.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		saveobject(<span class="keyword">new</span> Person(<span class="string">"笑喷涕"</span>,<span class="number">78</span>));</span><br><span class="line">		System.out.println(loadObject());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveobject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(SAVE_FILE));</span><br><span class="line">		oos.writeObject(obj);	<span class="comment">// 序列化</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(SAVE_FILE));</span><br><span class="line">		Object obj = ois.readObject();	<span class="comment">// 反序列化</span></span><br><span class="line">		ois.close();</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;	<span class="comment">// 可以被序列化</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person [name=笑喷涕, age=78]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在java中的对象序列化与反序列化必须使用内部提供的对象操作流，因为里面牵扯到二进制数据的格式，这是不能够自定义处理，如果想要实现一组对象的序列化，则可以使用对象数组完成；</p>
<p>​    在很多的实际项目开发之中，开发者就很少能够见到这两个类，因为有许多容器的帮助开发者自动实现；</p>
<h2 id="3-transient关键字"><a href="#3-transient关键字" class="headerlink" title="3. transient关键字"></a>3. transient关键字</h2><p>​    默认情况下执行了对象序列化的时候会将类中的全部属性的内容进行全部序列化，但很多情况下，并不需要进行序列化的处理，这时就可以在属性定义上使用transient关键字来完成；</p>
<p>​    在进行序列化处理的时候name属性的内容是不会被保存下来的，也就是说，读取的数据name将是其对应数据的默认值“null”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> File SAVE_FILE = <span class="keyword">new</span> File(<span class="string">"./fileOperation/zenner.person"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!SAVE_FILE.getParentFile().exists()) &#123;</span><br><span class="line">			SAVE_FILE.getParentFile().mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		saveobject(<span class="keyword">new</span> Person(<span class="string">"笑喷涕"</span>,<span class="number">78</span>));</span><br><span class="line">		System.out.println(loadObject());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveobject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(SAVE_FILE));</span><br><span class="line">		oos.writeObject(obj);	<span class="comment">// 序列化</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(SAVE_FILE));</span><br><span class="line">		Object obj = ois.readObject();	<span class="comment">// 反序列化</span></span><br><span class="line">		ois.close();</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;	<span class="comment">// 可以被序列化</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person [name=null, age=78]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>​    如果假设类之中有一些是需要计算保存的属性内容往往是不需要被序列化的，这时就可以使用 <code>transient</code>关键字，在实际开发之中大部分需要被序列化的类往往都是简单java类，所以这一个关键字出现的频率并不高。</p>
<h1 id="javaIO编程案例"><a href="#javaIO编程案例" class="headerlink" title="javaIO编程案例"></a>javaIO编程案例</h1><h2 id="1-数字大小比较"><a href="#1-数字大小比较" class="headerlink" title="1. 数字大小比较"></a>1. 数字大小比较</h2><p>编写程序，输入3个整数，并求出3个整数的最大值和最小值：</p>
<p>想要进行数字输入处理，那么应该保证输入错误的时候可以重新输入；那么为了达到重用的设计，我们应该准备一个单独的输入数据类。</p>
<blockquote>
<ol>
<li>定义一个输入工具类（Scanner实现）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.util;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputUtil</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(prompt);</span><br><span class="line">			<span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">			Scanner input = <span class="keyword">new</span> Scanner(System.in);		<span class="comment">// 这里用的是 Scanner</span></span><br><span class="line">			<span class="keyword">if</span> (input.hasNext(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">				num = Integer.parseInt(input.next(<span class="string">"\\d+"</span>));	</span><br><span class="line">				flag = <span class="keyword">false</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"输入的内容不是数字！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>用BufferedReader来实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputUtil</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">		BufferedReader buf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			System.out.println(prompt);</span><br><span class="line">			String str = <span class="keyword">null</span> ; </span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				str = buf.readLine();</span><br><span class="line">				<span class="keyword">if</span> (str.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">					num = Integer.parseInt(str);</span><br><span class="line">					flag = <span class="keyword">false</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"输入的内容不是数字！"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				System.out.println(<span class="string">"输入的内容不是数字！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义数据的输入处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	输入数据并且返回输入数据的最大值与最小值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> count	表示输入数据的个数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 整数数组，包含两项，第一个是最大值，第二个是最小值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> [] stat(<span class="keyword">int</span> count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实现接口的子类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.INumberService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.util.InputUtil;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberServiceImpl</span> <span class="keyword">implements</span> <span class="title">INumberService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] stat(<span class="keyword">int</span> count) &#123;</span><br><span class="line">		<span class="keyword">int</span> result [] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> data [] = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; data.length ; x ++) &#123;	<span class="comment">// 	信息循环输入</span></span><br><span class="line">			data[x] = InputUtil.getInt(<span class="string">"请输入第“"</span> + (x + <span class="number">1</span>) + <span class="string">"”个数字"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		result[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">		result[<span class="number">1</span>] = data[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; data.length ; x ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (data[x] &gt; result[<span class="number">0</span>]) &#123;</span><br><span class="line">				result[<span class="number">0</span>] = data[x];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (data[x] &lt; result[<span class="number">1</span>]) &#123;</span><br><span class="line">				result[<span class="number">1</span>] = data[x];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义工厂类获取接口对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.INumberService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.impl.NumberServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> INumberService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> NumberServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写测试类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.factory.Factory;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.INumberService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOcaseDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		INumberService numberService = Factory.getInstance();</span><br><span class="line">		<span class="keyword">int</span> result [] = numberService.stat(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">"最大值： "</span> + result[<span class="number">0</span>] + <span class="string">"、最小值： "</span> + result[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-文件保存处理"><a href="#2-文件保存处理" class="headerlink" title="2.文件保存处理"></a>2.文件保存处理</h2><p>​    从键盘输入文件的内容和要保存的文件名称，然后根据输入的名称创建文件，并将内容保存到文件中。</p>
<p>在这里可以看出文件路径在文件启动之前就应该启动好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOcaseDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SAVE_DIR = <span class="string">"D:"</span> + File.separator + <span class="string">"zenner"</span> + File.separator;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(SAVE_DIR);</span><br><span class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">			file.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>定义一个文件操作的服务接口：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFileService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	定义文件的保存处理方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	保存成功返回true,否则返回false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>InputUtil</code>类里面追加有输入字符串的处理方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputUtil</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">InputUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String prompt)</span> </span>&#123;</span><br><span class="line">		String str = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			Scanner input = <span class="keyword">new</span> Scanner(System.in);	</span><br><span class="line">			System.out.println(prompt);</span><br><span class="line">			<span class="keyword">if</span> (input.hasNext()) &#123;</span><br><span class="line">				str = input.next().trim();</span><br><span class="line">				<span class="keyword">if</span> (!<span class="string">""</span>.equals(str)) &#123;	<span class="comment">// 不是空字符串</span></span><br><span class="line">					flag = <span class="keyword">false</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"输入的内容不允许为空！"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"输入的内容不允许为空！"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实现文件名字与内容输入的实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IFileService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.util.InputUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServiceImpl</span> <span class="keyword">implements</span> <span class="title">IFileService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = InputUtil.getString(<span class="string">"请输入保存文件名称"</span>);</span><br><span class="line">		<span class="keyword">this</span>.content = InputUtil.getString(<span class="string">"请输入保存文件的内容"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(IFileService.SAVE_DIR + <span class="keyword">this</span>.name);</span><br><span class="line">		PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">			out.print(<span class="keyword">this</span>.content);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>工厂类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IFileService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.INumberService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.impl.FileServiceImpl;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.impl.NumberServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IFileService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FileServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：测试类里有一个static使得其启动时就会提前执行；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.factory.Factory;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IFileService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.INumberService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOcaseDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		File file = <span class="keyword">new</span> File(IFileService.SAVE_DIR);</span><br><span class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">			file.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IFileService fileService = Factory.getInstance();</span><br><span class="line">		fileService.save();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-字符串逆序显示"><a href="#3-字符串逆序显示" class="headerlink" title="3. 字符串逆序显示"></a>3. 字符串逆序显示</h2><p>从键盘传入的多个字符串到程序中，并将它们按逆序输出在屏幕上。</p>
<p>程序之中应该考虑到如下的几种设计：</p>
<ul>
<li>既然字符串的内容可以随时修改，最好建立一个StringBuffer做保存；</li>
<li>在进行数据处理的时候应由用户来决定是否继续输入</li>
</ul>
<blockquote>
<ol>
<li>定义字符串的操作标准</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStringService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span> </span>;</span><br><span class="line">	<span class="keyword">public</span> String[] reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实现子类里就使用<code>StringBuffer</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IStringService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringServiceImpl</span> <span class="keyword">implements</span> <span class="title">IStringService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> StringBuffer data = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data.append(str).append(<span class="string">"|"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] reverse() &#123;</span><br><span class="line">		String result [] = <span class="keyword">this</span>.data.toString().split(<span class="string">"\\|"</span>);</span><br><span class="line">		<span class="keyword">int</span> center = result.length/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tail = result.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; center ; x ++) &#123;</span><br><span class="line">			String temp = result[head] ;</span><br><span class="line">			result[head] = result[tail] ;</span><br><span class="line">			result[tail] = temp ;</span><br><span class="line">			head ++;</span><br><span class="line">			tail --;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义工厂类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IStringService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.impl.StringServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IStringService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StringServiceImpl();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义一个Menu处理类，采用交互式的界面完成处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.Menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.factory.Factory;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IStringService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.util.InputUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IStringService stringservice;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stringservice = Factory.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.choose();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.show();</span><br><span class="line">		String choose = InputUtil.getString(<span class="string">"请进行选择:"</span>);</span><br><span class="line">		<span class="keyword">switch</span>(choose) &#123;	<span class="comment">// 接受输入数据</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"1"</span> :&#123;</span><br><span class="line">			String str = InputUtil.getString(<span class="string">"请输入字符串数据："</span>);</span><br><span class="line">			<span class="keyword">this</span>.stringservice.append(str);</span><br><span class="line">			choose();</span><br><span class="line">		&#125;<span class="keyword">case</span> <span class="string">"2"</span> :&#123;	<span class="comment">//	逆序显示数据</span></span><br><span class="line">			String str = InputUtil.getString(<span class="string">"数据反转："</span>);</span><br><span class="line">			String result [] = <span class="keyword">this</span>.stringservice.reverse();</span><br><span class="line">			System.out.println(Arrays.toString(result));</span><br><span class="line">			choose();</span><br><span class="line">		&#125;<span class="keyword">case</span> <span class="string">"0"</span>:&#123;</span><br><span class="line">			System.out.println(<span class="string">"Bye"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">default</span>:&#123;</span><br><span class="line">			System.out.println(<span class="string">"未接受到选项\n\n\n"</span>);</span><br><span class="line">			choose();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"*******************************"</span>);</span><br><span class="line">		System.out.println(<span class="string">"【1】追加字符串数据"</span>);</span><br><span class="line">		System.out.println(<span class="string">"【2】逆序显示所有字符串数据"</span>);</span><br><span class="line">		System.out.println(<span class="string">"【0】结束程序进行"</span>);</span><br><span class="line">		System.out.println(<span class="string">"\n\n\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>主函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.Menu.Menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOcaseDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Menu();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>交互式整个比较容易</p>
<h2 id="4-数据排序处理"><a href="#4-数据排序处理" class="headerlink" title="4. 数据排序处理"></a>4. 数据排序处理</h2><p>​    从键盘输入以下数据：“TOM:89|JERRY:90|TONY:95”，数据格式为“姓名：成绩|姓名：成绩|姓名：成绩”</p>
<ul>
<li>对于排序要用Comparable接口完成，同时利用Arrays类来处理，这里面唯一不同的地方就在于此时的数据显示要用键盘输入</li>
</ul>
<blockquote>
<ol>
<li>建立Student程序类，并且进行排序规则的配置；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">		<span class="keyword">this</span>.score = score ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", score="</span> + score + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.score &gt; o.score) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.score &lt; o.score) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>建立数据的输入处理操作，因为牵扯到拆分问题：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.vo.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Student [] getData();	<span class="comment">// 获取排序后的数据</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>建立IStudentService子类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IStudentService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.vo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> <span class="keyword">implements</span> <span class="title">IStudentService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">	<span class="keyword">private</span> Student [] students;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentService</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">		<span class="keyword">this</span>.handle();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;		<span class="comment">// 进行字符串数据的处理操作</span></span><br><span class="line">		String result [] = <span class="keyword">this</span>.content.split(<span class="string">"\\|"</span>);</span><br><span class="line">		<span class="keyword">this</span>.students = <span class="keyword">new</span> Student[result.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="keyword">this</span>.students.length ; x ++) &#123;</span><br><span class="line">			String temp [] = result[x].split(<span class="string">":"</span>);</span><br><span class="line">			<span class="keyword">this</span>.students[x] = <span class="keyword">new</span> Student(temp[<span class="number">0</span>],Double.parseDouble(temp[<span class="number">1</span>]));</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Student[] getData() &#123;</span><br><span class="line">		Arrays.sort(<span class="keyword">this</span>.students);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.students;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义Factory工厂类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.IStringService;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.service.impl.StudentServiceImpl;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.util.InputUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IStringService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (IStringService) <span class="keyword">new</span> StudentServiceImpl(InputUtil.getString(<span class="string">"请输入数据信息： "</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.Demo.factory.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOcaseDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Arrays.toString(Factory.getInstance().getData()));</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-数据排序处理深入"><a href="#5-数据排序处理深入" class="headerlink" title="5. 数据排序处理深入"></a>5. 数据排序处理深入</h2><p>把全部输入信息保存在文件中，还可以添加信息，并可以显示全部信息</p>
<p>要进行内容保存，首先要确认好所有输入数据的保存位置，所有的数据之间如果要想沿用之前的设计结构，则数据文件里的保存应做到格式统一；</p>
<p>添加的时候还应考虑到有时添加的是“单独的内容”、“一组内容”；暂不考虑数据过大；</p>
<blockquote>
<p>fds</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>fds</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>fds</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类名称</th>
<th style="text-align:center">序列化：<code>objectOutputStream</code></th>
<th style="text-align:center">反序列化：<code>objectInputStream</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类定义</td>
<td style="text-align:center"><code>public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants</code></td>
<td style="text-align:center"><code>public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants</code></td>
</tr>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:center"><code>public ObjectOutputStream(OutputStream out)throws IOException</code></td>
<td style="text-align:center"><code>public ObjectInputStream(InputStream in) throws IOException</code></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>java</category>
        <category>java高级编程</category>
        <category>io</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2020/06/11/leetcode/</url>
    <content><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p>标签（空格分隔）： 2020 编程</p>
<p>[TOC]</p>
<a id="more"></a>
<hr>
<h1 id="2-两数相加-中等）"><a href="#2-两数相加-中等）" class="headerlink" title="2. 两数相加 (中等）"></a>2. 两数相加 (中等）</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        L = ListNode(-1)
        i = L
        if not l1:return l2
        if not l2:return l1
        n = 0
        while l1 and l2:
            a = l1.val +l2.val + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            l1 = l1.next
            l2 = l2.next
        B = l1 if not l2 else l2
        while B:
            a = B.val + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            B = B.next
        if n != 0:
            i.next = ListNode(n)
        return L.next
</code></pre><p>一个修正了的答案</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        L = ListNode(-1)
        i = L
        if not l1:return l2
        if not l2:return l1
        n = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            a = x + y + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            if l1:l1 = l1.next
            if l2:l2 = l2.next
        if n != 0:
            i.next = ListNode(n)
        return L.next
</code></pre><hr>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<pre><code># 我的这个答案的结果很差，勉强能通过
class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        if not s:
            return 0
        dp = [1]*len(s)
        for i in range(len(s)):
            for j in range(i+1,len(s)):
                if s[j] not in s[i:j]:
                    dp[i] += 1
                else:
                    break
        return max(dp)
</code></pre><p>看了一下答案，这个题目是可以学习滑动窗口的！</p>
<hr>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line"><span class="function">    # 走一个滑动窗口，长度为2（两种相同的字符）或者3（第一个和第三个相同）</span></span><br><span class="line"><span class="function">    # 需要记录最长回文子串的变量t</span></span><br><span class="line"><span class="function">    # 最长自串长度用<span class="title">len</span><span class="params">(t)</span>得到</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> not s:</span></span><br><span class="line"><span class="function">        return s</span></span><br><span class="line"><span class="function">    e </span>= len(s)</span><br><span class="line">    r1,r2 = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    t = s[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">for</span> l in <span class="title">range</span><span class="params">(len(s)</span>):</span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"l:"</span>+str(l)</span>+" r1:"+<span class="title">str</span><span class="params">(r1)</span>+" r2:"+<span class="title">str</span><span class="params">(r2)</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> r2&lt;e and s[l] </span>== s[r2]:</span><br><span class="line">            i,j = l,r2</span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> and j&lt;len(s):</span><br><span class="line">                <span class="keyword">if</span> i-<span class="number">1</span>&lt;<span class="number">0</span> or j+<span class="number">1</span>==e or s[i-<span class="number">1</span>] != s[j+<span class="number">1</span>]:</span><br><span class="line">                    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(t)</span> &lt; j-i+1:</span></span><br><span class="line"><span class="function">                        t </span>= s[i:j+<span class="number">1</span>]</span><br><span class="line">                        print(i)</span><br><span class="line">                        print(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r1&lt;e and s[l] == s[r1]:</span><br><span class="line">            i,j = l,r1</span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> and j&lt;len(s):</span><br><span class="line">                    <span class="keyword">if</span> i-<span class="number">1</span>&lt;<span class="number">0</span> or j+<span class="number">1</span>==e or s[i-<span class="number">1</span>] != s[j+<span class="number">1</span>]:</span><br><span class="line">                        <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(t)</span> &lt; j-i+1:</span></span><br><span class="line"><span class="function">                            t </span>= s[i:j+<span class="number">1</span>]</span><br><span class="line">                            print(i)</span><br><span class="line">                            print(j)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        i -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        r1+=<span class="number">1</span></span><br><span class="line">        r2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure>
<!-- more -->
<hr>
<h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a>6. Z 字形变换</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N</p>
<pre><code>def convert(self, s: str, numRows: int) -&gt; str:
    if not s or numRows&lt;2:
        return s
    size = len(s)
    Lines = [[] for _ in range(numRows)]
    p = 0
    d = 1
    for i in s:
        print(p)
        Lines[p].append(i)
        if p == numRows - 1:
            d = -1
        if p == 0:
            d = 1
        p += d
    T = &quot;&quot;
    for i in Lines:
        T += &quot;&quot;.join(i)
    return T
</code></pre><hr>
<h1 id="7-整数翻转"><a href="#7-整数翻转" class="headerlink" title="7. 整数翻转"></a>7. 整数翻转</h1><pre><code># 用字符串反转达成
# python3
class Solution:
def reverse(self, x: int) -&gt; int:
    f = True
    if x &lt; 0 :
        f = False
    y = str(abs(x))
    y = list(y)
    y = y[::-1]
    z = 0
    for i in y:
        z = 10*z + int(i)
    if z &gt; pow(2,31)-1 or z &lt; -pow(2,31):
        return 0
    else:
        if not f:
            z = -z
        return z
</code></pre><hr>
<h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<pre><code>def myAtoi(self, str: str) -&gt; int:
    p = True
    N = 0
    str = str.strip()
    if not str:
        return 0
    if str[0] == &quot;+&quot; or str[0] == &quot;-&quot; or ord(str[0]) &gt;= 48 and ord(str[0]) &lt;= 57:
        if str[0] == &quot;+&quot;:
            p = True
            str = str[1:]
        elif str[0] == &quot;-&quot;:
            p = False
            str = str[1:]
        if not str:
            return 0
        i = 0
        t = ord(str[0])
        while t &gt;= 48 and t &lt;= 57:
            N = N * 10 + (t - 48)
            i += 1
            if i &lt; len(str):
                t = ord(str[i])
            else:
                break
        if not p:
            N = -N
        if N &lt; -2147483648:
            return -2147483648
        if N &gt; 2147483647:
            return 2147483647
        return N
    else:
        return 0
</code></pre><hr>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><pre><code># 字符串解法
# python3
class Solution:
def isPalindrome(self, x: int) -&gt; bool:
    y = str(x)
    y = list(y)
    l = len(y)
    for i in range(l):
        if y[i] != y[l-1-i]:
            return False
    return True
</code></pre><hr>
<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<pre><code># 双指针法
class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        l,r = 0,len(height)-1
        Max = 0
        while l &lt; r:
            if (r-l)*min(height[l],height[r]) &gt; Max:
                Max = (r-l)*min(height[l],height[r])
            if height[l] &lt; height[r]:
                l += 1
            else:
                r -= 1
        return Max
</code></pre><hr>
<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><pre><code>def intToRoman(self, num: int) -&gt; str:
    Roman_char = {1000:&quot;M&quot;,900:&quot;CM&quot;, 500:&quot;D&quot;, 400:&quot;CD&quot;,
     100:&quot;C&quot;, 90:&quot;XC&quot;, 50:&quot;L&quot;, 40:&quot;XL&quot;, 10:&quot;X&quot;, 9:&quot;IX&quot;, 5:&quot;V&quot;, 4:&quot;IV&quot;, 1:&quot;I&quot;}
    L = &quot;&quot;
    for i in Roman_char:
        L += Roman_char[i]*(num // i)
        num = num - (num // i)*i
    return L
</code></pre><hr>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><pre><code># 在编译器帮助下运行通过的
# python3
class Solution:
def romanToInt(self, s: str) -&gt; int:
    roman = {&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000,
                 &#39;IV&#39;:4,&#39;IX&#39;:9,&#39;XL&#39;:40,&#39;XC&#39;:90,&#39;CD&#39;:400,&#39;CM&#39;:900}
    right = False
    num = 0
    if len(s) == 1:
        num += roman[s]
    else:
        for i in range(len(s)-1):
            if right:
                right = False
                continue
            if roman[s[i]] &lt; roman[s[i+1]]:
                right = True
                num += roman[s[i]+s[i+1]]
            else:
                num += roman[s[i]]
        if not right:
            num += roman[s[i+1]]
    return num
</code></pre><hr>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><pre><code># python3
class Solution:
def longestCommonPrefix(self, strs: List[str]) -&gt; str:
    s = &#39;&#39;
    l = len(strs)
    if l==0:
        return s
    mi = min([len(i) for i in strs])

    for i in range(mi):
        a = strs[0][i]
        b = True
        for j in range(1,l):
            if a != strs[j][i]:
                b = False
                break
        if b:
            s = s + a
        else:
            break
    return s
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    length = len(strs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="keyword">if</span> len(item) &lt; length:</span><br><span class="line">            length = len(item)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; length:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        cur_char = strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> item[i] != cur_char:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        res += cur_char</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">    N = len(strs)</span><br><span class="line">    <span class="keyword">if</span> N &gt; <span class="number">2</span>:</span><br><span class="line">        mid = N//<span class="number">2</span></span><br><span class="line">        str1 = self.longestCommonPrefix(strs[<span class="number">0</span>:mid])</span><br><span class="line">        str2 = self.longestCommonPrefix(strs[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.longestCommonPrefix([str1,str2])</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">        min_length = len(strs[<span class="number">0</span>]) <span class="keyword">if</span> len(strs[<span class="number">0</span>]) &lt;= len(strs[<span class="number">1</span>]) <span class="keyword">else</span> len(strs[<span class="number">1</span>])</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min_length):</span><br><span class="line">            <span class="keyword">if</span> strs[<span class="number">0</span>][i] != strs[<span class="number">1</span>][i]:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            res += strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<pre><code>def letterCombinations(self, digits: str) -&gt; List[str]:
    hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;],
                &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;],
                &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]}
    temp_list = []
    last_list = []
    for n in digits:
        if not last_list:
            last_list = hash_table[n]
            continue
        for key in hash_table[n]:
            for i in range(len(last_list)):
                temp_list.append(last_list[i]+key)
        last_list = temp_list
        temp_list = []
    return last_list

def letterCombinations(self, digits: str) -&gt; List[str]:
    # 回溯法
    hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;],
                &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;],
                &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]}
    L = []
    length = len(digits)
    print(length)
    if length &lt; 1:
        return L
    def helper(n,temp_s):
        if n == length:
            L.append(temp_s)
        else:
            c = digits[n]
            chars = hash_table[c]
            for item in chars:
                helper(n+1,temp_s + item)

    s = &quot;&quot;
    helper(0,s)
    return L
</code></pre><hr>
<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
<pre><code>def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
    L = ListNode(-1)
    L.next = head
    p = head
    i = 0
    while p:
        i += 1
        p = p.next
    print(i)
    p = L
    for _ in range(i-n):
        p = p.next
    print(p.val)
    p.next = p.next.next
    return L.next
</code></pre><hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><pre><code># python3
class Solution:
def isValid(self, s: str) -&gt; bool:
    bracket = {&#39;(&#39;:1,&#39;)&#39;:2,&#39;[&#39;:4,&#39;]&#39;:5,&#39;{&#39;:7,&#39;}&#39;:8}
    stack = []
    for i in s:
        if stack:
            if bracket[stack[-1]]+1 == bracket[i]:
                stack.pop()
            else:
                stack.append(i)
        else:
            stack.append(i)
    if stack:
        return False
    else:
        return True
</code></pre><hr>
<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<pre><code>def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
    L = ListNode(-1)
    p = L
    while l1 and l2:
        l3 = None
        if l1.val &gt; l2.val:
            l3 = l2
            l2 = l2.next
        else:
            l3 = l1
            l1 = l1.next
        p.next = l3
        p = p.next
    if 1:
        p.next = l1
    else:
        p.next = l2
    return L.next
</code></pre><hr>
<h1 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<pre><code>def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
    if not lists:
        return None
    L = ListNode(-1)
    x = L
    cur_min = None
    while len(lists) &gt; 1:
        n = len(lists)
        if lists[0] != None:
            cur_min = lists[0]
        else:
            lists.pop(0)
            continue
        # print(&quot;cur_min: &quot;+str(cur_min.val))
        # 找到最小的值
        t = 0
        for i in range(n):
            if lists[i] == None:
                continue
            if lists[i].val &lt; cur_min.val:
                cur_min = lists[i]
                t = i
        if lists[t].next != None:
            lists[t] = lists[t].next
        else:
            lists.pop(t)
        cur_min.next = None
        x.next = cur_min
        x = x.next
    x.next = lists[0]
    return L.next
</code></pre><hr>
<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<pre><code>def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:
    if not head:
        return head
    res = ListNode(-1)
    res.next = head
    def revereKnode(k,L):
        # 不足k个，直接返回
        t = L   # 用t来表示结尾
        for _ in range(k):
            if t.next == None:
                return L.next, None
            t= t.next

        # 足够k个进行翻转
        d = L.next   # d表示正序列上的末尾节点
        u = L.next
        while u != t:
            u = d.next
            d.next = u.next
            u.next = L.next
            L.next = u
        return L.next,d
    R = res
    E = res
    while E:
        R = E
        R.next,E = revereKnode(k,R)
    return res.next
</code></pre><h2 id="​"><a href="#​" class="headerlink" title="​          "></a>​          </h2><h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h1><pre><code># python3
class Solution:
def removeDuplicates(self, nums: List[int]) -&gt; int:
    if nums:
        a = nums[0]
        for i in nums[1:]:

            if i == a:
                nums.remove(i)
            else:
                a = i
        return len(nums)    
    else:
        return 0
</code></pre><hr>
<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><pre><code># python3
class Solution:
def strStr(self, haystack: str, needle: str) -&gt; int:
    if needle:
        if needle not in haystack:
            return -1
        else:
            return haystack.index(needle)
    else:
        return 0

# 这个题目水很深需要再多再看看KMP算法之流多翻一翻
</code></pre><hr>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<pre><code>def nextPermutation(self, nums: List[int]) -&gt; None:
    n = len(nums)
    if n == 0:
        return None
    for i in range(-1,-n,-1):
        if nums[i-1] &lt; nums[i]:
            t = 0
            j = -1
            # 找到下一个值,把它与i-1位置的元素交换
            while j &gt; i-1:
                if nums[j] &gt; nums[i-1]:
                    nums[i-1],nums[j] = nums[j],nums[i-1]
                    break
                j -= 1
            # i-1 后面一定是逆序的
            L = i
            R = -1
            while L&lt;R:
                nums[L], nums[R] = nums[R],nums[L]
                L += 1
                R -= 1
            return None
    nums.sort()
    return None
</code></pre><hr>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<pre><code>def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
    res = []
    n = len(nums)
    p = False
    for i in range(n):
        if not p and nums[i] == target:
            res.append(i)
            p = True
        if p and (i+1 == n or nums[i+1] != target):
            res.append(i)
            p = False
    if not res:
        return [-1,-1]
    return res

def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
    res = []
    n = len(nums)
    for i in range(n):
        if nums[i] == target:
            res.append(i)
    if not res:
        return [-1,-1]
    return [res[0],res[-1]]

def searchRange(self, nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            left_idx = i
            break
        else:
            return [-1, -1]
    for j in range(len(nums)-1, -1, -1):
        if nums[j] == target:
            right_idx = j
            break

    return [left_idx, right_idx]
</code></pre><hr>
<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><pre><code># python3 自己写的
class Solution:
def searchInsert(self, nums: List[int], target: int) -&gt; int:
    if target not in nums:
        for i in range(len(nums)):
            if target &lt;= nums[i]:
                nums.insert(i,target)
                return i
        nums.append(target)
        return len(nums)-1
    else:
        return nums.index(target)
</code></pre><hr>
<h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<pre><code>def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
    # 三重判定
    # 判定行
    for L in board:
        temp = []
        for i in L:
            if i != &quot;.&quot;:
                temp.append(i)
        if len(temp) != len(set(temp)):
            return False
    print(&quot;行OK&quot;)
    # 判定列
    for j in range(9):
        temp = []
        for i in range(9):
            if board[i][j] != &quot;.&quot;:
                temp.append(board[i][j])
        if len(temp) != len(set(temp)):
            return False
    print(&quot;列OK&quot;)
    # 判定方格
    for x in range(0,9,3):
        for y in range(0,9,3):
            print((x,y))
            temp = []
            for i in range(3):
                for j in range(3):
                    if board[x+i][y+j] != &quot;.&quot;:
                        temp.append(board[x+i][y+j])
            print(temp)
            if len(temp) != len(set(temp)):
                return False
    return True

def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
    # 只遍历一次的答案
    Row = [{} for _ in range(9)]
    Col = [{} for _ in range(9)]
    Square = [{} for _ in range(9)]
    for i in range(9):
        for j in range(9):
            if board[i][j] != &quot;.&quot;:
                if board[i][j] not in Row[i]:
                    Row[i][board[i][j]] = 1
                else:
                    return False
                if board[i][j] not in Col[j]:
                    Col[j][board[i][j]] = 1
                else:
                    return False
                local = (i//3)*3 + j //3
                if board[i][j] not in Square[local]:
                    Square[local][board[i][j]] = 1
                else:
                    return False
    return True
</code></pre><hr>
<h1 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h1><pre><code># python3自己解决
class Solution:
def countAndSay(self, n: int) -&gt; str:
    s = &quot;1&quot;
    for j in range(n-1):
        a = s[0]
        x = 1
        re = &quot;&quot;
        for i in s[1:]:
            if i == a:
                x = x + 1
            else:
                re = re + str(x) + str(a)
                a = i
                x = 1
        s = re + str(x) + str(a)
    return s
</code></pre><p>​    </p>
<p>l3 = []<br>        while l1 and l2:<br>            if l1[0] &gt;= l2[0]:<br>                l3.append(l2.pop(0))<br>            elif l1[0] &lt; l2[0]:<br>                l3.append(l1[0].pop(0))<br>        return l3</p>
<hr>
<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<pre><code>def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
    candidates.sort()
    def help(candidates,target,temp_list):
        print(temp_list)
        if target &gt;= candidates[0]:
            i = 0
            while i &lt; len(candidates) and candidates[i] &lt;= target:
                if target == candidates[i]:
                    print(&quot;yeap!!&quot;)
                    temp = temp_list.copy()
                    temp.append(target)
                    print(temp)
                    res.append(temp)
                temp = temp_list.copy()
                temp.append(candidates[i])
                help(candidates[i:],target-candidates[i],temp)
                i += 1
    res = []
    temp = []
    help(candidates,target,temp)
    return res
</code></pre><hr>
<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<pre><code>def multiply(self, num1: str, num2: str) -&gt; str:
    if num1 == &#39;0&#39; or num2 == &#39;0&#39;:
        return &quot;0&quot;
    n1 = len(num1)
    n2 = len(num2)
    digits = [0]*(n1+n2)
    for i in range(n1-1, -1, -1):
        for j in range(n2-1, -1, -1):
            prod = (ord(num1[i])-ord(&#39;0&#39;))*(ord(num2[j])-ord(&#39;0&#39;))
            sum_ = 0
            sum_ = prod + digits[i+j+1]
            digits[i+j] += sum_ //10
            digits[i+j+1] = sum_ %10
    # for i in range(n1 + n2 - 1, 0, -1):
    #     carry = digits[i] // 10
    #     digits[i] = digits[i] % 10
    #     digits[i - 1] += carry
    return &#39;&#39;.join([str(i) for i in digits]).lstrip(&#39;0&#39;)
</code></pre><hr>
<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h1><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<pre><code>class Solution:
def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
    res = []
    if not nums:
        return res
    nums.sort()
    N = len(nums)
    def helper(start,temp,unused):
        if start == N:
            print(str(start)+ &quot; &quot;+str(temp)+&quot; &quot;+str(unused))
            res.append(temp[:])
        i = 0
        while i &lt; len(unused):
            if i &gt; 0 and unused[i] == unused[i-1]:
                i += 1
                continue

            temp.append(unused[i])
            a = unused.pop(i)
            helper(start+1,temp,unused)
            temp.pop()
            unused.insert(i,a)
            i += 1
    helper(0,[],nums)
    return res
</code></pre><hr>
<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<pre><code>def rotate(self, matrix: List[List[int]]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify matrix in-place instead.
    &quot;&quot;&quot;
    N = len(matrix) # 矩阵行列数
    C = N //2 # 旋转层数
    for t in range(C):
        print(t)
        for i in range(0,N-t*2-1):
            a = matrix[t][t+i]   # 左上角
            matrix[t][t+i] = matrix[N-t-1-i][t]  # 左下角
            matrix[N-t-1-i][t] = matrix[N-t-1][N-t-1-i]    # 右下角
            matrix[N-t-1][N-t-1-i] = matrix[t+i][N-t-1]   # 右上角
            matrix[t+i][N-t-1] = a

            # a = matrix[t+i,N-t-1]   # 右上角
            # matrix[t+i,N-t-1]  = matrix[t][t+i] # 左上角
            # b = matrix[N-t-1][N-t-1-i]    # 右下角
            # matrix[N-t-1][N-t-1-i] = a
            # a = matrix[N-t-1-i][t]  # 左下角
            # matrix[N-t-1-i][t] = b
            # matrix[t][t+i] = a
</code></pre><hr>
<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<pre><code>from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs):
        ans = collections.defaultdict(list)
        for s in strs:
            ans[tuple(sorted(s))].append(s)
        return ans.values()

class Solution:
    def groupAnagrams(self, strs):
        ans = {}
        for s in strs:
            if tuple(sorted(s)) in ans:
                ans[tuple(sorted(s))].append(s)
            else:
                ans[tuple(sorted(s))] = [s]
        return list(ans.values())
</code></pre><hr>
<h1 id="53-最大子序和-（在这个题中学暴力法，动态规划和分治法）"><a href="#53-最大子序和-（在这个题中学暴力法，动态规划和分治法）" class="headerlink" title="53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）"></a>53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）</h1><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><pre><code># 这道题不会做。
# 答案中有四种解法：暴力法，动态规划，贪心法，分治法；
# 我都可以学！！！

# 2020年1月8日学会第一种暴力法！

# 这种暴力法超时了！！
class Solution:
def maxSubArray(self, nums: List[int]) -&gt; int:
    Max = nums[0]
    for i in range(len(nums)):
        Sum = 0
        for j in range(i,len(nums)):
            Sum += nums[j]
            if Sum &gt; Max:
                Max = Sum
    return Max

# 一个更为先进的暴力法，好吧，说好一起暴力呢，你怎么动起了脑子
class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        Sum = nums[0]
        Max = nums[0]
        for i in range(1,len(nums)):
            if Sum + nums[i] &gt; nums[i]:
                Sum = Sum + nums[i]
            else:
                Sum = nums[i]
            Max = max(Max,Sum)
        return Max

    # 20200109
</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>（动态规划代码在上面第二段）</p>
<blockquote>
<p>通常我们遍历子串或者子序列有三种遍历方式</p>
<ol>
<li><p>以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。</p>
<ol>
<li>根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。</li>
<li><p>以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。</p>
<p>而动态规划就是第三种方式，求出以某个节点结束节点的最大值。</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><pre><code># 分治法
class Solution:
def maxSubArray(self, nums: List[int]) -&gt; int:
    n = len(nums)
    #递归终止条件
    if n == 1:
        return nums[0]
    else:
        #递归计算左半边最大子序和
        max_left = self.maxSubArray(nums[0:len(nums) // 2])
        #递归计算右半边最大子序和
        max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)])

    max_l = nums[len(nums)//2-1]
    tmp = 0
    for i in range(len(nums)//2-1,-1,-1):
        tmp += nums[i]
        max_l = max(max_l, tmp)

    max_r = nums[len(nums)//2]
    tmp = 0
    for i in range(len(nums)//2,len(nums)):
        tmp += nums[i]
        max_r = max(max_r, tmp)
    return max(max_left,max_right,max_l+max_r)
</code></pre><hr>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h1><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<pre><code>def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
    res = []
    if not matrix:
        return res
    m = len(matrix)
    n = len(matrix[0])

    def next_item(i,j): 
        # 这里可以用另一个矩阵来表示这个是否被换过了。
        # 返回一个值，如果没返回则结束

        # 如果上下左右都不能走则返回None结束
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;):
            return None
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and not (j == n-1 or matrix[i][j+1]== &quot;*&quot;):
            return (i,j+1)
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (i == m-1 or matrix[i+1][j] == &quot;*&quot;):
            return (i+1,j)
        if (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (j == 0 or matrix[i][j-1]== &quot;*&quot;):
            return (i,j-1)
        if (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and not (i==0 or matrix[i-1][j] == &quot;*&quot;):
            return (i-1,j)

    t = (0,0)
    while t:
        i,j = t
        res.append(matrix[i][j])
        matrix[i][j] = &quot;*&quot;
        t = next_item(i,j)
    return res
</code></pre><hr>
<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<pre><code>def canJump(self, nums: List[int]) -&gt; bool:
    # dp
    n = len(nums)
    dp = [False]*n
    for i in range(n-1,-1,-1):
        if i == n-1:
            dp[i] = True
            continue
        for j in range(i+1,min(i+nums[i]+1,n)):
            if dp[j] == True:
                dp[i] = True
                break
    print(dp)
    return dp[0]
</code></pre><hr>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1><hr>
<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h1><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code>class Solution:
def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
    if not head:
        return head
    temp = ListNode(-1)
    temp.next = head
    node_count = 0
    point = temp
    while point.next:
        node_count+= 1
        point = point.next
    if k&gt;node_count:
        k = k%node_count
    elif k == node_count:
        return head
    # 再走node_count - k 步
    point = temp
    for _ in range(node_count-k):
        point = point.next
    t = point
    while t.next:
        t = t.next
    t.next = temp.next
    temp.next = point.next
    point.next = None
    return temp.next
</code></pre><h2 id="​-1"><a href="#​-1" class="headerlink" title="​        "></a>​        </h2><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
    N = m + n -2
    c = min(m,n)-1
    res = 1
    for i in range(1,c+1):
        res *= N
        res = res//i
        N = N-1
    return res
</code></pre><hr>
<h1 id="63-不同路径-II-（动态规划，浅拷贝陷阱）"><a href="#63-不同路径-II-（动态规划，浅拷贝陷阱）" class="headerlink" title="63. 不同路径 II   （动态规划，浅拷贝陷阱）"></a>63. 不同路径 II   （动态规划，浅拷贝陷阱）</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<pre><code>def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
    print(obstacleGrid)
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    print(m,n)
    dp = [[0]*n for _ in range(m)]  # 不要用下面这样的浅拷贝
    # dp = [[0]*n]*m    # 这样赋值会把整个列赋值成一样值
    # 放第一行，第一列：
    for i in range(m):
        if obstacleGrid[i][0] == 1:
            break
        dp[i][0] = 1
    for j in range(n):
        if obstacleGrid[0][j] == 1:
            break
        dp[0][j] = 1
    for i in range(1,m):
        for j in range(1,n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
                continue
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]
</code></pre><hr>
<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<pre><code>def minPathSum(self, grid: List[List[int]]) -&gt; int:
    m = len(grid)
    n = len(grid[0])
    dp = [[0]*n for _ in range(m)]
    for i in range(m):
        if i == 0:
            dp[0][0] = grid[0][0]
            continue
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for i in range(1,n):
        dp[0][i] = dp[0][i-1] + grid[0][i]
    for i in range(1,m):
        for j in range(1,n):
            dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
    print(dp)
    return dp[-1][-1]
</code></pre><p>​    </p>
<h2 id="​-2"><a href="#​-2" class="headerlink" title="​        "></a>​        </h2><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h1><p>这个题的第一印象就是把数组转成数字，加一后再转成数组；</p>
<pre><code>class Solution:
def plusOne(self, digits: List[int]) -&gt; List[int]:
    Sum = 0
    for i in digits:
        Sum = 10*Sum + i
    Sum =Sum + 1
    D_list = []
    while Sum:
        D_list.append(Sum%10)
        Sum = Sum//10
    D_list.reverse()
    return D_list
</code></pre><p>这个结果速度还可以，但是内存消耗大</p>
<p>第二个想法就是在原数组上进行</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        Up = False  # 进位符
        # 给最低位加一
        if digits[-1] + 1 &gt; 9:
            digits[-1] = (digits[-1] + 1)%10
            Up = True
        else:
            digits[-1] = digits[-1] + 1
        # 给整个数字进位：
        for i in range(len(digits)-2,-1,-1):
            if Up:
                digits[i] = digits[i] + 1
                if digits[i] &gt; 9:
                    digits[i] = digits[i]%10
                    Up = True
                else:
                    return digits
        # 多进位
        if Up:
            digits.insert(0,1)
            Up = False
        return digits
</code></pre><h2 id="​-3"><a href="#​-3" class="headerlink" title="​            "></a>​            </h2><h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h1><p>一个不用内置函数的解法</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    Up = False
    C = &quot;&quot;
    if len(a)&gt;len(b):
        b = (len(a)-len(b))*&quot;0&quot; + b
    else:
        a = (len(b)-len(a))*&quot;0&quot; + a
    for i in range(len(a)-1,-1,-1):
        z = int(a[i])+int(b[i])
        if Up:
            z = z + 1
            Up = False
        C = str(z%2) + C
        if z//2:
            Up = True
    if Up:
        C = &quot;1&quot; + C
    return C
</code></pre><p>题解里的一个答案：时间和空间都优于我写的</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    r, p = &#39;&#39;, 0
    d = len(b) - len(a)
    a = &#39;0&#39; * d + a
    b = &#39;0&#39; * -d + b
    for i, j in zip(a[::-1], b[::-1]):
        s = int(i) + int(j) + p
        r = str(s % 2) + r
        p = s // 2
    return &#39;1&#39; + r if p else r
</code></pre><p>用内置函数的解法</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    return bin(int(a,2)+int(b,2))[2:]
</code></pre><hr>
<h1 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h1><p>我的答案：<br>    class Solution:<br>    def mySqrt(self, x: int) -&gt; int:<br>        start = 0<br>        end = x<br>        while start + 1 != end:<br>            mid = (end-start)//2 + start<br>            if mid <em> mid == x:<br>                return mid<br>            elif mid </em> mid &gt; x:<br>                if (mid-1)<em>(mid-1) &lt; x:<br>                    return mid-1<br>                end = mid<br>            elif mid </em> mid &lt; x:<br>                if (mid+1)*(mid+1) &gt; x:<br>                    return mid<br>                start = mid<br>        return end</p>
<hr>
<h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h1><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<pre><code>def simplifyPath(self, path: str) -&gt; str:
    res = []
    i = 0
    while i&lt;len(path):
        if path[i] == &quot;/&quot;:
            i += 1
            continue
        j = i
        while j &lt; len(path) and path[j] != &quot;/&quot;:
            j += 1
        if j-i == 2 and path[i:j] == &quot;..&quot;:
            if res:
                res.pop()
        elif j-i == 1 and path[i:j] == &quot;.&quot;:
            pass
        else:
            res.append(path[i:j])
        i = j
    res_S = &quot;/&quot;
    if res:
        res_S += &quot;/&quot;.join(res)
    return res_S
</code></pre><hr>
<h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h1><p>给定一个 m x n 的矩阵，如果一个元素为0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<pre><code>def setZeroes(self, matrix: List[List[int]]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify matrix in-place instead.
    &quot;&quot;&quot;
    res = []
    m = len(matrix)
    n = len(matrix[0])
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                res.append((i,j))
    for i,j in res:
        for t in range(n):
            matrix[i][t] = 0
        for t in range(m):
            matrix[t][j] = 0
</code></pre><hr>
<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h1><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<pre><code>def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
    if not matrix or not matrix[0]:
        return False
    m = len(matrix)
    n = len(matrix[0])
    for row in range(m):
        if target &gt;= matrix[row][0] and target &lt;= matrix[row][-1]:
            for col in range(n):
                if matrix[row][col] == target:
                    return True
            return False
    return False
</code></pre><hr>
<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<pre><code>def sortColors(self, nums: List[int]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify nums in-place instead.
    &quot;&quot;&quot;
    n = len(nums)
    l1 = 0
    for i in range(n):
        if nums[i] == 0:
            nums.pop(i)
            nums.insert(0,0)
            l1 += 1
        if nums[i] == 1:
            nums.pop(i)
            nums.insert(l1,1)
</code></pre><hr>
<h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h1><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<pre><code>def minWindow(self, s: str, t: str) -&gt; str:
    t_table = defaultdict(int)
    for i in t:
        t_table[i] += 1
    hash_table = defaultdict(list)
    left , right = 0,len(s)
    count = 0
    flag = False
    for i in range(len(s)):
        if count &lt;len(t) and s[i] in t:
            if s[i] not in hash_table or len(hash_table[s[i]])&lt;t_table[s[i]]:
                count += 1
                hash_table[s[i]].append(i)
            else:
                hash_table[s[i]].pop(0)
                hash_table[s[i]].append(i)
        if count == len(t):
            flag = True
            alp_left = min(hash_table, key = lambda k: hash_table[k][0])
            alp_right = max(hash_table,key = lambda k: hash_table[k][-1])
            if hash_table[alp_right][-1]-hash_table[alp_left][0] &lt; right-left:
                right, left = hash_table[alp_right][-1], hash_table[alp_left][0]
            if len(hash_table[alp_left]) &gt;1:
                hash_table[alp_left].pop(0)
            else:
                hash_table.pop(alp_left)
            count -= 1
    if not flag:
        return &quot;&quot;
    return s[left:right+1]
</code></pre><hr>
<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<pre><code>def combine(self, n: int, k: int) -&gt; List[List[int]]:
    help_List = list(range(1,n+1))
    def help(temp,help_List):
        l = len(temp)
        T = len(help_List)
        if l == k:
            res.append(temp)
        else:
            for i in range(T-k+1+l):
                help(temp + [help_List[i]],help_List[i+1:])
    res = []
    help([],help_List)
    return res

# 第二种解法很厉害的！！ 94%
def combine(self, n: int, k: int) -&gt; List[List[int]]:
    def help(temp):
        l = len(temp)
        T = n - temp[-1] if l != 0 else n
        if l == k:
            res.append(temp)
        else:
            for i in range(1,T-k+1+l+1):
                if temp:
                    help(temp + [temp[-1]+i])
                else:
                    help([i])
    res = []
    help([])
    return res
</code></pre><hr>
<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
<pre><code>def subsets(self, nums: List[int]) -&gt; List[List[int]]:
    res = []
    if not nums:
        return [[]]
    N = len(nums)

    def help(temp,remain):
        res.append(temp)
        for i in range(len(remain)):
            help(temp+[remain[i]],remain[i+1:])

    help([],nums)
    return res
</code></pre><hr>
<h1 id="79-单词搜索-这道题是有点东西的"><a href="#79-单词搜索-这道题是有点东西的" class="headerlink" title="79. 单词搜索 (这道题是有点东西的)"></a>79. 单词搜索 <strong><em>(这道题是有点东西的)</em></strong></h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<pre><code>def exist(self, board: List[List[str]], word: str) -&gt; bool:
    m = len(board)
    n = len(board[0])
    # word = &quot;SEE&quot;
    def dfs(visited,word):
        l = len(visited)
        if l == len(word):
            return True
        x,y = visited[-1]
        dir_x = [-1,0,1,0]
        dir_y = [0,-1,0,1]
        for dx,dy in zip(dir_x,dir_y):
            if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and (x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[l] and dfs(visited+[(x+dx,y+dy)],word):
            # 这里的大判断分别判断了以下几件事：
            #       判断越界
            #       判断是否被访问过
            #       判断当下是否等于那个字母
            #       判断它以后是否找得到
            #   这些都满足了，把它返回True
                return True
        # 四个方向都不满足，就否定它
        return False

        # print(&quot;嘿嘿我进来了 &quot;+str((i,j)))
        # visited = [(i,j)]
        # dir_x = [-1,0,1,0]
        # dir_y = [0,-1,0,1]
        # x,y = i,j
        # for alp in range(1,len(word)):
        #     flag = False
        # for dx,dy in zip(dir_x,dir_y):
        #     if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and(x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[alp]:
        #             flag = True
        #             x,y = x+dx,y+dy
        #             print(x,y,word[alp])
        #             visited.append((x,y))
        #     if not flag:
        #         return False
        # return True
</code></pre><p>​<br>​        for i in range(m):<br>​            for j in range(n):<br>​                if board[i][j] == word[0] and dfs([(i,j)],word):<br>​                    return True<br>​        return False</p>
<hr>
<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<pre><code>def search(self, nums: List[int], target: int) -&gt; bool:
    if len(nums) &lt;= 0:
        return False
    left = 0
    right = len(nums) - 1
    while left &lt; right:
        mid = (right - left) // 2 + left
        if nums[mid] == target:
            return True
        if nums[left] == nums[mid]:
            left += 1
            continue
        if nums[left] &lt; nums[mid]:
            if nums[left] &lt;= target &lt;= nums[mid]:
                right = mid
            else:
                # 这里 +1，因为上面是 &lt;= 符号
                left = mid + 1
        else:
            # 注意：这里必须是 mid+1，因为根据我们的比较方式，mid属于左边的序列
            if nums[mid+1] &lt;= target &lt;= nums[right]:
                left = mid + 1
            else:
                right = mid
    return True if nums[left] == target else False
</code></pre><hr>
<h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h1><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现 的数字。</p>
<pre><code>def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
    Temp = ListNode(-1)
    Temp.next = head
    t = Temp
    while t:
        if t.next and t.next.next:
            if t.next.val == t.next.next.val:
                R = t.next.next
                while R.next:
                    if R.next.val == R.val:
                        R = R.next
                    else:
                        break
                t.next = R.next
            else:
                t = t.next
        else:
            t = t.next
    return Temp.next
</code></pre><hr>
<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        cur = head
        if not cur:
            return head
        V = cur.val
        while cur.next:
            if cur.next.val != V:
                V = cur.next.val
                cur = cur.next
            else:
                cur.next = cur.next.next
        return head
</code></pre><hr>
<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    hash_table = &#123;&#125;</span><br><span class="line">    area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">        delete = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> hash_table:</span><br><span class="line">            <span class="keyword">if</span> heights[i] &lt; item:</span><br><span class="line">                <span class="keyword">if</span> item * hash_table[item] &gt; area:</span><br><span class="line">                    area = item * hash_table[item]</span><br><span class="line">                delete.append(item)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[item] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> heights[i] <span class="keyword">not</span> <span class="keyword">in</span> hash_table:</span><br><span class="line">            m = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> delete:</span><br><span class="line">                <span class="keyword">if</span> hash_table[item] &gt; m:</span><br><span class="line">                    m = hash_table[item]</span><br><span class="line">            hash_table[heights[i]] = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> delete:</span><br><span class="line">            hash_table.pop(item)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> hash_table:</span><br><span class="line">        <span class="keyword">if</span> item * hash_table[item] &gt; area:</span><br><span class="line">            area = item * hash_table[item]</span><br><span class="line">    <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">    temp = ListNode(<span class="number">-1</span>)</span><br><span class="line">    temp.next = head</span><br><span class="line">    t = temp</span><br><span class="line">    p1 = temp</span><br><span class="line">    pass_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> t <span class="keyword">and</span> p1:</span><br><span class="line">        R = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> t.next:</span><br><span class="line">            <span class="keyword">if</span> pass_flag <span class="keyword">and</span> t.next.val &lt; x:</span><br><span class="line">                R = t.next</span><br><span class="line">                t.next = R.next</span><br><span class="line">                R.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> t.next <span class="keyword">and</span> t.next.val &gt;= x:</span><br><span class="line">                pass_flag = <span class="literal">True</span></span><br><span class="line">                t = t.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pass_flag:</span><br><span class="line">                t = t.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            <span class="keyword">if</span> p1.next.val &lt; x:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> R:</span><br><span class="line">                    R.next = p1.next</span><br><span class="line">                    p1.next = R</span><br><span class="line">                    p1 = p1.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> temp.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">    temp = ListNode(<span class="number">-1</span>)</span><br><span class="line">    temp.next = head</span><br><span class="line">    t = temp</span><br><span class="line">    p1 = temp</span><br><span class="line">    pass_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> p1.next:</span><br><span class="line">        <span class="keyword">if</span> p1.next.val &lt; x:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> t:</span><br><span class="line">        R = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> t.next:</span><br><span class="line">            <span class="keyword">if</span> pass_flag <span class="keyword">and</span> t.next.val &lt; x:</span><br><span class="line">                R = t.next</span><br><span class="line">                t.next = R.next</span><br><span class="line">                R.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> t.next <span class="keyword">and</span> t.next.val &gt;= x:</span><br><span class="line">                pass_flag = <span class="literal">True</span></span><br><span class="line">                t = t.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pass_flag:</span><br><span class="line">                t = t.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> R:</span><br><span class="line">            R.next = p1.next</span><br><span class="line">            p1.next = R</span><br><span class="line">            p1 = p1.next</span><br><span class="line">    <span class="keyword">return</span> temp.next</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h1><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>
<p>格雷编码序列必须以 0 开头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    res = [<span class="number">0</span>]</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>&lt;&lt;n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 判断第i位需要怎么变</span></span><br><span class="line">            flag = temp</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(i):</span><br><span class="line">                flag = flag // <span class="number">2</span></span><br><span class="line">            flag  = flag % <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> temp - (<span class="number">1</span>&lt;&lt;i) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(temp - (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                    temp = temp - (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> temp + (<span class="number">1</span>&lt;&lt;i) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(temp + (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                    temp = temp + (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>下面这是一个完全理解了格雷码产生方式的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    res,head = [<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># n次</span></span><br><span class="line">        <span class="comment"># 每一轮把列表里的值的二进制前面加一个1逆序添加进列表中</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):   </span><br><span class="line">            res.append(head+res[j])</span><br><span class="line">        head &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h1><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        N = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(step,temp)</span>:</span></span><br><span class="line">            res.append(temp[:])</span><br><span class="line">            <span class="keyword">if</span> step &lt;= N:</span><br><span class="line">                i = step</span><br><span class="line">                <span class="keyword">while</span> i &lt; N:</span><br><span class="line">                    <span class="keyword">if</span> i &gt; step <span class="keyword">and</span> nums[i] != nums[i<span class="number">-1</span>]:</span><br><span class="line">                        help(i+<span class="number">1</span>,temp+[nums[i]])</span><br><span class="line">                    <span class="keyword">elif</span> i==step:</span><br><span class="line">                        help(i+<span class="number">1</span>,temp+[nums[i]])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        help(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h1><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># head = ListNode(3)</span></span><br><span class="line">    <span class="comment"># head.next = ListNode(5)</span></span><br><span class="line">    <span class="comment"># m = 3</span></span><br><span class="line">    <span class="comment"># n = 4</span></span><br><span class="line">    Length = n-m+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> Length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    L = ListNode(<span class="number">-1</span>)</span><br><span class="line">    L.next = head</span><br><span class="line">    p = L</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">        p = p.next</span><br><span class="line">    end = p.next</span><br><span class="line">    start = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(Length):</span><br><span class="line">        <span class="comment"># 切除</span></span><br><span class="line">        temp = p.next</span><br><span class="line">        p.next = temp.next</span><br><span class="line">        <span class="comment"># 头插入</span></span><br><span class="line">        temp.next = start</span><br><span class="line">        start = temp</span><br><span class="line">    <span class="comment"># 再插入</span></span><br><span class="line">    end.next = p.next</span><br><span class="line">    p.next = start</span><br><span class="line">    <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p and q:
            if p.val != q.val:
                return False
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
        elif not p and not q:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        if not root.left and not root.right:
            return True
        elif root.left and root.right:
            return self.isSameTree(root.left,root.right)
        else:
            return False
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p and q:
            if p.val != q.val:
                return False
            return self.isSameTree(p.left,q.right) and self.isSameTree(p.right,q.left)
        elif not p and not q:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root:
            MD = 1
            return MD + max(self.maxDepth(root.left),self.maxDepth(root.right))
        else:
            return 0
</code></pre><hr>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return None
        head = TreeNode(preorder[0])
        ind_inorder = inorder.index(preorder[0])
        head.left = self.buildTree(preorder[1:1+ind_inorder],inorder[0:ind_inorder])
        head.right = self.buildTree(preorder[1+ind_inorder:], inorder[ind_inorder+1:])
        return head
</code></pre><hr>
<h1 id="107-二叉树的层次遍历"><a href="#107-二叉树的层次遍历" class="headerlink" title="107. 二叉树的层次遍历"></a>107. 二叉树的层次遍历</h1><pre><code>def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        A = []
        B = []
        if root.left:
            B.append(root.left)
        if root.right:
            B.append(root.right)
        nextL = [root.val]
        while nextL:
            A.insert(0,nextL)
            nextL = []
            nextNodes = []
            while B:
                c = B.pop(0)
                nextL.append(c.val)
                if c.left:
                    nextNodes.append(c.left)
                if c.right:
                    nextNodes.append(c.right)
            B = nextNodes
        return A
</code></pre><hr>
<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>首先答案是不一致的，则需要将他做成符合一定规则的结果。<br>emmmm最后的答案还是非常简单的。首先应该抓住他是一个生成平衡树的题目。其他的要求都是细节。有的细节需要技巧得出。有的细节自然而然就可以得出来结果。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        def helper(left, right):
            if left &gt; right:
                return None
            p = (left + right)//2
            root = TreeNode(nums[p])
            root.left = helper(left, p-1)
            root.right = helper(p+1, right)
            return root
        return helper(0,len(nums)-1)
</code></pre><hr>
<h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>首先它是一个判断题。针对每个节点都有可能进行对比。</p>
<pre><code># 这是一个暴力解法，从上到下
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        def helper(root):
            if not root:
                return 0
            return 1+ max(helper(root.left),helper(root.right))
        if abs(helper(root.left)-helper(root.right)) &gt; 1:
            return False
        else:
            return self.isBalanced(root.left) and self.isBalanced(root.right)
</code></pre><p>这里是从底到顶的解法</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        def helper(root):
            if not root:
                return 0
            left = helper(root.left)
            if left == -1:
                return -1
            right = helper(root.right)
            if right == -1:
                return -1
            return max(left,right)+1 if abs(left-right) &lt; 2 else -1
        return helper(root)!= -1
</code></pre><hr>
<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        mLeft = self.minDepth(root.left)
        mRight = self.minDepth(root.right)
        if mLeft &gt; 0 and mRight &gt; 0:
            return 1 + min(mLeft,mRight)
        elif mRight == 0:
            return 1+ mLeft
        elif mLeft == 0:
            return 1+ mRight
</code></pre><hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:
        def helper(root,temp):
            temp += root.val
            if not root.left and not root.right:    # 叶子节点
                return temp == sum
            elif root.left and not root.right:      # 有左节点没有右节点
                return  helper(root.left, temp)
            elif not root.left and root.right:      # 有右节点没有左节点
                return helper(root.right, temp)
            else:
                return helper(root.left, temp) or helper(root.right, temp)
        if not root:
            return False
        return helper(root,0)
</code></pre><hr>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h1><pre><code>class Solution:
def generate(self, numRows: int) -&gt; List[List[int]]:
    L = []
    for i in range(numRows):
        temp = (i+1)*[1]
        if i&gt;1:
            for j in range(i-1):
                temp[j+1] = L[i-1][j] +L[i-1][j+1]
        L.append(temp)
    return L
# 优秀解法
class Solution:
    def generate(self, numRows: int) -&gt; List[List[int]]:
        if numRows == 0: return []
        res = [[1]]
        while len(res) &lt; numRows:
            newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])]
            res.append(newRow)      
        return res
</code></pre><h1 id="119-杨辉三角II"><a href="#119-杨辉三角II" class="headerlink" title="119.杨辉三角II"></a>119.杨辉三角II</h1><pre><code>class Solution:
    def getRow(self, rowIndex: int) -&gt; List[int]:
        res = [1]
        while len(res) &lt;= rowIndex:
            res = [a+b for a, b in zip([0]+res, res+[0])]     
        return re
</code></pre><hr>
<h1 id="121-买股票的最佳时机"><a href="#121-买股票的最佳时机" class="headerlink" title="121.买股票的最佳时机"></a>121.买股票的最佳时机</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>暴力法：</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        m = 0
        for i in range(1,len(prices)):
            a = min(prices[0:i])
            if m &lt; prices[i]-a:
                m = prices[i]-a
        return m
</code></pre><p>改进：x5i</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        minprice = prices[0]
        maxprofit = 0
        for i in range(1,len(prices)):
            if minprice &gt; prices[i]:
                minprice = prices[i]
            elif prices[i]-minprice &gt; maxprofit:
                maxprofit = prices[i]-minprice
        return maxprofit
</code></pre><hr>
<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        if not s:
            return True
        # 1.字符串格式转换
        s = s.lower()
        t = &quot;&quot;
        for i in s:
            if (i&gt;=&quot;0&quot; and i&lt;=&quot;9&quot;) or (i&gt;=&quot;a&quot; and i&lt;=&quot;z&quot;):
                t = t+i
        # 2.对字符串进行翻转
        S = t[::-1]
        return S == t
        # 3.判断两字符串是否相等
</code></pre><hr>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>哈希表是最快的！！！</p>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        # 暴力一点，
        only = 0
        l = len(nums)
        for i in range(0,l):
            only = nums[i]
            if only not in nums[0:i] and only not in nums[i+1:l]:
                return only

class Solution(object):
    def singleNumber(self, nums):
        # 列表操作
        tale = []
        for i in nums:
            if i not in tale:
                tale.append(i)
            else:
                tale.remove(i)
        return tale[0]



class Solution(object):
    def singleNumber(self, nums):
        # 哈希操作
        hash_table = {}
        for i in nums:
            try:
                hash_table.pop(i)
            except:
                hash_table[i] = 1
        return hash_table.popitem()[0]
</code></pre><p>​<br>​    class Solution(object):<br>​        def singleNumber(self, nums):<br>​            # 位操作<br>​            “””<br>​            :type nums: List[int]<br>​            :rtype: int<br>​            “””<br>​            a = 0<br>​            for i in nums:<br>​                a ^= i<br>​            return a</p>
<hr>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        # 列表法
        hash_table = []
        t = head
        while t:
            if t in hash_table:
                return True
            else:
                hash_table.append(t)
            t = t.next
        return False

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        # 哈希法
        hash_table = {}
        t = head
        while t:
            try:
                hash_table.pop(t)
                return True
            except:
                hash_table[t] = 1
            t = t.next
        return False

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        if head == None or head.next == None:
            return False
        # 双指针法
        fast = head.next
        slow = head

        while slow != fast:
            if fast ==None or fast.next == None:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
</code></pre><hr>
<h1 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h1><pre><code>class Solution:
    def reverseWords(self, s: str) -&gt; str:
        if not s:
            return s
        s = s.strip()
        L = []
        P = False
        j = 0
        for i in range(len(s)):
            if s[i]!=&quot; &quot;:
                if not P:
                    j = i
                    P = True
            else:
                if P:
                    P = False
                    L.append(s[j:i])
        L.append(s[j:])
        return &quot; &quot;.join(L[::-1])
</code></pre><hr>
<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h1><p>给你一个整数数组 nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<pre><code>def maxProduct(self, nums: List[int]) -&gt; int:
    hash_table = {}
    hash_table[-1] = 1
    posi = [-1]
    nega = []
    Max = nums[0]
    for i in range(len(nums)):
        t = nums[i] * hash_table[i-1]
        if t &gt; 0:
            if Max &lt; t/hash_table[posi[0]]:
                Max = t//hash_table[posi[0]]
            hash_table[i] = t
        elif t &lt; 0:
            if nega:
                if Max &lt; t/hash_table[nega[0]]:
                    Max = t//hash_table[nega[0]]
            else:
                nega.append(i)
            hash_table[i] = t
        else:
            posi = [i]
            nega = []
            hash_table[i] = 1
            if Max &lt; 0:
                Max = 0
    return Max
</code></pre><h1 id="153-寻找旋转排序数组中的最小值-二分查找"><a href="#153-寻找旋转排序数组中的最小值-二分查找" class="headerlink" title="153. 寻找旋转排序数组中的最小值(二分查找)"></a>153. 寻找旋转排序数组中的最小值(二分查找)</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。</p>
<pre><code>def findMin(self, nums: List[int]) -&gt; int:
    # nums = [4,5,6,7,0,1,2]
    # 二分查找走一波
    left = 0
    right = len(nums)-1
    while left &lt; right:
        mid = left + (right-left)//2
        print(left,mid,right)
        if nums[mid] &lt; nums[mid-1]:
            return nums[mid]
        if nums[left] &lt;= nums[right]:
            return nums[left]
        if nums[mid] &gt;= nums[left]:
            left = mid+1
        else:
            right = mid
    return nums[left]
</code></pre><p>​    </p>
<hr>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        # 第一个想法，简单法：弄两个列表然后得到答案
        if not headA or not headB:
            return None
        listA = []
        listB = []
        A = headA
        B = headB
        while A:
            listA.append(A)
            A = A.next
        while B :
            listB.append(B)
            B = B.next
        if listA[-1] != listB[-1]:
            return None
        t = listA[-1]
        for i in range(1,min(len(listB),len(listA))+1):
            if listA[-i] != listB[-i]:
                return t
            else:
                t = listA[-i]
        return t
</code></pre><hr>
<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h1><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞。</p>
<pre><code>def findPeakElement(self, nums: List[int]) -&gt; int:
    left = 0
    right = len(nums) -1
    while left &lt; right:
        mid = left + (right - left)//2
        if nums[mid] &gt; nums[mid+1]:
            right = mid
        else:
            left = mid + 1
    return left
</code></pre><hr>
<h1 id="167-相交链表"><a href="#167-相交链表" class="headerlink" title="167.相交链表"></a>167.相交链表</h1><pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        m=0;n = 0

        for i in range(len(numbers)):
            T = target-numbers[i]
            if T in numbers[i+1:]:
                m = i+1
                n = numbers[m:].index(T)+m+1
                break
        return [m,n]
</code></pre><hr>
<h1 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a>168. Excel表列名称</h1><pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        L = &quot;&quot;
        while n != 0:
            j = n % 26 
            if j == 0:
                j = 26
                n -= 1
            L = chr(ord(&quot;A&quot;) + j -1) + L
            n = n//26
        return L
</code></pre><hr>
<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><pre><code>class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        hashtable = {}
        for i in nums:
            if i in hashtable:
                hashtable[i] += 1
            else:
                hashtable[i] = 1
        M = 0
        N = 0
        for i in list(hashtable):
            if hashtable[i]&gt;M:
                N = i
                M = hashtable[i]
        return N
</code></pre><hr>
<h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a>171. Excel表列序号</h1><pre><code>class Solution:
    def titleToNumber(self, s: str) -&gt; int:
        N = 0
        for i in s:
            w = ord(i)-ord(&quot;A&quot;)+1
            N = N*26 +w
        return N
</code></pre><hr>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h1><pre><code>class Solution:
    def trailingZeroes(self, n: int) -&gt; int:
        count = 0
        while n &gt;= 5:
            n = n//5
            count += n
        return count
</code></pre><hr>
<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h1><pre><code>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
</code></pre><p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<hr>
<h1 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
<pre><code>class Solution:
    def reverseBits(self, n: int) -&gt; int:
        a = bin(n)[2:]
        if len(a) &lt; 32:
            a = &quot;0&quot;*(32-len(a))+a
        return int(a[::-1],2)
</code></pre><hr>
<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<pre><code>class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        return bin(n)[2:].count(&quot;1&quot;)
</code></pre><hr>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<blockquote>
<p>我开始想把奇数与偶数分开算，但发现了例外测试。就是第一个和第四个加起来是最大的。所以我采用了动态规划的方法。</p>
</blockquote>
<pre><code>class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums) &lt;2:
            return nums[0]
        table = [0]*len(nums)
        table[0] = nums[0]
        table[1] = nums[1]
        for i in range(2,len(nums)):
            table[i] = nums[i] + max(table[0:i-1])
        return max(table)
</code></pre><p>我要看看答案里有没有更好的结果。</p>
<hr>
<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<pre><code>def numIslands(self, grid: List[List[str]]) -&gt; int:
    if not grid:
        return 0
    R = len(grid)
    C = len(grid[0])
    def modify_grid(i,j):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        if i &gt;= 0 and i &lt; R and j &gt;= 0 and j &lt; C:
            if grid[i][j] == &quot;1&quot;:
                grid[i][j] = &quot;0&quot;
                for p,q in zip(x,y):
                    modify_grid(i+p,j+q)
    I_num = 0
    for i in range(R):
        for j in range(C):
            # print(i)
            # print(j)
            if grid[i][j] == &quot;1&quot;:
                I_num += 1
                modify_grid(i,j)
    return I_num
</code></pre><hr>
<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<pre><code>class Solution:
    def isHappy(self, n: int) -&gt; bool:
        while True:
            n = sum([int(i)**2 for i in str(n)])
            if n == 4:
                return False
            if n == 1:
                return True
</code></pre><hr>
<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h1><p>删除链表中等于给定值 val 的所有节点。<br>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        L = ListNode(-1) 
        L.next = head
        head = L
        while L.next:
            if L.next.val == val:
                L.next = L.next.next
            else:
                L = L.next
        return head.next
</code></pre><hr>
<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h1><p>关于质数的计算还是很有讲究的。</p>
<pre><code>class Solution:
    def countPrimes(self, n: int) -&gt; int:
        if n &lt; 3:
            return 0
        results = [1]*n
        results[0],results[1] = 0, 1
        for i in range(2,int(n**0.5)+1):
            if results[i] == 1:
                results[i*2:n:i] = [0]*len(results[i*2:n:i])
        return sum(results)-1
</code></pre><hr>
<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h1><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “egg”, t = “add”<br>输出: true</p>
</blockquote>
<pre><code>class Solution:
    def isIsomorphic(self, s: str, t: str) -&gt; bool:
        hashtable1 = {}
        hashtable2 = {}
        x = 0
        for i in s:
            if i not in hashtable1:
                hashtable1[i] = x
                x = x + 1
        x = 0
        for i in t:
            if i not in hashtable2:
                hashtable2[i] = x
                x = x + 1
        for i,j in zip(s,t):
            if hashtable1[i] != hashtable2[j]:
                return False
        return True
</code></pre><hr>
<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre = None
        cur = head
        while cur:
            n = cur.next
            cur.next = pre
            pre = cur
            cur = n
        return pre
</code></pre><hr>
<h1 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h1><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<pre><code># 广度优先和深度优先方法的解法
def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
    # 存储有向图
    edges = collections.defaultdict(list)
    # 存储每个节点的入度
    indeg = [0] * numCourses
    # 存储答案
    result = list()

    for info in prerequisites:
        edges[info[1]].append(info[0])
        indeg[info[0]] += 1
    q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
    while q:
        # 从队首取出一个节点
        u = q.popleft()
        # 放入答案中
        result.append(u)
        for v in edges[u]:
            indeg[v] -= 1
            # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
            if indeg[v] == 0:
                q.append(v)
    if len(result) != numCourses:
        result = list()
    return result

def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
    # 存储有向图
    edges = collections.defaultdict(list)
    # 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    visited = [0] * numCourses
    # 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
    result = list()
    # 判断有向图中是否有环
    invalid = False

    for info in prerequisites:
        edges[info[1]].append(info[0])

    def dfs(u: int):
        nonlocal invalid
        # 将节点标记为「搜索中」
        visited[u] = 1
        # 搜索其相邻节点
        # 只要发现有环，立刻停止搜索
        for v in edges[u]:
            if visited[v] == 0:
                dfs(v)
                if invalid:
                    return
            # 如果「搜索中」说明找到了环
            elif visited[v] == 1:
                invalid = True
                return
        # 将节点标记为「已完成」
        visited[u] = 2
        # 将节点入栈
        result.append(u)

    # 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
    for i in range(numCourses):
        if not invalid and not visited[i]:
            dfs(i)

    if invalid:
        return list()
    # 如果没有环，那么就有拓扑排序
    # 注意下标 0 为栈底，因此需要将数组反序输出
    return result[::-1]
</code></pre><hr>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<pre><code>class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        hashtable = {}
        for i in nums:
            if i in hashtable:
                return True
            else:
                hashtable[i] = 1
        return False 
</code></pre><hr>
<h1 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h1><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<pre><code>class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:
        n = len(nums)
        table = n * [0]
        hashtable = {}
        for i in range(n):
            if nums[i] not in hashtable:
                hashtable[nums[i]] = i
                table[i] = 0
            else:
                table[i] = i - hashtable[nums[i]]
                hashtable[nums[i]] = i
        print(table)
        for i in table:
            if i&gt;0 and i&lt;=k:
                return True
        return False
</code></pre><hr>
<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含1的最大正方形，并返回其面积。</p>
<pre><code>def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
    if not matrix:
        return 0
    if not matrix[0]:
        return 0
    Row = len(matrix)
    Col = len(matrix[0])
    Max = 0
    for i in range(Row):
        for j in range(Col):
            if matrix[i][j] == &quot;1&quot;:
                print(i,j)
                temp = self.getArea(matrix,Row,Col,i,j)
                print(temp)
                if temp &gt; Max:
                    Max = temp
    return Max

# 判定以该节点为左上角所能得到的最大正方形面积
def getArea(self, matrix,Row, Col, i, j):
    x,y = i,j
    t = 1
    R = t
    flag = True
    while x+t &lt; Row and y+t &lt; Col:
        t += 1
        for p in range(t):
            if matrix[x+p][y+t-1] == &quot;0&quot;:
                flag = False
                break
        if not flag:
            break
        for q in range(t-1):
            if matrix[x+t-1][y+q]== &quot;0&quot;:
                flag = False
                break
        if not flag:
            break
        R = t
    return R*R
</code></pre><hr>
<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h1><p>使用队列实现栈的下列操作：</p>
<p>push(x) — 元素 x 入栈<br>pop() — 移除栈顶元素<br>top() — 获取栈顶元素<br>empty() — 返回栈是否为空<br>注意:</p>
<p>你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）</p>
<hr>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><p>翻转一棵二叉树。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return root
        a = self.invertTree(root.right)
        root.right = self.invertTree(root.left)
        root.left = a
        return root
</code></pre><hr>
<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h1><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<pre><code>class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        i = 0
        while i == 0 and n &gt;= 2:
            i = n%2
            n = n//2
        if i == 0 and n &gt; 0:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="234-回文链表（解答明天看一下）"><a href="#234-回文链表（解答明天看一下）" class="headerlink" title="234. 回文链表（解答明天看一下）"></a>234. 回文链表（解答明天看一下）</h1><p>请判断一个链表是否为回文链表。</p>
<p>我的简单解法</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        L = []
        t = head
        while t:
            L.append(t.val)
            t = t.next
        return True if L == L[::-1] else False
</code></pre><hr>
<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return None
        b = p if p.val &gt;= q.val else q
        s = p if p.val &lt; q.val else q
        if root.val &gt; b.val:
            return self.lowestCommonAncestor(root.left,p,q)
        elif root.val &gt;=s.val:
            return root
        else:
            return self.lowestCommonAncestor(root.right,p,q)
</code></pre><hr>
<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<pre><code>def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
    # 两个节点在路径中的最后一个相同的节点
    L1 = self.search(root,p)
    L2 = self.search(root,q)
    i,j = 0,0
    while i&lt;len(L1) and i &lt;len(L2):
        if L1[i] == L2[i]:
            i += 1
        else:
            break
    return L1[i-1]
def search(self, root, p):
    # p在root中的路径
    if not root:
        return []
    if root == p:
        return [root]
    left = self.search(root.left,p)
    right = self.search(root.right,p)
    if not left and not right:
        return []
    if not right:
        return [root] + left
    if not left:
        return [root] + right

def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
    if not root or root == p or root == q: return root
    left = self.lowestCommonAncestor(root.left, p, q)
    right = self.lowestCommonAncestor(root.right, p, q)
    if not left: return right
    if not right: return left
    return root
</code></pre><hr>
<h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        Sum = <span class="number">1</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            hash_table[i] = &#123;<span class="string">"pre"</span>:Sum,<span class="string">"rear"</span>:<span class="number">1</span>&#125;</span><br><span class="line">            Sum *= nums[i]</span><br><span class="line">        </span><br><span class="line">        Sum = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            hash_table[n<span class="number">-1</span>-i][<span class="string">"rear"</span>] = Sum</span><br><span class="line">            Sum *= nums[n<span class="number">-1</span>-i]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key,item <span class="keyword">in</span> hash_table.items():</span><br><span class="line">            <span class="comment"># print(key,item)</span></span><br><span class="line">            res.append(hash_table[key][<span class="string">"pre"</span>]*hash_table[key][<span class="string">"rear"</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>一个我写的更好的答案<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        pre_Sum = <span class="number">1</span></span><br><span class="line">        rear_Sum = <span class="number">1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        help_table = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            help_table[i][<span class="number">0</span>] = pre_Sum</span><br><span class="line">            help_table[n-i<span class="number">-1</span>][<span class="number">1</span>] = rear_Sum</span><br><span class="line">            pre_Sum *= nums[i]</span><br><span class="line">            rear_Sum *= nums[n-i<span class="number">-1</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res.append(help_table[i][<span class="number">0</span>]*help_table[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = [<span class="number">1</span>] * n</span><br><span class="line">        pre_Sum = <span class="number">1</span></span><br><span class="line">        rear_Sum = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res[i] *= pre_Sum</span><br><span class="line">            res[n-i<span class="number">-1</span>] *= rear_Sum</span><br><span class="line">            pre_Sum *= nums[i] </span><br><span class="line">            rear_Sum *= nums[n-i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre_Value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rear_value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] *= pre_Value;</span><br><span class="line">            res[nums.length-i-<span class="number">1</span>] *= rear_value;</span><br><span class="line">            pre_Value *= nums[i];</span><br><span class="line">            rear_value *= nums[nums.length-i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<pre><code>class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        hash_table1 = {}
        hash_table2 = {}
        for i in s:
            if i in hash_table1:
                hash_table1[i] += 1
            else:
                hash_table1[i] = 1
        for j in t:
            if j in hash_table2:
                hash_table2[j] += 1
            else:
                hash_table2[j] = 1
        if len(hash_table2) != len(hash_table1):
            return False
        else:
            for i in hash_table1:
                if i not in hash_table2:
                    return False
                elif hash_table2[i] != hash_table1[i]:
                    return False
            return True
</code></pre><hr>
<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<hr>
<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h1><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p>
<pre><code>class Solution:
    def addDigits(self, num: int) -&gt; int:
        x = 0
        while num != 0:
            x += num % 10
            num =num // 10
        return self.addDigits(x) if x &gt;= 10 else x
</code></pre><hr>
<h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h1><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<pre><code>class Solution:
    def isUgly(self, num: int) -&gt; bool:
        if num == 0:
            return False
        if num == 1:
            return True
        while True:
            if num % 2 == 0:
                num = num /2
            else: break
        while True:
            if num % 3 == 0:
                num = num /3
            else: break
        while True:
            if num % 5 == 0:
                num = num /5
            else: break
        return True if num == 1 else False
</code></pre><hr>
<h1 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h1><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<pre><code>class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        M = len(nums) + 1
        for i in range(M+1):
            if i not in nums:
                return i
        return M+1
</code></pre><hr>
<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre><code># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        二分排序
        &quot;&quot;&quot;
        i = 1
        j = n
        while i&lt;j:
            x = (i+j)//2
            if isBadVersion(x):
                j = x
            else:
                i = x+1
        return i
</code></pre><hr>
<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h1><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<pre><code>class Solution:
    def wordPattern(self, pattern: str, str: str) -&gt; bool:
        a = str.strip().split()
        b = list(pattern)
        hash_tabel = {}
        if len(a) != len(b):
            return False
        for i,j in zip(a,b):
            if j in hash_tabel:
                if hash_tabel[j] != i:
                    return False
            else:
                hash_tabel[j] = i
        # 判断不同key值不同
        S = []
        for i in hash_tabel:
            if hash_tabel[i] not in S:
                S.append(hash_tabel[i])
            else:
                return False
        return True
</code></pre><hr>
<h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a>292. Nim 游戏</h1><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<pre><code>class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        if n%4==0:
            return False
        else:
            return True
</code></pre><hr>
<h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h1><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
<p>我第一时间想到的也是动态规划，可是没有抓住重点就没写出来。还好。这个代码也是一看就懂的。动态规划的基本要素，一个表来记录已有的最好记录。一步一步推到想要的那一步。表是用来记录最好的结果的。</p>
<pre><code>class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp = len(nums)*[1]
        for i in range(len(nums)):
            t = dp[i]
            for j in range(0,i):
                if nums[j] &lt; nums[i]:
                    if dp[i] &lt; dp[j] + t:
                        dp[i] = dp[j] + t
        return max(dp)
</code></pre><hr>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre><code># 递归解法
def decodeString(self, s: str) -&gt; str:
    res = &quot;&quot;
    i = 0
    while i &lt; len(s) :
        if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
            k = int(s[i])
            i += 1
            while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
                k = k*10 + int(s[i])
                i += 1
            j = i+1
            stack = [&quot;[&quot;]
            while j&lt;len(s) and len(stack)&gt;0:
                if s[j] == &quot;[&quot;:
                    stack.append(&quot;[&quot;)
                elif s[j] == &quot;]&quot;:
                    stack.pop()
                j += 1
            temp = self.decodeString(s[i+1:j-1])
            res += k*temp
            i = j
        else:
            res += s[i]
            i += 1
    return res

# 栈解法
def decodeString(self, s: str) -&gt; str:
    res = &quot;&quot;
    i = 0
    stack = []
    while i &lt; len(s) :
        if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
            k = int(s[i])
            i += 1
            while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
                k = k*10 + int(s[i])
                i += 1
            stack.append(k)
        elif s[i] == &quot;]&quot;:
            temp = &quot;&quot;
            t = stack.pop()
            while t != &quot;[&quot;:
                temp = t + temp
                t = stack.pop()
            k = stack.pop()
            stack.append(k*temp)
            i += 1
        else:
            stack.append(s[i])
            i += 1
    return &quot;&quot;.join(stack)
</code></pre><hr>
<h1 id="466-统计重复个数"><a href="#466-统计重复个数" class="headerlink" title="466. 统计重复个数"></a>466. 统计重复个数</h1><p>由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcabcabc”。</p>
<p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p>
<p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。</p>
<p>请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。</p>
<pre><code>def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -&gt; int:
    if n1 == 0:
        return 0
    s1cnt, index, s2cnt = 0, 0, 0
    # recall 是我们用来找循环节的变量，它是一个哈希映射
    # 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符
    # 如果我们之前遍历了 s1cnt&#39; 个 s1 时，匹配到的是第 s2cnt&#39; 个 s2 中同样的第 index 个字符，那么就有循环节了
    # 我们用 (s1cnt&#39;, s2cnt&#39;, index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果
    # 那么哈希映射中的键就是 index，值就是 (s1cnt&#39;, s2cnt&#39;) 这个二元组
    # 循环节就是；
    #    - 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2
    #    - 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2
    # 那么还会剩下 (n1 - s1cnt&#39;) % (s1cnt - s1cnt&#39;) 个 s1, 我们对这些与 s2 进行暴力匹配
    # 注意 s2 要从第 index 个字符开始匹配
    recall = dict()
    while True:
        # 我们多遍历一个 s1，看看能不能找到循环节
        s1cnt += 1
        for ch in s1:
            if ch == s2[index]:
                index += 1
                if index == len(s2):
                    s2cnt, index = s2cnt + 1, 0
        # 还没有找到循环节，所有的 s1 就用完了
        if s1cnt == n1:
            return s2cnt // n2
        # 出现了之前的 index，表示找到了循环节
        if index in recall:
            s1cnt_prime, s2cnt_prime = recall[index]
            # 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2
            pre_loop = (s1cnt_prime, s2cnt_prime)
            # 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2
            in_loop = (s1cnt - s1cnt_prime, s2cnt - s2cnt_prime)
            break
        else:
            recall[index] = (s1cnt, s2cnt)

    # ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop
    ans = pre_loop[1] + (n1 - pre_loop[0]) // in_loop[0] * in_loop[1]
    # S1 的末尾还剩下一些 s1，我们暴力进行匹配
    rest = (n1 - pre_loop[0]) % in_loop[0]
    for i in range(rest):
        for ch in s1:
            if ch == s2[index]:
                index += 1
                if index == len(s2):
                    ans, index = ans + 1, 0
    # S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2
    return ans // n2
</code></pre><hr>
<h1 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组 (##)"></a>560. 和为K的子数组 (##)</h1><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<pre><code>class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        # 数组还可能有小于0的情况
        res = 0
        s = 0
        n = len(nums)
        hash_table = {}
        hash_table[s] = 1
        for i in range(n):
            pre += nums[i]
            if pre-k in hash_table:
                res += hash_table[s-k]
            if pre in hash_table:
                hash_table[pre] += 1
            else:
                hash_table[pre] = 1
        return res
</code></pre><hr>
<h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h1><p>用深度优先遍历：</p>
<pre><code>class Solution:
def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
    m = len(grid)
    if m == 0: return 0
    n = len(grid[0])
    ans = 0
    def dfs(i,j):
        if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n: return 0
        if grid[i][j] == 0: return 0
        grid[i][j] = 0
        top = dfs(i+1, j)
        bottom = dfs(i-1,j)
        left = dfs(i,j-1)
        right = dfs(i,j+1)
        return 1 + sum([top,bottom,left,right])
    for i in range(m):
        for j in range(n):
            ans = max(ans,dfs(i,j))
    return ans
</code></pre><hr>
<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h1><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    N = len(T)</span><br><span class="line">    res = [<span class="number">0</span>]*N</span><br><span class="line">    M = T[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> T[i] &gt; M:</span><br><span class="line">            M = T[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = i+<span class="number">1</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> T[i]&gt;=T[r]:</span><br><span class="line">                <span class="keyword">if</span> res[r] != <span class="number">0</span>:</span><br><span class="line">                    r = res[r] + r</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res[i] = r-i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="837-新21点-回溯法超时了，经提示还是用动态规划）"><a href="#837-新21点-回溯法超时了，经提示还是用动态规划）" class="headerlink" title="837. 新21点 (回溯法超时了，经提示还是用动态规划）"></a>837. 新21点 (回溯法超时了，经提示还是用动态规划）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="comment"># 回溯法超时了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &gt;= K <span class="keyword">and</span> score &lt;= N:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> score &gt;= K <span class="keyword">and</span> score &gt; N:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> score &lt; K:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,W+<span class="number">1</span>):</span><br><span class="line">                res += (<span class="number">1</span>/W)*help(score+i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> help(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>动态规划<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(K+W)</span><br><span class="line">    <span class="keyword">if</span> K+W<span class="number">-1</span> &lt;= N:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(K,N+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(K<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,i+<span class="number">1</span>+W):</span><br><span class="line">            dp[i] += dp[j]/W</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i&lt;N+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;N+<span class="number">1</span> &amp;&amp; j&lt;i+<span class="number">1</span>+W;j++)&#123;</span><br><span class="line">                dp[i] += dp[j]/W;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 最终通过的答案！！把相加的步骤优化一下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">        dp=[<span class="literal">None</span>]*(K+W)</span><br><span class="line">        s=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K,K+W):          <span class="comment"># 填蓝色的格子</span></span><br><span class="line">            dp[i] = <span class="number">1</span> <span class="keyword">if</span> i&lt;=N <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s+=dp[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):      <span class="comment"># 填橘黄色格子</span></span><br><span class="line">            dp[i]=s/W</span><br><span class="line">            s=s-dp[i+W]+dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h1><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        L = head
        N = 0
        while L:
            N += 1
            L = L.next
        L = head
        for _ in range(N//2):
            L = L.next
        return L
</code></pre><hr>
<h1 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h1><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p>
<p>你的目标是确切地知道 F 的值是多少。</p>
<p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p>
<pre><code>class Solution:
    def superEggDrop(self, K: int, N: int) -&gt; int:
        memo = {}
        def dp(k, n):
            if (k, n) not in memo:
                if n == 0:
                    ans = 0
                elif k == 1:
                    ans = n
                else:
                    lo, hi = 1, n
                    # keep a gap of 2 X values to manually check later
                    while lo + 1 &lt; hi:
                        x = (lo + hi) // 2
                        t1 = dp(k-1, x-1)
                        t2 = dp(k, n-x)

                        if t1 &lt; t2:
                            lo = x
                        elif t1 &gt; t2:
                            hi = x
                        else:
                            lo = hi = x

                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))
                                  for x in (lo, hi))

                memo[k, n] = ans
            return memo[k, n]

        return dp(K, N)
</code></pre><hr>
<h1 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h1><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。</p>
<pre><code>class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -&gt; bool:
        hashtable = {}
        for i in deck:
            if i in hashtable:
                hashtable[i] += 1
            else:
                hashtable[i] = 1
        a = set(hashtable.values())
        if len(a) == 1:
            return True if list(a)[0]&gt;1 else False
        else:
            b = min(a)
            for j in range(b,1,-1):
                print(j)
                p = False
                for i in a:
                    if i%j != 0:
                        p = True
                        break
                if p:
                    continue
                return True
            return False
</code></pre><hr>
<h1 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h1><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>
<pre><code>def subarraysDivByK(self, A: List[int], K: int) -&gt; int:
    hash_table = defaultdict(list)
    hash_table[0] = [-1]
    count = 0
    S = 0
    for i in range(len(A)):
        S += A[i]
        count += len(hash_table[S%K])
        hash_table[S%K].append(i)
    return count
</code></pre><hr>
<h1 id="990-等式方程的可满足性-并查集"><a href="#990-等式方程的可满足性-并查集" class="headerlink" title="990. 等式方程的可满足性 (并查集)"></a>990. 等式方程的可满足性 (并查集)</h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>:<span class="number">3</span>] == <span class="string">"=="</span>:</span><br><span class="line">                S1,S2 = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">                k1,k2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">0</span>] <span class="keyword">in</span> table[i]:</span><br><span class="line">                        S1 = table[i]</span><br><span class="line">                        k1 = i</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">3</span>] <span class="keyword">in</span> table[i]:</span><br><span class="line">                        S2 = table[i]</span><br><span class="line">                        k2 = i</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S1 <span class="keyword">and</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    table.append([item[<span class="number">0</span>],item[<span class="number">3</span>]])</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> S1 <span class="keyword">and</span> S2:</span><br><span class="line">                    S2.append(item[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">elif</span> S1 <span class="keyword">and</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    S1.append(item[<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> S1 != S2:</span><br><span class="line">                        S1.extend(S2)</span><br><span class="line">                        table.pop(k2)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>:<span class="number">3</span>] == <span class="string">"!="</span>:</span><br><span class="line">                S1,S2 = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">                <span class="keyword">for</span> L <span class="keyword">in</span> table:</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">0</span>] <span class="keyword">in</span> L:</span><br><span class="line">                        S1 = L</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">3</span>] <span class="keyword">in</span> L:</span><br><span class="line">                        S2 = L</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S1:</span><br><span class="line">                    table.append([item[<span class="number">0</span>]])</span><br><span class="line">                    S1 = table[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    table.append([item[<span class="number">3</span>]])</span><br><span class="line">                    S2 = table[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> S1 == S2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        parent = defaultdict(str)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parent[x] ==<span class="string">""</span>:</span><br><span class="line">                parent[x] = x</span><br><span class="line">            <span class="keyword">while</span> x != parent[parent[x]]:</span><br><span class="line">                parent[x] = parent[parent[x]]</span><br><span class="line">                x = parent[x]</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            parent[find(x)] = find(y)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>] == <span class="string">"="</span>:</span><br><span class="line">                union(item[<span class="number">0</span>],item[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>] == <span class="string">"!"</span>:</span><br><span class="line">                <span class="keyword">if</span> find(item[<span class="number">0</span>]) == find(item[<span class="number">3</span>]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="999-车的可用捕获量"><a href="#999-车的可用捕获量" class="headerlink" title="999. 车的可用捕获量"></a>999. 车的可用捕获量</h1><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<pre><code>class Solution:
    def numRookCaptures(self, board: List[List[str]]) -&gt; int:
        [(x,y)] = [(i,j) for i in range(8) for j in range(8) if board[i][j]==&quot;R&quot;]
        N = 0
        dx = [-1, 0, 1, 0]
        dy = [0, -1, 0, 1]
        for i,j in zip(dx,dy):
            d = 1
            while True:
                if x + i*d &lt;0 or x + i*d &gt;=8 or y + j*d &lt; 0 or y + j*d &gt;= 8:
                    break
                if board[x + i*d][y + j*d] == &quot;B&quot;:
                    break
                elif board[x + i*d][y + j*d] == &quot;p&quot;:
                    N += 1
                    break
                d += 1
        return N
</code></pre><hr>
<h1 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a>1014. 最佳观光组合</h1><p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。</p>
<p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p>
<p>返回一对观光景点能取得的最高分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时答案</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            cost = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                print(i,j,cost,A[i]+A[j],A[i]+A[j]-cost)</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]-cost &gt; res:</span><br><span class="line">                    res = A[i]+A[j]-cost</span><br><span class="line">                cost += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    dp = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">        dp = dp + (A[i]-A[i<span class="number">-1</span>]) <span class="number">-1</span></span><br><span class="line">        dp = A[i]+A[i<span class="number">-1</span>] <span class="number">-1</span> <span class="keyword">if</span> A[i]+A[i<span class="number">-1</span>] <span class="number">-1</span> &gt; dp <span class="keyword">else</span> dp</span><br><span class="line">        <span class="keyword">if</span> dp &gt; res:</span><br><span class="line">            res = dp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="1028-从先序遍历还原二叉树"><a href="#1028-从先序遍历还原二叉树" class="headerlink" title="1028. 从先序遍历还原二叉树"></a>1028. 从先序遍历还原二叉树</h1><p>我们从二叉树的根节点 root 开始进行深度优先搜索。</p>
<p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p>
<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>
<p>给出遍历输出 S，还原树并返回其根节点 root。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverFromPreorder</span><span class="params">(self, S: str)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># S = "1-2--3---4-5--6---7"</span></span><br><span class="line">        <span class="comment"># print(self.My_split(S))</span></span><br><span class="line">        val, S1, S2 = self.My_split(S)</span><br><span class="line">        root = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> S1:</span><br><span class="line">            root.left = self.recoverFromPreorder(S1)</span><br><span class="line">        <span class="keyword">if</span> S2:</span><br><span class="line">            root.right = self.recoverFromPreorder(S2)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">My_split</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[i] ==<span class="string">"-"</span>:</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> S[i] != <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j = i</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("step:" + str(step)</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[j] == <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> S[j] != <span class="string">"-"</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        val = S[i:j]</span><br><span class="line">        window_head = j</span><br><span class="line">        window_rear = window_head+step</span><br><span class="line">        <span class="keyword">while</span> window_rear &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[window_rear] != <span class="string">"-"</span>:</span><br><span class="line">                <span class="comment"># print("window_head: "+ str(window_head)+" window_rear: "+str(window_rear))</span></span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(window_head,window_rear):</span><br><span class="line">                    <span class="keyword">if</span> S[j] != <span class="string">"-"</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="comment"># print("flag: " + str(S[window_head]))</span></span><br><span class="line">                    <span class="keyword">if</span> (S[window_head<span class="number">-1</span>] != <span class="string">"-"</span>):</span><br><span class="line">                        res.append(window_head)</span><br><span class="line">                window_head = window_rear</span><br><span class="line">                window_rear = window_head+step</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                window_head += <span class="number">1</span></span><br><span class="line">                window_rear += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("res: " + str(res))</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> val, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> val, S[res[<span class="number">0</span>]:],<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> val, S[res[<span class="number">0</span>]:res[<span class="number">1</span>]],S[res[<span class="number">1</span>]:]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a>1095. 山脉数组中查找目标值</h1><p>（这是一个 交互式问题 ）</p>
<p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p>
<p>如果不存在这样的下标 index，就请返回 -1。</p>
<p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：</p>
<p>首先，A.length &gt;= 3</p>
<p>其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</p>
<p>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p>
<p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p>
<p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p>
<pre><code># &quot;&quot;&quot;
# This is MountainArray&#39;s API interface.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class MountainArray:
#    def get(self, index: int) -&gt; int:
#    def length(self) -&gt; int:

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: &#39;MountainArray&#39;) -&gt; int:
        length = mountain_arr.length()
        left = 0
        right = length -1
        return self.helper(target,mountain_arr,left,right)
</code></pre><p>​<br>​        def helper(self, target,mountain_arr, left, right):<br>​            if left &gt;= right:<br>​                if mountain_arr.get(left) == target:<br>​                    # 这里可以做一个实验，删掉这个判断和有这个有什么区别<br>​                    return left<br>​                return -1<br>​            mid = left + (right - left)//2<br>​            x = mountain_arr.get(index = mid)<br>​            print(“left: “ + str(left) + “ mid: “ + str(mid) + “ right: “ + str(right))<br>​            print(“x: “ +str(x))<br>​            if  x &gt; target:<br>​                # 先找前面，如果有就return，没有就再找后面<br>​                # 也可以判断坡<br>​                t = self.helper(target,mountain_arr, left, mid)<br>​                return t if t != -1 else self.helper(target,mountain_arr, mid+1, right)<br>​            else:<br>​                # 中间值小于目标值先判断在前坡还是后坡<br>​                if mid == 0 or x &gt; mountain_arr.get(mid-1):<br>​                    # 如果在前坡，就舍弃0~mid,查找mid+1到后面<br>​                    # 在前坡与目标值相等，直接返回<br>​                    if x == target:<br>​                        return mid<br>​                    return self.helper(target,mountain_arr, mid+1, right)<br>​                else:<br>​                    # 如果在后坡，就舍弃mid:,查找前面<br>​                    t = self.helper(target,mountain_arr, left, mid)<br>​                    if t != -1:<br>​                        return t<br>​                    else:<br>​                        if x == target:<br>​                            return mid<br>​                        return self.helper(target,mountain_arr, mid+1, right)</p>
<hr>
<h1 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h1><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<pre><code>class Solution:
    def massage(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        curMax = 0
        preMax = 0
        for x in nums:
            temp = curMax
            curMax = max(preMax+x, curMax)
            preMax = temp
        return curMax
</code></pre><hr>
<h1 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h1><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的方法就比较暴力，在原来的数组中把最大的几个给删了，剩下k个最小的留下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= len(arr):<span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            arr.remove(min(arr))</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46. 把数字翻译成字符串"></a>面试题46. 把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">    S= str(num)</span><br><span class="line">    N = len(S)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(step)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> step &gt; N<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            res += help(step+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> step &lt; N<span class="number">-1</span> <span class="keyword">and</span> int(S[step:step+<span class="number">2</span>])&lt;<span class="number">26</span> <span class="keyword">and</span> int(S[step:step+<span class="number">2</span>]) &gt; <span class="number">9</span> :</span><br><span class="line">                res += help(step+<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> help(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">    S= str(num)</span><br><span class="line">    N = len(S)</span><br><span class="line">    dp = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> int(S[i<span class="number">-2</span>:i])&lt;<span class="number">26</span> <span class="keyword">and</span> int(S[i<span class="number">-2</span>:i]) &gt; <span class="number">9</span>:</span><br><span class="line">            dp[i] += dp[i<span class="number">-2</span>]</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面试题51-数组中的逆序对-用分治法和归并排序的经典使用模式）"><a href="#面试题51-数组中的逆序对-用分治法和归并排序的经典使用模式）" class="headerlink" title="面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）"></a>面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）</h1><pre><code>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
</code></pre><p>​<br>​    class Solution:<br>​        def reversePairs(self, nums: List[int]) -&gt; int:<br>​            L = len(nums)<br>​            if L &lt; 2:<br>​                return 0<br>​            def reversePairs(nums, left, right):<br>​                if left == right:<br>​                    return 0<br>​                mid = left + (right - left)//2<br>​                leftpairs = reversePairs(nums, left, mid)<br>​                rightpairs = reversePairs(nums, mid+1, right)<br>​                crosspairs = self.crosspairs(nums, left, mid, right)<br>​                return leftpairs + rightpairs + crosspairs<br>​            return reversePairs(nums, 0, L-1)<br>​<br>​        def crosspairs(self, nums, left, mid, right):<br>​                temp = nums[left:right+1]<br>​                m = mid - left<br>​                r = right - left<br>​                i,j = 0, m+1<br>​                count = 0<br>​                for k in range(left, right+1):<br>​                    if i == m+1:<br>​                        nums[k] = temp[j]<br>​                        j += 1<br>​                    elif j == r + 1:<br>​                        nums[k] = temp[i]<br>​                        i += 1<br>​                    elif temp[i] &lt;= temp[j]:<br>​                        nums[k] = temp[i]<br>​                        i += 1<br>​                    else:<br>​                        nums[k] = temp[j]<br>​                        j += 1<br>​                        count += m - i + 1<br>​                return count</p>
<hr>
<h1 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h1><hr>
<p>[TOC]</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title>java高级编程上</title>
    <url>/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h1><p>启动后会选择工作目录</p>
<p>如果把一些视图关闭了可以从 windows+show View:</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200620094308218.png" alt="image-20200620094308218">t</p>
<p>里打开 “project Explorer”,”outline”,”console”,”problems”;</p>
<ul>
<li>建立项目：命名为Myproject</li>
</ul>
<p>项目创建完成后会产生两个目录：</p>
<ul>
<li><p>src : 保存所有的原代码目录</p>
</li>
<li><p>bin : 保存所有的生成的 *.class 目录；</p>
</li>
</ul>
<p>这个视图会和原来不一样，可以在右上角切换；</p>
<ul>
<li>字体大小通过Ctrl + ++放大字体，通过 windows+preference也可以调整</li>
</ul>
<blockquote>
<p>范例：编写程序</p>
</blockquote>
<ul>
<li>输入main,然后ALt+”/“可补充完成</li>
<li>系统输出：sysout，ALT+/</li>
</ul>
<p>代码生成功能可以生成一些类方法：</p>
<blockquote>
<p>范例生成类方法：</p>
</blockquote>
<ul>
<li>光标放在这里：</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200620100005420.png" alt="image-20200620100005420"></p>
<ul>
<li>状态栏【source】</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200620100058934.png" alt="image-20200620100058934"></p>
<ul>
<li>里面可选 生成 setter，getter；有参构造，无参构造；</li>
</ul>
<blockquote>
<p>快捷键：</p>
</blockquote>
<ul>
<li>Alt+/:代码编写提示</li>
<li>Ctr + 1：代码纠正；</li>
<li>CTRL + SHIFT + O :开发包的自动导入</li>
<li>CTRL  + / ：注释代码</li>
<li>CTRL + SHIFT + / ：注释多行</li>
<li>CTRL + SHIFT + F ：格式化代码</li>
<li>CTRL + SHIFT + L : 快捷键列表；</li>
<li>文档注释：<code>/**</code>+回车</li>
</ul>
<p>项目导入导出：</p>
<ul>
<li>导出：【file】+【export】;</li>
<li>导入：【项目】右键+【properties】+【java build path】+【library】+【classpath】+【Add External JARs】</li>
</ul>
<p>带参数的项目运行</p>
<a id="more"></a>
<h2 id="3-debug操作"><a href="#3-debug操作" class="headerlink" title="3. debug操作"></a>3. debug操作</h2><blockquote>
<p>范例</p>
</blockquote>
<p>类方法代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		temp = x + y;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.util.MyMath;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = MyMath.add(<span class="number">10</span>, <span class="number">20</span>);	<span class="comment">//将此处设置为断点：在行头双击，出现蓝点；</span></span><br><span class="line">		System.out.println(<span class="string">"加法结果 "</span>+ result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后就可以以debug模式进行操作，</p>
<p>调试的几种形式：</p>
<ul>
<li>单步跳入【F5】：进入到代码之中观察，进入到内部；</li>
<li>单步跳过【F6】：不进入到代码中观察，只观察代码表面</li>
<li>单步返回【F7】：后面的代码不再调试，返回到进入处</li>
<li>恢复执行【F8】：程序直接正常执行完毕</li>
</ul>
<h2 id="4-Junit测试工具"><a href="#4-Junit测试工具" class="headerlink" title="4. Junit测试工具"></a>4. Junit测试工具</h2><p>junit是一种用例测试工具；</p>
<blockquote>
<p>测试用例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		temp = x + y;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>选中要测试的例，继续选择新建；</li>
<li>java-junit</li>
<li>junit属于第三方程序包，需要额外的配置；</li>
<li>导入包后再import还报错了，删除项目自带的那个module什么文件；</li>
<li>Junit测试有两个返回结果：<ul>
<li>GREEN BAR：测试通过</li>
<li>RED BAR：测试失败；</li>
</ul>
</li>
</ol>
<h1 id="java新特性"><a href="#java新特性" class="headerlink" title="java新特性"></a>java新特性</h1><h2 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1.可变参数"></a>1.可变参数</h2><p>设计一个方法，用于计算任意个数的整数的相加结果；</p>
<blockquote>
<p>最开始用数组实现</p>
</blockquote>
<p>现在可以用的方法定义形式是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法模板</span></span><br><span class="line"><span class="keyword">public</span> [<span class="keyword">static</span>] [<span class="keyword">final</span>] 返回值 方法名称(参数类型 ... 参数名称)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>参数上的 …就明确描述了数组得的结构；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(add(<span class="number">1</span>,<span class="number">23</span>,<span class="number">124</span>));	<span class="comment">// 多个参数是可以的</span></span><br><span class="line">		System.out.println(add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;));	<span class="comment">// 用数组也是可以的</span></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实现任意个整数的相加</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data 要进行相加的整数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回多个整数相加结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>... data)</span> </span>&#123; <span class="comment">// 描述的是一个数组</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; data.length; x++) &#123;</span><br><span class="line">			sum += data[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：传递多个参数，可变参数写在最后</p>
<h2 id="2-foreach-循环（增加for）"><a href="#2-foreach-循环（增加for）" class="headerlink" title="2. foreach 循环（增加for）"></a>2. foreach 循环（增加for）</h2><p>原始数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; data.length; x++) &#123;</span><br><span class="line">    sum += data[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">for</span>(数据类型 临时变量：数组)&#123;</span><br><span class="line">    <span class="comment">//循环次数为数组长度，每一次循环都会取出一个数组元素给临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强型的for循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:data) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免角标问题，避免越界问题；</p>
<h2 id="3-静态导入"><a href="#3-静态导入" class="headerlink" title="3.静态导入"></a>3.静态导入</h2><p>定义一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		temp = x + y;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x - y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始肯定是先导入MyMath类，然后再用MyMath类来使用类中的static方法</p>
<blockquote>
<p> 范例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.jubingyi.util.MyMath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(MyMath.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">		System.out.println(MaMath.sub(<span class="number">20</span>,<span class="number">10</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态导入的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.jubingyi.util.MyMath.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMath</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">		System.out.println(sub(<span class="number">20</span>,<span class="number">10</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>可以解决程序的参数转换问题</p>
<h2 id="1-泛型问题引出"><a href="#1-泛型问题引出" class="headerlink" title="1. 泛型问题引出"></a>1. 泛型问题引出</h2><p>假设定义一个描述坐标的类Point; 类中有两个属性x，y;</p>
<ul>
<li>参数可能有如下的选择：<ul>
<li>x = 10 、y = 20</li>
<li>x = 10.1, y = 20.2</li>
<li>x = 东经70° y = 北纬20°</li>
</ul>
</li>
</ul>
<p>首先要解决的就是Point类属性x，y类型问题，那么此时需要保存的有int，double，String类型；再Java里只有一种类型Object可以保存所有的类型；</p>
<ul>
<li>int 自动装箱 Integer，在自动转型到Object</li>
<li>double 自动装箱 Double，Double自动向上到Object</li>
<li>String 向上转型Object；</li>
</ul>
<blockquote>
<p>范例：定义Point类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object x;</span><br><span class="line">	<span class="keyword">private</span> Object y;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(Object y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：设置整形数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point();</span><br><span class="line">    p.setX(<span class="number">10</span>);</span><br><span class="line">    p.setY(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> x = (Integer) p.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (Integer) p.getY();</span><br><span class="line">    System.out.println(<span class="string">"x = "</span> + x + <span class="string">"、 y="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例设置字符串：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point();</span><br><span class="line">    p.setX(<span class="string">"东经70°"</span>);</span><br><span class="line">    p.setY(<span class="string">"北纬20°"</span>);</span><br><span class="line">    String x = (String) p.getX();</span><br><span class="line">    String y = (String) p.getY();</span><br><span class="line">    System.out.println(<span class="string">"x = "</span> + x + <span class="string">"、 y="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但设置就可以随意设置，但接收时总要确定的类型来接收；</p>
<h2 id="2-泛型基本定义"><a href="#2-泛型基本定义" class="headerlink" title="2. 泛型基本定义"></a>2. 泛型基本定义</h2><p> 泛型就是类在定义时候不会设置类中的属性或方法中的参数的具体类型，在类使用的时候才进行定义</p>
<p>如果想要进行这种泛型的操作，就必须进行一个类型标记的声明</p>
<blockquote>
<p>范例：Point类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Point类定义的时候完全不知道属性的类型，完全由使用者来决定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">// T表示参数，是一个占位标记</span></span><br><span class="line">	<span class="keyword">private</span> T x;</span><br><span class="line">	<span class="keyword">private</span> T y;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(T y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;();</span><br><span class="line">		p.setX(<span class="string">"东经70°"</span>);</span><br><span class="line">		p.setY(<span class="string">"北纬20°"</span>);</span><br><span class="line">		String x = p.getX();	<span class="comment">// 避免了向下转型</span></span><br><span class="line">		String y = p.getY();</span><br><span class="line">		System.out.println(<span class="string">"x = "</span> + x + <span class="string">"、 y="</span> + y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-通配符（重点）"><a href="#3-通配符（重点）" class="headerlink" title="3. 通配符（重点）"></a>3. 通配符（重点）</h2><p>增加了泛型解决了不同类型的定义问题，但又有了统一参数的问题</p>
<blockquote>
<p>范例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> &lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">	<span class="keyword">private</span> T note;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> note;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(T note)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.note = note;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message&lt;String&gt; message = <span class="keyword">new</span> Message &lt;String&gt;();</span><br><span class="line">		message.setNote(<span class="string">"巨饼很帅气"</span>);</span><br><span class="line">		fun(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Message&lt;String&gt; temp)</span> </span>&#123;</span><br><span class="line">		System.out.println(temp.getNote());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在的问题是在于使用时类型使用的不是String那么其他的就不能使用fun函数了；也就是说还得写其他的重载方法；但写了所谓的重载方法也是错的：因为方法在程序看来都是<code>Message&lt;T&gt;</code>类型的，而不是你想要的，<code>Message&lt;String&gt;</code>，<code>Message&lt;Integer&gt;</code>之类的；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200620155851949.png" alt="image-20200620155851949"></p>
<p>我们想要的就是可以接受所有的类型，又不想让用户随意修改我们使用的类型；</p>
<hr>
<p><strong>这里使用“？”来处理</strong> ：能接收一切，但不能修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message&lt;Integer&gt; message = <span class="keyword">new</span> Message &lt;Integer&gt;();</span><br><span class="line">		message.setNote(<span class="number">99</span>);</span><br><span class="line">		fun(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时使用的通配符“？”描述的是他可以接受任意类型，但由于不确定类型，而无法修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Message&lt;?&gt; temp)</span> </span>&#123;</span><br><span class="line">		temp.setNote(<span class="string">"句柄很帅"</span>);	<span class="comment">// 这时就报错了，这是不能修改的；</span></span><br><span class="line">        temp.setNote(<span class="number">87</span>);	<span class="comment">// 这种自身传进来的修改也不可以；</span></span><br><span class="line">		System.out.println(temp.getNote());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在“？”的基础上产生了两个子通配符</p>
<ul>
<li><code>？ extends 类</code> ： 设置泛型上限：<ul>
<li>例如 <code>？ extends Number</code>，只能设置Number 或其子类，Integer，Double之类的</li>
</ul>
</li>
<li>? super 类： 设置泛型下限：<ul>
<li>例如 <code>？ super String</code> ,表示只能够设置String或其父类：Object；</li>
</ul>
</li>
</ul>
<blockquote>
<p>范例：泛型上限</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123; <span class="comment">// 设置泛型上限 ，表示只接收Number及其子类</span></span><br><span class="line">	<span class="keyword">private</span> T note;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> note;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(T note)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.note = note;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message&lt;Integer&gt; message = <span class="keyword">new</span> Message &lt;Integer&gt;();</span><br><span class="line">		message.setNote(<span class="number">99</span>);</span><br><span class="line">		fun(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Message&lt;? extends Number&gt; temp)</span> </span>&#123;	<span class="comment">// 只接收Number及其子类</span></span><br><span class="line">		System.out.println(temp.getNote());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型：泛型下限</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T note;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> note;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNote</span><span class="params">(T note)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.note = note;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message&lt;String&gt; message = <span class="keyword">new</span> Message &lt;String&gt;();</span><br><span class="line">		message.setNote(<span class="string">"Hello world"</span>);</span><br><span class="line">		fun(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Message&lt;? <span class="keyword">super</span> String&gt; temp)</span> </span>&#123;	<span class="comment">// 只在这里使用</span></span><br><span class="line">		System.out.println(temp.getNote());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4. 泛型接口"></a>4. 泛型接口</h2><blockquote>
<p>范例：泛型接口</p>
<ul>
<li>第一种类实现接口也泛型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;	<span class="comment">// 在接口上定义了泛型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage&lt;String&gt; msg = <span class="keyword">new</span> MessageImpl&lt;String&gt;();</span><br><span class="line">		msg.print(<span class="string">"Hello world!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：在子类实现接口的时候明确给出具体类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span>&lt;<span class="title">T</span>&gt;</span>&#123;	<span class="comment">// 在接口上定义了泛型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage</span>&lt;<span class="title">String</span>&gt;</span>&#123;	<span class="comment">// 明确了类型是String</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage&lt;String&gt; msg = <span class="keyword">new</span> MessageImpl();</span><br><span class="line">		msg.print(<span class="string">"Hello world!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-泛型方法"><a href="#5-泛型方法" class="headerlink" title="5. 泛型方法"></a>5. 泛型方法</h2><p>在类或接口里的方法就是泛型方法，但这些方法不一定非要在类或接口里</p>
<blockquote>
<p>范例：定义泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer [] data = fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> temp:data) &#123;</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &lt;T&gt;描述的是泛型标记的声明</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun(T ... args) &#123;	</span><br><span class="line">		<span class="keyword">return</span> args;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举功能比较玩出现，所以一定程度上来说，可以不会；</p>
<h2 id="1-多例与枚举"><a href="#1-多例与枚举" class="headerlink" title="1. 多例与枚举"></a>1. 多例与枚举</h2><p>多例设计模式：构造方法私有化，而后类内部需要提供有若干个实例化对象，后面通过static方法返回</p>
<blockquote>
<p>范例：定义一个描述颜色基色的多例设计类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color(<span class="string">"RED"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color(<span class="string">"GREEN"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color(<span class="string">"BLUE"</span>);</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> ch)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> RED;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> GREEN;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> BLUE;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Color.getInstance(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限制本类实例化个数</p>
</blockquote>
<p>所谓枚举就是一种高级的多例设计模式</p>
<blockquote>
<p>范例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color&#123;</span><br><span class="line">	RED,GREEN,BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Color.RED);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-Enum类"><a href="#2-Enum类" class="headerlink" title="2. Enum类"></a>2. Enum类</h2><p>enum是对一种类型的包装：使用enum定义的枚举类本质上就相当于一个class定义的类继承了<code>java.lang.Enum</code>父类；</p>
<p>在Enum类里面有以下的方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span></span></span><br></pre></td></tr></table></figure>
<p>当定义枚举类中对象的时候会自动设置序号和名字；</p>
</li>
<li><p>取得枚举名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取得枚举序号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color&#123;</span><br><span class="line">	RED,GREEN,BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Color.RED.name()+<span class="string">" : "</span>+Color.RED.ordinal());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RED : 0</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在枚举操作里还有一个方法可以取得所有的枚举数据：values()返回的是一个枚举的对象数组</p>
<blockquote>
<p>范例：取得所有的枚举数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">	RED, GREEN, BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Color temp : Color.values()) &#123;</span><br><span class="line">			System.out.println(temp.name() + <span class="string">" : "</span> + temp.ordinal());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RED : 0</span></span><br><span class="line"><span class="comment">GREEN : 1</span></span><br><span class="line"><span class="comment">BLUE : 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>面试题</strong>：请解释enum和Enum的区别</p>
<ul>
<li>enum是一个关键字，用enum定义的枚举类本质上就相当于一个类继承了Enum这个抽象类；</li>
</ul>
<h2 id="3-枚举中定义其他结构"><a href="#3-枚举中定义其他结构" class="headerlink" title="3. 枚举中定义其他结构"></a>3. 枚举中定义其他结构</h2><p>多例设计是在一个类中产生的，所以在这个类中就可以定义更多的属性和方法。</p>
<p>而枚举依靠以上额概念只能够说产生了若干个对象，但并不能扩充方法定义更多的结构。</p>
<p>所以设计枚举：定义属性，方法，或者实现接口</p>
<blockquote>
<p>范例：在枚举中定义更多的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">	RED(<span class="string">"红色"</span>), GREEN(<span class="string">"绿色"</span>), BLUE(<span class="string">"蓝色"</span>);	<span class="comment">//定义有其他内容，枚举对象定义在第一行；</span></span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Color temp : Color.values()) &#123;</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">红色</span></span><br><span class="line"><span class="comment">绿色</span></span><br><span class="line"><span class="comment">蓝色</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>枚举还可以实现接口</p>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Color implements IColor&#123;	<span class="comment">// 实现了接口！！！	</span></span><br><span class="line">	RED(<span class="string">"红色"</span>), GREEN(<span class="string">"绿色"</span>), BLUE(<span class="string">"蓝色"</span>);	<span class="comment">//定义有其他内容，枚举对象定义在第一行；</span></span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String title)</span> </span>&#123;	<span class="comment">// 构造方法不能用public</span></span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IColor ic = Color.RED;</span><br><span class="line">		System.out.println(ic.getColor());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">红色</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-枚举应用"><a href="#4-枚举应用" class="headerlink" title="4. 枚举应用"></a>4. 枚举应用</h2><p>实现一个表示性别的对象</p>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Sex sex;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age, Sex sex)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Sex&#123;</span><br><span class="line">	MALE(<span class="string">"男"</span>),FEMALE(<span class="string">"女"</span>);</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		People per = <span class="keyword">new</span> People(<span class="string">"张三"</span>,<span class="number">20</span>,Sex.MALE);</span><br><span class="line">		System.out.println(per);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>枚举还支持switch判断</p>
<blockquote>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Sex&#123;</span><br><span class="line">	MALE(<span class="string">"男"</span>),FEMALE(<span class="string">"女"</span>);</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Sex.MALE) &#123;</span><br><span class="line">		<span class="keyword">case</span> MALE:</span><br><span class="line">			System.out.println(<span class="string">"是男人"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FEMALE:</span><br><span class="line">			System.out.println(<span class="string">"是女人"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="代码开发逻辑"><a href="#代码开发逻辑" class="headerlink" title="代码开发逻辑"></a>代码开发逻辑</h2><ol>
<li>项目开发：把所有地址信息写在程序里</li>
</ol>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621114310743.png" alt="image-20200621114310743"></p>
<p>​    如果地址换了，则需要修改程序，</p>
<ol>
<li>使用一个配置文件，程序运行时要通过文件读取相关的配置操作</li>
</ol>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621114547669.png" alt="image-20200621114547669"></p>
<p>如果此时要更改一些配置，只需要更改配置文件即可（可以不修改源代码）</p>
<p>当使用配置文件后，</p>
<p>代码维护方便了，但开发还不是很方便；配置文件很难去修改，并且会造成一个项目的配置文件非常多；</p>
<p>JDK提供了一种做法把配置写进代码里，但用注解来控制；这样可以减少配置文件；</p>
<p>主要关注三个JDK内置的注解：<code>@override</code>,<code>@Deprecated</code>,<code>@SuppressWarnnings</code></p>
<h2 id="1-准确覆写-override"><a href="#1-准确覆写-override" class="headerlink" title="1. 准确覆写  @override"></a>1. 准确覆写  <code>@override</code></h2><p>覆写：子类定义了与父类方法名称相同、参数类型及个数、返回值类型相同的方法的时候叫做覆写；被覆写方法不能拥有比父类更为严格的访问控制权限</p>
<blockquote>
<p>范例：观察问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写了一个类里的toString写错成：tostring；导致没有报错；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 写了一个类里的toString写错成：tostring；导致没有报错；</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">tostring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"是个人"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> Person());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>现在为了保证覆写方法严格，可以使用一个注解（<code>@override</code>）来检测是否覆写成功</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">tostring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"是个人"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错：The method tostring() of type Person must override or implement a supertype method</p>
</blockquote>
<h2 id="2-过期声明-Deprecated"><a href="#2-过期声明-Deprecated" class="headerlink" title="2. 过期声明  @Deprecated"></a>2. 过期声明  <code>@Deprecated</code></h2><p>如果一个程序类废止了，不能直接删除，加一个过期注解；</p>
<blockquote>
<p>范例：<del>观察过期操作</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="meta">@Deprecated</span>	<span class="comment">// 表明该方法过期了，但用了也没事；</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();	<span class="comment">//明确表示出过期</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621120942170.png" alt="image-20200621120942170"></p>
</blockquote>
<p>仅仅警告不建议在使用；</p>
<h2 id="3-压制警告-SuppressWarnnings"><a href="#3-压制警告-SuppressWarnnings" class="headerlink" title="3. 压制警告  @SuppressWarnnings"></a>3. 压制警告  <code>@SuppressWarnnings</code></h2><p>调用某些操作会出现警告信息。警告不代表有错误；但用压制警告可以不再提示警告</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621121407749.png" alt="image-20200621121407749"></p>
<p>这里可以给主方法main加l也可以给person加；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621121547031.png" alt="image-20200621121547031"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unused"</span> &#125;)	<span class="comment">//	压制警告</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();	<span class="comment">//明确表示出过期</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口定义加强"><a href="#接口定义加强" class="headerlink" title="接口定义加强"></a>接口定义加强</h1><p>分析实际问题：</p>
<blockquote>
<p>接口使用问题</p>
</blockquote>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621122311938.png" alt="image-20200621122311938"></p>
<p>造成此种情况就在于接口只是个方法的声明，而没有具体方法实现；</p>
<ul>
<li>使用default来定义普通方法，通过对象调用</li>
<li>使用static来定义静态方法，通过接口名来使用</li>
</ul>
<blockquote>
<p>范例：定义普通方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;	<span class="comment">//	追加了普通方法体</span></span><br><span class="line">		System.out.println(<span class="string">"Hello world!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"你开门一直可以的"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage msg = <span class="keyword">new</span> Message();</span><br><span class="line">		msg.print();</span><br><span class="line">		msg.fun();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：追加静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;	<span class="comment">//	追加了普通方法体</span></span><br><span class="line">		System.out.println(<span class="string">"Hello world!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 可以由类名称直接调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMessage <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"你开门一直可以的"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage msg = <span class="keyword">new</span> Message();</span><br><span class="line">		msg.print();</span><br><span class="line">		msg.fun();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>更像抽象类了。但可以多继承；这是一种挽救设计</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-lambda表达式"><a href="#1-lambda表达式" class="headerlink" title="1. lambda表达式"></a>1. lambda表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage msg = <span class="keyword">new</span> IMessage() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Hello world!!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		msg.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对对象方法太完整了；使用时需要写的太多了。而使用lambda表达式就可以写出一个简单的救急函数；</p>
<p>函数式编程模型,同样的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMessage msg = ()-&gt;System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">		msg.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对对象的要求在于结构必须非常完整</p>
<p>但是要想使用函数式编程，接口方法只能有一个；</p>
<p>所以可以加一个注解：<code>@FunctionalInterface</code>，加上这个注解的接口的方法就不能是两个及两个以上；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;	<span class="comment">//报错</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Invalid '@FunctionalInterface' annotation; IMessage is not a functional interface</span></span><br></pre></td></tr></table></figure>
<p><code>()-&gt;</code>括号里写参数</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621124716729.png" alt="image-20200621124716729"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IMessage msg1 = ()-&gt;System.out.println(<span class="string">"hello world!"</span>);	<span class="comment">//	单行语句</span></span><br><span class="line">IMessage msg2 = ()-&gt;&#123;	<span class="comment">// 多行语句</span></span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是返回，可以不写<code>return</code>直接写结果即可；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMath</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IMath msg = (x,y)-&gt;x+y;</span><br><span class="line">		System.out.println(msg.add(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h2><p>数组、类有引用；</p>
<p>方法引用也就是别名；</p>
<ul>
<li>引用静态方法：<code>类名称 :: static方法名称</code></li>
<li>引用某个对象方法：<code>实例化对象 :: 普通方法</code></li>
<li>引用某个特定类的方法：<code>类名称 :: 普通方法</code></li>
</ul>
<blockquote>
<p>范例：引用静态方法：</p>
</blockquote>
<ul>
<li>在String类中有一个valueof()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUtil</span>&lt;<span class="title">P</span>,<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">transfor</span><span class="params">(P p)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IUtil&lt;Integer,String&gt; iu = String::valueOf;	<span class="comment">// 进行方法引用</span></span><br><span class="line">		String str = iu.transfor(<span class="number">1000</span>);</span><br><span class="line">		System.out.println(str.length());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给函数起了个别名</p>
<blockquote>
<p>范例：引用某一个对象中的方法</p>
<ul>
<li>使用大写转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUtil</span>&lt;<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">transfor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IUtil&lt;String&gt; iu = <span class="string">"hello"</span>::toUpperCase;	<span class="comment">// 进行方法引用</span></span><br><span class="line">		System.out.println(iu.transfor());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*HELLO*/</span></span><br></pre></td></tr></table></figure>
<p>范例：引用类中的普通方法</p>
<ul>
<li>String类有一个compareTo</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUtil</span>&lt;<span class="title">R</span>,<span class="title">P</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">transfor</span><span class="params">(P p1,P p2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IUtil&lt;Integer,String&gt; iu = String::compareTo;	<span class="comment">// 进行方法引用</span></span><br><span class="line">		System.out.println(iu.transfor(<span class="string">"H"</span>,<span class="string">"h"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p> 范例:引用构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUtil</span>&lt;<span class="title">R</span>,<span class="title">FP</span>,<span class="title">SP</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">transfor</span><span class="params">(FP p1,SP p2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IUtil&lt;Person,String,Integer&gt; iu = Person::<span class="keyword">new</span>;	<span class="comment">// 进行方法引用</span></span><br><span class="line">		System.out.println(iu.transfor(<span class="string">"张三"</span>,<span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person [name=张三, age=20]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-内建函数式接口"><a href="#3-内建函数式接口" class="headerlink" title="3. 内建函数式接口"></a>3. 内建函数式接口</h2><p>lambda的核心在于函数式接口；函数式接口的核心在于只有一个方法；在函数式编程里面只需要有四类接口（<code>java.util.function</code>）</p>
<ul>
<li><p>功能型的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;<span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>供给型函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费型函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>断言型函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：功能型的函数式接口</p>
<ul>
<li>String.valueOf</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Function&lt;Integer,String&gt; fun = String::valueOf;</span><br><span class="line">		System.out.println(fun.apply(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输入一个数据对数据处理后再进行输出；</p>
<p>如果知道输入的是 <code>Integer</code> 可以用 <code>IntFunction&lt;R&gt;</code>泛型仅表示一个返回值；</p>
<blockquote>
<p>范例：扩展的Function接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		IntFunction&lt;String&gt; fun = String::valueOf;</span><br><span class="line">		System.out.println(fun.apply(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：使用供给型函数式接口</p>
<ul>
<li>“hello”.toUpperCase()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Supplier&lt;String&gt; sup = <span class="string">"Hello"</span>::toUpperCase;</span><br><span class="line">		System.out.println(sup.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：消费型函数式接口</p>
<ul>
<li>System.out.println</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Consumer&lt;String&gt; fun = System.out::println;</span><br><span class="line">		System.out.println(fun.accept(<span class="string">"Hello world"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：断言型函数式接口</p>
<ul>
<li>isempty()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Predicate&lt;String&gt; pre = <span class="string">"hello"</span>::startsWith;</span><br><span class="line">		System.out.println(pre.test(<span class="string">"he"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>java的多线程编程是最大的特色</p>
<h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621180328764.png" alt="image-20200621180328764"></p>
<p>线程启动所花费的时间一定是短的；进程一定要比线程慢；</p>
<p><strong>思考</strong>：那里体现了多线程的应用</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621180930045.png" alt="image-20200621180930045"></p>
<p>所谓的高并发指的就是访问的线程量暴高；高并发最直白的问题是：服务器的内存不够用了，无法处理过多的线程（用户）</p>
<p>线程实在进程基础上的一个划分。没有进程就没有线程；进程消失了，线程也就消失了；</p>
<h2 id="2-继承Thread类实现多线程"><a href="#2-继承Thread类实现多线程" class="headerlink" title="2. 继承Thread类实现多线程"></a>2. 继承Thread类实现多线程</h2><p>实现多线程的前提是：在一个执行主类里；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621181501789.png" alt="image-20200621181501789"></p>
<p>有两种途径实现多线程主类：</p>
<ul>
<li>继承Thread类</li>
<li>【推荐】实现Runnable、Callable接口</li>
</ul>
<p><code>java.lang.Thread</code>是核心类； 若想定义一个线程的主类，直接的方法就是继承Thread类，而后覆写其中的<code>run()</code>方法（相当于线程中的主方法）。</p>
<blockquote>
<p>范例：定义线程主体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;	<span class="comment">//线程主体类</span></span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;	<span class="comment">//	所有的线程从此处开始执行；</span></span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.title+<span class="string">", x = "</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>一般认为有了主题类就产生对象，执行run方法；但这里不能直接调用run方法；</p>
<blockquote>
<p>范例：观察直接调用run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>);</span><br><span class="line">		MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>);</span><br><span class="line">		MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>);</span><br><span class="line">		mt1.run();</span><br><span class="line">		mt2.run();</span><br><span class="line">		mt3.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程A, x = 0</span></span><br><span class="line"><span class="comment">线程A, x = 1</span></span><br><span class="line"><span class="comment">线程B, x = 0</span></span><br><span class="line"><span class="comment">线程B, x = 1</span></span><br><span class="line"><span class="comment">线程C, x = 0</span></span><br><span class="line"><span class="comment">线程C, x = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>仅做了一个顺序打印，和多线程没有关系；多线程也是交替执行，不是各自执行各自的；</p>
</blockquote>
<p>正确启动多线程的方式是Thread类中的start方法</p>
<ul>
<li>启动多线程：<code>public void start()</code></li>
</ul>
<blockquote>
<p>范例：正确启动多线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>);</span><br><span class="line">		MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>);</span><br><span class="line">		MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>);</span><br><span class="line">		mt1.start();</span><br><span class="line">		mt2.start();</span><br><span class="line">		mt3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程B, x = 0</span></span><br><span class="line"><span class="comment">线程B, x = 1</span></span><br><span class="line"><span class="comment">线程C, x = 0</span></span><br><span class="line"><span class="comment">线程C, x = 1</span></span><br><span class="line"><span class="comment">线程C, x = 2</span></span><br><span class="line"><span class="comment">线程A, x = 0</span></span><br><span class="line"><span class="comment">线程B, x = 2</span></span><br><span class="line"><span class="comment">线程A, x = 1</span></span><br><span class="line"><span class="comment">线程A, x = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时执行代码发现所有的线程对象变为了交替执行；</p>
</blockquote>
<p>为什么要这样做而不是直接执行start？</p>
<p>​    这里它查看了源代码：</p>
<ul>
<li>每一个线程只能启动一次</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621184205832.png" alt="image-20200621184205832"></p>
<h2 id="3-使用Runable接口实现多线程"><a href="#3-使用Runable接口实现多线程" class="headerlink" title="3. 使用Runable接口实现多线程"></a>3. 使用Runable接口实现多线程</h2><p>Thread类的核心功能是进行线程启动，但是如果一个类直接继承Thread类所造成的问题就是单继承局限；</p>
<p>另一种实现模式：Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时也存在一个run方法和Thread一样得</p>
<blockquote>
<p>范例：利用Runnable定义线程主体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.title + <span class="string">", x="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是此时没有了start类，解决方法是Thread类里有一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span></span><br></pre></td></tr></table></figure>
<p>可以接收Runnable的接口对象，也就是可以通过Thread去启动它；</p>
<blockquote>
<p>范例：启动多线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>);</span><br><span class="line">		MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>);</span><br><span class="line">		MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(mt1).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt2).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt3).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程A, x=0</span></span><br><span class="line"><span class="comment">线程C, x=0</span></span><br><span class="line"><span class="comment">线程B, x=0</span></span><br><span class="line"><span class="comment">线程C, x=1</span></span><br><span class="line"><span class="comment">线程C, x=2</span></span><br><span class="line"><span class="comment">线程B, x=1</span></span><br><span class="line"><span class="comment">线程A, x=1</span></span><br><span class="line"><span class="comment">线程B, x=2</span></span><br><span class="line"><span class="comment">线程C, x=3</span></span><br><span class="line"><span class="comment">线程B, x=3</span></span><br><span class="line"><span class="comment">线程A, x=2</span></span><br><span class="line"><span class="comment">线程A, x=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这时就启动了多线程，多线程的启动永远都是THread类里的start方法；</p>
<p>也可以启动多个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>);</span><br><span class="line">		MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>);</span><br><span class="line">		MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread(mt1).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt1).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程A, x=0</span></span><br><span class="line"><span class="comment">线程A, x=0</span></span><br><span class="line"><span class="comment">线程A, x=1</span></span><br><span class="line"><span class="comment">线程A, x=2</span></span><br><span class="line"><span class="comment">线程A, x=1</span></span><br><span class="line"><span class="comment">线程A, x=3</span></span><br><span class="line"><span class="comment">线程A, x=2</span></span><br><span class="line"><span class="comment">线程A, x=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时的Runnable接口对象也可以采用匿名内部类或lambda表达式来定义</p>
<blockquote>
<p>范例：通过匿名内部类定义操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">"Hello world!!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：使用lambda</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"Hello world"</span>)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-Thread和Runnable的区别"><a href="#4-Thread和Runnable的区别" class="headerlink" title="4. Thread和Runnable的区别"></a>4. Thread和Runnable的区别</h2><p>使用形式上来说Runable可以实现多继承；</p>
<p>但这两个都有一定的联系；</p>
<p>首先观察Thread类的继承定义形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>
<p>翻开源代码看到Thread实现了Runnable中的<code>run()</code>方法，他写的是：如果targe不为空就运行这个target</p>
<p>这个target在Thread类的构造时赋值进来的。Thread初始化时把它作为属性保存了起来；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621212319879.png" alt="image-20200621212319879"></p>
<p>所以在多线程的处理上使用的就是代理设计模式；</p>
<p>实际上开发过程中Runnable还有一个特点：使用Runnable实现的多线程的程序类可以更好地描述出数据的共享的概念；（并不是说Thread不能）</p>
<p>目标只是希望产生若干个线程进行同一数据的处理操作</p>
<blockquote>
<p>范例：使用Thread实现数据操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"卖票，票剩 = "</span>+ <span class="keyword">this</span>.ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> MyThread().start();</span><br><span class="line">		<span class="keyword">new</span> MyThread().start();</span><br><span class="line">		<span class="keyword">new</span> MyThread().start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票，票剩 = 10</span></span><br><span class="line"><span class="comment">卖票，票剩 = 9</span></span><br><span class="line"><span class="comment">卖票，票剩 = 8</span></span><br><span class="line"><span class="comment">卖票，票剩 = 7</span></span><br><span class="line"><span class="comment">卖票，票剩 = 6</span></span><br><span class="line"><span class="comment">卖票，票剩 = 5</span></span><br><span class="line"><span class="comment">卖票，票剩 = 4</span></span><br><span class="line"><span class="comment">卖票，票剩 = 3</span></span><br><span class="line"><span class="comment">卖票，票剩 = 2</span></span><br><span class="line"><span class="comment">卖票，票剩 = 1</span></span><br><span class="line"><span class="comment">卖票，票剩 = 10</span></span><br><span class="line"><span class="comment">卖票，票剩 = 10</span></span><br><span class="line"><span class="comment">卖票，票剩 = 9</span></span><br><span class="line"><span class="comment">卖票，票剩 = 9</span></span><br><span class="line"><span class="comment">卖票，票剩 = 8</span></span><br><span class="line"><span class="comment">卖票，票剩 = 8</span></span><br><span class="line"><span class="comment">卖票，票剩 = 7</span></span><br><span class="line"><span class="comment">卖票，票剩 = 7</span></span><br><span class="line"><span class="comment">卖票，票剩 = 6</span></span><br><span class="line"><span class="comment">卖票，票剩 = 5</span></span><br><span class="line"><span class="comment">卖票，票剩 = 6</span></span><br><span class="line"><span class="comment">卖票，票剩 = 4</span></span><br><span class="line"><span class="comment">卖票，票剩 = 5</span></span><br><span class="line"><span class="comment">卖票，票剩 = 3</span></span><br><span class="line"><span class="comment">卖票，票剩 = 2</span></span><br><span class="line"><span class="comment">卖票，票剩 = 1</span></span><br><span class="line"><span class="comment">卖票，票剩 = 4</span></span><br><span class="line"><span class="comment">卖票，票剩 = 3</span></span><br><span class="line"><span class="comment">卖票，票剩 = 2</span></span><br><span class="line"><span class="comment">卖票，票剩 = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>各自卖各自的10张票</p>
<p>范例：用Thraed实现数据共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票，票剩 = 10</span></span><br><span class="line"><span class="comment">卖票，票剩 = 9</span></span><br><span class="line"><span class="comment">卖票，票剩 = 7</span></span><br><span class="line"><span class="comment">卖票，票剩 = 8</span></span><br><span class="line"><span class="comment">卖票，票剩 = 5</span></span><br><span class="line"><span class="comment">卖票，票剩 = 6</span></span><br><span class="line"><span class="comment">卖票，票剩 = 3</span></span><br><span class="line"><span class="comment">卖票，票剩 = 4</span></span><br><span class="line"><span class="comment">卖票，票剩 = 1</span></span><br><span class="line"><span class="comment">卖票，票剩 = 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>它把同一堆内存空间（MyThread对象）传给了一个新的Thread对象让其各自start；但是这样有点多此一举，因为MyThread也有继承自Thread里的start方法；它用了别人的</p>
</blockquote>
<p>此时的MyThread对象各自有各自的空间就像图中上面的这个；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621213423162.png" alt="image-20200621213423162"></p>
<blockquote>
<p>范例：实现Runnable实现数据共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"卖票，票剩 = "</span>+ <span class="keyword">this</span>.ticket--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票，票剩 = 10</span></span><br><span class="line"><span class="comment">卖票，票剩 = 8</span></span><br><span class="line"><span class="comment">卖票，票剩 = 7</span></span><br><span class="line"><span class="comment">卖票，票剩 = 6</span></span><br><span class="line"><span class="comment">卖票，票剩 = 5</span></span><br><span class="line"><span class="comment">卖票，票剩 = 4</span></span><br><span class="line"><span class="comment">卖票，票剩 = 3</span></span><br><span class="line"><span class="comment">卖票，票剩 = 2</span></span><br><span class="line"><span class="comment">卖票，票剩 = 1</span></span><br><span class="line"><span class="comment">卖票，票剩 = 9</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>此时Runnable是没有<code>start()</code>方法的它传给<code>Thread</code>类是合适的</p>
</blockquote>
<h2 id="5-线程运行状态"><a href="#5-线程运行状态" class="headerlink" title="5. 线程运行状态"></a>5. 线程运行状态</h2><p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621214512575.png" alt="image-20200621214512575"></p>
<p>调用了start不是立即执行，而是就绪，等待资源分配给了线程后才进入运行资源；</p>
<h2 id="6-通过Callable实现多线程"><a href="#6-通过Callable实现多线程" class="headerlink" title="6. 通过Callable实现多线程"></a>6. 通过Callable实现多线程</h2><p>JDK1.5加入了一个新的开发包：<code>java.util.concurrent</code>,主要进行高性能开发使用的，提供高并发操作才会用到的类。在这个包里面定义有一个新接口<code>Callable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Runnable虽也是线程主方法，但是它么有返回值；很多时候需要返回值时就可以用Callable</p>
<blockquote>
<p>范例：使用Callable定义线程主体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"卖票，x = "</span>+ x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"票卖完了"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Thread貌似与Callable没啥关系但通过分析得出以下的关系图</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200621220421505.png" alt="image-20200621220421505"></p>
<blockquote>
<p>范例：启动Callable多线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">卖票，x = 0</span></span><br><span class="line"><span class="comment">卖票，x = 1</span></span><br><span class="line"><span class="comment">卖票，x = 2</span></span><br><span class="line"><span class="comment">卖票，x = 3</span></span><br><span class="line"><span class="comment">卖票，x = 4</span></span><br><span class="line"><span class="comment">卖票，x = 5</span></span><br><span class="line"><span class="comment">卖票，x = 6</span></span><br><span class="line"><span class="comment">卖票，x = 7</span></span><br><span class="line"><span class="comment">卖票，x = 8</span></span><br><span class="line"><span class="comment">卖票，x = 9</span></span><br><span class="line"><span class="comment">票卖完了</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="多线程常用操作方法"><a href="#多线程常用操作方法" class="headerlink" title="多线程常用操作方法"></a>多线程常用操作方法</h1><p>多线程的主要操作方法都在Thread里面。重点掌握核心几个方法就可以了；</p>
<h2 id="1-线程的命名及取得"><a href="#1-线程的命名及取得" class="headerlink" title="1. 线程的命名及取得"></a>1. 线程的命名及取得</h2><p>Thread类里提供了如下的名称操作方法；</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>public Thread(Runnable target, String name)</code></td>
<td style="text-align:center">构造</td>
<td style="text-align:center">创建线程对象时设置好名字</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>public final void setName(String name)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">设置线程名字</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>public final String getName()</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得线程名字</td>
</tr>
</tbody>
</table>
</div>
<p>如果想要取得线程的对象，在Thread类有一个方法：</p>
<ul>
<li>取得当前线程对象：<code>public static Thread currentThread()</code>；</li>
</ul>
<blockquote>
<p>范例：观察线程名称的取得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">",x = "</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"有名线程"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0,x = 0</span></span><br><span class="line"><span class="comment">Thread-0,x = 1</span></span><br><span class="line"><span class="comment">有名线程,x = 0</span></span><br><span class="line"><span class="comment">Thread-1,x = 0</span></span><br><span class="line"><span class="comment">有名线程,x = 1</span></span><br><span class="line"><span class="comment">Thread-0,x = 2</span></span><br><span class="line"><span class="comment">有名线程,x = 2</span></span><br><span class="line"><span class="comment">Thread-1,x = 1</span></span><br><span class="line"><span class="comment">Thread-1,x = 2</span></span><br><span class="line"><span class="comment">Thread-1,x = 3</span></span><br><span class="line"><span class="comment">有名线程,x = 3</span></span><br><span class="line"><span class="comment">Thread-0,x = 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>没有设置线程名字会自动分配一个；</p>
<p>范例：观察线程执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		mt.run();	<span class="comment">// 通过对象调用run方法	main</span></span><br><span class="line">		<span class="keyword">new</span> Thread(mt).start();	<span class="comment">//没有名字通过线程调用	Thread-0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">Thread-0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>主方法就是一个线程；其他线程就是由主线程创建的</p>
</blockquote>
<h2 id="2-线程休眠"><a href="#2-线程休眠" class="headerlink" title="2. 线程休眠"></a>2. 线程休眠</h2><p>用来模拟延迟操作；</p>
<p>指的是让线程暂缓执行，等到了一定的时间再运行；</p>
<ul>
<li><p>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>休眠实现使用毫秒为单位</li>
</ul>
</li>
</ul>
<blockquote>
<p>范例：休眠操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">",x = "</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入代码的顺序有差异，但他们的执行基本是并发执行</p>
</blockquote>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622091300923.png" alt="image-20200622091300923"></p>
<h2 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3. 线程中断"></a>3. 线程中断</h2><p>线程被打断一定是由其他线程完成的；Thread类里提供的中断执行处理方法：</p>
<ul>
<li>判断线程是否被中断：<code>public boolean isInterrupted()</code></li>
<li>中断线程执行：<code>public void interrupt()</code>;</li>
</ul>
<blockquote>
<p>范例：观察线程中断处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">"我想睡觉"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">				System.out.println(<span class="string">"睡够了！！"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				System.out.println(<span class="string">"谁把我弄醒了"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!thread.isInterrupted()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"打扰你睡眠"</span>);</span><br><span class="line">			thread.interrupt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有执行的线程都是可以被中断的；</p>
</blockquote>
<h2 id="4-线程强制执行"><a href="#4-线程强制执行" class="headerlink" title="4. 线程强制执行"></a>4. 线程强制执行</h2><p>线程强制执行是指当满足某些条件之后，某一线程对象将可以一直独占资源，一直到程序执行结束；</p>
<blockquote>
<p>范例：没有强制执行的程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"正常的线程"</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"[霸道的Main线程] Number = "</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 0</span></span><br><span class="line"><span class="comment">正常的线程,x = 0</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 1</span></span><br><span class="line"><span class="comment">正常的线程,x = 1</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 2</span></span><br><span class="line"><span class="comment">正常的线程,x = 2</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 3</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 4</span></span><br><span class="line"><span class="comment">正常的线程,x = 3</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 5</span></span><br><span class="line"><span class="comment">正常的线程,x = 4</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 6</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 7</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 8</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 9</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 10</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 11</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 12</span></span><br><span class="line"><span class="comment">正常的线程,x = 5</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 13</span></span><br><span class="line"><span class="comment">正常的线程,x = 6</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 14</span></span><br><span class="line"><span class="comment">正常的线程,x = 7</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 15</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 16</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 17</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 18</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 19</span></span><br><span class="line"><span class="comment">正常的线程,x = 8</span></span><br><span class="line"><span class="comment">正常的线程,x = 9</span></span><br><span class="line"><span class="comment">正常的线程,x = 10</span></span><br><span class="line"><span class="comment">正常的线程,x = 11</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>强制执行的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：强制执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread MainThread = Thread.currentThread();	<span class="comment">// 获得主线程</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (x&gt;<span class="number">3</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						MainThread.join();	<span class="comment">//	霸道线程独占！</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"正常的线程"</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"[霸道的Main线程] Number = "</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 0</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 1</span></span><br><span class="line"><span class="comment">正常的线程,x = 0</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 2</span></span><br><span class="line"><span class="comment">正常的线程,x = 1</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 3</span></span><br><span class="line"><span class="comment">正常的线程,x = 2</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 4</span></span><br><span class="line"><span class="comment">正常的线程,x = 3</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 5</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 6</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 7</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 8</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 9</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 10</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 11</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 12</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 13</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 14</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 15</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 16</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 17</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 18</span></span><br><span class="line"><span class="comment">[霸道的Main线程] Number = 19</span></span><br><span class="line"><span class="comment">正常的线程,x = 4</span></span><br><span class="line"><span class="comment">正常的线程,x = 5</span></span><br><span class="line"><span class="comment">正常的线程,x = 6</span></span><br><span class="line"><span class="comment">正常的线程,x = 7</span></span><br><span class="line"><span class="comment">正常的线程,x = 8</span></span><br><span class="line"><span class="comment">正常的线程,x = 9</span></span><br><span class="line"><span class="comment">正常的线程,x = 10</span></span><br><span class="line"><span class="comment">正常的线程,x = 11</span></span><br><span class="line"><span class="comment">正常的线程,x = 12</span></span><br><span class="line"><span class="comment">正常的线程,x = 13</span></span><br><span class="line"><span class="comment">正常的线程,x = 14</span></span><br><span class="line"><span class="comment">正常的线程,x = 15</span></span><br><span class="line"><span class="comment">正常的线程,x = 16</span></span><br><span class="line"><span class="comment">正常的线程,x = 17</span></span><br><span class="line"><span class="comment">正常的线程,x = 18</span></span><br><span class="line"><span class="comment">正常的线程,x = 19</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-线程礼让"><a href="#5-线程礼让" class="headerlink" title="5.线程礼让"></a>5.线程礼让</h2><p>先将资源让出去，让别的线程先完成；用Thread中的方法：</p>
<ul>
<li>礼让：<code>public static void yield()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread MainThread = Thread.currentThread();	<span class="comment">// 获得主线程</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (x%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">					Thread.yield();</span><br><span class="line">					System.out.println(<span class="string">"#####子线程礼让执行"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"正常的线程"</span>);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"[霸道的Main线程] Number = "</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次礼让只会礼让当前一次的资源；可能就是一次程序轮转的机会；</p>
<h2 id="6-线程优先级"><a href="#6-线程优先级" class="headerlink" title="6. 线程优先级"></a>6. 线程优先级</h2><p>优先级越高越有可能先执行</p>
<p>Thread类里有以下优先级操作：</p>
<ul>
<li>设置优先级：<code>public final void setPriority(int newPriority)</code></li>
<li>取得优先级：<code>public final int getPriority()</code></li>
</ul>
<p>对于优先级设置的内容可以通过Thread类的几个常量来决定；</p>
<ul>
<li>最高优先级：<code>public static final int MAX_PRIORITY</code></li>
<li>中等优先级：<code>public static final int NORM_PRIORITY</code></li>
<li>最低优先级：<code>public static final int MIN_PRIORITY</code></li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622094842671.png" alt="image-20200622094842671"></p>
<blockquote>
<p>范例：设置优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(mt,<span class="string">"线程A"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(mt,<span class="string">"线程B"</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(mt,<span class="string">"线程C"</span>);</span><br><span class="line">		t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">		t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">		t3.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>主方法是一个线程，那么主线程的优先级可以这么得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5	中等优先级</span></span><br></pre></td></tr></table></figure>
<h1 id="线程的同步与死锁"><a href="#线程的同步与死锁" class="headerlink" title="线程的同步与死锁"></a>线程的同步与死锁</h1><h2 id="1-同步问题的引出"><a href="#1-同步问题的引出" class="headerlink" title="1.同步问题的引出"></a>1.同步问题的引出</h2><p>编写一个卖票操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;	<span class="comment">//总票数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">",剩余票数"</span>+<span class="keyword">this</span>.ticket--);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"**票卖光了**"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子C"</span>).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个票贩子卖十张票；看似没有问题，但这是有问题的，加入延迟操作来查看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;	<span class="comment">//总票数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);	<span class="comment">//	模拟网络延迟</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">",剩余票数"</span>+<span class="keyword">this</span>.ticket--);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"**票卖光了**"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子C"</span>).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">票贩子C,剩余票数10</span></span><br><span class="line"><span class="comment">票贩子B,剩余票数9</span></span><br><span class="line"><span class="comment">票贩子A,剩余票数8</span></span><br><span class="line"><span class="comment">票贩子C,剩余票数7</span></span><br><span class="line"><span class="comment">票贩子B,剩余票数6</span></span><br><span class="line"><span class="comment">票贩子A,剩余票数5</span></span><br><span class="line"><span class="comment">票贩子C,剩余票数4</span></span><br><span class="line"><span class="comment">票贩子B,剩余票数3</span></span><br><span class="line"><span class="comment">票贩子A,剩余票数2</span></span><br><span class="line"><span class="comment">票贩子C,剩余票数1</span></span><br><span class="line"><span class="comment">**票卖光了**</span></span><br><span class="line"><span class="comment">票贩子B,剩余票数0</span></span><br><span class="line"><span class="comment">**票卖光了**</span></span><br><span class="line"><span class="comment">票贩子A,剩余票数-1</span></span><br><span class="line"><span class="comment">**票卖光了**</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622101408070.png" alt="image-20200622101408070"></p>
<h2 id="2-线程同步处理"><a href="#2-线程同步处理" class="headerlink" title="2. 线程同步处理"></a>2. 线程同步处理</h2><p>同步问题的解决关键是锁：当一个线程执行操作的时候，其他线程外边等着；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622101611992.png" alt="image-20200622101611992"></p>
<p>要实现这把锁的功能，就要用<code>synchronized</code>关键字来实现，利用此关键字可以定义同步方法或者同步代码块；在同步代码块里只允许一个线程执行；</p>
<ol>
<li>利用同步代码块来执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">	同步代码操作；    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    一般进行同步对象，处理的时候采用当前对象this进行同步；</p>
<blockquote>
<p>范例：利用同步代码块解决数据同步访问问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;	<span class="comment">//总票数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;	<span class="comment">//	每一次只允许一个线程进行访问</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">50</span>);	<span class="comment">//	模拟网络延迟</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">",剩余票数"</span>+<span class="keyword">this</span>.ticket--);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"**票卖光了**"</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子C"</span>).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入同步解决了上述的问题，但是一个线程运行的时间太长了；同步实际上造成了性能的降低；</p>
</blockquote>
<ol>
<li>利用同步方法解决：只需要在方法定义上使用<code>synchronized</code>;</li>
</ol>
<blockquote>
<p>范例：同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;	<span class="comment">//总票数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">50</span>);	<span class="comment">//	模拟网络延迟</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">",剩余票数"</span>+<span class="keyword">this</span>.ticket--);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"**票卖光了**"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">this</span>.sale()) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(mt,<span class="string">"票贩子C"</span>).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>同步会造成性能的下降</p>
<h2 id="3-线程死锁"><a href="#3-线程死锁" class="headerlink" title="3. 线程死锁"></a>3. 线程死锁</h2><p>死锁是在进行多线程同步处理之中有可能产生的一种问题，所谓的死锁指的是若干个线程彼此等待对方释放资源的过程；</p>
<blockquote>
<p>范例：死锁展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wang</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Li l)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【王】要想过路先交钱！！"</span>);</span><br><span class="line">		l.get();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【王】拿到钱了！！你过吧"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Li</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Wang w)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【李】先过路再交钱！！"</span>);</span><br><span class="line">		w.get();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【李】过来了，还是先跑吧"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Wang w = <span class="keyword">new</span> Wang();</span><br><span class="line">	<span class="keyword">private</span> Li l = <span class="keyword">new</span> Li();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">		l.say(w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		w.say(l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DeadLock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="综合实战：”生产者-消费者“模型"><a href="#综合实战：”生产者-消费者“模型" class="headerlink" title="综合实战：”生产者-消费者“模型"></a>综合实战：”生产者-消费者“模型</h1><p>流程如下：</p>
<ul>
<li>生产者负责信息内容的生产</li>
<li>每当生产者生产完一项完整的信息之后消费者要从这里取走信息；</li>
<li>如果生产者没有生产则消费者要等待他生产完成；</li>
<li>如果消费者没有及时对信息进行消费，则生产者应该等待消费完成之后再继续生产；</li>
</ul>
<h2 id="1-生产者消费者基本程序模型"><a href="#1-生产者消费者基本程序模型" class="headerlink" title="1. 生产者消费者基本程序模型"></a>1. 生产者消费者基本程序模型</h2><p>将生产者与消费者定义为两个独立的线程类对象，对于生产的数据可以使用如下的组成</p>
<ul>
<li>数据一：</li>
<li>数据二：</li>
</ul>
<p>两个线程独立，那么两个线程之间需要有一个存放数据的地方</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622110829449.png" alt="image-20200622110829449"></p>
<blockquote>
<p>范例：实现基本结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.setTitle(<span class="string">"小王"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.msg.setContent(<span class="string">"宇宙大帅哥"</span>);	</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.setTitle(<span class="string">"小李"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.msg.setContent(<span class="string">"猥琐第一人"</span>);	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="keyword">this</span>.msg.getTitle()+<span class="string">" - "</span>+<span class="keyword">this</span>.msg.getContent());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(msg)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(msg)).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - null</span></span><br><span class="line"><span class="comment">小王 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小王 - 猥琐第一人</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment">小李 - 宇宙大帅哥</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>通过程序执行法系拿了两个问题：</p>
<ul>
<li>问题一：数据不同步；</li>
<li>问题二：应该生产一个取走一个，但发现有了重复生产，重复取出的问题</li>
</ul>
</blockquote>
<h2 id="2-解决消费者-生产者同步问题"><a href="#2-解决消费者-生产者同步问题" class="headerlink" title="2. 解决消费者-生产者同步问题"></a>2. 解决消费者-生产者同步问题</h2><p>最简单的解决同步使用<code>synchronized</code>关键字；</p>
<p>把数据的set与get的同步交给Message类来处理；</p>
<blockquote>
<p>范例：解决同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.set(<span class="string">"小王"</span>,<span class="string">"宇宙大帅哥"</span>,x);	</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.set(<span class="string">"小李"</span>,<span class="string">"猥琐第一人"</span>,x);	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第"</span> + x + <span class="string">"次取值： "</span>+ <span class="keyword">this</span>.msg.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;	<span class="comment">//	生产批号</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String title,String content,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.title+<span class="string">" - "</span>+<span class="keyword">this</span>.content+<span class="string">" -id- "</span>+<span class="keyword">this</span>.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(msg)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(msg)).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第0次取值： 小王 - 宇宙大帅哥 -id- 0</span></span><br><span class="line"><span class="comment">第1次取值： 小李 - 猥琐第一人 -id- 1</span></span><br><span class="line"><span class="comment">第2次取值： 小王 - 宇宙大帅哥 -id- 2</span></span><br><span class="line"><span class="comment">第3次取值： 小王 - 宇宙大帅哥 -id- 14</span></span><br><span class="line"><span class="comment">第4次取值： 小王 - 宇宙大帅哥 -id- 28</span></span><br><span class="line"><span class="comment">第5次取值： 小李 - 猥琐第一人 -id- 33</span></span><br><span class="line"><span class="comment">第6次取值： 小李 - 猥琐第一人 -id- 37</span></span><br><span class="line"><span class="comment">第7次取值： 小王 - 宇宙大帅哥 -id- 40</span></span><br><span class="line"><span class="comment">第8次取值： 小王 - 宇宙大帅哥 -id- 42</span></span><br><span class="line"><span class="comment">第9次取值： 小李 - 猥琐第一人 -id- 45</span></span><br><span class="line"><span class="comment">第10次取值： 小李 - 猥琐第一人 -id- 47</span></span><br><span class="line"><span class="comment">第11次取值： 小李 - 猥琐第一人 -id- 49</span></span><br><span class="line"><span class="comment">第12次取值： 小李 - 猥琐第一人 -id- 53</span></span><br><span class="line"><span class="comment">第13次取值： 小王 - 宇宙大帅哥 -id- 56</span></span><br><span class="line"><span class="comment">第14次取值： 小李 - 猥琐第一人 -id- 57</span></span><br><span class="line"><span class="comment">第15次取值： 小李 - 猥琐第一人 -id- 59</span></span><br><span class="line"><span class="comment">第16次取值： 小王 - 宇宙大帅哥 -id- 62</span></span><br><span class="line"><span class="comment">第17次取值： 小王 - 宇宙大帅哥 -id- 64</span></span><br><span class="line"><span class="comment">第18次取值： 小李 - 猥琐第一人 -id- 65</span></span><br><span class="line"><span class="comment">第19次取值： 小王 - 宇宙大帅哥 -id- 66</span></span><br><span class="line"><span class="comment">第20次取值： 小王 - 宇宙大帅哥 -id- 68</span></span><br><span class="line"><span class="comment">第21次取值： 小李 - 猥琐第一人 -id- 69</span></span><br><span class="line"><span class="comment">第22次取值： 小王 - 宇宙大帅哥 -id- 70</span></span><br><span class="line"><span class="comment">第23次取值： 小李 - 猥琐第一人 -id- 71</span></span><br><span class="line"><span class="comment">第24次取值： 小王 - 宇宙大帅哥 -id- 78</span></span><br><span class="line"><span class="comment">第25次取值： 小王 - 宇宙大帅哥 -id- 84</span></span><br><span class="line"><span class="comment">第26次取值： 小李 - 猥琐第一人 -id- 85</span></span><br><span class="line"><span class="comment">第27次取值： 小李 - 猥琐第一人 -id- 87</span></span><br><span class="line"><span class="comment">第28次取值： 小王 - 宇宙大帅哥 -id- 88</span></span><br><span class="line"><span class="comment">第29次取值： 小李 - 猥琐第一人 -id- 89</span></span><br><span class="line"><span class="comment">第30次取值： 小李 - 猥琐第一人 -id- 91</span></span><br><span class="line"><span class="comment">第31次取值： 小王 - 宇宙大帅哥 -id- 92</span></span><br><span class="line"><span class="comment">第32次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment">第33次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment">第34次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment">第35次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment">第36次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>可以看出他们的信息同步了，但是生产者-消费者之间的协作还不够；存在消费者重复操作的问题；</p>
</blockquote>
<h2 id="3-利用Object类解决重复操作：线程等待与唤醒机制"><a href="#3-利用Object类解决重复操作：线程等待与唤醒机制" class="headerlink" title="3. 利用Object类解决重复操作：线程等待与唤醒机制"></a>3. 利用Object类解决重复操作：线程等待与唤醒机制</h2><p>等待与唤醒利用Object类中的三个方法：</p>
<ul>
<li><p>等待机制：</p>
<ul>
<li>死等：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置等待时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置等待时间：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒机制</p>
<ul>
<li>唤醒第一个等待进程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>	<span class="comment">//	有若干个等待线程，唤醒其中的的第一个等待的；</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>唤醒全部等待线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>	<span class="comment">// 唤醒所有的等待进程</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：修改Message类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.set(<span class="string">"小王"</span>,<span class="string">"宇宙大帅哥"</span>,x);	</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.msg.set(<span class="string">"小李"</span>,<span class="string">"猥琐第一人"</span>,x);	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Message msg ;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">100</span>;x++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第"</span> + x + <span class="string">"次取值： "</span>+ <span class="keyword">this</span>.msg.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String content;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;	<span class="comment">//	生产批号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// flag = True 允许生产，不许消费</span></span><br><span class="line">	<span class="comment">// flag = False 允许消费不许生产</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String title,String content,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">super</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">super</span>.notify();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">super</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.title+<span class="string">" - "</span>+<span class="keyword">this</span>.content+<span class="string">" -id- "</span>+<span class="keyword">this</span>.id;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">super</span>.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeme</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producter(msg)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(msg)).start();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第0次取值： 小王 - 宇宙大帅哥 -id- 0</span></span><br><span class="line"><span class="comment">第1次取值： 小李 - 猥琐第一人 -id- 1</span></span><br><span class="line"><span class="comment">第2次取值： 小王 - 宇宙大帅哥 -id- 2</span></span><br><span class="line"><span class="comment">第3次取值： 小李 - 猥琐第一人 -id- 3</span></span><br><span class="line"><span class="comment">第4次取值： 小王 - 宇宙大帅哥 -id- 4</span></span><br><span class="line"><span class="comment">第5次取值： 小李 - 猥琐第一人 -id- 5</span></span><br><span class="line"><span class="comment">第6次取值： 小王 - 宇宙大帅哥 -id- 6</span></span><br><span class="line"><span class="comment">第7次取值： 小李 - 猥琐第一人 -id- 7</span></span><br><span class="line"><span class="comment">第8次取值： 小王 - 宇宙大帅哥 -id- 8</span></span><br><span class="line"><span class="comment">第9次取值： 小李 - 猥琐第一人 -id- 9</span></span><br><span class="line"><span class="comment">第10次取值： 小王 - 宇宙大帅哥 -id- 10</span></span><br><span class="line"><span class="comment">第11次取值： 小李 - 猥琐第一人 -id- 11</span></span><br><span class="line"><span class="comment">第12次取值： 小王 - 宇宙大帅哥 -id- 12</span></span><br><span class="line"><span class="comment">第13次取值： 小李 - 猥琐第一人 -id- 13</span></span><br><span class="line"><span class="comment">第14次取值： 小王 - 宇宙大帅哥 -id- 14</span></span><br><span class="line"><span class="comment">第15次取值： 小李 - 猥琐第一人 -id- 15</span></span><br><span class="line"><span class="comment">第16次取值： 小王 - 宇宙大帅哥 -id- 16</span></span><br><span class="line"><span class="comment">第17次取值： 小李 - 猥琐第一人 -id- 17</span></span><br><span class="line"><span class="comment">第18次取值： 小王 - 宇宙大帅哥 -id- 18</span></span><br><span class="line"><span class="comment">第19次取值： 小李 - 猥琐第一人 -id- 19</span></span><br><span class="line"><span class="comment">第20次取值： 小王 - 宇宙大帅哥 -id- 20</span></span><br><span class="line"><span class="comment">第21次取值： 小李 - 猥琐第一人 -id- 21</span></span><br><span class="line"><span class="comment">第22次取值： 小王 - 宇宙大帅哥 -id- 22</span></span><br><span class="line"><span class="comment">第23次取值： 小李 - 猥琐第一人 -id- 23</span></span><br><span class="line"><span class="comment">第24次取值： 小王 - 宇宙大帅哥 -id- 24</span></span><br><span class="line"><span class="comment">第25次取值： 小李 - 猥琐第一人 -id- 25</span></span><br><span class="line"><span class="comment">第26次取值： 小王 - 宇宙大帅哥 -id- 26</span></span><br><span class="line"><span class="comment">第27次取值： 小李 - 猥琐第一人 -id- 27</span></span><br><span class="line"><span class="comment">第28次取值： 小王 - 宇宙大帅哥 -id- 28</span></span><br><span class="line"><span class="comment">第29次取值： 小李 - 猥琐第一人 -id- 29</span></span><br><span class="line"><span class="comment">第30次取值： 小王 - 宇宙大帅哥 -id- 30</span></span><br><span class="line"><span class="comment">第31次取值： 小李 - 猥琐第一人 -id- 31</span></span><br><span class="line"><span class="comment">第32次取值： 小王 - 宇宙大帅哥 -id- 32</span></span><br><span class="line"><span class="comment">第33次取值： 小李 - 猥琐第一人 -id- 33</span></span><br><span class="line"><span class="comment">第34次取值： 小王 - 宇宙大帅哥 -id- 34</span></span><br><span class="line"><span class="comment">第35次取值： 小李 - 猥琐第一人 -id- 35</span></span><br><span class="line"><span class="comment">第36次取值： 小王 - 宇宙大帅哥 -id- 36</span></span><br><span class="line"><span class="comment">第37次取值： 小李 - 猥琐第一人 -id- 37</span></span><br><span class="line"><span class="comment">第38次取值： 小王 - 宇宙大帅哥 -id- 38</span></span><br><span class="line"><span class="comment">第39次取值： 小李 - 猥琐第一人 -id- 39</span></span><br><span class="line"><span class="comment">第40次取值： 小王 - 宇宙大帅哥 -id- 40</span></span><br><span class="line"><span class="comment">第41次取值： 小李 - 猥琐第一人 -id- 41</span></span><br><span class="line"><span class="comment">第42次取值： 小王 - 宇宙大帅哥 -id- 42</span></span><br><span class="line"><span class="comment">第43次取值： 小李 - 猥琐第一人 -id- 43</span></span><br><span class="line"><span class="comment">第44次取值： 小王 - 宇宙大帅哥 -id- 44</span></span><br><span class="line"><span class="comment">第45次取值： 小李 - 猥琐第一人 -id- 45</span></span><br><span class="line"><span class="comment">第46次取值： 小王 - 宇宙大帅哥 -id- 46</span></span><br><span class="line"><span class="comment">第47次取值： 小李 - 猥琐第一人 -id- 47</span></span><br><span class="line"><span class="comment">第48次取值： 小王 - 宇宙大帅哥 -id- 48</span></span><br><span class="line"><span class="comment">第49次取值： 小李 - 猥琐第一人 -id- 49</span></span><br><span class="line"><span class="comment">第50次取值： 小王 - 宇宙大帅哥 -id- 50</span></span><br><span class="line"><span class="comment">第51次取值： 小李 - 猥琐第一人 -id- 51</span></span><br><span class="line"><span class="comment">第52次取值： 小王 - 宇宙大帅哥 -id- 52</span></span><br><span class="line"><span class="comment">第53次取值： 小李 - 猥琐第一人 -id- 53</span></span><br><span class="line"><span class="comment">第54次取值： 小王 - 宇宙大帅哥 -id- 54</span></span><br><span class="line"><span class="comment">第55次取值： 小李 - 猥琐第一人 -id- 55</span></span><br><span class="line"><span class="comment">第56次取值： 小王 - 宇宙大帅哥 -id- 56</span></span><br><span class="line"><span class="comment">第57次取值： 小李 - 猥琐第一人 -id- 57</span></span><br><span class="line"><span class="comment">第58次取值： 小王 - 宇宙大帅哥 -id- 58</span></span><br><span class="line"><span class="comment">第59次取值： 小李 - 猥琐第一人 -id- 59</span></span><br><span class="line"><span class="comment">第60次取值： 小王 - 宇宙大帅哥 -id- 60</span></span><br><span class="line"><span class="comment">第61次取值： 小李 - 猥琐第一人 -id- 61</span></span><br><span class="line"><span class="comment">第62次取值： 小王 - 宇宙大帅哥 -id- 62</span></span><br><span class="line"><span class="comment">第63次取值： 小李 - 猥琐第一人 -id- 63</span></span><br><span class="line"><span class="comment">第64次取值： 小王 - 宇宙大帅哥 -id- 64</span></span><br><span class="line"><span class="comment">第65次取值： 小李 - 猥琐第一人 -id- 65</span></span><br><span class="line"><span class="comment">第66次取值： 小王 - 宇宙大帅哥 -id- 66</span></span><br><span class="line"><span class="comment">第67次取值： 小李 - 猥琐第一人 -id- 67</span></span><br><span class="line"><span class="comment">第68次取值： 小王 - 宇宙大帅哥 -id- 68</span></span><br><span class="line"><span class="comment">第69次取值： 小李 - 猥琐第一人 -id- 69</span></span><br><span class="line"><span class="comment">第70次取值： 小王 - 宇宙大帅哥 -id- 70</span></span><br><span class="line"><span class="comment">第71次取值： 小李 - 猥琐第一人 -id- 71</span></span><br><span class="line"><span class="comment">第72次取值： 小王 - 宇宙大帅哥 -id- 72</span></span><br><span class="line"><span class="comment">第73次取值： 小李 - 猥琐第一人 -id- 73</span></span><br><span class="line"><span class="comment">第74次取值： 小王 - 宇宙大帅哥 -id- 74</span></span><br><span class="line"><span class="comment">第75次取值： 小李 - 猥琐第一人 -id- 75</span></span><br><span class="line"><span class="comment">第76次取值： 小王 - 宇宙大帅哥 -id- 76</span></span><br><span class="line"><span class="comment">第77次取值： 小李 - 猥琐第一人 -id- 77</span></span><br><span class="line"><span class="comment">第78次取值： 小王 - 宇宙大帅哥 -id- 78</span></span><br><span class="line"><span class="comment">第79次取值： 小李 - 猥琐第一人 -id- 79</span></span><br><span class="line"><span class="comment">第80次取值： 小王 - 宇宙大帅哥 -id- 80</span></span><br><span class="line"><span class="comment">第81次取值： 小李 - 猥琐第一人 -id- 81</span></span><br><span class="line"><span class="comment">第82次取值： 小王 - 宇宙大帅哥 -id- 82</span></span><br><span class="line"><span class="comment">第83次取值： 小李 - 猥琐第一人 -id- 83</span></span><br><span class="line"><span class="comment">第84次取值： 小王 - 宇宙大帅哥 -id- 84</span></span><br><span class="line"><span class="comment">第85次取值： 小李 - 猥琐第一人 -id- 85</span></span><br><span class="line"><span class="comment">第86次取值： 小王 - 宇宙大帅哥 -id- 86</span></span><br><span class="line"><span class="comment">第87次取值： 小李 - 猥琐第一人 -id- 87</span></span><br><span class="line"><span class="comment">第88次取值： 小王 - 宇宙大帅哥 -id- 88</span></span><br><span class="line"><span class="comment">第89次取值： 小李 - 猥琐第一人 -id- 89</span></span><br><span class="line"><span class="comment">第90次取值： 小王 - 宇宙大帅哥 -id- 90</span></span><br><span class="line"><span class="comment">第91次取值： 小李 - 猥琐第一人 -id- 91</span></span><br><span class="line"><span class="comment">第92次取值： 小王 - 宇宙大帅哥 -id- 92</span></span><br><span class="line"><span class="comment">第93次取值： 小李 - 猥琐第一人 -id- 93</span></span><br><span class="line"><span class="comment">第94次取值： 小王 - 宇宙大帅哥 -id- 94</span></span><br><span class="line"><span class="comment">第95次取值： 小李 - 猥琐第一人 -id- 95</span></span><br><span class="line"><span class="comment">第96次取值： 小王 - 宇宙大帅哥 -id- 96</span></span><br><span class="line"><span class="comment">第97次取值： 小李 - 猥琐第一人 -id- 97</span></span><br><span class="line"><span class="comment">第98次取值： 小王 - 宇宙大帅哥 -id- 98</span></span><br><span class="line"><span class="comment">第99次取值： 小李 - 猥琐第一人 -id- 99</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>注意初始的flag应设置为true让它能够生产</p>
</blockquote>
<h1 id="多线程深入话题"><a href="#多线程深入话题" class="headerlink" title="多线程深入话题"></a>多线程深入话题</h1><h2 id="1-优雅的停止线程"><a href="#1-优雅的停止线程" class="headerlink" title="1. 优雅的停止线程"></a>1. 优雅的停止线程</h2><p>原本提供了stop方法，destory方法，suspend方法，resume方法（回复挂起线程执行）；需要一种柔和的方式在进行线程停止；</p>
<blockquote>
<p>范例：实现柔和的停止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">10</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">" 正在运行"</span>+ num++);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">"执行线程"</span>).start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他线程控制这个flag，也不是说立马就能停止，而是根据flag的内容来判断的；</p>
</blockquote>
<h2 id="2-后台守护线程"><a href="#2-后台守护线程" class="headerlink" title="2. 后台守护线程"></a>2. 后台守护线程</h2><p>所以多线程里可以进行守护线程</p>
<p>在Thread类里提供的守护线程的操作方法：</p>
<ul>
<li>设置为守护线程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否为守护线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：使用守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread userThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">" 正在运行"</span>+ x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">"用户线程"</span>);	<span class="comment">// 完成核心业务</span></span><br><span class="line">		Thread daemonThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;Integer.MAX_VALUE;x++) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">" 正在运行"</span>+ x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="string">"守护线程"</span>);</span><br><span class="line">		daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		userThread.start();</span><br><span class="line">		daemonThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">守护线程 正在运行0</span></span><br><span class="line"><span class="comment">用户线程 正在运行0</span></span><br><span class="line"><span class="comment">守护线程 正在运行1</span></span><br><span class="line"><span class="comment">用户线程 正在运行1</span></span><br><span class="line"><span class="comment">守护线程 正在运行2</span></span><br><span class="line"><span class="comment">用户线程 正在运行2</span></span><br><span class="line"><span class="comment">守护线程 正在运行3</span></span><br><span class="line"><span class="comment">用户线程 正在运行3</span></span><br><span class="line"><span class="comment">用户线程 正在运行4</span></span><br><span class="line"><span class="comment">守护线程 正在运行4</span></span><br><span class="line"><span class="comment">用户线程 正在运行5</span></span><br><span class="line"><span class="comment">守护线程 正在运行5</span></span><br><span class="line"><span class="comment">守护线程 正在运行6</span></span><br><span class="line"><span class="comment">用户线程 正在运行6</span></span><br><span class="line"><span class="comment">守护线程 正在运行7</span></span><br><span class="line"><span class="comment">用户线程 正在运行7</span></span><br><span class="line"><span class="comment">用户线程 正在运行8</span></span><br><span class="line"><span class="comment">守护线程 正在运行8</span></span><br><span class="line"><span class="comment">用户线程 正在运行9</span></span><br><span class="line"><span class="comment">守护线程 正在运行9</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<p>用户线程完毕了，守护线程也就消失了。java程序中最大的守护线程就是GC线程；</p>
</blockquote>
<h2 id="3-volatile关键字"><a href="#3-volatile关键字" class="headerlink" title="3. volatile关键字"></a>3. volatile关键字</h2><p>volatile关键字是在属性定义上使用的，表示此属性为直接数据操作，而不进行副本的拷贝处理；但是他不是同步操作；</p>
<p>在进行变量处理的时候会进行如下几个步骤：</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622125513284.png" alt="image-20200622125513284"></p>
<ul>
<li>获取变量原有的数据内容副本</li>
<li>利用副本为变量及逆行数学计算</li>
<li>将计算后的变量保存到原始空间中</li>
</ul>
<p>如果属性加了 volatile关键字，表示就是不使用副本，而是直接在原变量上操作’；</p>
<blockquote>
<p><strong>面试题</strong>：volatile关键字与sychronized的区别：</p>
<ul>
<li>volatile在属性，sychronized在代码块与方法上使用；</li>
<li>volatile无法描述同步处理，只是一种直接内存的处理</li>
</ul>
</blockquote>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>所谓的线程池就是多个线程封装在一起进行操作</p>
<h2 id="1-线程池简介"><a href="#1-线程池简介" class="headerlink" title="1. 线程池简介"></a>1. 线程池简介</h2><p>用来处理问题的线程池不同情况下：</p>
<ul>
<li>要解决的活很大有多少人来多少人</li>
<li>活很大，但要求只招聘10个人</li>
<li>活虽然很大，但只允许一个人做</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200622174935708.png" alt="image-20200622174935708"></p>
<p>JDK 1.5后追加了一并发访问的程序包：<code>java.util.concurrent</code>，对于线程池操作的核心类和接口就定义在此包之中，这里面有两个核心的接口：</p>
<ul>
<li>普通的执行线程池定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.ExecutorService</span><br></pre></td></tr></table></figure>
<ul>
<li>调度线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.ScheduledExecutorService</span><br></pre></td></tr></table></figure>
<p>要进行线程池的创建，一般可以使用<code>java.util.concurrent.Executors</code> 类完成，有以下几个方法：</p>
<ul>
<li>创建无大小限制的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建固定大小的线性池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,ThreadFactorythreadFactory)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>单线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建定时调度池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-线程池的实现"><a href="#2-线程池的实现" class="headerlink" title="2. 线程池的实现"></a>2. 线程池的实现</h2><ol>
<li><p>无限大小的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//	创建了线程池模型，但里面没有线程</span></span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();<span class="comment">//核心</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			<span class="keyword">int</span> index = x;</span><br><span class="line">			newCachedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span>+ index);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		newCachedThreadPool.shutdown();	<span class="comment">//	 关闭线程池</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建单线程线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//	创建了线程池模型，但里面没有线程</span></span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newSingleThreadScheduledExecutor();	<span class="comment">//核心</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = x;</span><br><span class="line">			newCachedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span>+ index);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		newCachedThreadPool.shutdown();	<span class="comment">//	 关闭线程池</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建固定大小的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//	创建了线程池模型，但里面没有线程</span></span><br><span class="line">		ExecutorService newCachedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);	<span class="comment">//核心</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = x;</span><br><span class="line">			newCachedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span>+ index);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		newCachedThreadPool.shutdown();	<span class="comment">//	 关闭线程池</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>定时调度池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">//	三个大小的定时调度池</span></span><br><span class="line">		ScheduledExecutorService newCachedThreadPool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x&lt;<span class="number">10</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = x;</span><br><span class="line">			newCachedThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">",x = "</span>+ index);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;, <span class="number">3</span>, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 使用的是秒的单位，表示3秒后执行，而后每2秒执行一次</span></span><br><span class="line">		&#125;</span><br><span class="line">		newCachedThreadPool.shutdown();	<span class="comment">//	 关闭线程池</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="多线程综合案例"><a href="#多线程综合案例" class="headerlink" title="多线程综合案例"></a>多线程综合案例</h1><h2 id="1-数字加减"><a href="#1-数字加减" class="headerlink" title="1. 数字加减"></a>1. 数字加减</h2><p>设计4个线程对象，两个线程执行减操作，两个线程执行加操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Resource res = <span class="keyword">new</span> Resource();</span><br><span class="line">		AddThread at = <span class="keyword">new</span> AddThread(res);</span><br><span class="line">		SubThread st = <span class="keyword">new</span> SubThread(res);</span><br><span class="line">		<span class="keyword">new</span> Thread(at,<span class="string">"加法线程 - A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(at,<span class="string">"加法线程 - B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(st,<span class="string">"减法线程 - X"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(st,<span class="string">"减法线程 - Y"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Resource resource;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">50</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.resource.add();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Resource resource;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubThread</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">50</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.resource.sub();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// flag : true 	可加 不可减</span></span><br><span class="line">	<span class="comment">// flag : false 可减不可加</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">			<span class="keyword">super</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		<span class="keyword">this</span>.num++;</span><br><span class="line">		System.out.println(<span class="string">"【加法操作- "</span>+Thread.currentThread().getName()+<span class="string">"】 num = "</span>+<span class="keyword">this</span>.num );</span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">super</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">super</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		<span class="keyword">this</span>.num--;</span><br><span class="line">		System.out.println(<span class="string">"【减法操作- "</span>+Thread.currentThread().getName()+<span class="string">"】 num = "</span>+<span class="keyword">this</span>.num );</span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">super</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-生产电脑"><a href="#2-生产电脑" class="headerlink" title="2. 生产电脑"></a>2. 生产电脑</h2><p>要求生产出来一台电脑就搬走一台电脑；</p>
<p>如果没有新的电脑生产出来，搬运工要等电脑生产出来；</p>
<p>如果没有搬走则要等电脑搬走后再生产，并统计处生产的电脑数量；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Resource res = <span class="keyword">new</span> Resource();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(res)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Remover(res)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remover</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Resource res;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Remover</span><span class="params">(Resource res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.res = res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">50</span>;x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				res.get();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Resource res;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Resource res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.res = res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">50</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				res.make();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Computer computer;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.computer != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">super</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		<span class="keyword">this</span>.computer = <span class="keyword">new</span> Computer(<span class="string">"联想牌"</span>,<span class="number">1.1</span>);</span><br><span class="line">		System.out.println(<span class="string">"【生产电脑】： "</span>+<span class="keyword">this</span>.computer);</span><br><span class="line">		<span class="keyword">super</span>.notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.computer == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">super</span>.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"【取走电脑】： "</span>+<span class="keyword">this</span>.computer);</span><br><span class="line">		<span class="keyword">this</span>.computer = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">super</span>.notifyAll();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;	<span class="comment">//	生产个数</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">this</span>.count ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"第"</span>+count+<span class="string">"台电脑"</span>+<span class="string">"Coumputer [name="</span> + name + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-竞争抢答"><a href="#3-竞争抢答" class="headerlink" title="3. 竞争抢答"></a>3. 竞争抢答</h2><p>有三个抢答者。同时发出抢答指令，抢答成功者给出成功提示，未抢答成功的给出失败提示；</p>
<p>这是看到有返回，则用Callable是比较合适的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		FutureTask&lt;String&gt; taskA = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt);</span><br><span class="line">		FutureTask&lt;String&gt; taskB = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt);</span><br><span class="line">		FutureTask&lt;String&gt; taskC = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt);</span><br><span class="line">		<span class="keyword">new</span> Thread(taskA,<span class="string">"竞赛者 - A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(taskB,<span class="string">"竞赛者 - B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(taskC,<span class="string">"竞赛者 - C"</span>).start();</span><br><span class="line">		System.out.println(taskA.get());</span><br><span class="line">		System.out.println(taskB.get());</span><br><span class="line">		System.out.println(taskC.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" 抢答成功！!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" 抢答失败！!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">竞赛者 - A 抢答失败！!</span></span><br><span class="line"><span class="comment">竞赛者 - B 抢答成功！!</span></span><br><span class="line"><span class="comment">竞赛者 - C 抢答失败！!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>只返回一个信息的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>&#123;</span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		FutureTask&lt;String&gt; taskA = <span class="keyword">new</span> FutureTask&lt;String&gt;(mt);</span><br><span class="line">		<span class="keyword">new</span> Thread(taskA,<span class="string">"竞赛者 - A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(taskA,<span class="string">"竞赛者 - B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(taskA,<span class="string">"竞赛者 - C"</span>).start();</span><br><span class="line"></span><br><span class="line">		System.out.println(taskA.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" 抢答成功！!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" 抢答失败！!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">竞赛者 - B 抢答成功！!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="java基础类库"><a href="#java基础类库" class="headerlink" title="java基础类库"></a>java基础类库</h1><h2 id="1-StringBuffer类"><a href="#1-StringBuffer类" class="headerlink" title="1. StringBuffer类"></a>1. StringBuffer类</h2><p>String类是所有项目开发中，一定会使用到的一个功能类，这个类有如下的特点：</p>
<ul>
<li>每个字符串常量都属于String类的匿名对象，并且不可更改；</li>
<li>String有两个常量池：静态常量池，运行时常量池；</li>
<li>String实例化建议直接使用赋值的形式完成，这样可以把对象保存在常量池中，方便下次重用；</li>
</ul>
<p>字符串目前所能看到的最大的弊端就是字符串不允许修改；</p>
<p>为了解决此问题，专门提供了一个<code>StringBuffer</code>类可以使用String字符串内容的处理；</p>
<blockquote>
<p>范例：观察String与StringBuffer类</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String类引用传递</th>
<th style="text-align:center">StringBuffer类应用传递</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"><span class="comment">// String类引用传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"Hello "</span>;</span><br><span class="line">		change(str);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String temp)</span> </span>&#123;	<span class="comment">// 内容没有发生改变</span></span><br><span class="line">		temp += <span class="string">"world!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>StringBuffer</code>没有String类的两种对象实例化方式，StringBuffer得像普通类对象一样先对象实例化，再调用方法执行处理</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据追加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 有各种类型参数的此方法</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jubingyi.Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		sb.append(<span class="string">"Hello "</span>);</span><br><span class="line">		change(sb);</span><br><span class="line">		System.out.println(sb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer temp)</span> </span>&#123;	</span><br><span class="line">		temp.append(<span class="string">"world!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，大部分情况下，很少会出现字符串内容的改变，改变指的并不是针对静态常量池的改变</p>
<blockquote>
<p> 范例：分析已有问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String strA = <span class="string">"Hello world"</span>;</span><br><span class="line">		String strB = <span class="string">"Hello "</span> + <span class="string">"world"</span>;</span><br><span class="line">		System.out.println(strA == strB);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候strB对象的内容并不算是改变；对于strB再程序编译后会变成如下形式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>String strB = “Hello “ + “world”;</th>
<th>StringBuffer buf = new StringBuffer();<br>buf.append(“Hello “).append(“world”);</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>String 方法的”+“在编译之后都变为了StringBuffer里的append方法；StringBuffer和String类之间可以相互转换；</p>
</blockquote>
<ul>
<li>String类变为StringBuffer类：StringBuffer类的构造方法或者使用append</li>
<li>所有的类通过<code>toString</code>方法将其变为<code>String</code>类型；</li>
</ul>
<p>其他方法：</p>
<ul>
<li><p>插入数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, 数据类型 b)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class JavaApiDemo </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buf.append(<span class="string">"miao"</span>).insert(<span class="number">0</span>,<span class="string">"Hello"</span>).insert(<span class="number">5</span>, <span class="string">" "</span>);</span><br><span class="line">		System.out.println(buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class JavaApiDemo </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buf.append(<span class="string">"Hello world"</span>).delete(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">		System.out.println(buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hlo world</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class JavaApiDemo </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buf.append(<span class="string">"Hello world"</span>);</span><br><span class="line">		System.out.println(buf.reverse());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dlrow olleH</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>与<code>StringBuffer</code>类有一个类似的功能类：<code>StringBuilder</code>：提供的方法与<code>StringBuffer</code>有相同的方法；</p>
<p><code>StringBuffer</code>属于线程安全的，全部使用了<code>synchronnized</code>关键字；<code>StringBuffer</code>没有这个；</p>
<h2 id="2-CharSequence接口"><a href="#2-CharSequence接口" class="headerlink" title="2. CharSequence接口"></a>2. CharSequence接口</h2><p>这个接口描述字符串接口的接口，实现了这个接口的有三个常用子类：String,StringBuffer,StringBuilder</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">String</th>
<th style="text-align:center">StringBuffer</th>
<th style="text-align:center">StringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence</code></td>
<td style="text-align:center"><code>public final class StringBuffer extends Object implements Serializable, CharSequence</code></td>
<td style="text-align:center"><code>public final class StringBuilder extends Object implements Serializable, CharSequence</code></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623094532493.png" alt="image-20200623094532493"></p>
<p>现在只要有字符串就可以为<code>CharSequence</code>接口实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CharSequence str = <span class="string">"Hello world"</span>;	<span class="comment">// 子类实例向父接口转型</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CharSequence</code>中定义的操作方法如下：</p>
<ul>
<li><p>获取指定索引字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取字符串长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>截取部分字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：字符串截取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CharSequence str = <span class="string">"Hello world"</span>;	<span class="comment">// 子类实例向父接口转型</span></span><br><span class="line">		System.out.println(str.subSequence(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>CharSequence</code>描述的就是一个字符串</p>
<h2 id="3-AutoCloseable接口"><a href="#3-AutoCloseable接口" class="headerlink" title="3. AutoCloseable接口"></a>3. AutoCloseable接口</h2><p>用于资源开发的处理，以实现资源的自动关闭；</p>
<p>更好的说明资源问题，通过一个消息的发送处理来完成；</p>
<blockquote>
<p>范例：手工实现资源处理:反正就是调用close函数关闭资源；</p>
</blockquote>
<p>这个接口只提供了一个方法：</p>
<ul>
<li>关闭方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623102242087.png" alt="image-20200623102242087"></p>
<p>要想使用自动关闭除了AutoCloseable之外，还需要结合异常处理语句才可以；</p>
<blockquote>
<p>范例：实现自动关闭:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (NetMessage nm = <span class="keyword">new</span> NetMessage(<span class="string">"Hello world"</span>))&#123;</span><br><span class="line">			nm.send();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetMessage</span> <span class="keyword">implements</span> <span class="title">IMessage</span>, <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String msg ;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NetMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【open】获取消息发送连接资源"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"【close】关闭消息发送通道"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.open()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"【*** 发送消息 ***】 "</span>+<span class="keyword">this</span>.msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后接触到资源关闭时经常会遇到AutoCloseable</p>
<h2 id="4-Runtime类"><a href="#4-Runtime类" class="headerlink" title="4. Runtime类"></a>4. Runtime类</h2><p>描述运行时的状态；Runtime是唯一一个与JVM运行状态有关的类，并且默认提供一个该类的实例化对象；</p>
<p>由于JVM运行时只有一个Runtime类对象，所以这个类的构造方法私有化了。也就是单例设计模式；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623104048946.png" alt="image-20200623104048946"></p>
<p>Runtime类负责描述系统信息，由JVM维护，所以就只有一个；</p>
<p>如果想获取这个对象可以使用Runtime类中的<code>getRuntime</code>方法获得；</p>
<ul>
<li><p>获取实例化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：获取Runtime对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Runtime run = Runtime.getRuntime();</span><br><span class="line">        <span class="comment">// 获取内核数availableProcessors()</span></span><br><span class="line">		System.out.println(<span class="string">"可用的进程数量："</span>+run.availableProcessors());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>获取最大内存空间：默认为本机系统内存的四分之一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxMemory</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取内存空间：默认为本机系统内存的64分之一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">totalMemory</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取空闲内存空间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">freeMemory</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手工进行垃圾回收处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：观察内存状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Runtime run = Runtime.getRuntime();</span><br><span class="line">		System.out.println(<span class="string">"可用的进程数量："</span>+run.availableProcessors());</span><br><span class="line">		System.out.println(<span class="string">"最大内存空间"</span>+run.maxMemory());</span><br><span class="line">		System.out.println(<span class="string">"空闲内存空间"</span>+run.freeMemory());</span><br><span class="line">		System.out.println(<span class="string">"获取内存空间"</span>+run.totalMemory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-system类"><a href="#5-system类" class="headerlink" title="5. system类"></a>5. system类</h2><p>其他方法：</p>
<ul>
<li>数组拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前日期时间数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span>	<span class="comment">// 计算程序耗时</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>垃圾回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>&#123;	<span class="comment">//	和Runtime.getRuntime().gc()是一样的；</span></span><br><span class="line">    Runtime.getRuntime().gc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-cleaner类"><a href="#6-cleaner类" class="headerlink" title="6. cleaner类"></a>6. cleaner类</h2><p>对象清理操作，主要功能是进行<code>finalize()</code>方法的替代；</p>
<p>C++类中的函数：构造函数，析构函数（对象手工回收）；java中由垃圾回收机制不太用这类析构函数；</p>
<p>Java给提供了用户收尾操作，Object类中的<code>finalized()</code>；JDK 9 之后不建议使用了；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>
<p>这个类最大特征是抛出<code>Throwable</code>异常类型； 这个异常类型分为两个子类型：<code>Error</code>，<code>Exception</code>，平常都是<code>Exception</code>;</p>
<blockquote>
<p>范例：观察传统回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【构造】你诞生了！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【回收】凡人终有一死"</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"哎，我还想活500年"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Member m = <span class="keyword">new</span> Member();</span><br><span class="line">		m = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		System.out.println(<span class="string">"太阳照常升起"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【构造】你诞生了！！</span></span><br><span class="line"><span class="comment">太阳照常升起</span></span><br><span class="line"><span class="comment">【回收】凡人终有一死</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>JDK 1.9开始finalize已经不建议使用了；建议使用 <code>java.lang.ref.Cleaner</code>类进行回收处理；（Cleaner也支持AutoCloseable接口处理）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.Cleaner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【构造】你诞生了！！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"【回收】凡人终有一死"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberCleaning</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner cleaner = Cleaner.create();</span><br><span class="line">	<span class="keyword">private</span> Member member;</span><br><span class="line">    <span class="keyword">private</span> Cleaner.Cleanable cleanable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemberCleaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.member = <span class="keyword">new</span> Member();</span><br><span class="line">    	<span class="keyword">this</span>.cleanable = <span class="keyword">this</span>.cleaner.register(<span class="keyword">this</span>, <span class="keyword">this</span>.member);	<span class="comment">//注册使用的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.cleanable.clean();	<span class="comment">//	启动多线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (MemberCleaning mc = <span class="keyword">new</span> MemberCleaning())&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-对象克隆"><a href="#7-对象克隆" class="headerlink" title="7. 对象克隆"></a>7. 对象克隆</h2><p>要使用Object类里的<code>clone()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br></pre></td></tr></table></figure>
<p>所有的类都会继承这个方法，但不是所有类都可以被克隆；要实现克隆就要实现一个接口<code>Cloneable</code>，这个接口没有任何方法提供；它只描述一种能力</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**Throws:**</span></span><br><span class="line"></span><br><span class="line"><span class="code">`CloneNotSupportedException`</span> - if the object's class does not support the <span class="code">`Cloneable`</span> interface. Subclasses that override the <span class="code">`clone`</span> method can also throw this exception to indicate that an instance cannot be cloned</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：实现clone</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【"</span>+<span class="keyword">super</span>.toString()+<span class="string">"】 Member [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Member mem = <span class="keyword">new</span> Member(<span class="string">"小王"</span>,<span class="number">23</span>);</span><br><span class="line">		Member mem_clone = (Member)mem.clone();</span><br><span class="line">		System.out.println(mem);</span><br><span class="line">		System.out.println(mem_clone);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【cn.jubingyi.Demo.Member@54bedef2】 Member [name=小王, age=23]</span></span><br><span class="line"><span class="comment">【cn.jubingyi.Demo.Member@5caf905d】 Member [name=小王, age=23]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>不覆写clone方法的话就会报错：<code>The method clone() from the type Object is not visible</code></p>
<p>不实现<code>Cloneable</code>接口就会抛出<code>CloneNotSupportedException</code>异常：</p>
<p>调用clone后返回的是一个Object类方法，还需要向下转</p>
<h1 id="数学操作类"><a href="#数学操作类" class="headerlink" title="数学操作类"></a>数学操作类</h1><h2 id="1-Math数学计算类"><a href="#1-Math数学计算类" class="headerlink" title="1. Math数学计算类"></a>1. Math数学计算类</h2><p>这个类构造方法被私有化了，但不是单例；</p>
<p>其中很多方法都是static，可以直接通过类名称调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">		System.out.println(Math.max(<span class="number">10.4</span>, <span class="number">19</span>));</span><br><span class="line">		System.out.println(Math.log(<span class="number">0.75</span>));	<span class="comment">// -0.2876820724517809</span></span><br><span class="line">		System.out.println(Math.log(<span class="number">0.5</span>));	<span class="comment">// -0.6931471805599453</span></span><br><span class="line">		System.out.println(Math.log(<span class="number">0.25</span>)); <span class="comment">// -1.3862943611198906</span></span><br><span class="line">		System.out.println(Math.round(<span class="number">15.51</span>));	<span class="comment">// 四舍五入，返回最接近的long</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：实现自定义的四舍五入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(MathUtil.round(<span class="number">19.562</span>, -<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">MathUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	实现四舍五入操作</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num：要进行的数字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> scale：四舍五入保留的位数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	四舍五入处理后的结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> num,<span class="keyword">int</span> scale )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.round(num * Math.pow(<span class="number">10</span>, scale)) / Math.pow(<span class="number">10</span>, scale);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-Random随机数生成类"><a href="#2-Random随机数生成类" class="headerlink" title="2. Random随机数生成类"></a>2. Random随机数生成类</h2><p><code>java.util.Random</code>类，这个类主要靠内部提供的方法来完成：</p>
<ul>
<li><p>产生一个不大于边界的随机非负整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Random a = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++) &#123;</span><br><span class="line">			System.out.print(a.nextInt(<span class="number">5</span>)+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有一款彩票叫做36选7，利用Random实现随机生成彩票号：</p>
<blockquote>
<p>范例：随机生成彩票号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> data []  = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">		Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">int</span> foot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (foot&lt;<span class="number">7</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = rand.nextInt(<span class="number">37</span>);</span><br><span class="line">			<span class="keyword">if</span> (isUsable(num, data)) &#123;</span><br><span class="line">				data[foot++] = num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		java.util.Arrays.sort(data);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t:data) &#123;</span><br><span class="line">			System.out.print(t+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断传入的数组是否为0以及是否在数组中中存在</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num	要判断的数字</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp	已经存在的数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	判断是否可用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x:temp) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == num) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-大数字处理类"><a href="#3-大数字处理类" class="headerlink" title="3. 大数字处理类"></a>3. 大数字处理类</h2><p>海量数字计算（基础计算）；在<code>java.math</code>包里提供了<code>BigInteger</code>,<code>BigDecimal</code>；他们继承自<code>Number</code>类；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623155100322.png" alt="image-20200623155100322"></p>
<p>观察两个大数字操作类的构造方法</p>
<ul>
<li><p>BigInteger类构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigInteger</span><span class="params">(String val)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BigDecimal类构造： </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：使用BIgInteger实现四则运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		BigInteger bigA = <span class="keyword">new</span> BigInteger(<span class="string">"234234234234234234243242678678678676786883432"</span>);</span><br><span class="line">		BigInteger bigB = <span class="keyword">new</span> BigInteger(<span class="string">"23423423"</span>);</span><br><span class="line">		System.out.println(<span class="string">"加法操作"</span>+bigA.add(bigB));</span><br><span class="line">		System.out.println(<span class="string">"减法操作"</span>+bigA.subtract(bigB));</span><br><span class="line">		System.out.println(<span class="string">"除法操作"</span>+bigA.divide(bigB));</span><br><span class="line">		System.out.println(<span class="string">"乘法操作"</span>+bigA.multiply(bigB));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可以但还是要考虑性能问题</p>
<p>范例：观察性能问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种计算是非常缓慢的，任何电脑都是有极限的；</p>
</blockquote>
<ul>
<li><p>求余：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger[] divideAndRemainder​(BigInteger val)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：求余除法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		BigInteger bigA = <span class="keyword">new</span> BigInteger(<span class="string">"234234234234234234243242678678678676786883432"</span>);</span><br><span class="line">		BigInteger bigB = <span class="keyword">new</span> BigInteger(<span class="string">"23423423"</span>);</span><br><span class="line">		BigInteger result [] = bigA.divideAndRemainder(bigB);</span><br><span class="line">		System.out.println(<span class="string">"商： "</span>+result[<span class="number">0</span>]+<span class="string">"、余数"</span>+result[<span class="number">1</span>]);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>BigDicimal都是非常类似的，都有基础的数学支持；</p>
<blockquote>
<p>范例：使用BigDecimal计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		BigDecimal bigA = <span class="keyword">new</span> BigDecimal(<span class="string">"234234234234234234243242678678678676786883432"</span>);</span><br><span class="line">		BigDecimal bigB = <span class="keyword">new</span> BigDecimal(<span class="string">"23423423"</span>);</span><br><span class="line">		System.out.println(<span class="string">"加法操作"</span>+bigA.add(bigB));</span><br><span class="line">		System.out.println(<span class="string">"减法操作"</span>+bigA.subtract(bigB));</span><br><span class="line">		System.out.println(<span class="string">"除法操作"</span>+bigA.divide(bigB,<span class="number">6</span>,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">		System.out.println(<span class="string">"乘法操作"</span>+bigA.multiply(bigB));</span><br><span class="line">		BigDecimal result [] = bigA.divideAndRemainder(bigB);</span><br><span class="line">		System.out.println(<span class="string">"除法计算：商： "</span>+ result[<span class="number">0</span>] + <span class="string">"、 余数："</span> + result[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中除法操作：第二个参数表示精度，第三个表示进位模式；但是已经被废弃了；</p>
</blockquote>
<h1 id="日期操作类"><a href="#日期操作类" class="headerlink" title="日期操作类"></a>日期操作类</h1><p>因为java的设计来自于数据表中的结构，数据表中的字符，数字都学了；现在就差日期了；</p>
<p>java提供了一个<code>java.util.Data</code>类，直接实例化就可以获取当前的日期时间；</p>
<blockquote>
<p>范例：观察<code>java.util.Data</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		System.out.println(date);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察：Data构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">        fastTime = date; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>结论：Data类只不过是对long数据的一种包装；所以Data类中一定有所谓的日期与long之间的转换的方法：</p>
<ul>
<li><p>将long转为日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">        fastTime = date; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将日期转为Long：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：观察Data与long之间的转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="keyword">long</span> current = date.getTime();</span><br><span class="line">		current += <span class="number">864000000</span>;</span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date(current);</span><br><span class="line">		System.out.println(date);</span><br><span class="line">		System.out.println(date2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-日期的格式化处理"><a href="#2-日期的格式化处理" class="headerlink" title="2. 日期的格式化处理"></a>2. 日期的格式化处理</h2><p>Data类输出的日期结构不习惯，进行格式化日期使用：<code>java.text.SimpleDateFormat</code>类；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623172221564.png" alt="image-20200623172221564"></p>
<p>这个类是<code>DateFormat</code>类的子类，在这个类中提供有如下的方法：</p>
<ul>
<li><p>【DateFormat继承】将日期格式化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【DateFormat继承】将字符串转为日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>【SimpleDateFormat】构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDateFormat</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>日期格式描述：年（yyyy）、月（MM）、日（dd）、时（H,h）、分（m）、秒（ss）、毫秒（SSS）；</li>
</ul>
</li>
</ul>
<p><table class="striped"></table></p>
<p><thead>
     <tr>
         <th style="text-align:left">Letter
         </th><th style="text-align:left">Date or Time Component
         </th><th style="text-align:left">Presentation
         </th><th style="text-align:left">Examples
 </th></tr></thead><br> <tbody>
     <tr>
         <td><code>G</code>
         </td><td>Era designator
         </td><td><a href="#text">Text</a>
         </td><td><code>AD</code>
     </td></tr><tr>
         <td><code>y</code>
         </td><td>Year
         </td><td><a href="#year">Year</a>
         </td><td><code>1996</code>; <code>96</code>
     </td></tr><tr>
         <td><code>Y</code>
         </td><td>Week year
         </td><td><a href="#year">Year</a>
         </td><td><code>2009</code>; <code>09</code>
     </td></tr><tr>
         <td><code>M</code>
         </td><td>Month in year (context sensitive)
         </td><td><a href="#month">Month</a>
         </td><td><code>July</code>; <code>Jul</code>; <code>07</code>
     </td></tr><tr>
         <td><code>L</code>
         </td><td>Month in year (standalone form)
         </td><td><a href="#month">Month</a>
         </td><td><code>July</code>; <code>Jul</code>; <code>07</code>
     </td></tr><tr>
         <td><code>w</code>
         </td><td>Week in year
         </td><td><a href="#number">Number</a>
         </td><td><code>27</code>
     </td></tr><tr>
         <td><code>W</code>
         </td><td>Week in month
         </td><td><a href="#number">Number</a>
         </td><td><code>2</code>
     </td></tr><tr>
         <td><code>D</code>
         </td><td>Day in year
         </td><td><a href="#number">Number</a>
         </td><td><code>189</code>
     </td></tr><tr>
         <td><code>d</code>
         </td><td>Day in month
         </td><td><a href="#number">Number</a>
         </td><td><code>10</code>
     </td></tr><tr>
         <td><code>F</code>
         </td><td>Day of week in month
         </td><td><a href="#number">Number</a>
         </td><td><code>2</code>
     </td></tr><tr>
         <td><code>E</code>
         </td><td>Day name in week
         </td><td><a href="#text">Text</a>
         </td><td><code>Tuesday</code>; <code>Tue</code>
     </td></tr><tr>
         <td><code>u</code>
         </td><td>Day number of week (1 = Monday, ..., 7 = Sunday)
         </td><td><a href="#number">Number</a>
         </td><td><code>1</code>
     </td></tr><tr>
         <td><code>a</code>
         </td><td>Am/pm marker
         </td><td><a href="#text">Text</a>
         </td><td><code>PM</code>
     </td></tr><tr>
         <td><code>H</code>
         </td><td>Hour in day (0-23)
         </td><td><a href="#number">Number</a>
         </td><td><code>0</code>
     </td></tr><tr>
         <td><code>k</code>
         </td><td>Hour in day (1-24)
         </td><td><a href="#number">Number</a>
         </td><td><code>24</code>
     </td></tr><tr>
         <td><code>K</code>
         </td><td>Hour in am/pm (0-11)
         </td><td><a href="#number">Number</a>
         </td><td><code>0</code>
     </td></tr><tr>
         <td><code>h</code>
         </td><td>Hour in am/pm (1-12)
         </td><td><a href="#number">Number</a>
         </td><td><code>12</code>
     </td></tr><tr>
         <td><code>m</code>
         </td><td>Minute in hour
         </td><td><a href="#number">Number</a>
         </td><td><code>30</code>
     </td></tr><tr>
         <td><code>s</code>
         </td><td>Second in minute
         </td><td><a href="#number">Number</a>
         </td><td><code>55</code>
     </td></tr><tr>
         <td><code>S</code>
         </td><td>Millisecond
         </td><td><a href="#number">Number</a>
         </td><td><code>978</code>
     </td></tr><tr>
         <td><code>z</code>
         </td><td>Time zone
         </td><td><a href="#timezone">General time zone</a>
         </td><td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code>
     </td></tr><tr>
         <td><code>Z</code>
         </td><td>Time zone
         </td><td><a href="#rfc822timezone">RFC 822 time zone</a>
         </td><td><code>-0800</code>
     </td></tr><tr>
         <td><code>X</code>
         </td><td>Time zone
         </td><td><a href="#iso8601timezone">ISO 8601 time zone</a>
         </td><td><code>-08</code>; <code>-0800</code>;  <code>-08:00</code>
 </td></tr></tbody><br>&lt;/table&gt;&gt;</p>
<p><table class="striped">
 <thead>
     <tr>
         <th style="text-align:left">Date and Time Pattern
         </th><th style="text-align:left">Result
 </th></tr></thead>
 <tbody>
     <tr>
         <td><code>"yyyy.MM.dd G 'at' HH:mm:ss z"</code>
         </td><td><code>2001.07.04 AD at 12:08:56 PDT</code>
     </td></tr><tr>
         <td><code>"EEE, MMM d, ''yy"</code>
         </td><td><code>Wed, Jul 4, '01</code>
     </td></tr><tr>
         <td><code>"h:mm a"</code>
         </td><td><code>12:08 PM</code>
     </td></tr><tr>
         <td><code>"hh 'o''clock' a, zzzz"</code>
         </td><td><code>12 o'clock PM, Pacific Daylight Time</code>
     </td></tr><tr>
         <td><code>"K:mm a, z"</code>
         </td><td><code>0:08 PM, PDT</code>
     </td></tr><tr>
         <td><code>"yyyyy.MMMMM.dd GGG hh:mm aaa"</code>
         </td><td><code>02001.July.04 AD 12:08 PM</code>
     </td></tr><tr>
         <td><code>"EEE, d MMM yyyy HH:mm:ss Z"</code>
         </td><td><code>Wed, 4 Jul 2001 12:08:56 -0700</code>
     </td></tr><tr>
         <td><code>"yyMMddHHmmssZ"</code>
         </td><td><code>010704120856-0700</code>
     </td></tr><tr>
         <td><code>"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</code>
         </td><td><code>2001-07-04T12:08:56.235-0700</code>
     </td></tr><tr>
         <td><code>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</code>
         </td><td><code>2001-07-04T12:08:56.235-07:00</code>
     </td></tr><tr>
         <td><code>"YYYY-'W'ww-u"</code>
         </td><td><code>2001-W27-3</code>
 </td></tr></tbody>
 </table></p>
<blockquote>
<p>范例: 格式化日期显示<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">		String str = sdf.format(date);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-06-23 17:15:08.686</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>​    </p>
<blockquote>
<p>范例: 接下来实现字符串转为date;<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String birthday = <span class="string">"1995-09-24 00:40:00.000"</span>;</span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">		Date date = sdf.parse(birthday); </span><br><span class="line">		System.out.println(date);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sun Sep 24 00:40:00 CST 1995</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>范例:数字格式化<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>到目前可以发现字符串可以向所有类型转换：基本类型，日期类型；</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-认识正则表达式"><a href="#1-认识正则表达式" class="headerlink" title="1. 认识正则表达式"></a>1. 认识正则表达式</h2><p>基本数用户输入的信息用String表示，为了转换的正确性需要进行一些复杂的验证处理；</p>
<p>给一个字符串判断是否由数字所组成，如果为数字所组成，就把它变为数字进行乘法计算</p>
<blockquote>
<p>范例：字符串转数字<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"123"</span>;</span><br><span class="line">		<span class="keyword">if</span> (str.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">			System.out.println(num * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">246</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>有开发包<code>java.util.regex</code>,也有String类里的直接支持</p>
<p>正则方便进行验证处理，方便机型复杂字符串的修改处理；</p>
<h2 id="2-常用正则标记"><a href="#2-常用正则标记" class="headerlink" title="2. 常用正则标记"></a>2. 常用正则标记</h2><p>在<code>java.util.regex</code>有一个pattern类，这个程序类定义所有支持的正则标记；</p>
<ol>
<li><p>【数量：单个】字符匹配</p>
<ul>
<li><p>任意字符：表示有任意字符组成</p>
<blockquote>
<p>范例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure>
<pre><code>            String regex = &quot;a&quot;;
            System.out.println(str.matches(regex));
        }
    }
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		</span><br></pre></td></tr></table></figure>
</code></pre></blockquote>
</li>
<li><p>\ \: 匹配 ” \ “</p>
</li>
<li>\n :匹配换行</li>
<li>\t : 匹配制表符</li>
</ul>
</li>
<li><p>【数量：单个】字符集（可以从其中选一个字符）</p>
<ul>
<li><p>[ abc ] : 表示其中任意一个 </p>
</li>
<li><p>[ ^abc ] : 不是a、b、c</p>
</li>
<li>[ a-zA-Z ] : 表示所有字母步在意大小写</li>
<li>[ 0-9 ] : 数字 </li>
</ul>
</li>
<li><p>【数量：单个】简化字符集</p>
<ul>
<li>”.” : 任意的一个字符</li>
<li>”\d“ : 表示一个数字等价于[ 0-9 ]</li>
<li>”\D“ : 不是一个数字等价于[ ^0-9 ]</li>
<li>“\s” : 匹配任意的一位空格，可能是空格、换行、制表符；</li>
<li>“\S” : 匹配任意的一位非（空格，可能是空格、换行、制表符）；</li>
<li>”\w“ : 匹配字母与数字下划线</li>
<li>”\W“ ： 求反</li>
</ul>
</li>
<li><p>边界匹配</p>
<ul>
<li>^ : 匹配边界开始</li>
<li>$ :匹配边界结束</li>
</ul>
</li>
<li><p>数量表达：默认情况下只有添加上了数量单位才可以匹配多位字符</p>
<ul>
<li>表达式？： 该表达式可以出现0次或1次</li>
<li>表达式* ： 该正则可以出现0次、1次或多次；</li>
<li>表达式+ ： 该正则可以出现1次或多次</li>
<li>表达式{n} ：表达式长度为n次</li>
<li>表达式{n,} ：表达式长度为n次及以上</li>
<li>表达式{n,m} ：表达式长度为n~m次</li>
</ul>
</li>
<li><p>逻辑表达式</p>
<ul>
<li>表达式X表达式Y ： X表达式后紧跟Y表达式；</li>
<li>表达式X|表达式Y ： X表达式 或 Y表达式；</li>
<li>(表达式) ： 为表达式设置一个整体描述，可以为整体描述设置数量单位；</li>
</ul>
</li>
</ol>
<h2 id="3-String类对正则的支持"><a href="#3-String类对正则的支持" class="headerlink" title="3. String类对正则的支持"></a>3. String类对正则的支持</h2><p>String类里提供有如下方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>public boolean matches(String regex)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">与指定字符串进行正则判断</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>public String replaceAll(String regex,  String replacement)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换全部</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>public String replacefirst(String regex,  String replacement)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换首个</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>public String[] split(String regex,int limit)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">正则拆分</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>public String[] split(String regex)</code></td>
<td style="text-align:center">普通</td>
<td style="text-align:center">正则拆分</td>
</tr>
</tbody>
</table>
</div>
<p>接下来范例说</p>
<blockquote>
<p>范例：实现字符串替换（删除掉非字母和数组）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"jfds91$%38&amp;4fh&amp;*931h&amp;**((NKN$%^nununouuiu*(*(non^&amp;*nfwqonf"</span>;</span><br><span class="line">		String regex = <span class="string">"\\W+"</span>;</span><br><span class="line">		System.out.println(str.replaceAll(regex, <span class="string">""</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jfds91384fh931hNKNnununouuiunonnfwqonf</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>范例：实现字符串的拆分 ：一个含有字母和数字的字符串，把字母取出来<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"a1b22c333d4444e5555f666666"</span>;</span><br><span class="line">		String regex = <span class="string">"\\d+"</span>;</span><br><span class="line">		System.out.println(str.replaceAll(regex, <span class="string">""</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>范例：判断一个数据是不是小数如果是小数则把它转换为double类型<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"100."</span>;</span><br><span class="line">		String regex = <span class="string">"\\d+(\\.\\d+)?"</span>;</span><br><span class="line">		System.out.println(str.matches(regex));</span><br><span class="line">		<span class="keyword">if</span> (str.matches(regex)) &#123;</span><br><span class="line">			System.out.println(Double.parseDouble(str));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>范例：判断一个字符串是否由日期所组成，如果是由日子所组成，则将其转成Date类型<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"2007-02-13"</span>;</span><br><span class="line">		String regex = <span class="string">"\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;"</span>;</span><br><span class="line">		System.out.println(str.matches(regex));</span><br><span class="line">		<span class="keyword">if</span> (str.matches(regex)) &#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).parseObject(str));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>范例：判定给定的电话号码是否正确</p>
<ul>
<li>电话号码：52518590</li>
<li>电话号码：01052518590</li>
<li>电话号码：(010)-52518590</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"(010)-51283346"</span>;</span><br><span class="line">		String regex = <span class="string">"((\\d&#123;3,4&#125;)|(\\(\\d&#123;3,4&#125;\\)-))?\\d&#123;7,8&#125;"</span>;</span><br><span class="line">		System.out.println(str.matches(regex));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范例：实现一个email地址格式的验证</p>
<ul>
<li>email的用户名可以由字母、数字、下划线_、中划线- 所组成（不能用下划线开头）</li>
<li>Email的域名由字母、数字、下划线_、中划线-；</li>
<li>后缀必须是：.cn   .com   .net   .com.cn   .gov</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200623185632111.png" alt="image-20200623185632111"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"juyi006@163.com"</span>;</span><br><span class="line">		String regex = <span class="string">"[a-zA-Z0-9]\\w*@\\w+\\.(cn|com|com.cn|gov)"</span>;</span><br><span class="line">		System.out.println(str.matches(regex));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-java-util-regex包支持"><a href="#3-java-util-regex包支持" class="headerlink" title="3. java.util.regex包支持"></a>3. java.util.regex包支持</h2><p>这个包有两个类：Pattern（正则表达式编译），Matcher（匹配）</p>
<ol>
<li><p>pattern类提供有正则表达式的编译处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex,<span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时也有字符串拆分支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(CharSequence input,<span class="keyword">int</span> limit)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>范例：Pattern的使用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		String str = <span class="string">"juyi006@1jif_.com"</span>;</span><br><span class="line">		String regex = <span class="string">"[^a-zA-Z]+"</span>;</span><br><span class="line">		Pattern pat = Pattern.compile(regex);</span><br><span class="line">		String[] split = pat.split(str);</span><br><span class="line">		<span class="keyword">for</span> (String temp:split) &#123;</span><br><span class="line">			System.out.println(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>Matcher类：实现了正则匹配的处理类，这个类的实例化对象依靠Pattern类完成；</p>
<p>Pattern类提供的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">matcher</span><span class="params">(CharSequence input)</span></span></span><br></pre></td></tr></table></figure>
<p>当获取了Matcher类的对象之后就可以利用该类中的方法进行如下操作：</p>
<ul>
<li><p>正则匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>范例：字符串匹配<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String str = <span class="string">"juyi006@1jif_.com"</span>;</span><br><span class="line">		String regex = <span class="string">"[^a-zA-Z]+"</span>;</span><br><span class="line">		Pattern pat = Pattern.compile(regex);</span><br><span class="line">		Matcher mat = pat.matcher(str);</span><br><span class="line">		System.out.println(mat.matches());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之前的拆分，匹配，替换都根本用不到这个开发包；但有一些正则是String不具备的：Matcher类里有一个分组的功能，这个功能时Matcher不具备的；</p>
<blockquote>
<p>范例：用于分组把<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 要求取出 #&#123;&#125;中的内容</span></span><br><span class="line">		String str = <span class="string">"INSERT INTO dept(deptno,dname,loc) VALUES (#&#123;deptno&#125;，#&#123;dname&#125;，#&#123;loc&#125;)"</span>;</span><br><span class="line">		String regex = <span class="string">"#\\&#123;\\w+\\&#125;"</span>;</span><br><span class="line">		Pattern pat = Pattern.compile(regex);</span><br><span class="line">		Matcher mat = pat.matcher(str);</span><br><span class="line">		<span class="keyword">while</span>(mat.find()) &#123;</span><br><span class="line">			System.out.println(mat.group(<span class="number">0</span>).replaceAll(<span class="string">"#|\\&#123;|\\&#125;"</span>, <span class="string">""</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个开发包不是很复杂的正则处理也很难用到；</p>
</blockquote>
<h1 id="国际化程序实现"><a href="#国际化程序实现" class="headerlink" title="国际化程序实现"></a>国际化程序实现</h1><p>同一个代码可以更具不同的国家实现不同的语言描述，但是程序处理的核心业务是相同的</p>
<h2 id="1-国际化程序实现原理"><a href="#1-国际化程序实现原理" class="headerlink" title="1.国际化程序实现原理"></a>1.国际化程序实现原理</h2><p>语言环境不同；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200624130022432.png" alt="image-20200624130022432"></p>
<p>通过分析，可以发现，想实现这个国际化程序开发，就要解决以下两点：</p>
<ul>
<li>如何可以保存文字的文件信息；</li>
<li>如何可以根据不同的区域语言的编码读取指定的资源信息；</li>
</ul>
<h2 id="2-locale类"><a href="#2-locale类" class="headerlink" title="2. locale类"></a>2. locale类</h2><p>首先需要解决的就是不同国家用户的区域和语言编码问题，而在<code>java.util.Locale</code>类中就提供类似的功能；而后可以利用Locale类中的两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Locale​(String language)</span><br><span class="line"><span class="keyword">public</span> Locale​(String language,String country)</span><br></pre></td></tr></table></figure>
<p>此时需要知道国家和语言的代码：中文代码：<code>zh_CN</code>;    美国英语：<code>en_US</code>;</p>
<p>获取这些信息的方式：网上搜吧</p>
<blockquote>
<p>范例：实例化Locale类对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>, <span class="string">"CN"</span>);	<span class="comment">//中文环境</span></span><br><span class="line">		System.out.println(locale);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">zh_CN</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>如果现在像自动获得当前的环境，就可以利用Locale类本身默认方法进行实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Locale getDefault​()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：当地的环境；<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = Locale.getDefault();</span><br><span class="line">		System.out.println(locale);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">zh_CN</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在开发中并不关心国家和语言的编码，把著名的这些设置为了常量：</p>
<blockquote>
<p>范例：读取常量<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = Locale.CHINA;</span><br><span class="line">		Locale loc = Locale.CHINESE;</span><br><span class="line">		System.out.println(locale);</span><br><span class="line">		System.out.println(loc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">zh_CN</span></span><br><span class="line"><span class="comment">zh</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="3-ResourceBundle读取资源文件"><a href="#3-ResourceBundle读取资源文件" class="headerlink" title="3. ResourceBundle读取资源文件"></a>3. ResourceBundle读取资源文件</h2><p>现在已经准备好了资源文件，那么随后就需要进行资源文件；读取资源文件依靠：<code>java.util.ResourceBundle</code>类完成；此类定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBundle</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>
<p>·ResourceBundle是一个抽象类，如果说要想进行此类的实例化可以直接·利用该类中提供的一个<code>static</code>方法来完成；</p>
<ul>
<li><p>获取ResourceBundle类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceBundle getBundle​(String baseName)</span><br></pre></td></tr></table></figure>
<ul>
<li>baseName：描述资源文件的名称，但是没有后缀</li>
</ul>
</li>
<li><p>根据key读取读取资源内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String getString​(String key)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>范例：使用ResourceBundle类读取内容</p>
<p>在<code>cn.jubingyi.message</code>下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">info</span>=<span class="string">\u5F88\u9AD8\u5174\u89C1\u5230\u4F60</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(val);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在进行数据读取时，key一定要存在，如果不存在会出现异常；</p>
<h2 id="4-实现国际化程序开发"><a href="#4-实现国际化程序开发" class="headerlink" title="4. 实现国际化程序开发"></a>4. 实现国际化程序开发</h2><ol>
<li><p>在CLASSPATH下建立：cn.jubingyi.message.Message_zh_CN.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">info</span>=<span class="string">\u5F88\u9AD8\u5174\u89C1\u5230\u4F60</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在CLASSPATH下建立：cn.jubingyi.message.Message_en_US.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">info</span>=<span class="string">Welcome !</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过程序进行指定区域的资源信息加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">欢迎你的到来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这时没有指定locale对象，但是<code>Message_zh_CN.properties</code>起作用了;</p>
<p><code>getBundle</code>这个方法默认获取当前本地Locale的资源；</p>
</li>
</ol>
<ol>
<li><p>如果有需要也可以修改当前的<code>locale</code>环境，则可以使用<code>ResourceBundle.getBundle</code>的重载：</p>
<ul>
<li>获取ResourceBundle</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceBundle getBundle​(String baseName,Locale locale)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = <span class="keyword">new</span> Locale(<span class="string">"en"</span>,<span class="string">"US"</span>);</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>,locale);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Welcome !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果资源包中没有德国但是设置了德国，则会读取本地的那一项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = Locale.GERMAN;</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>,locale);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">欢迎您的访问</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果本地都没有（把<code>zh-CN</code>文件去掉了），则显示<code>Message.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = Locale.GERMAN;</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>,locale);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TaDaYiMaSi!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>读取顺序：读取指定区域的资源文件 &gt; 默认本地资源 &gt; 公共的资源（没有区域设置的）</p>
<h2 id="5-格式化文本显示"><a href="#5-格式化文本显示" class="headerlink" title="5.  格式化文本显示"></a>5.  格式化文本显示</h2><p>某一位用户登录成功：显示“xxx，欢迎您”；这样的信息保存在资源文件里就需要用占位符来描述；对于读取出来的数据进行消息格式化</p>
<blockquote>
<p>范例：修改资源文件</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>【中文资源】<strong>cn.jubingyi.message.Message_zh_CN.properties</strong></th>
<th>info=欢迎{0}的访问，日期{1}</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>【英文资源】cn.jubingyi.message.Message_en_US.properties</strong></td>
<td><strong>info=Welcome{0}, data:{1} !</strong></td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p> 如果有需要可增加{n}之类的内容；</p>
<p> 如果要进行资源读取会将占位符的信息一起读取，所以此时就需要利用MessageFormat类进行格式化处理</p>
<p> <img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200624185030139.png" alt="image-20200624185030139"></p>
<p> 在<code>MessageFormat</code>里提供了一个格式化文本的方法：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String format​(String pattern,Object... arguments)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：格式化国际化程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Locale locale = Locale.US;</span><br><span class="line">		ResourceBundle resource = ResourceBundle.getBundle(<span class="string">"cn.jubingyi.message.Message"</span>,locale);</span><br><span class="line">		String val = resource.getString(<span class="string">"info"</span>);</span><br><span class="line">		System.out.println(MessageFormat.format(val, <span class="string">"zenner"</span>,<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date())));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Welcome zenner, data: 2020-06-24 !</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>日后见到资源文件里的<code>{0}</code>，<code>{1}</code>的结构表示，要实现相应的格式化文本</p>
<h1 id="开发支持类库"><a href="#开发支持类库" class="headerlink" title="开发支持类库"></a>开发支持类库</h1><p>UUID生成无重复字符串的程序类，根据时间戳实现一个自动的无重复的字符串定义；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(UUID.randomUUID());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-UUID类"><a href="#1-UUID类" class="headerlink" title="1. UUID类"></a>1. UUID类</h2><p>A UUID represents a 128-bit value. There exist different variants of these global identifiers. </p>
<ul>
<li><p>获取UUID对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UUID randomUUID​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据字符串获取UUID内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UUID fromString​(String name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在对一些文件进行自动命名处理的情况下，UUID非常好用；</p>
<h2 id="2-Optional类"><a href="#2-Optional类" class="headerlink" title="2. Optional类"></a>2. Optional类</h2><p>Optional类主要功能进行null的相关处理；在以前进行程序开发的时候，如果为了防止程序之中出现空指向异常往往可以追加有null的验证；</p>
<p>一般情况下都是在引用接收方被动进行判断，所以为了解决这种被动处理操作，在java中提供的Optional类；这个类提供的操作方法：</p>
<ul>
<li><p>返回空的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; empty​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T get​()</span><br></pre></td></tr></table></figure></li>
<li><p>保存数据，但是不允许出现null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; of​(T value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果保存数据的时候存在有null，则会抛出NullPointerException异常</p>
</li>
<li><p>保存数据，允许为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; ofNullable​(T value)</span><br></pre></td></tr></table></figure></li>
<li><p>空的时候，返回其他数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T orElse​(T other)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200625151325238.png" alt="image-20200625151325238"></p>
<blockquote>
<p>范例：修改程序，按照正规结构完成<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		IMessage temp = MessageUtil.getMessage().get();</span><br><span class="line">		MessageUtil.useMessage(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">MessageUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IMessage&gt; <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Optional.of(<span class="keyword">new</span> MessageImpl());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMessage</span><span class="params">(IMessage msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(msg.getContent());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"www.get.cn"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>如果说现在数据保存的内容是null，则就会在<u>保存处</u>出现异常；</p>
<blockquote>
<p>范例：修改 getMessage() 给他返回一个null<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">MessageUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IMessage&gt; <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Optional.of(<span class="keyword">null</span>);	<span class="comment">// 修改处</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMessage</span><span class="params">(IMessage msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(msg.getContent());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">	at java.base/java.util.Objects.requireNonNull(Objects.java:<span class="number">222</span>)</span><br><span class="line">	at java.base/java.util.Optional.of(Optional.java:<span class="number">111</span>)</span><br><span class="line">	at cn.jubingyi.Demo.MessageUtil.getMessage(JavaApiDemo.java:<span class="number">14</span>)	<span class="comment">// 报错了</span></span><br><span class="line">	at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>由于Optional类中允许保存有null的内容，所以在数据获取的时候也可以进行null的处理；但是如果为空，使用get获取对象时就会报错；</p>
<blockquote>
<p>范例：处理空<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		IMessage temp = MessageUtil.getMessage().get();	<span class="comment">// get时就会报错</span></span><br><span class="line">		MessageUtil.useMessage(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">MessageUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IMessage&gt; <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Optional.ofNullable(<span class="keyword">null</span>);	<span class="comment">// 修改为可以接受null的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMessage</span><span class="params">(IMessage msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(msg.getContent());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"www.get.cn"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.NoSuchElementException: No value present</span><br><span class="line">	at java.base/java.util.Optional.get(Optional.java:<span class="number">141</span>)</span><br><span class="line">	at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>再把get换掉换成<code>orelse</code>，在为null时返回null或设定值；</p>
<blockquote>
<p>范例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		IMessage temp = MessageUtil.getMessage().orElse(<span class="keyword">new</span> Message_send_Impl());</span><br><span class="line">		MessageUtil.useMessage(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span></span>&#123;</span><br><span class="line">	MessageUtil() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IMessage&gt; <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useMessage</span><span class="params">(IMessage msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(msg.getContent());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"www.get.cn"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message_send_Impl</span> <span class="keyword">implements</span> <span class="title">IMessage</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"www.send.cn"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">www.send.cn</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在所有的引用数据类型的操作处理之中null是一个重要的问题</p>
<h2 id="3-ThreadLocal类"><a href="#3-ThreadLocal类" class="headerlink" title="3. ThreadLocal类"></a>3. ThreadLocal类</h2><p>解决了核心资源与多线程并发访问的处理情况</p>
<blockquote>
<p>范例：定义一个消息发送结构：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">		msg.setInfo(<span class="string">"www.zenner.com"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">		Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">		Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;	<span class="comment">//消息发送通道</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Message msg;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Channel</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		Channel.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【消息发送】"</span>+msg.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628103908525.png" alt="image-20200628103908525"></p>
<p>当前的程序实际上采用的是一种单线程的模式处理的；那么在多线程的状态下能否实现完全一致的效果呢？</p>
<blockquote>
<p>范例：多线程影响<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 1-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者A"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 2-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 3-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者C"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;	<span class="comment">//消息发送通道</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Message msg;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Channel</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		Channel.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【"</span>+Thread.currentThread().getName()+<span class="string">"、消息发送】"</span>+msg.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【消息发送者A、消息发送】The 2-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment">【消息发送者B、消息发送】The 2-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment">【消息发送者C、消息发送】The 3-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这个时候消息的处理产生了影响，出现了数据覆盖</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628105010956.png" alt="image-20200628105010956"></p>
<p>在保持Channel（所有发送的通道）核心结构不改变的情况下，需要考虑到每个线程的独立操作问题；在这种情况下，对于Channel类而言除了要保留有发送的消息之外，还应该对存放有每一个线程的标记（当前线程），那么我们就可以通过ThreadLocal类存放数据；在ThreadLocal里提供有如下的方法：</p>
<ul>
<li><p>构造方法：创建有新的ThreadLocal类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadLocal​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set​(T value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>取出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get​()</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void remove​()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628110527647.png" alt="image-20200628110527647"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628110845248.png" alt="image-20200628110845248"></p>
<blockquote>
<p>范例：使用ThreadLocal解决核心资源与多线程的问题<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 1-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者A"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 2-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">			Message msg = <span class="keyword">new</span> Message();	<span class="comment">// 实例化消息对象</span></span><br><span class="line">			msg.setInfo(<span class="string">"The 3-th Thread's MESSAGE"</span>);	<span class="comment">// 设置要发送的内容</span></span><br><span class="line">			Channel.setMsg(msg);	<span class="comment">//	通道中设置要发送的消息</span></span><br><span class="line">			Channel.send();	<span class="comment">// 发送消息</span></span><br><span class="line">		&#125;,<span class="string">"消息发送者C"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;	<span class="comment">//消息发送通道</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Message&gt; ThreadLocalMsg = <span class="keyword">new</span> ThreadLocal&lt;Message&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Channel</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		Channel.ThreadLocalMsg.set(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"【"</span>+Thread.currentThread().getName()+<span class="string">"、消息发送】"</span>+ThreadLocalMsg.get().getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【消息发送者C、消息发送】The 3-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment">【消息发送者A、消息发送】The 1-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment">【消息发送者B、消息发送】The 2-th Thread's MESSAGE</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>每一个线程通过ThreaLocal只允许保存一个数据</p>
<h2 id="4-定时调度"><a href="#4-定时调度" class="headerlink" title="4.定时调度"></a>4.定时调度</h2><p>定时器的主要操作就是进行定时任务的处理，像闹钟一样；在java中有定时任务的支持，但是这种任务的处理只是实现了一种间隔触发的操作；如果要想实现定时的处理操作需要有一个定时操作的主体类，以及一个定时任务的控制； 可使用两个类实现:： <code>Timer</code>，<code>TimeTask</code>;</p>
<ul>
<li><p><code>java.util.TimerTask</code> 类：实现定时任务处理</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628113338547.png" alt="image-20200628113338547"></p>
</li>
<li><p><code>java.util.Timer</code> 类：进行任务的启动，启动的方法：</p>
<ul>
<li><p>任务启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> schedule​(TimerTask task,<span class="keyword">long</span> delay)	<span class="comment">// 延迟单位是毫秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>间隔触发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> scheduleAtFixedRate​(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200628231249732.png" alt="image-20200628231249732"></p>
<blockquote>
<p>范例：实现定时任务处理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"、当前时间为: "</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		timer.schedule(<span class="keyword">new</span> MyTask(), <span class="number">3000</span>);	<span class="comment">//	修改点位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sun Jun 28 23:17:23 CST 2020</span></span><br><span class="line"><span class="comment">Timer-0、当前时间为: Sun Jun 28 23:17:26 CST 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>范例：间隔启动任务<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"、当前时间为: "</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		timer.scheduleAtFixedRate(<span class="keyword">new</span> MyTask(), <span class="number">3000</span>, period);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sun Jun 28 23:17:23 CST 2020</span></span><br><span class="line"><span class="comment">Timer-0、当前时间为: Sun Jun 28 23:17:26 CST 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="5-Base64-加密与解密"><a href="#5-Base64-加密与解密" class="headerlink" title="5. Base64 加密与解密"></a>5. Base64 加密与解密</h2><p>正常来说加密永远伴随着解密；加密与解密都伴随着一定的规则；提供的加密加密操作类：<code>Base64</code>，这个类里面有两个类：</p>
<ul>
<li><p>Base64 Encoder：进行加密处理</p>
<ul>
<li><p>加密处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] encode​(<span class="keyword">byte</span>[] src)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Base64 Decoder ：进行解密处理</p>
<ul>
<li><p>解密处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] decode​(<span class="keyword">byte</span>[] src)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>范例：实现加密与解密操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String msg = <span class="string">"www.zenner.com"</span>;	<span class="comment">// 要发送的信息内容</span></span><br><span class="line">		String encMsg = <span class="keyword">new</span> String(Base64.getEncoder().encode(msg.getBytes()));</span><br><span class="line">		System.out.println(encMsg);</span><br><span class="line">		String oldMsg = <span class="keyword">new</span> String(Base64.getDecoder().decode(encMsg));</span><br><span class="line">		System.out.println(oldMsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d3d3Lnplbm5lci5jb20=</span></span><br><span class="line"><span class="comment">www.zenner.com</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>目前这个只是对一个字符串进行加密加密；是一个公版算法，用这个加密不安全，那么最好的做法是使用盐值操作·</p>
<blockquote>
<p>范例：盐值操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String salt = <span class="string">"zennerJBY"</span>;</span><br><span class="line">		String msg = <span class="string">"www.zenner.com"</span>+<span class="string">"&#123;"</span>+salt+<span class="string">"&#125;"</span>;	<span class="comment">// 要发送的信息内容</span></span><br><span class="line">		String encMsg = <span class="keyword">new</span> String(Base64.getEncoder().encode(msg.getBytes()));</span><br><span class="line">		System.out.println(encMsg);</span><br><span class="line">		String oldMsg = <span class="keyword">new</span> String(Base64.getDecoder().decode(encMsg));</span><br><span class="line">		System.out.println(oldMsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d3d3Lnplbm5lci5jb217emVubmVySkJZfQ==</span></span><br><span class="line"><span class="comment">www.zenner.com&#123;zennerJBY&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>即便有盐值但加密的效果也不是很好；可以用多次加密；</p>
<ul>
<li><p>范例：多层加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringUtil</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SALT = <span class="string">"zennerJBY"</span>;	<span class="comment">// 公共盐值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPEAT = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 加密处理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> repeat</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		String temp = str +<span class="string">"&#123;"</span>+SALT+<span class="string">"&#125;"</span>;	<span class="comment">// 盐值对外不公布</span></span><br><span class="line">		<span class="keyword">byte</span> data[] = temp.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; REPEAT;x++) &#123;</span><br><span class="line">			data = Base64.getEncoder().encode(data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解密处理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span> data [] = str.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; REPEAT; x++) &#123;</span><br><span class="line">			data = Base64.getDecoder().decode(data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(data).replaceAll(<span class="string">"\\&#123;\\w+\\&#125;"</span>, <span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String str = StringUtil.encode(<span class="string">"www.zenner.com"</span>);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		System.out.println(StringUtil.decode(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WkROa00weHVjR3hpYlRWc1kyazFhbUl5TVRkbGJWWjFZbTFXZVZOclNscG1VVDA5</span></span><br><span class="line"><span class="comment">www.zenner.com</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h1><p>所谓的比较器就是进行大小关系的确定判断，分析比较器存在的意义是什么；</p>
<h2 id="1-比较器问题的引出"><a href="#1-比较器问题的引出" class="headerlink" title="1. 比较器问题的引出"></a>1. 比较器问题的引出</h2><p>若要进行数组操作，肯定是用<code>java.util.Arrays</code> 的操作完成，这个类一定是提供有绝大部分的数组操作；这个类还提供了对象数组的排序支持；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sort​(Object[] a)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>范例：实现对象数组得排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Integer data [] = <span class="keyword">new</span> Integer [] &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">20</span>&#125;;</span><br><span class="line">		Arrays.sort(data);	<span class="comment">// 进行对象数组的排序</span></span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3, 6, 9, 10, 20]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>同样，如果数现在给定的是一个String型的对象数组，那么也是可以进行排序处理的；</p>
<blockquote>
<p>范例：String 对象数组排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String data [] = <span class="keyword">new</span> String [] &#123;<span class="string">"X"</span>,<span class="string">"B"</span>,<span class="string">"A"</span>,<span class="string">"E"</span>,<span class="string">"G"</span>&#125;;</span><br><span class="line">		Arrays.sort(data);	<span class="comment">// 进行对象数组的排序</span></span><br><span class="line">		System.out.println(Arrays.toString(data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A, B, E, G, X]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>接下来看看自定义的类如何进行比较</p>
<blockquote>
<p>范例：采用自定义类型进行排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Person per [] = <span class="keyword">new</span> Person [] &#123;</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-A"</span>,<span class="number">89</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-B"</span>,<span class="number">50</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-C"</span>,<span class="number">100</span>),</span><br><span class="line">		&#125;;</span><br><span class="line">		Arrays.sort(per);</span><br><span class="line">		System.out.println(Arrays.toString(per));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.ClassCastException: class cn.jubingyi.Demo.Person cannot be cast to class java.lang.Comparable (cn.jubingyi.Demo.Person is in unnamed module of loader 'app'; java.lang.Comparable is in module java.base of loader 'bootstrap')</span></span><br><span class="line"><span class="comment">	at java.base/java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.ComparableTimSort.sort(ComparableTimSort.java:188)</span></span><br><span class="line"><span class="comment">	at java.base/java.util.Arrays.sort(Arrays.java:1040)</span></span><br><span class="line"><span class="comment">	at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:25)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>任意一个类默认情况下是无法使用系统内部的类实现数组排序或比较需求的，是因为我们没有明确指出自定义类该如何比较（没有比较规则），所以提供有比较器的接口：Comparable接口</p>
<h2 id="2-Comparable比较器"><a href="#2-Comparable比较器" class="headerlink" title="2. Comparable比较器"></a>2. Comparable比较器</h2><p>要实现对象的比较肯定需要有比较器来制定规则，而比较的规则则需要comparable来实现；对于Comparable需要清楚其定义的结构；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	实现对象的比较处理操作</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> o	要比较的对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	当数据比传入的对象小返回负数，如果大于返回正数，等于返回0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> compareTo​(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702155322434.png" alt="image-20200702155322434"></p>
<blockquote>
<p>范例：实现自定义对象数组排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Person per [] = <span class="keyword">new</span> Person [] &#123;</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-A"</span>,<span class="number">89</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-B"</span>,<span class="number">50</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-C"</span>,<span class="number">100</span>),</span><br><span class="line">		&#125;;</span><br><span class="line">		Arrays.sort(per);</span><br><span class="line">		System.out.println(Arrays.toString(per));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[【Person】 [name=小强-B, age=50]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-A, age=89]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-C, age=100]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>排序里面只需要有一个<code>comparaTo()</code>方法进行排序规则的定义，而后整个java系统里面就可以为其实现排序处理了；</p>
<h2 id="3-Comparator比较器"><a href="#3-Comparator比较器" class="headerlink" title="3. Comparator比较器"></a>3. Comparator比较器</h2><p><code>Comparator</code>是一种挽救的比较器支持，其主要目的是解决一些没有使用<code>Comparable</code>排序的类的对象数组；</p>
<blockquote>
<p>范例：已开发完成的程序项目，并且先期设计没有考虑到所谓的比较器功能；<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>就是上一版没有加入<code>Comparable</code>的 Person 类；后来需要进行对Person类进行排序处理，但是又不能修改Person类。此时就需要一种挽救的方法来实现比较，在Arrays类里排序有另外一种实现</p>
<ul>
<li><p>基于<code>Comparator</code>的排序处理（这是一个接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> sort​(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702162340499.png" alt="image-20200702162340499"></p>
<p>在排序类里引入一个要排序类的辅助类用来实现比较器；</p>
<p>在<code>java.util.Comparator</code>里最初只定义有一个排序的<code>compare</code>方法（<code>int compare(T o1,T o2)</code>）后来添加了很多static方法</p>
<blockquote>
<p>范例：定义排序规则类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在测试类进行测序处理时就可以利用排序规则实现操作。</p>
<blockquote>
<p>范例：排序<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Person per [] = <span class="keyword">new</span> Person [] &#123;</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-A"</span>,<span class="number">89</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-B"</span>,<span class="number">50</span>),</span><br><span class="line">				<span class="keyword">new</span> Person(<span class="string">"小强-C"</span>,<span class="number">100</span>),</span><br><span class="line">		&#125;;</span><br><span class="line">		Arrays.sort(per,<span class="keyword">new</span> PersonComparator());	<span class="comment">// 使用了自定义的比较类</span></span><br><span class="line">		System.out.println(Arrays.toString(per));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[【Person】 [name=小强-B, age=50]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-A, age=89]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-C, age=100]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p><strong>面试题</strong>：请解释 Comparable 和 Comparator的区别？</p>
<ul>
<li><code>java.lang.Comparable</code> 是在类定义的时候实现的父接口，主要用于定于排序规则，里面只有一个<code>compareTo()</code> 方法</li>
<li><code>java.util.Comparator</code> 是挽救的比较器操作，需要设置单独的比较器规则类实现排序，里面有<code>compare</code>方法</li>
</ul>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="1-二叉树结构简介"><a href="#1-二叉树结构简介" class="headerlink" title="1. 二叉树结构简介"></a>1. 二叉树结构简介</h2><p>数据的存储形式，在二叉树的实现之中其基本的实现原理如下：取第一个数据为保存的根节点，小于等于根节点的数据放在节点的左子树，大于的数组放在右子树；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702165622679.png" alt="image-20200702165622679"></p>
<p>要进行信息检索，就需要进行每个节点的判断。他的时间复杂度是O(logn)</p>
<p>再有三种遍历方式：前序遍历，中序遍历，后序遍历</p>
<h2 id="2-二叉树基础实现"><a href="#2-二叉树基础实现" class="headerlink" title="2. 二叉树基础实现"></a>2. 二叉树基础实现</h2><p>实现二叉树的处理中最为关键的问题在于数据的保存，而数据由于牵扯到对象比较的问题，这就需要到了比较器的支持，而且比较器首选Comparable，所以本次将保存Person类</p>
<blockquote>
<p>范例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		BinaryTree&lt;Person&gt; bt = <span class="keyword">new</span> BinaryTree&lt;Person&gt;();</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-80"</span>,<span class="number">80</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-30"</span>,<span class="number">30</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-50"</span>,<span class="number">50</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-60"</span>,<span class="number">60</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-90"</span>,<span class="number">90</span>));</span><br><span class="line">		System.out.println(Arrays.toString(bt.toArray()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Comparable &lt;T&gt; data;</span><br><span class="line">		<span class="keyword">private</span> Node parent;</span><br><span class="line">		<span class="keyword">private</span> Node left;</span><br><span class="line">		<span class="keyword">private</span> Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 实现节点数据的适当位置的存储</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> newNode	创建的新节点</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (newNode.data.compareTo((T)<span class="keyword">this</span>.data) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.left = newNode;</span><br><span class="line">					<span class="keyword">this</span>.parent = <span class="keyword">this</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">this</span>.left.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.right = newNode;</span><br><span class="line">					newNode.parent = <span class="keyword">this</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">this</span>.right.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 实现所有数据的获取处理，按照中序遍历的形式来完成</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArrayNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.left.toArrayNode();</span><br><span class="line">			&#125;</span><br><span class="line">			BinaryTree.<span class="keyword">this</span>.returnData[BinaryTree.<span class="keyword">this</span>.foot++] = <span class="keyword">this</span>.data;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.right.toArrayNode();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ------------------- 以下为二叉树的功能实现 ---------</span></span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; </span><br><span class="line">	<span class="keyword">private</span> Object [] returnData;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> foot = <span class="number">0</span>;	<span class="comment">// 角标控制</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"保存的数据不允许为空"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 所有的数据本身不具有节点关系的匹配，一定要将其包装在Node类中；</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root = newNode;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;	<span class="comment">//保存到合适的位置</span></span><br><span class="line">			<span class="keyword">this</span>.root.addNode(newNode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.count ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**	</span></span><br><span class="line"><span class="comment">	 * 以对象数组的形式返回全部数据，如果没有数据返回null</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.returnData = <span class="keyword">new</span> Object [<span class="keyword">this</span>.count];</span><br><span class="line">		<span class="keyword">this</span>.foot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.root.toArrayNode();	<span class="comment">// 直接由Node类来负责</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.returnData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[【Person】 [name=小强-30, age=30]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-50, age=50]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-60, age=60]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-80, age=80]</span></span><br><span class="line"><span class="comment">, 【Person】 [name=小强-90, age=90]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在进行数据添加的时候只是实现了节点关系的保存，而这种关系保存后的结果就是所有的数据都是有序排列；</p>
<h2 id="3-数据删除"><a href="#3-数据删除" class="headerlink" title="3. 数据删除"></a>3. 数据删除</h2><p>二叉树的节点删除非常复杂，要考虑的情况是非常多的。</p>
<ul>
<li><p>情况一：如果待删除的节点没有子节点，那么直接删除；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702175100493.png" alt="image-20200702175100493"></p>
</li>
</ul>
<ul>
<li><p>情况二：如果待删除节点只有一个子节点，那么直接删除，并用其子节点去顶替它</p>
<ul>
<li><p>只有左子树</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702175311288.png" alt="image-20200702175311288"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>只有右子树</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702175415864.png" alt="image-20200702175415864"></p>
</li>
</ul>
<ul>
<li><p>情况三：如果待删除的节点有两个子节点，首选找出它的后继节点，然后处理“后继节点” 和“被删节点的父节点”的关系</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200702175751215.png" alt="image-20200702175751215"></p>
</li>
</ul>
<blockquote>
<p>范例：在Node类中追加由新的处理功能<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取要删除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 比较的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>	要删除的节点对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> BinaryTree&lt;T&gt;.<span class="function">Node <span class="title">getRemoveNode</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.getRemoveNode(data);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.getRemoveNode(data);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>范例：在BinaryTree 里面进行节点的处理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行数据删除处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data	要删除的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root.data.compareTo((T)data)==<span class="number">0</span>) &#123;	<span class="comment">// 要删除的是根节点</span></span><br><span class="line">            Node moveNode = root.right;</span><br><span class="line">            <span class="keyword">while</span> (moveNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                moveNode = moveNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (moveNode.parent.left.data.compareTo((T)moveNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">                moveNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                moveNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            moveNode.parent = root.parent;</span><br><span class="line">            System.out.println(moveNode.toString());</span><br><span class="line">            moveNode.right = root.right;</span><br><span class="line">            moveNode.left = root.left;</span><br><span class="line">            <span class="keyword">this</span>.root = moveNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node removeNode = <span class="keyword">this</span>.root.getRemoveNode(data);</span><br><span class="line">            <span class="keyword">if</span> (removeNode != <span class="keyword">null</span>) &#123;	<span class="comment">// 找到要删除的对象信息</span></span><br><span class="line">                System.out.println(removeNode.toString());</span><br><span class="line">                <span class="comment">// 情况一：没有任何的子节点</span></span><br><span class="line">                <span class="keyword">if</span> (removeNode.left == <span class="keyword">null</span> &amp;&amp; removeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    removeNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">                    removeNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">                    removeNode.parent = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (removeNode.left != <span class="keyword">null</span> &amp;&amp; removeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">                        removeNode.parent.left = removeNode.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        removeNode.parent.right = removeNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeNode.left.parent = removeNode.parent;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (removeNode.left == <span class="keyword">null</span> &amp;&amp; removeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">                        removeNode.parent.left = removeNode.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        removeNode.parent.right = removeNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeNode.right.parent = removeNode.parent;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Node moveNode = removeNode.right;</span><br><span class="line">                    <span class="keyword">while</span> (moveNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        moveNode = moveNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (moveNode.parent.left.data.compareTo((T)moveNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">                        moveNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        moveNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveNode.parent = removeNode.parent;</span><br><span class="line">                    System.out.println(moveNode.toString());</span><br><span class="line">                    <span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">                        removeNode.parent.left = moveNode;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        removeNode.parent.right = moveNode;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveNode.right = removeNode.right;</span><br><span class="line">                    moveNode.left = removeNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>范例：全代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		BinaryTree&lt;Person&gt; bt = <span class="keyword">new</span> BinaryTree&lt;Person&gt;();</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-80"</span>,<span class="number">80</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-50"</span>,<span class="number">50</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-60"</span>,<span class="number">60</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-30"</span>,<span class="number">30</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-90"</span>,<span class="number">90</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-10"</span>,<span class="number">10</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-55"</span>,<span class="number">55</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-70"</span>,<span class="number">70</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-85"</span>,<span class="number">85</span>));</span><br><span class="line">		bt.add(<span class="keyword">new</span> Person(<span class="string">"小强-95"</span>,<span class="number">95</span>));</span><br><span class="line">		bt.remove(<span class="keyword">new</span> Person(<span class="string">"小强-61"</span>,<span class="number">61</span>));</span><br><span class="line">		System.out.println(Arrays.toString(bt.toArray()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Comparable &lt;T&gt; data;</span><br><span class="line">		<span class="keyword">private</span> Node parent;</span><br><span class="line">		<span class="keyword">private</span> Node left;</span><br><span class="line">		<span class="keyword">private</span> Node right;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Node [data="</span> + data + <span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 实现节点数据的适当位置的存储</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> newNode	创建的新节点</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (newNode.data.compareTo((T)<span class="keyword">this</span>.data) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.left = newNode;</span><br><span class="line">					newNode.parent = <span class="keyword">this</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">this</span>.left.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.right = newNode;</span><br><span class="line">					newNode.parent = <span class="keyword">this</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">this</span>.right.addNode(newNode);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 实现所有数据的获取处理，按照中序遍历的形式来完成</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArrayNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.left.toArrayNode();</span><br><span class="line">			&#125;</span><br><span class="line">			BinaryTree.<span class="keyword">this</span>.returnData[BinaryTree.<span class="keyword">this</span>.foot++] = <span class="keyword">this</span>.data;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.right.toArrayNode();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 判断节点是否存在给定的数据</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> data	给定的数据</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span>	存在返回true，不存在返回false</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNode</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">this</span>.left.containsNode(data);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">this</span>.right.containsNode(data);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取要删除的节点</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> data 比较的对象</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span>	要删除的节点对象</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> BinaryTree&lt;T&gt;.<span class="function">Node <span class="title">getRemoveNode</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (data.compareTo((T)<span class="keyword">this</span>.data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">this</span>.left.getRemoveNode(data);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">this</span>.right.getRemoveNode(data);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ------------------- 以下为二叉树的功能实现 ---------</span></span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count; </span><br><span class="line">	<span class="keyword">private</span> Object [] returnData;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> foot = <span class="number">0</span>;	<span class="comment">// 角标控制</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Contains</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.root.containsNode(data);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"保存的数据不允许为空"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 所有的数据本身不具有节点关系的匹配，一定要将其包装在Node类中；</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root = newNode;</span><br><span class="line">			newNode.parent = <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;	<span class="comment">//保存到合适的位置</span></span><br><span class="line">			<span class="keyword">this</span>.root.addNode(newNode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.count ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**	</span></span><br><span class="line"><span class="comment">	 * 以对象数组的形式返回全部数据，如果没有数据返回null</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.returnData = <span class="keyword">new</span> Object [<span class="keyword">this</span>.count];</span><br><span class="line">		<span class="keyword">this</span>.foot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.root.toArrayNode();	<span class="comment">// 直接由Node类来负责</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.returnData;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行数据删除处理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data	要删除的数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Comparable&lt;T&gt; data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.root.data.compareTo((T)data)==<span class="number">0</span>) &#123;	<span class="comment">// 要删除的是根节点</span></span><br><span class="line">				Node moveNode = root.right;</span><br><span class="line">				<span class="keyword">while</span> (moveNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">					moveNode = moveNode.left;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (moveNode.parent.left.data.compareTo((T)moveNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">					moveNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					moveNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				moveNode.parent = root.parent;</span><br><span class="line">				System.out.println(moveNode.toString());</span><br><span class="line">				moveNode.right = root.right;</span><br><span class="line">				moveNode.left = root.left;</span><br><span class="line">				<span class="keyword">this</span>.root = moveNode;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				Node removeNode = <span class="keyword">this</span>.root.getRemoveNode(data);</span><br><span class="line">				<span class="keyword">if</span> (removeNode != <span class="keyword">null</span>) &#123;	<span class="comment">// 找到要删除的对象信息</span></span><br><span class="line">					System.out.println(removeNode.toString());</span><br><span class="line">					<span class="comment">// 情况一：没有任何的子节点</span></span><br><span class="line">					<span class="keyword">if</span> (removeNode.left == <span class="keyword">null</span> &amp;&amp; removeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">						removeNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">						removeNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">						removeNode.parent = <span class="keyword">null</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span> (removeNode.left != <span class="keyword">null</span> &amp;&amp; removeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">							removeNode.parent.left = removeNode.left;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							removeNode.parent.right = removeNode.left;</span><br><span class="line">						&#125;</span><br><span class="line">						removeNode.left.parent = removeNode.parent;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span> (removeNode.left == <span class="keyword">null</span> &amp;&amp; removeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">							removeNode.parent.left = removeNode.right;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							removeNode.parent.right = removeNode.right;</span><br><span class="line">						&#125;</span><br><span class="line">						removeNode.right.parent = removeNode.parent;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						Node moveNode = removeNode.right;</span><br><span class="line">						<span class="keyword">while</span> (moveNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">							moveNode = moveNode.left;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (moveNode.parent.left.data.compareTo((T)moveNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">							moveNode.parent.left = <span class="keyword">null</span>;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							moveNode.parent.right = <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						moveNode.parent = removeNode.parent;</span><br><span class="line">						System.out.println(moveNode.toString());</span><br><span class="line">						<span class="keyword">if</span> (removeNode.parent.left.data.compareTo((T)removeNode.data)==<span class="number">0</span>) &#123;</span><br><span class="line">							removeNode.parent.left = moveNode;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							removeNode.parent.right = moveNode;</span><br><span class="line">						&#125;</span><br><span class="line">						moveNode.right = removeNode.right;</span><br><span class="line">						moveNode.left = removeNode.left;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">this</span>.count --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"【Person】 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="4-红黑树原理简介"><a href="#4-红黑树原理简介" class="headerlink" title="4. 红黑树原理简介"></a>4. 红黑树原理简介</h2><p>二叉树的主要特点：数据查询的时候可以提供更好的查询性能，这种原始的二叉树结构是有明显缺陷的。当改变二叉树结构的时候可能会产生树的不平衡</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703091438511.png" alt="image-20200703091438511"></p>
<p>成为了一个链表结构；要想达到最良好效果的二叉树，那么他应该是一个平衡二叉树，同时所有的节点层次深度应该不超过1；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703091729898.png" alt="image-20200703091729898"></p>
<p>这个时候二叉树的检索操作效率一定是最高的，并且树可以忍受着这些频繁的增加或者删除操作；所以针对二叉树有着进一步的设计要求：</p>
<p>​    红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则是红黑树保证了一种平衡，插入，删除，查找的最坏时间复杂度都为O(logn);</p>
<p>​    红黑树本质上在节点上追加了一个表示颜色的操作信息而已；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color&#123;</span><br><span class="line">	RED,BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> T data;</span><br><span class="line">		<span class="keyword">private</span> Node parent;</span><br><span class="line">		<span class="keyword">private</span> Node left;</span><br><span class="line">		<span class="keyword">private</span> Node right;</span><br><span class="line">		<span class="keyword">private</span> Color colo;	<span class="comment">// 多增加的一个属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>红黑树的不一定要用枚举，用true或者false来实现也可以；不一定非要用枚举类；</p>
<p>一个标准的红黑树的结构如下所示</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703092903184.png" alt="image-20200703092903184"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703092957642.png" alt="image-20200703092957642"></p>
<p>主要是利用这个红色节点和黑色节点实现均衡的控制；简单理解红黑树的结构就是为了实现左旋，右旋操作，已保证树的平衡；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703093842704.png" alt="image-20200703093842704"></p>
<p>但是对于平衡，还需要考虑数据增加的平衡以及数据删除的平衡，增加和删除都是需要对这颗树进行平衡修复的；</p>
<h3 id="数据插入的平衡修复"><a href="#数据插入的平衡修复" class="headerlink" title="数据插入的平衡修复"></a>数据插入的平衡修复</h3><p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703100930114.png" alt="image-20200703100930114"></p>
<p>在进行红黑树处理的时候为了方便操作都会将新的节点使用红色来描述。于是当设置根节点的时候就会违反规则2：根节点为黑色；那么这时候只需要将节点的颜色涂黑即可；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703101420358.png" alt="image-20200703101420358"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703101536770.png" alt="image-20200703101536770"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703101944620.png" alt="image-20200703101944620"></p>
<p>在红黑树进行修复处理中，他需要根据 当前节点 以及 当前节点的父节点 和 叔叔节点 的颜色来推断树是否需要修复处理；</p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703102522310.png" alt="image-20200703102522310"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703102542488.png" alt="image-20200703102542488"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703102609251.png" alt="image-20200703102609251"></p>
<h3 id="数据删除的平衡修复"><a href="#数据删除的平衡修复" class="headerlink" title="数据删除的平衡修复"></a>数据删除的平衡修复</h3><p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703103056376.png" alt="image-20200703103056376"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703103245195.png" alt="image-20200703103245195"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703103510803.png" alt="image-20200703103510803"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703103715408.png" alt="image-20200703103715408"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703103826585.png" alt="image-20200703103826585"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703104218170.png" alt="image-20200703104218170"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703104122403.png" alt="image-20200703104122403"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703104415382.png" alt="image-20200703104415382"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703104503801.png" alt="image-20200703104503801"></p>
<p><img src="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/image-20200703104604553.png" alt="image-20200703104604553"></p>
<p>在红黑树之中修复的目的是为了保证树结构中的黑色节点的数量平衡，黑色节点的数量平衡了，那么才可能得到“O(logn)”的执行性能，但是修复的过程一方面是红黑的处理，另一方面就是子节点保存的层次。</p>
<h1 id="类库使用案例分析"><a href="#类库使用案例分析" class="headerlink" title="类库使用案例分析"></a>类库使用案例分析</h1><h2 id="1-StringBuffer使用"><a href="#1-StringBuffer使用" class="headerlink" title="1.StringBuffer使用"></a>1.StringBuffer使用</h2><p>​        定义一个StringBuffer类对象，然后通过<code>append()</code>方法向对象中添加26个小写字母，要求每次只添加一次，共添加26次，然后按照逆序的方式输出，并且可以删除前5个字符；</p>
<p>​        本操作只要是训练StringBuffer类中的处理方法，因为StringBuffer的主要特点是内容允许修改</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="string">'a'</span>;x &lt;= <span class="string">'z'</span>;x++) &#123;</span><br><span class="line">			buf.append((<span class="keyword">char</span>)x);</span><br><span class="line">		&#125;</span><br><span class="line">		buf.reverse().delete(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(buf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">utsrqponmlkjihgfedcba</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-随机数组"><a href="#2-随机数组" class="headerlink" title="2. 随机数组"></a>2. 随机数组</h2><p>利用Random类产生5个1~30之间（包括1和30）的随机数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberFactory</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过随机数来生成一个数组的内容，该内容不包括有0</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> len：要开辟的数组大小</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>	返回的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> [] creat(<span class="keyword">int</span> len) &#123;</span><br><span class="line">		<span class="keyword">int</span> data [] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">int</span> foot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (foot &lt; data.length) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = random.nextInt(<span class="number">31</span>);</span><br><span class="line">			<span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">				data[foot++] = num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result [] = NumberFactory.creat(<span class="number">30</span>);</span><br><span class="line">		System.out.println(Arrays.toString(result));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Email验证"><a href="#3-Email验证" class="headerlink" title="3. Email验证"></a>3. Email验证</h2><p>输入一个Email地址，然后使用正则表达式验证该Email地址是否正确</p>
<p>在这里设置一个单独的验证处理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"程序执行错误，没有输入初始化参数，正确格式为： java JavaApiDemo Email地址"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		String email = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (Validator.isEmail(email)) &#123;</span><br><span class="line">			System.out.println(email+<span class="string">" 是一个email地址"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(email+<span class="string">" 不符合格式！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Validator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (email == <span class="keyword">null</span> || <span class="string">""</span>.equals(email))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String regex = <span class="string">"\\w+@\\w+\\.\\w+"</span>;</span><br><span class="line">		<span class="keyword">return</span> email.matches(regex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-扔硬币"><a href="#4-扔硬币" class="headerlink" title="4. 扔硬币"></a>4. 扔硬币</h2><p>用0~1之间的随机数来模拟扔硬币试验，统计扔1000次后出现正、反面的次数并输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coin</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front ;	<span class="comment">// 保存正面的次数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> back;	<span class="comment">// 保存北面的次数</span></span><br><span class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *	 扔硬币的处理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> num	执行次数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwCol</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; num; x++) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = random.nextInt(<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.front ++;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.back ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> back;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Coin coin = <span class="keyword">new</span> Coin();</span><br><span class="line">		coin.throwCol(<span class="number">1000000</span>);</span><br><span class="line">		System.out.println(<span class="string">"正面次数： "</span>+coin.getFront() + <span class="string">"、背面出现次数： "</span>+coin.getBack());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-IP验证"><a href="#5-IP验证" class="headerlink" title="5. IP验证"></a>5. IP验证</h2><p>编写正则表达式，判断给定的是否是一个合法IP地址：第一位内容是无，1，或者2，后面的内容可以0-5，第三位0-9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateIP</span><span class="params">(String IP)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (IP == <span class="keyword">null</span>||<span class="string">""</span>.equals(IP)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String regex = <span class="string">"([12]?[0-9]?[0-9].)&#123;3&#125;[12]?[0-9]?[0-9]"</span>;</span><br><span class="line">		<span class="keyword">if</span> (IP.matches(regex)) &#123;</span><br><span class="line">			String result [] = IP.split(<span class="string">"\\."</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt; result.length; x++) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = Integer.parseInt(result[x]);</span><br><span class="line">				<span class="keyword">if</span> (temp &gt; <span class="number">255</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String str = <span class="string">"252.168.122.2"</span>;</span><br><span class="line">		System.out.println(Validator.validateIP(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-HTML拆分"><a href="#6-HTML拆分" class="headerlink" title="6. HTML拆分"></a>6. HTML拆分</h2><p>给定下面的HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"Arial,Serif"</span> <span class="attr">size</span>=<span class="string">"+2"</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要求对内容进行拆分，拆分之后的结果是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">face Arial,Serif</span><br><span class="line">size +2</span><br><span class="line">color red</span><br></pre></td></tr></table></figure>
<p>对于此时最简单的方法就是进行分组处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String str = <span class="string">"&lt;font face=\"Arial,Serif\" size=\"+2\" color=\"red\"&gt;"</span>;</span><br><span class="line">		String regex = <span class="string">"\\w+=\"[a-zA-Z0-9,\\+]+\""</span>;</span><br><span class="line">		Matcher matcher = Pattern.compile(regex).matcher(str);</span><br><span class="line">		<span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">			String temp = matcher.group(<span class="number">0</span>);</span><br><span class="line">			String[] result = temp.split(<span class="string">"="</span>);</span><br><span class="line">			System.out.println(result[<span class="number">0</span>] + <span class="string">"\t"</span> + result[<span class="number">1</span>].replaceAll(<span class="string">"\""</span>,<span class="string">""</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">face	Arial,Serif</span></span><br><span class="line"><span class="comment">size	+2</span></span><br><span class="line"><span class="comment">color	red</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="7-国家代码"><a href="#7-国家代码" class="headerlink" title="7. 国家代码"></a>7. 国家代码</h2><p>编写代码，实现国际化应用，从命令行输入国家的代码，例如：1代表中国，2代表美国，然后根据输入代码的不同调用不同的资源文件显示信息；</p>
<p>​    这个程序肯定要通过Locale类的对象来指定区域，然后利用ResourceBundle类来加载资源文件，而对于数据的输入可以继续使用初始化的参数形式来完成；</p>
<blockquote>
<ol>
<li>定义中文资源文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">info=感谢老铁刷的火箭！</span><br></pre></td></tr></table></figure>
<ol>
<li>定义英文资源文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">info=Thanks <span class="keyword">for</span> Mr.Tie<span class="string">'s Rocket!</span></span><br></pre></td></tr></table></figure>
<ol>
<li>定义程序类进行加载控制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHINA = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USA = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY = <span class="string">"info"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASENAME = <span class="string">"cn.jubingyi.message.Message"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		Locale loc = <span class="keyword">this</span>.getLocale(num);</span><br><span class="line">		<span class="keyword">if</span> (loc == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Nothing"</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ResourceBundle.getBundle(BASENAME, loc).getString(KEY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Locale <span class="title">getLocale</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (num) &#123;</span><br><span class="line">		<span class="keyword">case</span> CHINA:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Locale(<span class="string">"zh"</span>, <span class="string">"CN"</span>);</span><br><span class="line">		<span class="keyword">case</span> USA:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Locale(<span class="string">"en"</span>, <span class="string">"US"</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"程序执行错误，没有设置地区编码"</span>);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> choose = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> MessageUtil().getMessage(choose));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1	感谢老铁刷的火箭！</span></span><br><span class="line"><span class="comment">2	Thanks for Mr.Tie's Rocket!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="8-学生信息比较"><a href="#8-学生信息比较" class="headerlink" title="8. 学生信息比较"></a>8. 学生信息比较</h2><p>按照“姓名：年龄：成绩|姓名：年龄：成绩”的格式定义字符串“张三：22：89|王五：20：70”，要求将每组值分别保存在student对象之中，并对这些对象进行排序，排序的原则为：按照成绩由高到低排列，如果成绩相同则按年龄由低向高排序。</p>
<p>是一个直接的做法按照比较器来完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaApiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String input = <span class="string">"张三:21:89|李四:22:89|王五:20:70"</span>;</span><br><span class="line">		String result [] = input.split(<span class="string">"\\|"</span>);</span><br><span class="line">		Student students [] = <span class="keyword">new</span> Student [result.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; result.length; x ++) &#123;</span><br><span class="line">			String [] temp = result[x].split(<span class="string">":"</span>);</span><br><span class="line">			students[x] = <span class="keyword">new</span> Student(temp[<span class="number">0</span>],Integer.parseInt(temp[<span class="number">1</span>]),Double.parseDouble(temp[<span class="number">2</span>])); </span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(students);</span><br><span class="line">		System.out.println(Arrays.toString(students));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", score="</span> + score + <span class="string">"]\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.score &lt; o.score) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.score &lt; o.score) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Student [name=张三, age=21, score=89.0]</span></span><br><span class="line"><span class="comment">, Student [name=李四, age=22, score=89.0]</span></span><br><span class="line"><span class="comment">, Student [name=王五, age=20, score=70.0]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
