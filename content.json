{"meta":{"title":"zenner's Blog","subtitle":"巨饼的技术博","description":"Deep ploughing those days ​​​​","author":null,"url":"http://zenner006.github.io","root":"/"},"pages":[{"title":"about","date":"2020-07-14T12:02:01.000Z","updated":"2020-07-14T13:00:56.610Z","comments":true,"path":"about/index.html","permalink":"http://zenner006.github.io/about/index.html","excerpt":"","text":"吼吼吼！我有站了！"},{"title":"categories","date":"2020-07-14T11:58:33.000Z","updated":"2020-07-14T12:13:11.504Z","comments":true,"path":"categories/index.html","permalink":"http://zenner006.github.io/categories/index.html","excerpt":"","text":""},{"title":"leetcode","date":"2020-07-11T12:17:40.000Z","updated":"2020-07-11T12:17:40.198Z","comments":true,"path":"leetcode/index.html","permalink":"http://zenner006.github.io/leetcode/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-07-14T12:38:22.000Z","updated":"2020-07-14T12:39:48.026Z","comments":true,"path":"schedule/index.html","permalink":"http://zenner006.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-14T12:15:51.000Z","updated":"2020-07-14T12:16:49.029Z","comments":true,"path":"tags/index.html","permalink":"http://zenner006.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一些maven操作","slug":"一些maven操作-md","date":"2021-07-01T03:50:47.000Z","updated":"2021-07-01T04:07:41.481Z","comments":true,"path":"2021/07/01/一些maven操作-md/","link":"","permalink":"http://zenner006.github.io/2021/07/01/%E4%B8%80%E4%BA%9Bmaven%E6%93%8D%E4%BD%9C-md/","excerpt":"一些关于maven的小技巧 如果发现包不在了可以更新一下maven的源 如果控制台输出中文乱码了，可以在idea的setting-maven-running-VM options里写下参数-Dfile. encoding=gb2312：发现原本的日志输出乱码了。。。所以把字符集改成GBK后，OK了。 IDEA的Maven Projects无法显示idea自带了maven控件，不像Eclipse还需要下载控件，如果你以前有maven在右边，出于某种原因，消失找不到 了，可以试试以下方法. 方法1.你点击一下你idea界面最左下角的那个小框，maven应该从里面找到 方法2.点击菜单栏View-&gt;Tool Windows-&gt;Maven projects 方法3.点击菜单栏Help-&gt;Find Action(Ctrl+Shift+A),输入Maven projects 方法4.在Settings—&gt;Plugins搜索Maven Integration，打勾（原本没打勾的就勾上保存，有打勾就去掉勾保存后再勾上）重启IDEA即可.","text":"一些关于maven的小技巧 如果发现包不在了可以更新一下maven的源 如果控制台输出中文乱码了，可以在idea的setting-maven-running-VM options里写下参数-Dfile. encoding=gb2312：发现原本的日志输出乱码了。。。所以把字符集改成GBK后，OK了。 IDEA的Maven Projects无法显示idea自带了maven控件，不像Eclipse还需要下载控件，如果你以前有maven在右边，出于某种原因，消失找不到 了，可以试试以下方法. 方法1.你点击一下你idea界面最左下角的那个小框，maven应该从里面找到 方法2.点击菜单栏View-&gt;Tool Windows-&gt;Maven projects 方法3.点击菜单栏Help-&gt;Find Action(Ctrl+Shift+A),输入Maven projects 方法4.在Settings—&gt;Plugins搜索Maven Integration，打勾（原本没打勾的就勾上保存，有打勾就去掉勾保存后再勾上）重启IDEA即可. 前三个方法都试了还是不行，发现maven控件直接没有了，用上方法4，问题解决 Ideal 导入Maven项目选择打开Maven项目 然后先点开 File -&gt; Other Settings -&gt; Structure for New Projects… 设置全局 JDK 之后点击 Project 应用刚才添加的 JDK 设置 Maven 点击 Other Settings -&gt; Settings for new Projects…由于我的项目里配置了Tomcat所以直接在IDEA的Maven Projects里找tomcat7里的tomcat7:run;","categories":[{"name":"tips","slug":"tips","permalink":"http://zenner006.github.io/categories/tips/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://zenner006.github.io/tags/IDEA/"},{"name":"maven","slug":"maven","permalink":"http://zenner006.github.io/tags/maven/"},{"name":"tips","slug":"tips","permalink":"http://zenner006.github.io/tags/tips/"}]},{"title":"Maven基础","slug":"Maven-basic-md","date":"2021-03-13T14:02:22.000Z","updated":"2021-06-28T07:57:05.539Z","comments":true,"path":"2021/03/13/Maven-basic-md/","link":"","permalink":"http://zenner006.github.io/2021/03/13/Maven-basic-md/","excerpt":"第一章 Maven介绍1.1 什么是MavenMaven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 1.2 Maven两个经典作用1.2.1 Maven 的依赖管理要将项目运行起来，就得要把项目所依赖得jar包添加到工程，项目工程大小就很大，得几兆。 如果使用Maven则会发现总体上工程的大小会少很多。 因为Maven把所用到得jar包管理到了一个仓库中。它让任何想要用jar包的工程都去从仓库中引用。那么每个工程就不用自己携带jar包了。在每个项目中放置jar包在jar包仓库中的坐标即可。 这个就叫做Maven的依赖管理。 Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。","text":"第一章 Maven介绍1.1 什么是MavenMaven 是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 1.2 Maven两个经典作用1.2.1 Maven 的依赖管理要将项目运行起来，就得要把项目所依赖得jar包添加到工程，项目工程大小就很大，得几兆。 如果使用Maven则会发现总体上工程的大小会少很多。 因为Maven把所用到得jar包管理到了一个仓库中。它让任何想要用jar包的工程都去从仓库中引用。那么每个工程就不用自己携带jar包了。在每个项目中放置jar包在jar包仓库中的坐标即可。 这个就叫做Maven的依赖管理。 Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar 包的坐标。 问题一：通过读取 pom.xml 文件中的坐标，再到仓库中找到 jar 包，会不会很慢？从而导致这种方式 不可行！ ​ 通过 pom.xml 文件配置要引入的 jar 包的坐标，再读取坐标并到仓库中加载 jar 包，这样我们就可以直接使用 jar 包了，为了解决这个过程中速度慢的问题，maven 中也有索引的概念，通 过建立索引，可以大大提高加载 jar 包的速度，使得我们认为 jar 包基本跟放在本地的工程文件中再 读取出来的速度是一样的。 1.2.2 项目的一键构建项目往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 构建指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理的过程。 一键构建指的是整个构建过程，使用 maven一个命令（mvn tomcat:run）可以轻松完成整个工作。 第二章 Maven的使用2.1 Maven的安装2.1.1 下载与安装下载后解压即可，放在一个没有中文没有空格的路径下。 2.1.2 配置系统变量配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录） 然后在系统变量中加入 %MAVEN_HOME%/bin 2.1.3 Maven 版本测试mvn -v 检查maven是否安装成功。 2.2 Maven仓库2.2.1 Maven 仓库的分类“远程仓库”，“本地仓库”，“中央仓库”的关系 本地仓库：用来存储从远程仓库或中央仓库下载的插件和 jar 包， 默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示 windows 用户目录。 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。 中央仓库：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件。 2.2.2 Maven 本地仓库的配置在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置（maven 的安装目录下) 打开 settings.xml文件，配置其中localRepository标签： 1&lt;localRepository&gt;D:\\software\\Programing_software\\maven_repository&lt;/localRepository&gt; 2.2.3 全局 setting 与用户 settingmaven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。 在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project 项目，它作为 maven 的全局配置。 如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user.dir} /.m2/settings.xml 目录中,${user.dir} 指 windows 中的用户目录。 maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven 工程的认识2.3.1 Maven 工程的目录结构这个目录结构不是上面那个Maven软件的目录结构。而是用Maven管理的工程的目录结构 一个项目管理起来所需要的几个组成部分都有四种： （1）核心代码部分 （2）配置文件部分 （3）测试代码部分 （4）测试配置部分 传统项目目录结构： src目录下存放着四种代码。打包的时候可能会发生交叉混乱。 Maven建立了一个项目的标准目录结构 第3章 Maven 常用命令3.1 Maven 常用命令在Maven工程下，打开命令提示符，可以输入Maven 常用命令对Maven工程进行操作。 3.1.1 mvn clean可以把target文件夹删除掉。也就是删除之前编译的信息。 3.1.2 mvn compile仅把src/main目录下的代码进行编译。 3.1.3 mvn test对src/test下的代码进行测试。而且还把src/main目录下的代码也进行编译 3.1.4 mvn package对整个项目进行打包。还生成了war文件。 查看pom.xml文件就会发现，配置文件中配置了打包成war包。 3.1.5 mvn install相当于mvn package后，再把war包安装到了本地仓库。 3.2 Maven 指令的生命周期Maven工程的过程 清理生命周期（Clean Lifecycle） 在进行真正的构建之前进行一些清理工作。 默认生命周期（Default Lifecycle） 构建的核心部分，编译，测试，打包，部署等等。 站点生命周期（Site Lifecycle） 生成项目报告，站点，发布站点。 3.3 Maven概念模型Maven 包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段 (phase)中插件(plugin)目标(goal)的逻辑。 3.4 idea开发maven项目3.4.1 在idea中配置maven要在idea中使用maven就要配置它。 setttings里搜maven。然后填写maven主目录，设置文件路径，还有本地仓库路径。 running里面配置：-DarchetypeCatalog=internal 使得它首先从本地仓库中找包。 再对maven下的setting进行配置阿里云的镜像： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 3.4.2 使用maven骨架创建java工程新建maven项目就好。选择quickstart骨架。然后结束后，它不会把整个的目录创建好，需要手动补齐。 添加 resources文件。 3.4.3 使用maven无骨架创建java工程新建maven项目就好。然后结束后，他有着默认的maven目录结构。 3.4.4 使用maven骨架创建web工程用到了webapp骨架。创建好以后，只有src/main/webapp目录。其他的需要自主创建。 3.5 创建一个servlet3.5.1 指定某目录为web资源包可以在webapp下加入网页资源文件。要想在其他文件夹下加入网页资源文件可以把该文件设为该工程的”project structure”，“module”，然后“web”。 3.5.2 导入项目依赖的jar包给pom.xml加入依赖jar包。可以直接在中央仓库中找xml的写法。 这里写了一个servlet。需要两个jar包。servlet 和 jsp 然后用 mvn tomcat:run 来运行。 发现报错 3.5.3 解决jar包冲突因为tomcat是maven带的。它里面也带了servlet 和 jsp。运行时把代码拿进去发现这两个对象不一样。所以会出现冲突。 为解决这个问题需要给pom.xml里的依赖包加入一个范围。这个范围决定了该jar包仅在写的时候不让他报错就好。 1&lt;scope&gt;provided&lt;/scope&gt; 这样下来就可以使得代码用tomcat里的包了。 3.5.4 maven工程运行环境修改还可以用tomcat7，还设置了端口 12345678&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; 一般这种可以设置动态模板的方式来定义。 setting ——Live templates——加号选择创建动态模板的组。然后在该组里创建模板。写入模板代码，然后定义模板使用范围XML。就可以在XML中写入tomcat7，自动导入tomcat7插件模板。 3.5.5 maven的java工程从mysql中取数据 先在mySQL里建立一个数据库，建立表Items，有id，name两个列 创建一个java工程 创建一个Items类，有两个私有变量。","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java web","slug":"java/java-web","permalink":"http://zenner006.github.io/categories/java/java-web/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://zenner006.github.io/tags/maven/"}]},{"title":"左神算法-基础课-05","slug":"zuoshen-basic-class-5","date":"2020-12-11T09:52:44.000Z","updated":"2020-12-11T10:08:24.214Z","comments":true,"path":"2020/12/11/zuoshen-basic-class-5/","link":"","permalink":"http://zenner006.github.io/2020/12/11/zuoshen-basic-class-5/","excerpt":"题目一 认识哈希函数和哈希表哈希函数一、性质 哈希函数的输入域是无限大的； 哈希函数的输出域是有穷尽的； 输入如果一样，输出一定一样； 哈希碰撞：输入不一样，也可能得到输出一样的值；（因为输入域无穷大，输出域有限大，所以必然会产生冲突；) 哈希函数的离散性：也就是输出域每个值被输出的概率都差不多一样大； 二、特征 输出的值和输入没有关系；保证它结果是均匀出现的； 三、找到一千个独立的哈希函数 独立的意思在于一个哈希函数不会随着一个的变化而变化；","text":"题目一 认识哈希函数和哈希表哈希函数一、性质 哈希函数的输入域是无限大的； 哈希函数的输出域是有穷尽的； 输入如果一样，输出一定一样； 哈希碰撞：输入不一样，也可能得到输出一样的值；（因为输入域无穷大，输出域有限大，所以必然会产生冲突；) 哈希函数的离散性：也就是输出域每个值被输出的概率都差不多一样大； 二、特征 输出的值和输入没有关系；保证它结果是均匀出现的； 三、找到一千个独立的哈希函数 独立的意思在于一个哈希函数不会随着一个的变化而变化； 具体做法： 一个哈希函数可以生成16位的十六进制的输出集；他们每个位的码都是相互不关联的； 那么可以把它前八位作为一个哈希函数$h_1$，后八位做一个哈希函数$h_2$ 紧接着，$h_3 = h_1+1*h_2$ ；这里第三个哈希函数与他们两个是没有关系的； 以此类推： $h_i=h_1+(i-2)*h_2$ 做出很多很多的哈希函数，并且它们相互之间是相互独立的； 四、 粗略介绍哈希函数的内部构造 比如说一个字符串，不管多长，要把它得到一个16位的哈希函数； 就分割16位16位的异或，再错位异或之类的； 实现方法有很多； 哈希表哈希表可以： put(key1, value1)，get(key1)，remote(key1) 一、哈希表的存放 比方有一个数组大小是 N，进来一个(key, value) ; 通过计算 key的哈希值，膜上数组的大小 N ; 可以在数组中找到一个存放这个(key, value) 的位置；以节点的形式把它存放在数组中； 再有值进来冲突了某个位置，就在节点后形成链表的形式； 二、哈希表的扩容 某一个位置的链很长了，那么就把它扩容；扩容讲究也很宽泛。可以成倍扩容；那么存放N个元素可能就要扩容 $log_2N$次 离线扩容：指的是在用的哈希表已经很元素很多了，那么想办法先让访问都在目前的哈希表上访问；然后再后台再扩容的空间里把元素放进来。等做好后就把访问引到这个上面来；它扩容过程不占用线上访问时间； 哈希函数的一个使用场景【面试题】：给你一个大文件，100T，寸的都是数字；把其中所有数字得到一个新文件，保证每个数不重复； 给1000个机器；为了充分使用这1000个机器，可以用哈希函数来给1000个机器来分流。每从大文件中读书来一个数，就算出它的哈希函数。然后再膜上1000，决定它该由哪个机器处理。这样做有个好处就是相同的数会被分配到同一个机器上去；这样重复的值就可以被找到； 大数据的题目：就用哈希函数，相同输入导致相同输出。不同输入均匀分布； 题目二 设计RandomPool结构题目设计一种结构，在该结构中有如下三个功能： insert(key)：将某个key加入到该结构，做到不重复加入。 delete(key)：将原本在结构中的某个key移除。 getRandom()： 等概率随机返回结构中的任何一个key。 【要求】Insert、delete和getRandom方法的时间复杂度都是 O(1) 思想前两个方法是可以考虑用一个哈希表来自然实现的；但是第三个单纯用一个哈希表是得不到的； 所以这里除了原本的哈希表还需要另外的结构来辅助完成这个功能； 在不考虑delete的情况，仅仅往哈希表里的加入元素： 我们要知道加入了几个了 第一个哈希表加入第一个元素(key,value)，另一个哈希表加入（value，key），value表示第几次插入到这个哈希表中； 我们在第一个哈希表中可以根据key找到它是第几个插入的；在第二个可以通过第几个插入的找到key值； str0 —— 0 0 —— str0 str1 —— 1 1 —— str1 str2 —— 2 2 —— str2 strN —— N N —— strN 以此类推，加入N个后，可以在 0 ~ N-1之间随机选择一个数在第二个哈希表找到key，再在第二个哈希表中找到相对应的值；这种情况下，可以根据加入元素多少实现等概率返回。 删除情况： 比方要删除 0 ~ N-1 中的某一个数。可以在第一个哈希表中找到它是第几个加入的。相对应的加入的元素数目也减少了；但是在随机的时候就可能随机到 i。另外由于总数变为 N-1了，随机范围是 0 ~ N-2了，所以之前最后一个加入的次序为 N-1 的元素就随机不到了。所以可以用最后一个加入的这个元素补被删除的那个位置。 另外这里的进入哈希表的次序只不过是一个辅助信息。它在接口中，不对外呈现；所以更改它没有多大影响； 实现123456789101112131415161718192021222324252627282930313233343536373839404142public static class Pool&lt;K&gt; &#123; private HashMap&lt;K, Integer&gt; KeyIndexMap; private HashMap&lt;Integer, K&gt; IndexKeyMap; private int size; public Pool() &#123; this.IndexKeyMap = new HashMap&lt;Integer, K&gt;(); this.KeyIndexMap = new HashMap&lt;K, Integer&gt;(); this.size = 0; &#125; public void insert(K key) &#123; if (!this.KeyIndexMap.containsKey(key)) &#123; this.KeyIndexMap.put(key, size); this.IndexKeyMap.put(size ++ , key); &#125; else &#123; System.out.println(\"Already exits!\"); &#125; &#125; public void delete(K key) &#123; if (this.KeyIndexMap.containsKey(key)) &#123; int deleteIndex = this.KeyIndexMap.get(key); int lastIndex = --this.size; K lastKey = this.IndexKeyMap.get(lastIndex); this.KeyIndexMap.put(lastKey, deleteIndex); this.IndexKeyMap.put(deleteIndex, lastKey); this.KeyIndexMap.remove(key); this.IndexKeyMap.remove(lastIndex); &#125; else &#123; System.out.println(\"SomeThing Wrong!\"); &#125; &#125; public K getRandom() &#123; if (this.size == 0) &#123; return null; &#125; int randomIndex = (int) (Math.random() * this.size); // 0 ~ size - 1 return this.IndexKeyMap.get(randomIndex); &#125;&#125; 在序列中出现了洞，用最后一个去填是常规操作 题目三 认识布隆过滤器场景假设有一个需求：100亿个url黑名单；每个url是64字节；使用场景是，给一个 url 如果这个 url 属于黑名单，那就返回 true， 否则返回 false； 这种场景用哈希表的话就需要把所有的东西加入到内存当中来；这样子所需的内存资源就很多很多。所以就可以用布隆过滤器； 布隆过滤器有一个缺点：它有一定的失误率（宁可错杀3000不可放过一个；在黑名单的不会弄错，他会返回 True；但是不在黑名单的有一定的概率会搞错。） 布隆过滤器需要先准备一个长比特数组，它的长度为 $m$ ；使用这个长比特数组的目的就在于我们准备用其中某几个 bit 的位置来组合说明某个url是否存在； 长比特数组的实现 123456789101112public static void main(String[] args) &#123; // 一个整数的位数是 32个bit，那么申请的整数数组是 32000 bits int[] arr = new int[1000]; int index = 30000; // 把第 30000 个位置描黑 int intIndex = index / 32; // 它在整数数组里的位置 int bitIndex = index % 32; // 在所在的整数里的哪一个 bit 位； arr[intIndex] = (arr[intIndex] | (1 &lt;&lt; bitIndex)); // 把arr[intIndex] 这个整数的 第bitIndex位描黑&#125; 针对每个 url 我们把它经过 $k$ 个独立的哈希函数，算出 $k$ 个哈希值，再膜上比特数组的长度 $m$ 得到比特数组的 $k$ 个位置 ；分别在数组上把这 $k$ 个位置给描黑（写上1）； 查询：来了一个 url ，用它经过我们之前的 $k$ 个哈希函数，同样的方法求出来 $k$ 个位置；看比特数组中这 $k$ 个位置是否被描黑了；如果都被描黑了，则我们可以认为这个 url 在黑名单里（有可能有失误，碰巧那几个都被涂黑了。）。如果有一个不是黑的，则它绝对不在黑名单了； 所以选择哈希函数的 $k$ 的大小，和比特数组长度 $m$ 来控制失误率； $m$ 越大，失误率降低；$m$ 越小，失误率升高；下面是 $m$ 的所需公式 ：$n$ 表示样本量；$p$ 是预期失误率； m = -\\frac{n*\\ln p}{(\\ln 2)^2} 确定哈希函数个数 $k$ 的个数：这个数是小数需要向上取整 k=\\ln 2 * \\frac{m}{n} 当哈希函数个数 $k$ 和样本数 $m$ 确定时（都向上取整了），预期失误率是：$$ p=(1-e^{-\\frac{n*k}{m}})^k $$ 题目四 认识一致性哈希场景经典服务器抗压结构：后端集群有 $N$ 台机器；前端获取请求后根据请求的 $key$ 来得到一个哈希值。 然后在得到这个哈希值除以 $N$ 的余数；根据这个余数把这个请求分配到相对应位置的机器上。这样会使得几台机器得到的请求压力差不多相同。（负载均衡） 但是当需要在这个结构中加机器或者减机器的时候这个结构就需要大范围的改动。因为每一个key的哈希值会根据新的机器数和之前得到的位置是不同的。（数据归属变化了） 这种情况下就可以使用一致性哈希。它可以把数据迁移代价变得很低，又负载均衡； 过程 实际服务器集群的结构： 此时需要加入新的机器 缺陷 在机器数量比较小的时候，他们在哈希值组成的环中的分布不是均分的；使得某个机器可能负载过多； 即使人为的让他分布均匀，但是再加入新机器时；还是会破环原来的均衡； 这里我们可以用虚拟节点技术来解决这个问题； 虚拟节点每个物理机器不再使用自己的ip信息来分配哈希域的区间 题目五 岛问题题目一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？ 举例： 0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 这个矩阵中有三个岛。 思想单任务的想法： 遇到岛就深度遍历把遍历过的都给标记起来。之后遇到标记过的，直接跳过，直到遇到未标记的岛，就给岛的数量加一； 12345678910111213141516171819202122232425262728public static int countIslands(int[][] m) &#123; if (m == null || m[0] == null) &#123; return 0; &#125; int N = m.length; int M = m[0].length; int res = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (m[i][j] == 1) &#123; res ++; infect(m, i, j, N, M); &#125; &#125; &#125; return res;&#125;public static void infect(int[][] m, int i, int j, int N, int M) &#123; if (i &lt; 0 || i &gt;= N || j &lt; 0 || j &gt;= M || m[i][j] != 1) &#123; return ; &#125; m[i][j] = 2; infect(m, i + 1, j, N, M); infect(m, i - 1, j, N, M); infect(m, i, j + 1, N, M); infect(m, i, j - 1, N, M);&#125; 多任务的思想（并行计算）： 把矩阵分块处理分别数出其中各自有多少岛屿 然后对矩阵块的边缘进行考虑 普遍情况下要对矩阵间的边缘也就是 灰色部分进行考察；两个矩阵边缘相连，在不同情况下是不同的，在下图中两个边缘区域相连，他们总岛屿数 - 1； 考虑矩阵块边界相连时，把各个矩阵块里找到的岛屿当作并查集； 搜索边界，如果分属于两个矩阵块里的岛屿（并查集）在边界是相连的但是没有被合并过，那么总岛屿数减一，把他们相连； 题目六 并查集概念好理解，但是比较难的是在什么场合去应用他。 可应用的地方 检查两个元素是否属于一个集合： isSameSet(A, B) ： 两个元素各自所在的集合合并在一起： set union(element A, element B) 并查集的结构并查集的初始化 初始化时需要把所有的元素都给出；并每个元素都可以被看成是独立的集合；它有一个自旋指向； 并查集代表一个集合的节点会把指针指向自己；可以通过指针指向自己的节点识别出集合的头。 并查集合并 两个集合合并时任意的让其中一个集合的代表节点解除自旋指向，指向另一个并查集中的节点： 一般会让节点数更小的，指向节点多一些的并查集。 检查元素是否在一个集合：就是找到两个节点一直找到他们所在集合的代表节点，看他们是否是一个节点； 并查集的优化查询后再优化，仅优化查询路径上的节点 查询 $4$ 节点会路过三个节点，直到找到 $1$ 节点 然后再把这个结构进行优化成这个样子： 至于那些指向 $4$ 或者 $3$ 和 $2$ 的都保持原地不动。仅仅把查询 $4$ 到代表节点的路径扁平化，让它们指向 $1$ 节点； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static class Node &#123; // whatever you like&#125;public static class UnionFindSet &#123; public HashMap&lt;Node, Node&gt; fatherMap; public HashMap&lt;Node, Integer&gt; sizeMap; public UnionFindSet() &#123; fatherMap = new HashMap&lt;Node, Node&gt;(); sizeMap = new HashMap&lt;Node, Integer&gt;(); &#125; public void makeSets(List&lt;Node&gt; nodes) &#123; fatherMap.clear(); sizeMap.clear(); for (Node node: nodes) &#123; fatherMap.put(node, node); sizeMap.put(node, 1); &#125; &#125; private Node findHead(Node node) &#123; Node father = fatherMap.get(node); if (father != node) &#123; father = findHead(father); &#125; fatherMap.put(node, father); return father; &#125; public boolean isSameSet(Node a, Node b) &#123; return findHead(a) == findHead(b); &#125; public void union(Node a, Node b) &#123; if (a == null || b == null) &#123; return; &#125; Node aHead = findHead(a); Node bHead = findHead(b); if (aHead != bHead) &#123; int aSetSize = sizeMap.get(aHead); int bSetSIze = sizeMap.get(bHead); if (aSetSize &lt;= bSetSIze) &#123; fatherMap.put(aHead, bHead); sizeMap.put(bHead, aSetSize + bSetSIze); &#125; else &#123; fatherMap.put(bHead, aHead); sizeMap.put(aHead, aSetSize + bSetSIze); &#125; &#125; &#125; 时间复杂度所有的操作包括：查询过程 + 合并过程 ——&gt; $O(N)$ 及以上，那么平均每次操作都是常数级别，可以说是：$O(1)$ 应用：岛问题","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"哈希","slug":"algorithm/左神算法/初级/哈希","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E5%93%88%E5%B8%8C/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"哈希函数","slug":"哈希函数","permalink":"http://zenner006.github.io/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"},{"name":"哈希表","slug":"哈希表","permalink":"http://zenner006.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://zenner006.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"一致性哈希","slug":"一致性哈希","permalink":"http://zenner006.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"},{"name":"并查集","slug":"并查集","permalink":"http://zenner006.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"左神算法-基础课-04","slug":"zuoshen-basic-class-4","date":"2020-12-03T08:16:55.000Z","updated":"2020-12-11T09:57:39.828Z","comments":true,"path":"2020/12/03/zuoshen-basic-class-4/","link":"","permalink":"http://zenner006.github.io/2020/12/03/zuoshen-basic-class-4/","excerpt":"题目一 实现二叉树的先序、中序、后序遍历包括递归方式和非递归方式 递归方式遍历 非递归遍历先序遍历 自行准备一个栈，判断头节点非空时，将头节点压入栈中 以下部分循环：直到栈为空； 弹出节点，输出 判断是否有右孩子，有的话压入栈中 判断是否有左孩子，有的话压入栈中 打印换行，结束","text":"题目一 实现二叉树的先序、中序、后序遍历包括递归方式和非递归方式 递归方式遍历 非递归遍历先序遍历 自行准备一个栈，判断头节点非空时，将头节点压入栈中 以下部分循环：直到栈为空； 弹出节点，输出 判断是否有右孩子，有的话压入栈中 判断是否有左孩子，有的话压入栈中 打印换行，结束 中序遍历 准备一个栈， 循环：当栈为空且当前指针为空时停止 当前节点不为空： 当前节点压入栈中，当前节点找到左孩子； 当前节点为空 从栈中弹出给当前节点，打印；然后当前节点找到右孩子； 后序遍历先序遍历是: 中右左； 后序遍历是：中左右的逆序；可以用到先序遍历的技巧+栈序打印； 也就是再先序遍历打印的位置把它保存起来；逆序打印；所以用到栈结构保存，再弹出打印就很方便； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public static class Node &#123; public int value; public Node left; public Node right; public Node(int data) &#123; this.value = data; &#125;&#125;public static void preOrderRecur(Node head) &#123; if (head == null) &#123; return ; &#125; System.out.print(head.value + \" \"); preOrderRecur(head.left); preOrderRecur(head.right);&#125;public static void inOrderRecur(Node head) &#123; if (head == null) &#123; return ; &#125; inOrderRecur(head.left); System.out.print(head.value + \" \"); inOrderRecur(head.right);&#125;public static void posOrderRecur(Node head) &#123; if (head == null) &#123; return ; &#125; posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + \" \");&#125;public static void preOrderUnRecur(Node head) &#123; System.out.print(\"pre-order: \"); if (head == null) &#123; return ; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(head); Node tmp = null; while (!stack.isEmpty()) &#123; tmp = stack.pop(); System.out.print(tmp.value + \" \"); if (tmp.right != null) &#123; stack.push(tmp.right); &#125; if (tmp.left != null) &#123; stack.push(tmp.left); &#125; &#125; System.out.println();&#125;public static void inOrderUnRecur(Node head) &#123; System.out.print(\"in-order: \"); if (head == null) &#123; return ; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head != null) &#123; if (head != null) &#123; stack.push(head); head = head.left; &#125; else &#123; head = stack.pop(); System.out.print(head.value + \" \"); head = head.right; &#125; &#125; System.out.println();&#125;public static void posOrderUnRecur1(Node head) &#123; System.out.print(\"pos-order: \"); if (head == null) &#123; return ; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(head); Stack&lt;Node&gt; stack_p = new Stack&lt;Node&gt;(); Node tmp; while (!stack.isEmpty()) &#123; tmp = stack.pop(); stack_p.push(tmp); if (tmp.left != null) &#123; stack.push(tmp.left); &#125; if (tmp.right != null) &#123; stack.push(tmp.right); &#125; &#125; while (!stack_p.isEmpty()) &#123; System.out.print(stack_p.pop().value + \" \"); &#125; System.out.println();&#125;public static void posOrderUnRecur2(Node head) &#123; System.out.print(\"pos-order: \"); if (head != null) &#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); stack.push(head); Node c = null; while (!stack.isEmpty()) &#123; c = stack.peek(); /* 1. 左节点为空或者它的孩子节点刚被输出过 反过来想，这个节点的左孩子不为空，并且左孩子没有被刚输出（没有右孩子），右孩子也没有被刚输出（左孩子可能被输出过了） 这种情况下就需要把左孩子压栈 */ if (c.left != null &amp;&amp; head != c.left &amp;&amp; head != c.right) &#123; stack.push(c.left); &#125; /* 2. 右节点为空或者它的右节点刚被输出过； 右孩子不为空，并且栈顶结点的右孩子没有被输出过，满足这个条件即可压入栈 因为左孩子被上一个判断了，它可能为空，也可能被输出过了。 在这一步判断要不要把右孩子加入到栈中不重要； */ else if (c.right != null &amp;&amp; head != c.right) &#123; stack.push(c.right); &#125; /* 3. 当前栈顶节点的左右孩子要么为空要么被输出了，那么就把它输出了； */ else &#123; // 当前栈顶节点，在以上两个条件同时不满足的情况下输出： System.out.print(stack.pop().value + \" \"); head = c; &#125; &#125; &#125; System.out.println();&#125; 题目二 如何直观的打印一颗二叉树左神说：从上到下的树很难画出来； 1234567891011121314151617181920212223242526272829// for test -- print treepublic static void printTree(Node head) &#123; System.out.println(\"Binary Tree:\"); printInOrder(head, 0, \"H\", 17); System.out.println();&#125;public static void printInOrder(Node head, int height, String to, int len) &#123; if (head == null) &#123; return; &#125; printInOrder(head.right, height + 1, \"v\", len); String val = to + head.value + to; int lenM = val.length(); int lenL = (len - lenM) / 2; int lenR = len - lenM - lenL; val = getSpace(lenL) + val + getSpace(lenR); System.out.println(getSpace(height * len) + val); printInOrder(head.left, height + 1, \"^\", len);&#125;public static String getSpace(int num) &#123; String space = \" \"; StringBuffer buf = new StringBuffer(\"\"); for (int i = 0; i &lt; num; i++) &#123; buf.append(space); &#125; return buf.toString();&#125; 题目三 在二叉树中找到一个节点的后继节点题目现在有一种新的二叉树节点类型如下： 123456789public class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125;&#125; 该结构比普通二叉树节点结构多了一个指向父节点的parent指针。 假设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向 自己的父节点，头节点的parent指向null。 只给一个在 二叉树中的某个节点 node，请实现返回node的后继节点的函数。 在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。 思考针对一个给定节点，要求出它的后继结点； 首先第一步就是判断它是什么节点：它是其父节点的左孩子，他是其父节点的右孩子，它是根节点； 它是父节点的左孩子 如果它的右子树存在：则返回右子树中序遍历的第一个节点； 如果不存在右子树：则返回其父节点 它是父节点的右孩子 它是父节点的右孩子，那么它的左孩子都已经被中序遍历过了。即只能再看其右孩子； 如果它没有右孩子，那就需要考虑其父节点在树中的位置 它是根节点 找到其右子树中序遍历的第一个节点； 题解当前节点有右子树，那么返回其右子树上最左的节点 节点右子树不存在：那么当前节点即可被认为是某一节点的左子树中序遍历的最后一个节点；找到这个节点即可； 找到节点的父节点判断节点是其父节点的左孩子或者右孩子： 左孩子：停止，返回这个父节点 右孩子：继续往上找； 空或者自循环：到树的根节点了，则不存在下一个； 123456789101112131415161718192021222324252627282930313233343536public static class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125;&#125;public static Node getSuccessorNode(Node node) &#123; if (node == null) &#123; return node; &#125; if (node.right != null) &#123; return getLeftMost(node.right); &#125; else &#123; Node parent = node.parent; while (parent != null &amp;&amp; parent.left != node) &#123; node = parent; parent = node.parent; &#125; return parent; &#125;&#125;public static Node getLeftMost(Node node) &#123; if (node == null) &#123; return node; &#125; while (node.left != null) &#123; node = node.left; &#125; return node;&#125; 题目四 介绍二叉树的序列化和反序列化序列化​ 先序遍历：节点和节点之间用一个符号（比如 _）分隔。并且遇到空时用另一个符号（比如 #）来表示。 反序列化 **按照先序遍历序列化的就按照先序遍历反序列化** ​ 依次取出头节点，再取就是头节点的左节点或者空左孩子；依次完成树的重建； 序列化实现先序遍历 通过递归的方式： 如果当前节点为空则直接返回 “ #! ” ; 如果不为空，字符串加入头节点的值和分割符 “ ! ” ； 再把字符串后加上当前节点左节点的返回和右节点的返回； 整个函数返回字符串； 123456789public static String serialByPre(Node head) &#123; if (head == null) &#123; return \"#!\"; &#125; String res = head.value + \"!\"; res += serialByPre(head.left); res += serialByPre(head.right); return res;&#125; 层序遍历 如果当前节点为空则直接返回 “ #! ” ; 申请一个队列来保存队列的顺序； 给字符串 res 加上根节点的值以及分割符； 再把根节点加入到队列当中； 持续循环——&gt;直到队列为空： 从队列中取出一个节点； 判断这个节点的左节点是否为空 ？ 字符串加上这个节点的左节点的值以及分割符，队列加入 这个节点的左节点 : 给字符串加上空节点的符号表示 同样的流程判断右节点是否为空； 返回字符串 123456789101112131415161718192021222324public static String serialByLevel(Node head) &#123; if (head == null) &#123; return \"#!\"; &#125; String res = head.value + \"!\"; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(head); while (!queue.isEmpty()) &#123; head = queue.poll(); if (head.left != null) &#123; res += head.left.value + \"!\"; queue.offer(head.left) ; &#125; else &#123; res += \"#!\"; &#125; if (head.right != null) &#123; res += head.right.value + \"!\"; queue.offer(head.right); &#125; else &#123; res += \"#!\"; &#125; &#125; return res;&#125; 反序列化实现前序遍历反序列化 把序列化字符串用分割符分割开成为一个字符串数组； 申请一个保存字符串的队列； 按照前序遍历的方式序列化的，就按照前序遍历的方式反序列化 调用一个从队列反序列化的函数： 从队列中取出第一个节点的字符串。判断它是否是空节点的表示，是的话，返回null； 如果不是，创建节点对象，保存这个值；然后再递归调用自身得到接下来的左子树的表示和右子树的表示； 最终返回头节点； 12345678910111213141516171819public static Node reconByPreString(String preStr) &#123; String[] values = preStr.split(\"!\"); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); for (int i = 0; i != values.length ; i++) &#123; queue.offer(values[i]); &#125; return reconPreOrder(queue);&#125;public static Node reconPreOrder(Queue&lt;String&gt; queue) &#123; String value = queue.poll(); if (value.equals(\"#\")) &#123; return null; &#125; Node head = new Node(Integer.valueOf(value)); head.left = reconPreOrder(queue); head.right = reconPreOrder(queue); return head;&#125; 层次遍历反序列化 把序列化字符串用分割符分割开成为一个字符串数组； 把字符川数组的第一个字符串转成根节点； 申请一个保存节点的队列； 如果头节点不为空，则把根节点加入进去； while 循环 ——&gt; 如果队列不为空 从队列中取出一个节点 把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的左节点； 如果左节点不为空则把左节点加入队列 把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的右节点； 如果右节点不为空则把左节点加入队列 返回根节点 1234567891011121314151617181920212223242526272829public static Node reconByLevelString(String levelStr) &#123; String[] values = levelStr.split(\"!\"); int index = 0; Node head = generateNodeByString(values[index++]); Queue&lt;Node&gt; quene = new LinkedList&lt;Node&gt;(); if (head != null) &#123; quene.offer(head); &#125; Node node = null; while (!quene.isEmpty()) &#123; node = quene.poll(); node.left = generateNodeByString(values[index ++]); node.right = generateNodeByString(values[index ++]); if (node.left != null) &#123; quene.offer(node.left); &#125; if (node.right != null) &#123; quene.offer(node.right); &#125; &#125; return head;&#125;public static Node generateNodeByString(String val) &#123; if (val.equals(\"#\")) &#123; return null; &#125; return new Node(Integer.valueOf(val));&#125; 题目五 折纸问题题目【题目】 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次， 请从上到下打印所有折痕的方向。 例如：N=1时，打印： down N=2时，打印： down down up 思路把纸折一次，它的中间是凹的；它的上部分再折也是凹的；它的下部分再折是凸的；以此类推，就可以得到这个问题的答案； 123456789101112public static void printAllFolds(int N) &#123; printProcess(1, N, true);&#125;public static void printProcess(int i, int N, boolean down) &#123; if (i &gt; N) &#123; return ; &#125; printProcess(i + 1, N, true); System.out.println(down ? \"down \" : \"up \"); printProcess(i + 1, N, false);&#125; 题目六 判断一棵树是否是平衡二叉树（AVL）平衡二叉树 ：一颗树的任意节点左子树与右子树的高度差不超过1； 树算法：递归很好用；因为针对一个节点的递归会返回一个节点三次：他自己，左子树回来，右子树回来； 思考判断一个节点 x 是否平衡： 左树是否平衡； 右数是否平衡； 左树的高度是什么？ 右数的高度是什么？ 左树与右数高度差是否平衡； 就是需要求左子树与右子树的高度，还要时刻判断当下的树是否平衡： 方法传入了两个值，一个是level表示判断节点的层级，res用了数组。使其能改变自身使值返回。 123456789101112131415161718192021222324public static boolean isBalance(Node head) &#123; boolean[] res = new boolean[1]; res[0] = true; getHeight(head, 1, res); return res[0];&#125;public static int getHeight(Node head, int level, boolean[] res) &#123; if (head == null) &#123; return level; &#125; int lH = getHeight(head.left, level + 1, res); if (!res[0]) &#123; return level; &#125; int rH = getHeight(head.right, level + 1, res); if (!res[0]) &#123; return level; &#125; if (Math.abs(lH - rH) &gt; 1) &#123; res[0] = false; &#125; return Math.max(lH, rH);&#125; 接下来是一个套路化的过程，具体的思想就是把需要求得到信息封装成一个类，然后把这个类打包在每个节点间传递： 123456789101112131415161718192021222324252627282930public static class ReturnData&#123; public boolean isB; public int h; public ReturnData(boolean isB, int h) &#123; this.isB = isB; this.h = h; &#125;&#125;public static boolean isB(Node head) &#123; return process(head).isB;&#125;public static ReturnData process(Node head) &#123; if (head == null) &#123; return new ReturnData(true, 0); &#125; ReturnData leftData = process(head.left); if (!leftData.isB) &#123; return new ReturnData(false,0); &#125; ReturnData rightData = process(head.right); if (!rightData.isB) &#123; return new ReturnData(false,0); &#125; if (Math.abs(leftData.h-rightData.h) &gt; 1) &#123; return new ReturnData(false, 0); &#125; return new ReturnData(true, Math.max(leftData.h, rightData.h));&#125; 题目七 判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树搜索二叉树搜索二叉树：这棵树上任何一个节点为头的子树，这个节点的左子树都比这个节点的数小，右子树都比他大；（中序遍历是依次升序的，充分必要条件） 所以看一个树是否是搜索二叉树，可以直接判断它的中序遍历是否是依次升序的； 所以对于非递归版的中序遍历打印那句，就判断要打印的当前节点是否大于本应该打印的上一个节点，不大于就是不是搜索二叉树，大于就直接更新，找下一个中序节点； 12345678910111213141516171819202122public static boolean isBST(Node head) &#123; if (head &#x3D;&#x3D; null) &#123; return true; &#125; Node node &#x3D; null; Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head !&#x3D; null) &#123; if (head !&#x3D; null) &#123; stack.push(head); head &#x3D; head.left; &#125; else &#123; head &#x3D; stack.pop(); if (node!&#x3D; null &amp;&amp; node.value &gt; head.value) &#123; System.out.println(node.value+&quot; &quot;+ head.value);; return false; &#125; node &#x3D; head; head &#x3D; head.right; &#125; &#125; return true;&#125; 完全二叉树完全二叉树：算法过程需要按层遍历； 如果一个节点有右孩子，没有左孩子；一定不是完全二叉树； 如果一个节点只有一个左孩子，或者没有孩子，那么它后面遇到的节点都必须是叶节点；否则不是完全二叉树； （由于情况一违反的话直接就没了，所以判断是否是情况二的情况，右边叶子一定是空；） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 我写的public static boolean isCBT(Node head) &#123; if (head == null) &#123; return true; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(head); Node node; boolean leaf = false; while (!queue.isEmpty()) &#123; node = queue.poll(); if (node.right != null &amp;&amp; node.left != null) &#123; if (leaf) &#123; return false; &#125; queue.offer(node.left); queue.offer(node.right); &#125; else if (node.left == null &amp;&amp; node.right != null) &#123; return false; &#125; else &#123; if (node.left != null) &#123; if (leaf) &#123; return false; &#125; queue.offer(node.left); &#125; leaf = true; &#125; &#125; return true;&#125;// 左神简化版public static boolean isCBT2(Node head) &#123; if (head == null) &#123; return true; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); boolean leaf = false; Node l = null; Node r = null; queue.offer(head); while (!queue.isEmpty()) &#123; head = queue.poll(); l = head.left; r = head.right; if ((leaf &amp;&amp; (l != null || r != null)) || (l == null &amp;&amp; r != null) ) &#123; return false; &#125; if (l != null) &#123; queue.offer(l); &#125; if (r != null) &#123; queue.offer(r); &#125; else &#123; leaf = true; &#125; &#125; return true;&#125; 题目八 已知一棵完全二叉树，求其节点的个数要求：时间复杂度低于O(N)，N为这棵树的节点个数 思路先遍历完全二叉树根节点到它的最左节点；这样可以判断出完全二叉树的高度；然后再判断右子树的最左节点是否存在； 如果存在则说明他的根节点的左子树是满二叉树：左子树可以通过高度求出来；右子树可以通过递归求得； 如果不存在说明右节点也是满二叉树；则可以由递归求得左子树； 123456789101112131415161718192021222324252627public static int nodeNum(Node head) &#123; if (head == null) &#123; return 0; &#125; return bs(head, 1, mostLeftLevel(head, 1));&#125;public static int bs(Node node, int level, int h) &#123; if (level == h) &#123; return 1; &#125; if (mostLeftLevel(node.right, level + 1) == h)&#123; return (1 &lt;&lt; (h - level)) + bs(node.right, level + 1, h); &#125; else &#123; return (1 &lt;&lt; (h - level - 1)) + bs(node.left, level + 1, h); &#125;&#125;public static int mostLeftLevel(Node node, int level) &#123; while (node != null) &#123; level += 1; node = node.left; &#125; return level - 1;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"树","slug":"algorithm/左神算法/初级/树","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%A0%91/"}],"tags":[{"name":"树","slug":"树","permalink":"http://zenner006.github.io/tags/%E6%A0%91/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"http://zenner006.github.io/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"完全二叉树","slug":"完全二叉树","permalink":"http://zenner006.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"左神算法-基础课-03","slug":"zuoshen-basic-class-3","date":"2020-12-01T08:20:03.000Z","updated":"2020-12-11T10:00:47.673Z","comments":true,"path":"2020/12/01/zuoshen-basic-class-3/","link":"","permalink":"http://zenner006.github.io/2020/12/01/zuoshen-basic-class-3/","excerpt":"题目一：用数组结构实现大小固定的队列和栈栈与队列的数据结构都是很熟悉的了； 栈具体在这里他们的实现：栈的实现涉及：压栈，出栈，返回栈顶元素，返回栈元素个数等等；在栈满时压栈会报错；在栈空时出栈会报错； 1234567891011121314151617181920212223242526272829303132public static class ArrayStack &#123; private Integer [] arr; private Integer size; public ArrayStack(int initSize) &#123; if (initSize &lt; 0)&#123; throw new IllegalArgumentException(\"The init size is less than 0\"); &#125; arr = new Integer[initSize]; size = 0; &#125; public Integer peek() &#123; if (size == 0)&#123; return null; &#125; return arr[size - 1]; &#125; public void push(int obj) &#123; if (size == arr.length)&#123; throw new ArrayIndexOutOfBoundsException(\"The Stack is full\"); &#125; arr[size++] = obj; &#125; public Integer pop() &#123; if (size == 0)&#123; throw new ArrayIndexOutOfBoundsException(\"The stack is empty\"); &#125; return arr[--size]; &#125;&#125;","text":"题目一：用数组结构实现大小固定的队列和栈栈与队列的数据结构都是很熟悉的了； 栈具体在这里他们的实现：栈的实现涉及：压栈，出栈，返回栈顶元素，返回栈元素个数等等；在栈满时压栈会报错；在栈空时出栈会报错； 1234567891011121314151617181920212223242526272829303132public static class ArrayStack &#123; private Integer [] arr; private Integer size; public ArrayStack(int initSize) &#123; if (initSize &lt; 0)&#123; throw new IllegalArgumentException(\"The init size is less than 0\"); &#125; arr = new Integer[initSize]; size = 0; &#125; public Integer peek() &#123; if (size == 0)&#123; return null; &#125; return arr[size - 1]; &#125; public void push(int obj) &#123; if (size == arr.length)&#123; throw new ArrayIndexOutOfBoundsException(\"The Stack is full\"); &#125; arr[size++] = obj; &#125; public Integer pop() &#123; if (size == 0)&#123; throw new ArrayIndexOutOfBoundsException(\"The stack is empty\"); &#125; return arr[--size]; &#125;&#125; 队另外的是队列的实现；一般普通的方法是维护队头和队尾两个变量。左神在这里引入了第三个变量：size，也就是队列中元素的个数； 如果size是数组的大小的话，那么就不能从队尾入队了，如果小于数组的大小，则可以入队； 如果size是0的话，就不能从队头出队；如果大于0，就可以从队头入队； 这样对于入队与出队的操作就只需要看size就可以；队头和队尾两个变量就没有关系了； 12345678910111213141516171819202122232425262728293031323334353637383940public static class ArrayQueue &#123; private Integer [] arr; private Integer size; private Integer first; private Integer last; // 指向队尾的后一格（可能空，也可能不空） public ArrayQueue(int initSize) &#123; if (initSize &lt; 0)&#123; throw new IllegalArgumentException(\"The init size is less than 0\"); &#125; arr = new Integer[initSize]; size = 0; first = last = 0; &#125; public Integer peek() &#123; if (size == 0)&#123; return null; &#125; return arr[first]; &#125; public void push(int obj) &#123; if (size == arr.length)&#123; throw new ArrayIndexOutOfBoundsException(\"The queue is full\"); &#125; size++; arr[last] = obj; last = last == arr.length - 1 ? 0 : last + 1; &#125; public Integer poll() &#123; if (size == 0)&#123; throw new ArrayIndexOutOfBoundsException(\"The stack is empty\"); &#125; size --; int tmp = first; first = first == arr.length - 1 ? 0 : first + 1; return arr[tmp]; &#125;&#125; 【思考】如果没有size该如何实现 如果没有size则在队为空时，队头 start 和队尾 end 都指向一个位置； 入队时要判断是否还有空间，则就是 end 的下一个位置如果不是start 就说明可以入队；这里 end 的下一个位置分为两种情况，end到达数组尾部，他的下一个位置是0，end未到达数组尾部，他的下一个位置是 end + 1； 出队时要判断是否队为空，则就是 start 和 end相等； 题目二：实现栈，并且实现返回栈中最小元素的操作 【实现】：这个栈有两个数组，一个数组是 data 数组，另一个数组是 min最小值数组； 在往data和min是两个同步运作的数组； data入栈，min也入栈：data入栈一个数字 x，则把这个数字与min的栈顶比较，把较小值入min栈；当然如果min为空，则直接入栈就好了； data出栈，min也出栈：这个没得说，他们的个数是一样的； 实现一：最小栈与数据栈同步123456789101112131415161718192021222324252627282930313233public static class MyStack2 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack2() &#123; this.stackData = new Stack&lt;Integer&gt;(); this.stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int newNum) &#123; if (this.stackMin.isEmpty())&#123; this.stackMin.push(newNum); &#125; else if (newNum &lt; this.getmin())&#123; this.stackMin.push(newNum); &#125; else &#123; int newMin = this.stackMin.peek(); this.stackMin.push(newMin); &#125; this.stackData.push(newNum); &#125; public int pop() &#123; if (this.stackMin.isEmpty()) &#123; throw new RuntimeException(\"Your Stack is empty\"); &#125; this.stackMin.pop(); return this.stackData.pop(); &#125; public int getmin() &#123; return this.stackMin.peek(); &#125;&#125; 实现二：最小栈与数据栈不一定同步之前两个栈是同步的过程；而当进来的数大于当前最小值时的过程可以通过判断不用往最小栈里添加。弹出栈时，当当前栈中最小值被弹出了，最小栈才做改变。 123456789101112131415161718192021222324252627282930313233public static class MyStack1 &#123; private Stack&lt;Integer&gt; stackData; private Stack&lt;Integer&gt; stackMin; public MyStack1()&#123; this.stackData = new Stack&lt;Integer&gt;(); this.stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int newNum) &#123; if (this.stackMin.isEmpty())&#123; this.stackMin.push(newNum); &#125; else if (newNum &lt;= this.getmin())&#123; this.stackMin.push(newNum); &#125; this.stackData.push(newNum); &#125; public int pop() &#123; if (this.stackData.isEmpty()) &#123; throw new RuntimeException(\"Your stack is empty.\"); &#125; int value = this.stackData.pop(); if (value == this.getmin())&#123; this.stackMin.pop(); &#125; return value; &#125; public int getmin() &#123; if (this.stackMin.isEmpty()) &#123; throw new RuntimeException(\"Your stack is empty.\"); &#125; return this.stackMin.peek(); &#125;&#125; 题目三：用队列实现栈，用栈实现队列 用队列实现栈结构需要两个队列； 一个数据队列 data，一个辅助队列 help ； 入队就把数据放进 data； 弹出时需要弹出进入 data 的最后一个元素；所以需要把队列前面的元素出队放入 help 当中；得到和栈一样的结果； 但此时的 help 成了 data 的作用，所以把他们的引用交换一下就可以； 123456789101112131415161718192021222324252627282930313233343536373839404142public static class TwoQueuesStack &#123; private Queue&lt;Integer&gt; queue; private Queue&lt;Integer&gt; help; public TwoQueuesStack() &#123; queue = new LinkedList&lt;Integer&gt;(); help = new LinkedList&lt;Integer&gt;(); &#125; public void push(int pushInt) &#123; queue.add(pushInt); &#125; public int peek() &#123; if (queue.isEmpty()) &#123; throw new RuntimeException(\"Stack is empty!\"); &#125; while (queue.size() != 1) &#123; help.add(queue.poll()); &#125; int res = queue.poll(); help.add(res); swap(); return res; &#125; public int pop() &#123; if (queue.isEmpty()) &#123; throw new RuntimeException(\"Stack is empty!\"); &#125; while (queue.size() != 1) &#123; help.add(queue.poll()); &#125; int res = queue.poll(); swap(); return res; &#125; private void swap() &#123; Queue&lt;Integer&gt; tmp = help; help = queue; queue = tmp; &#125;&#125; 用栈实现队列需要两个栈； push 栈 和 pop 栈 往 push 栈里加入数据；若想得到该队列的出队。则需要从 push 栈中把所有数据倒到 pop 栈中；从pop 栈栈顶返回； 倒数据有两个规则： 1）push 栈往 pop 栈里倒数据要一次性倒完；不要有剩余； 2）如果 pop 栈不为空，那么push 栈一定不要倒； 12345678910111213141516171819202122232425262728293031323334public static class TwoStacksQueue &#123; private Stack&lt;Integer&gt; stackpush; private Stack&lt;Integer&gt; stackpop; public TwoStacksQueue()&#123; stackpush = new Stack&lt;Integer&gt;(); stackpop = new Stack&lt;Integer&gt;(); &#125; public void push(int pushInt) &#123; stackpush.push(pushInt); &#125; public int poll() &#123; if (stackpush.empty() &amp;&amp; stackpop.empty()) &#123; throw new RuntimeException(\"Queue is empty!\"); &#125; else if (stackpop.empty())&#123; while (!stackpush.empty()) &#123; stackpop.push(stackpush.pop()); &#125; &#125; return stackpop.pop(); &#125; public int peek() &#123; if (stackpush.empty() &amp;&amp; stackpop.empty()) &#123; throw new RuntimeException(\"Queue is empty!\"); &#125; else if (stackpop.empty())&#123; while (!stackpush.empty()) &#123; stackpop.push(stackpush.pop()); &#125; &#125; return stackpop.peek(); &#125;&#125; 题目四 猫狗队列题目宠物、狗和猫的类如下： 123456789101112131415161718192021public static class Pet &#123; private String type; public Pet(String type) &#123; this.type = type; &#125; public String getPetType() &#123; return this.type; &#125;&#125;public static class Dog extends Pet &#123; public Dog() &#123; super(\"dog\"); &#125;&#125;public static class Cat extends Pet &#123; public Cat() &#123; super(\"cat\"); &#125;&#125; 实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的 实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列 的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照 进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实 例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是 否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog 类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。 实现两个队列分别保存狗和猫；需要最早进的狗与猫这两个操作可以得以解决； 在这两个队列里保存的是包装后的狗和猫，另外包装的信息是他们进入队列的时间戳；这样对比两个队列的头部来返回最早进入队列的宠物； 对Pet的包装 有添加进入队列的时间戳；获取宠物的方法，获取时间戳的方法，获取宠物类型的方法； 123456789101112131415161718192021public static class PetEnterQueue &#123; private Pet pet; private long count; public PetEnterQueue(Pet pet, long count) &#123; this.pet = pet; this.count = count; &#125; public Pet getPet() &#123; return this.pet; &#125; public long getCount() &#123; return this.count; &#125; public String getEnterPetType() &#123; return this.pet.getPetType(); &#125;&#125; 猫狗队列的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static class DogCatQueue &#123; private Queue&lt;PetEnterQueue&gt; dogQ; private Queue&lt;PetEnterQueue&gt; catQ; private long count; public DogCatQueue() &#123; this.dogQ = new LinkedList&lt;PetEnterQueue&gt;(); this.catQ = new LinkedList&lt;PetEnterQueue&gt;(); this.count = 0; &#125; public void add(Pet pet) &#123; if (pet.getPetType().equals(\"dog\")) &#123; this.dogQ.add(new PetEnterQueue(pet, count++)); &#125; else if (pet.getPetType().equals(\"cat\")) &#123; this.catQ.add(new PetEnterQueue(pet, count++)); &#125; else &#123; throw new RuntimeException(\"err, not dog or cat\"); &#125; &#125; public Pet pollAll() &#123; if (!this.dogQ.isEmpty() &amp;&amp; !this.catQ.isEmpty()) &#123; if (this.dogQ.peek().getCount() &lt; this.catQ.peek().getCount()) &#123; return this.dogQ.poll().getPet(); &#125; else &#123; return this.catQ.poll().getPet(); &#125; &#125; else if (!this.dogQ.isEmpty()) &#123; return dogQ.poll().getPet(); &#125; else if (!this.catQ.isEmpty()) &#123; return catQ.poll().getPet(); &#125; else&#123; throw new RuntimeException(\"err, the queue is empty!\"); &#125; &#125; public Dog pollDog() &#123; if (!this.dogQ.isEmpty()) &#123; return (Dog) dogQ.poll().getPet(); &#125; else &#123; throw new RuntimeException(\"err, the queue is empty!\"); &#125; &#125; public Cat pollCat() &#123; if (!this.catQ.isEmpty()) &#123; return (Cat) catQ.poll().getPet(); &#125; else &#123; throw new RuntimeException(\"err, the queue is empty!\"); &#125; &#125; public boolean isEmpty()&#123; return this.dogQ.isEmpty() &amp;&amp; this.catQ.isEmpty(); &#125; public boolean isDogQueueEmpty() &#123; return this.dogQ.isEmpty(); &#125; public boolean isCatQueueEmpty() &#123; return this.catQ.isEmpty(); &#125;&#125; 题目五 转圈打印矩阵题目给定一个整形矩阵matrix，请按照转圈的方式打印它； 1 2 3 4 5 6 7 8 9 10 11 12 转圈打印的结果为： 1，2，3，4，8，12，11，10，9，5，6，7 要求：额外空间复杂度为 O(1) 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546package zuoshen.basic_class.class03;public class Code_06_PrintMatrixSpiralOrder &#123; public static void spiralOrderPrint(int[][] matrix) &#123; int tR = 0; int tC = 0; int dR = matrix.length - 1; int dC = matrix[0].length - 1; while (tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123; printEdge(matrix, tR++, tC++, dR--, dC--); &#125; &#125; public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) &#123; // 先判断边界条件 if (tR == dR)&#123; for (int i = tC; i &lt;= dC ; i++) &#123; System.out.println(m[tR][i] + \" \"); &#125; &#125; else if (tC == dC)&#123; for (int i = tR; i &lt;= dR ; i++) &#123; System.out.println(m[i][tC] + \" \"); &#125; &#125; else&#123; int curC = tC; int curR = tR; while (curC != dC)&#123; System.out.println(m[curR][curC++] + \" \"); &#125; while (curR != dR)&#123; System.out.println(m[curR++][curC] + \" \"); &#125; while (curC != tC) &#123; System.out.println(m[curR][curC--] + \" \"); &#125; while (curR != tR)&#123; System.out.println(m[curR--][curC] + \" \"); &#125; &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8 &#125;, &#123;9, 10, 11,12 &#125;, &#123;13, 14, 15,16&#125; &#125;; spiralOrderPrint(matrix); &#125;&#125; 题目六 旋转正方形矩阵题目【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 【要求】 额外空间复杂度为O(1)。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243package zuoshen.basic_class.class03;public class Code_05_RotateMatrix &#123; public static void rotate(int[][] matrix) &#123; int tR = 0; int tC = 0; int dR = matrix.length - 1; int dC = matrix[0].length - 1; while (tR &lt; dR)&#123; rotateEdge(matrix, tR++, tC++, dR--, dC--); &#125; &#125; public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) &#123; int times = dC - tC; int tmp = 0; for (int i = 0; i != times; i++) &#123; tmp = m[tR][tC + i]; m[tR][tC + i] = m[dR - i][tC]; m[dR - i][tC] = m[dR][dC - i]; m[dR][dC - i] = m[tR + i][dC]; m[tR + i][dC] = tmp; &#125; &#125; public static void printMatrix(int[][] matrix) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; System.out.print(matrix[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; printMatrix(matrix); rotate(matrix); System.out.println(\"=========\"); printMatrix(matrix); &#125;&#125; 题目七 反转单向和双向链表题目【题目】分别实现反转单向链表和反转双向链表的函数； 【要求】如果链表长度为N，时间复杂度要求为 $O(N)$ , 额外空间复杂度要求为 $O(1)$ ; 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package zuoshen.basic_class.class03;public class Code_07_ReverseList &#123; // 节点类； public static class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value = data; this.next = null; &#125; &#125; // 反转链表函数 public static Node reverseList(Node head)&#123; Node pre = null; Node tmp = null; while (head != null) &#123; // tmp指向头节点 tmp = head; // tmp拿着头节点，head向后走 head = head.next; tmp.next = pre; pre = tmp; &#125; return pre; &#125; // 双向链表类 public static class DoubleNode&#123; public int value; public DoubleNode last; public DoubleNode next; public DoubleNode(int data)&#123; this.value = data; &#125; &#125; // 反转双向链表函数 public static DoubleNode reverseList(DoubleNode head)&#123; DoubleNode p = head; DoubleNode tmp = null; while (p != null) &#123; p.last = p.next; p.next = tmp; tmp = p; p = p.last; &#125; return tmp; &#125; // 打印链表函数 public static void printLinkedList(Node head)&#123; System.out.println(\"Linked List: \"); while (head != null) &#123; System.out.print(head.value + \" \"); head = head.next; &#125; System.out.println(); &#125; // 打印双向链表函数 public static void printDoubleLinkedList(DoubleNode head)&#123; System.out.println(\"Double Linked List \"); while (head != null) &#123; System.out.print(head.value + \" \"); head = head.next; &#125; System.out.println(); &#125; // 主函数 public static void main(String[] args) &#123; Node head1 = new Node(1); head1.next = new Node(2); head1.next.next = new Node(3); printLinkedList(head1); head1 = reverseList(head1); printLinkedList(head1); DoubleNode head2 = new DoubleNode(1); head2.next = new DoubleNode(2); head2.next.last = head2; head2.next.next = new DoubleNode(3); head2.next.next.last = head2.next; head2.next.next.next = new DoubleNode(4); head2.next.next.next.last = head2.next.next; printDoubleLinkedList(head2); printDoubleLinkedList(reverseList(head2)); &#125;&#125; 题目八 “之”字形打印矩阵题目 实现在矩阵中设计两个初始位置相同的点； A和B分别有着不同的运动轨迹；A每次往右移动直到到矩阵的边缘再往下移动；B每次往下移动直到矩阵的边缘再往右移动 经历过一次移动之后，A和B分别到达的位置，可以看出A和B总是处在一条线的两端： 此时B到达矩阵的边缘，开始往右走了；此时A和B仍处于一个对角线上； 依次类推，按顺序打印A和B所在的线，不过按照 “之” 字型打印，就需要看好是从A到B还是从B到A；需要一个布尔类型的变量来设定这件事情； 接下来就是实现一个打印函数，这个函数需要被告知矩阵的A点和B点，然后还需要告知打印的方向； 1234567891011121314151617181920212223242526272829303132333435package zuoshen.basic_class.class03;public class Code_07_ZigZagPrintMatrix &#123; public static void printMatrixZigZag(int[][] matrix) &#123; int aR = 0, bR = 0, aC = 0, bC = 0; int endR = matrix.length - 1; int endC = matrix[0].length - 1; boolean fromUp = false; while (aR != endR) &#123; printLevel(matrix, aR, aC, bR, bC, fromUp); aR = aC == endC ? aR + 1 : aR; aC = aC == endC ? aC : aC + 1; bC = bR == endR ? bC + 1 : bC; // 这里需要注意这几个语句的顺序；被判断的值一定是最后才修改的； bR = bR == endR ? bR : bR + 1; fromUp = !fromUp; &#125; &#125; public static void printLevel(int[][] m, int tR, int tC, int dR, int dC, boolean f) &#123; if (f)&#123; while (tR != dR + 1) &#123; System.out.println(m[tR++][tC--] + \" \"); &#125; &#125; else &#123; while(dR != tR - 1) &#123; System.out.println(m[dR--][dC++] + \" \"); &#125; &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; printMatrixZigZag(matrix); &#125;&#125; 题目九 在行和列都排好序的矩阵中找数题目在行列都排好序的矩阵中找数； 给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。 实现从左上角或右下角开始找，每次都能排除一行或一列的数据； 【思路】从数据状况考虑出发 1234567891011121314151617181920212223242526272829303132package zuoshen.basic_class.class03;public class Code_09_FindNumInSortedMatrix &#123; public static boolean isContains(int[][] matrix, int value) &#123; int row = 0; int col = matrix[0].length - 1; while (row &lt; matrix.length &amp;&amp; col &gt;= 0) &#123; if (matrix[row][col] == value)&#123; return true; &#125; else if (matrix[row][col] &gt; value) &#123; col --; &#125; else &#123; row ++; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; int[][] matrix = new int[][] &#123; &#123; 0, 1, 2, 3, 4, 5, 6 &#125;,// 0 &#123; 10, 12, 13, 15, 16, 17, 18 &#125;,// 1 &#123; 23, 24, 25, 26, 27, 28, 29 &#125;,// 2 &#123; 44, 45, 46, 47, 48, 49, 50 &#125;,// 3 &#123; 65, 66, 67, 68, 69, 70, 71 &#125;,// 4 &#123; 96, 97, 98, 99, 100, 111, 122 &#125;,// 5 &#123; 166, 176, 186, 187, 190, 195, 200 &#125;,// 6 &#123; 233, 243, 321, 341, 356, 370, 380 &#125; // 7 &#125;; int K = 233; System.out.println(isContains(matrix, K)); &#125;&#125; 题目十 打印两个有序链表的公共部分题目给定两个有序链表的头指针head1和head2，打印两个链表的公共部分 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package zuoshen.basic_class.class03;public class Code_10_PrintCommonPart &#123; // 需要一个节点类； public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125; &#125; public static void printCommonPart(Node head1, Node head2) &#123; System.out.print(\"Common Part: \"); while (head1 != null &amp;&amp; head2 != null) &#123; if (head1.value &gt; head2.value) &#123; head2 = head2.next; &#125; else if(head1.value &lt; head2.value) &#123; head1 = head1.next; &#125; else &#123; System.out.print(head1.value + \" \"); head1 = head1.next; head2 = head2.next; &#125; &#125; System.out.println(); &#125; // 打印链表函数 public static void printLinkedList(Node head)&#123; System.out.println(\"Linked List: \"); while (head != null) &#123; System.out.print(head.value + \" \"); head = head.next; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; Node node1 = new Node(2); node1.next = new Node(3); node1.next.next = new Node(5); node1.next.next.next = new Node(6); Node node2 = new Node(1); node2.next = new Node(2); node2.next.next = new Node(5); node2.next.next.next = new Node(7); node2.next.next.next.next = new Node(8); printLinkedList(node1); printLinkedList(node2); printCommonPart(node1, node2); &#125;&#125; 题目十一 判断一个链表是否为回文结构题目 实现思路一：一个长度与链表一样长的栈 12345678910111213141516// need n extra space 一个长度与链表一样长的栈；public static boolean isPalindrome1(Node head) &#123; Stack&lt;Node&gt; nodes = new Stack&lt;Node&gt;(); Node cur = head; while (cur != null) &#123; nodes.push(cur); cur = cur.next; &#125; while (head != null)&#123; if (nodes.pop().value != head.value)&#123; return false; &#125; head = head.next; &#125; return true;&#125; 思路二：快慢指针 + 栈 1234567891011121314151617181920212223// need n/2 extra spacepublic static boolean isPalindrome2(Node head) &#123; if (head == null || head.next == null)&#123; return true; &#125; Node fast = head, slow = head; while (fast.next != null) &#123; slow = slow.next; fast = fast.next.next != null ? fast.next.next : fast.next; &#125; Stack&lt;Node&gt; nodes = new Stack&lt;Node&gt;(); while (slow != null) &#123; nodes.push(slow); slow = slow.next; &#125; while (!nodes.isEmpty())&#123; if (nodes.pop().value != head.value) &#123; return false; &#125; head = head.next; &#125; return true;&#125; 思路三：快慢指针，快指针走两步，慢指针走一步；（其实这个方法也是找到链表中心点的方法） 快指针每次走两步直到末尾，此时慢指针指向中心 当链表节点个数为偶数时，慢指针刚好指向第 $\\frac{N}{2}$ 的位置 当链表节点个数为奇数时，快指针会移动 $\\frac{N+1}{2}$ 次，慢指针也会移动 $\\frac{N+1}{2}$ 次（比被2整数结果后面的一个，例如：N=5，那么移动三次指向第4个节点；N=9，移动5次指向第6个节点）； 然后把慢指针之后的链表逆序； 与头节点开始与慢指针比较是否是回文结构； 然后恢复原链表结构； 12345678910111213141516171819202122232425262728293031323334353637383940// need O(1) extra spacepublic static boolean isPalindrome3(Node head) &#123; if (head == null || head.next == null)&#123; return true; &#125; Node fast = head, slow = head; while ( fast.next != null &amp;&amp; fast.next.next !=null) &#123; slow = slow.next; fast = fast.next.next; &#125; Node tmp = null; fast = null; while (slow != null) &#123; tmp = slow; slow = slow.next; tmp.next = fast; fast = tmp; &#125; // 分别从head 和 fast出发查看是否一样 slow = head; // 保存头节点 tmp = fast; // 保存最后一个节点 boolean res = true; while (fast != null &amp;&amp; slow != null) &#123; if (fast.value != slow.value)&#123; res = false; &#125; fast = fast.next; slow = slow.next; &#125; // 复原链表 fast = tmp.next; // 保存最后一个节点最后一个值 tmp.next = null; while (fast != null) &#123; slow = fast; fast = fast.next; slow.next = tmp; tmp = slow; &#125; return res;&#125; 题目十二 将单向链表按某值划分成左边小、中间相等、右边大的形式题目【题目】 给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。 除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9-&gt;0-&gt;4-&gt;5- &gt;1，pivot=3。调整后链表可以是1-&gt;0-&gt;4-&gt;9-&gt;5，也可以是0-&gt;1-&gt;9-&gt;5-&gt;4。总 之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部 分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做要求。 【进阶】在原问题的要求之上再增加如下两个要求。 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的 顺序与原链表中节点的先后次序一致。 例如：链表9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。 调整后的链表是0-&gt;1-&gt;9-&gt;4-&gt;5。 在满足原问题要求的同时，左部分节点从左到 右为0、1。在原链表中也 是先出现0，后出现1；中间部分在本例中为空，不再 讨论；右部分节点 从左到右为9、4、5。在原链表中也是先出现9，然后出现4， 最后出现5。 如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。 实现思路一：把链表套进一个数组当中；数组的元素就是链表的节点；然后用荷兰国旗问题进行解决；这样子的解决方案是不能达到稳定性要求的； 12345678910111213141516171819202122232425262728293031323334353637383940414243public static Node listPartition1(Node head, int pivot) &#123; if (head == null) &#123; return head; &#125; Node cur = head; int i = 0; while (cur != null)&#123; i ++; cur = cur.next; &#125; Node[] nodearr = new Node[i]; cur = head; for (i = 0; i &lt; nodearr.length ; i++) &#123; nodearr[i] = cur; cur = cur.next; &#125; arrPartition(nodearr, pivot); for (i = 1; i &lt; nodearr.length; i++) &#123; nodearr[i-1].next = nodearr[i]; &#125; nodearr[i - 1].next = null; return nodearr[0];&#125;public static void arrPartition(Node[] nodeArr, int pivot) &#123; int small = -1; int big = nodeArr.length; int index = 0; while (index &lt; big) &#123; if (nodeArr[index].value &lt; pivot) &#123; swap(nodeArr, index++, ++small); &#125; else if (nodeArr[index].value == pivot)&#123; index ++; &#125; else &#123; swap(nodeArr,index, --big); &#125; &#125;&#125;public static void swap(Node[] nodeArr, int a, int b) &#123; Node tmp = nodeArr[a]; nodeArr[a] = nodeArr[b]; nodeArr[b] = tmp;&#125; 思路二： 用分别准备三个链表变量分别保存小于，等于和大于的组； 每个链表需要两个变量保存头和尾 然后把三个链表串起来就可以实现； 需要判断每个链表是否存在，涉及一个较为复杂的编程过程； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Node listPartition2(Node head, int pivot) &#123; Node sH = null; // small head Node sT = null; // small tail Node eH = null; // equal head Node eT = null; // equal tail Node bH = null; // big head Node bT = null; // big tail Node cur = null; while (head != null) &#123; cur = head; head = head.next; cur.next = null; if (cur.value &lt; pivot) &#123; if (sH == null) &#123; sH = cur; sT = cur; &#125; else &#123; sT.next = cur; sT = cur; &#125; &#125; else if (cur.value == pivot) &#123; if (eH == null) &#123; eH = cur; eT = cur; &#125; else &#123; eT.next = cur; eT = cur; &#125; &#125; else &#123; if (bH == null) &#123; bH = cur; bT = cur; &#125; else &#123; bT.next = cur; bT = cur; &#125; &#125; &#125; // small and equal reconnect if (sT != null) &#123; sT.next = eH; eT = eT == null ? sT : eT; &#125; if (eT != null) &#123; eT.next = bH; &#125; return sH != null ? sH : eH != null ? eH : bH;&#125; 题目十三 复制含有随机指针的链表题目【题目】 一种特殊的链表节点类描述如下： 12345678public class Node &#123; public int value; public Node next; public Node rand; public Node(int data) &#123; this.value = data; &#125; &#125; Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null。给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 $O(N)$ 内完成原问题要实现的函数。 实现【我的考虑】：直接复制相对应的节点把他们的节点的值和next 指针复制好。接着问题出现了 rand 是无法复制的。要找到第一个节点的 rand 指针需要和原始链表一样去同步遍历才能找到。这样无疑会有很大的时间复杂度； 【解法一】把原始链表与新链表通过哈希表的方式来建立联系 哈希表中的 key 是原始链表中的节点，相对应的 value 是它复制后的节点。要找到新链表节点的 next 和 rand，可以通过哈希表查找原始链表节点相对应节点来完成赋值； 【解法二】原地把原始链表与新链表关联起来： 用 $i’$ 来表示 $i$ 节点的复制节点 ，那么把它关联起来的方式是 ： 1 -> 1' -> 2 -> 2' -> 3 -> 3' -> null把原来的链表组织成这样的形式；每次从链表中去取出两个节点 $1 -&gt; 1’$ ；先复制 rand 指针，$1$ 的 rand 指针可以直接找到。 而复制的新的 $1’$ 的 rand 指针可以从 $1$ 的 rand 指针找到对应节点的下一个就是 $1’$ 的 rand 指针的对应节点； 最后再把 next 指针复原组织好。即可完成； 题目十四 两个单链表相交的一系列问题题目【题目】 在本题中，单链表可能有环，也可能无环。 给定两个 单链表的头节点 head1和head2，这两个链表可能相交，也可能 不相交。 请实现一个函数， 如果两个链表相交，请返回相交的 第一个节点； 如果不相交，返回null 即可。 要求：如果链表1 的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外 空间复杂度请达到O(1)。 实现【我的考虑】 先分类考虑 有环相交，有环不相交，无环相交，无环不相交 然后发现任何一个都很复杂； 问题一 如何判断链表有没有环 ​ 【方法一】哈希表 ​ 通过一个哈希表，遍历链表节点；每遍历一个节点如果它不在集合中就把它放集合当中；如果第一个发现在集合中的节点，那就说明这是链表的环的入口；如果判断到节点为空，则说明不存在环； ​ 实现 : 判断一个链表是否有环，如果有，则返回环的第一个节点；没有则返回空； ​ 【方法二】快慢指针 快指针走两步，慢指针走一步； 直到相遇； 如果相遇，快指针回到开头，由一次走两步变为一次走一步，【结论】快指针与慢指针一定会在入环节点处相遇； 问题二 如何判断一个无环单链表第一个相交的节点 由问题一我们可以知道是否有环，则可以考虑两个链表调用了判断是否有环函数后都返回为空，这个情况下他们是否有相交的节点 ​ 【方法一】哈希表 ​ 同样是用一个哈希表；遍历第一个链表节点，都放入哈希表当中去。 ​ 然后依次遍历第二个链表，在哈希表中查。如果都没有，说明它们不相交；如果第二个链表的节点在哈希表中出现了，则说明这个节点是相交节点； ​ 【方法二】 ​ 遍历第一个链表，得到他的长度与最后一个节点的指针；同样的遍历第二个链表，得到他的长度和最后一个节点的指针； 显而易见：判断 两个链表的最后一个节点是否是一个节点即可判断他们是否相交； 如果它们相交，根据链表长度去遍历； 让长的链表先走，走到与短的一样长时它们一起走。 然后判断两个链表当下节点是否一样，直到它们指向节点一样也就是找到了相交的第一个节点； 问题三 如何判断一个有环单链表与无环单链表第一个相交的节点 ​ 不可能相交； 问题四 如何判断两个有环单链表第一个相交的节点 三种情况： 如果判断是有环并且得到的入环节点位置相同，他就是结构2： 此时也就等同于无环链表相交，此时相交位置与入环节点没有关系； 如果入环节点不相同，他可能是结构1也可能是结构2： 此时从链表一的入环节点出发，遍历链表； 如果碰到链表二的入环节点：则说明是第三种结构 此时返回链表一的入环节点和链表二的入环节点都是对的； 如果链表一的入环节点遍历回去了，还没碰到说明是结构一； 不存在相交节点； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public static Node getIntersectNode(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node loop1 = getLoopNode(head1); Node loop2 = getLoopNode(head2); if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1, head2); &#125; else if (loop1 != null &amp;&amp; loop2 != null) &#123; return bothLoop(head1, loop1, head2, loop2); &#125; return null;&#125;public static Node getLoopNode(Node head) &#123; if (head == null || head.next == null || head.next.next == null) &#123; return null; &#125; Node n1 = head.next; Node n2 = head.next.next; while (n1 != n2) &#123; if (n2.next == null || n2.next.next == null) &#123; return null; &#125; n1 = n1.next; n2 = n2.next.next; &#125; n2 = head; while (n1 != n2) &#123; n1 = n1.next; n2 = n2.next; &#125; return n1;&#125;public static Node noLoop(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node cur1 = head1; Node cur2 = head2; int n = 0; while (cur1.next != null) &#123; n ++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n --; cur2 = cur2.next; &#125; if (cur1 != cur2) &#123; return null; &#125; cur1 = n &gt; 0 ? head1 : head2; // cur1 指向较长的链表 cur2 = cur1 == head1 ? head2 : head1; // cur2 指向另一个 n = Math.abs(n); while (n != 0) &#123; n --; cur1 = cur1.next; &#125; // cur1 和 cur2 同时出发 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1;&#125;public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node cur1 = null; Node cur2 = null; if (loop1 == loop2) &#123; cur1 = head1; cur2 = head2; int n = 0; while (cur1 != loop1) &#123; n ++; cur1 = cur1.next; &#125; while (cur2 != loop2) &#123; n --; cur2 = cur2.next; &#125; cur1 = n &gt; 0 ? head1 : head2; // cur1 指向较长的链表 cur2 = cur1 == head1 ? head2 : head1; // cur2 指向另一个 n = Math.abs(n); while (n != 0) &#123; n --; cur1 = cur1.next; &#125; // cur1 和 cur2 同时出发 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; else &#123; cur1 = loop1.next; while (cur1 != loop1) &#123; if (cur1 == loop2) &#123; return loop1; &#125; cur1 = cur1.next; &#125; return null; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"链表","slug":"algorithm/左神算法/初级/链表","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://zenner006.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://zenner006.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://zenner006.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"}]},{"title":"第二章 关系模型介绍","slug":"database-system-conception-2","date":"2020-11-09T03:17:44.000Z","updated":"2020-11-25T09:42:03.524Z","comments":true,"path":"2020/11/09/database-system-conception-2/","link":"","permalink":"http://zenner006.github.io/2020/11/09/database-system-conception-2/","excerpt":"2.1 关系数据库的结构 关系数据库由表（table）的集合构成，每个表有唯一的名字； 关系模型的术语中，关系用来指代表，而元组用来指代行。属性指代的是表中的列； 用关系实例来表示一个关系的特性实例，也就是所包含的一组特定的行； 对于关系的每个属性，都存在一个允许取值的集合，成为这个属性的域；如果域中元素被看作不可再分的单元，则域是原子的；（就是一个属性不能再被多个属性表示） 空 （null）指是一个特殊的值，表示值未知或不存在；空值会给数据库访问和更新带来很多困难。 2.2 关系数据库模式​ 需区分 数据库模式 和 数据库实例；前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照； ​ 关系对应于程序设计语言中变量的概念； ​ 关系模式 的概念对应于程序设计语言中类型定义的概念；关系模式由属性序列及各属性对应域组成； ​ 当关系被更新时，关系实例的内容也随时间发生了变化。相反，关系的模式是不常变化的；","text":"2.1 关系数据库的结构 关系数据库由表（table）的集合构成，每个表有唯一的名字； 关系模型的术语中，关系用来指代表，而元组用来指代行。属性指代的是表中的列； 用关系实例来表示一个关系的特性实例，也就是所包含的一组特定的行； 对于关系的每个属性，都存在一个允许取值的集合，成为这个属性的域；如果域中元素被看作不可再分的单元，则域是原子的；（就是一个属性不能再被多个属性表示） 空 （null）指是一个特殊的值，表示值未知或不存在；空值会给数据库访问和更新带来很多困难。 2.2 关系数据库模式​ 需区分 数据库模式 和 数据库实例；前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照； ​ 关系对应于程序设计语言中变量的概念； ​ 关系模式 的概念对应于程序设计语言中类型定义的概念；关系模式由属性序列及各属性对应域组成； ​ 当关系被更新时，关系实例的内容也随时间发生了变化。相反，关系的模式是不常变化的； 2.3 码我们必须有一种能区分给定关系中的不同元组的方法。一个关系中没有两个元组在所有属性上的取值都相同； 超码 是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组； 形式化地描述，设 $R$ 表示关系 $r$ 模式中的属性集合。如果我们说 $R$ 的一个子集 $K$ 是 $r$ 的一个超码，则限制了关系 $r$ 中任意两个不同元组不会在 $K$ 的所有属性上取值完全相等，即如果 $t_1$ 和 $t_2$ 在 $r$ 中且 $t_1\\neq t_2$ , 则 $t_1.K \\neq t_2.K$ 超码可能包含无关紧要的属性。则如果 $K$ 是一个超码，那么 $K$ 的任意超集也是超码； 任意真子集都不能成为超码的最小超码被称为候选码( candidate key) 几个不同的属性集都可以做候选码的情况是存在的； 主码这个术语代表被数据库设计者选中的、主要用来在一个关系中区分不同元组的候选码； 主码的选择必须慎重：有的候选码不适合做主码 主码应选择那些值从不或极少变化的属性；（地址、电话号码等就不应该作为主码） 习惯上把主码放在其他属性前面 关系中的任意两个不同的元组都不允许同时在码属性上具有相同的值。码的指定代表了被建模的事物在现实世界中的约束； 一个关系模式（如 $r_1$）可能在它的属性中包括另一个关系模式（如 $r_2$）的主码。这个属性在 $r_1$ 上称作参照 $r_2$ 的外码 ; 关系 $r_1$ 称为外码依赖的参照关系，关系 $r_2$ 叫做外码的被参照关系 ； 参照完整性要求在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值； 也就是在参照关系中出现的一些属性，我们也希望他们出现在被参照关系中，但是这些属性可能不能够成被参照关系的主键，而此时还需要达成这样的约束就叫做参照完整性； 2.4 模式图一个含有主码和外码依赖的数据库模式可以用模式图（schema diagram）来表示。 每一个关系用一个矩形来表示，关系的名字显示在矩形上方，矩形内列出各属性。 主码属性用下划线标注。 外码依赖用从参照关系的外码属性到被参照关系的主码属性之间的箭头来表示。 除外码约束外，模式图没有显示出参照完整性约束；（后面学的实体-联系图的图形化表示有助于我们表示几种约束） 2.5 关系查询语言查询语言是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化的和非过程化的。 在 过程化语言 中，用户指导系统对数据库执行一系列操作以计算出所需结果； 在 非过程化语言 中，用户只需描述所需信息，而不用给出获取该信息的具体过程； 实际使用的查询语言两种方式都有。 有一些”纯“查询语言：关系代数是过程化的，而 元组关系演算 和 域关系演算 是非过程化的。 关系代数 包括一个运算的集合，这些运算以一个或两个关系为输入，产生一个新的关系作为结果。 关系演算 使用谓词逻辑来定义所需的结果，但不需给出获取结果的特定代数过程。 2.6 关系运算所有的过程化关系查询语言都提供了一组运算；这些运算要么施加于单个关系上，要么施加于一对关系上，并且运算结果总是单个关系。 最常用的关系运算是 从单个关系（如 instructor）种选出满足一些特定谓词（如 salary &gt; 85000美元）的特殊元组；其结果是一个新关系，它是原始关系（instructor）的一个子集； 另一个常用的运算是 从一个关系中选出特定的属性（列）。其结果是一个只包含那些被选择属性的新关系； 连接运算：把分别来自两个关系的元组对合并成单个元组； 自然连接：对于两个关系中的分别两个元组，如果他们在某一属性上取值相同，那么它们就是匹配的； 笛卡尔积：结果是包含来自两个关系元组的所有对，无论它们的属性值是否匹配； 集合运算：包括 并、交、集合差； 查询结果中可能包含重复值。有的查询语言严格遵守集合的数学定义，取出了重复，有的没有； 关系代数 ： 关系代数定义了在关系上的一组运算，通常以一个或两个关系为输入，返回一个关系作为返回；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库系统概念","slug":"数据库/数据库系统概念","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"第一章 引言","slug":"databaseSystemConcepts-1","date":"2020-11-09T03:17:44.000Z","updated":"2020-11-25T09:43:33.246Z","comments":true,"path":"2020/11/09/databaseSystemConcepts-1/","link":"","permalink":"http://zenner006.github.io/2020/11/09/databaseSystemConcepts-1/","excerpt":"1.2 数据库系统的目标文件处理系统中存储组织信息的主要弊端包括： 数据的冗余和不一致 数据访问困难 数据孤立 完整性问题 原子性问题 并发访问异常 安全性问题 1.3 数据视图​ 数据库系统的一个主要目的是给用户提供数据的抽象视图，就是说，系统隐藏关于数据存储和维护的某些细节； 1.3.1 数据抽象 系统要能高效地检索数据。而这促使设计者再数据库中使用复杂的数据结构来表示数据； 许多用户不懂计算机，需要系统开发人员通过如下几个层次对用户屏蔽复杂性：","text":"1.2 数据库系统的目标文件处理系统中存储组织信息的主要弊端包括： 数据的冗余和不一致 数据访问困难 数据孤立 完整性问题 原子性问题 并发访问异常 安全性问题 1.3 数据视图​ 数据库系统的一个主要目的是给用户提供数据的抽象视图，就是说，系统隐藏关于数据存储和维护的某些细节； 1.3.1 数据抽象 系统要能高效地检索数据。而这促使设计者再数据库中使用复杂的数据结构来表示数据； 许多用户不懂计算机，需要系统开发人员通过如下几个层次对用户屏蔽复杂性： 物理层：最低层次的抽象，描述数据实际上是怎样存储的。 ​ 详细描述复杂的底层数据结构； 逻辑层：比物理层稍高一层。描述数据库存储什么数据，及数据间存在什么关系。 虽然逻辑层的简单结的实现可能涉及复杂的物理层结构。但逻辑层用户不必知道这样的复杂性；这叫做物理独立性 数据库管理员使用抽象的逻辑层。 视图层：最高层，只描述数据库的某个部分； 大型数据库信息的多样性使得其仍存在一定程度的复杂性； 数据库系统的很多用户并不关心所有的信息，只需要访问数据库的一部分； 视图层的定义正是为了使用户和系统交互更简单。 系统可以为同一数据库提供多个视图； 1.3.2 实例和模式存储在数据库中的信息的集合称作数据库的一个 实例 。而数据库的总体设计称作数据库模式（schema）； 不同的抽象层次，数据库系统可以分为几种不同的模式：物理模式在物理层描述数据库的设计、而逻辑模式则在逻辑层描述数据库的设计。数据库在视图层可以有几种模式，成为 子模式； 物理数据独立性：物理层可以在应用程序（视图层）丝毫不受影响的情况下被轻易地改变；应用程序不依赖于物理模式； 1.3.3 数据模型数据库结构的基础是数据模型； 数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。 数据模型可被划分为四类： 关系模型（relational model）：关系模型用表的集合来表示数据和数据间的联系； 实体-联系模型（entity-relationship model）：实体-联系（E-R）数据模型基于对现实世界的这样一种认识：现实世界由一组称为实体的基本对象以及这些对象间的联系构成； 基于对象的数据模型（object-based data model）：面对对象的数据模型可以看成是E-R模型增加了封装、方法（函数）和对象标识等概念后的扩展； 半结构化数据模型：半结构化数据模型允许那些相同类型的数据项含有不同的属性集的数据定义。可扩展标记语言被广泛地用来表示半结构化数据； 1.4 数据库语言数据库定义语言，数据库操纵语言；（不限于关系型数据库） 1.4.1 数据操纵语言要实现：增删改查 有两类基本的数据操纵语言： 过程化DML：要求用户指定需要什么数据以及如何获得这些数据； 声明式DML：只要求用户指定需要什么数据，不知名如何获得这些数据； 1.4.2 数据定义语言数据存储和定义语言规定了数据库系统所使用地存储结构和访问方式；这些语句定义了数据库模式的实现细节，而这些细节对用户来说通常不可见； 存储在数据库的数据值必须满足某些一致性约束。约束可以是关于数据库的任意谓词；测试任意谓词的代价比较高。因此数据库系统要以最小代价测试的完整性约束； 域约束（domain constraint）：每个属性都必须对应于一个所有可能的取值构成的域；声明一种属性属于某种具体的域就相当于约束它可以取的值。域约束是完整性约束的最基本形式； 参照完整性（referential integrity）：一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现；当参照完整性约束被违反时，通常的处理是拒绝执行导致完整性被破坏的操作； 断言（assertion）：一个断言就是数据库需要时刻满足的某一条件； 可以定义涉及多个表或聚集操作的比较复杂的完整性约束。断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。 授权（authorization）：对不同的用户在数据库中的不同数据值上允许不同的访问类型。 这些区别以 授权 来表达： 读授权：允许读不允许修改； 插入授权：允许插入新数据，不允许修改已有数据； 更新授权： 删除授权： DDL的输出放在数据字典中，数据字典包含了元数据；元数据是关于数据的数据；可以把数据字典看成之恩那个有数据库系统本身来访问和修改的特殊表； 1.5 关系数据库1.5.1 表关系模型是基于记录的模型的一个实例。基于记录的模型是因为数据库的结构是几种固定格式的记录。每个表包含一种特定类型的记录。每个记录类型定义固定数目的字段或属性。表的列对应记录类型的属性； 在关系模型中可能创建一些有问题的模式，比如出现不必要的冗余信息； 1.5.2 数据操纵语言SQL语言是非过程的； 1.5.3 数据定义语言SQL提供了丰富的DDL，通过它可以定义表、完整性约束、断言等； 1.5.4 来自应用程序的数据库访问 通过提供应用程序接口，它可以用来将 DML 和 DDL 的语句发送给数据库，再取回结果。（ODBC、JDBC等） 通过扩展宿主语言的语法，在宿主语言中嵌入DML调用。通常用一个特殊字符作为DML调用的开始，并且通过预处理器，称为DML预编译器，来将DML语句转变成宿主语言中的过程调用； 1.6 数据库设计数据库设计的主要内容是数据库模式的设计； 1.6.1 设计过程 数据库设计初始阶段是全面刻画预期的数据库用户的数据需求；这阶段的成果是制定出用户需求的规格文档； 下一步，设计者选择一个数据模型，并运用该选定的数据模型的概念把那些需求转换成一个数据库的概念模式。在 概念设计 阶段开发出来的模式提供了企业的详细概述。 确保所有数据需求都满足并且相互之间没有冲突；也可去掉一些冗余特性； 从关系模型的角度来看，概念设计阶段设计决定数据库中应该包括哪些属性（商业决策），以及如何将这些属性组织到多个表中（计算机科学问题）。 解决问题的主要方法： 使用实体-联系模型 引入一套算法(称为规范化)，这套算法将所有属性集作为输入，生成一组关系表； 一个开发完全的概念模式还将指出企业的功能需求。在 功能需求说明 中，用户描述数据之上的各种操作。 最后两个阶段 逻辑设计阶段 ：设计者将高层的概念模式映射到要使用的数据库系统的实现数据模式上； 物理设计阶段 ：这阶段指定数据库的物理特性，特性包括文件组织的形式以及内部的存储结构； 1.6.2 大学机构的数据库设计1.6.3 实体-联系模型实体-联系（E-R）数据模型使用一组称作实体的基本对象，以及这些对象间的联系。 实体是现实世界中可区别于其他对象的一件”事情“或一个”物体“。 数据库中实体通过属性集合来描述 联系 是几个实体之间的关联。 同一类型的所有实体称为实体集。 同一类型的所有联系称为联系集。 数据库的总体逻辑结构可以用实体-联系图来表示： 实体集用矩形框表示，实体名在头部，属性名在下面； 联系集用联系一对相关的实体集的菱形表示，联系名放在菱形内部。 除了实体和联系外，E-R模型还描述了数据库必须描述的对其内容的某些约束。 1.6.4 规范化规范化的目标是生成一个关系模式集合，使存储信息时没有不必要的冗余，同时又能很轻易地检索数据； 规范化是设计一种符合适当的范式的模式；最常用的方法是使用函数依赖 不好的设计可能会包括如下特性： 信息重复 ：重复信息的修改也是个问题 缺乏表达某些信息的能力 1.7 数据存储和查询数据库系统功能部件大致可分为 存储管理器 和 存储处理部件 ； 存储管理：要在大量存储空间组织数据，使其满足和主存之间数据的移动最小化； 查询处理：帮助数据库系统简化和方便数据的访问。使得用户获得高性能，同时在视图的层次上工作。不必了解系统实现物理层次细节的负担。 将在逻辑层编写的更新和查询转变成物理层的高效操作序列，这是数据库系统的任务； 1.7.1 存储管理器存储管理器 是 数据库系统中负责在【数据库中存储的底层数据】与【应用程序】以及【向系统提交的查询】之间提供接口的部件；它负责与文件管理器进行交互； ​ 存储管理器将各种 DML 语句翻译为底层文件系统命令。而原始数据通过操作系统提供的文件系统存储在硬盘上。 因此存储管理器负责数据库中数据的存储、检索和更新； 存储管理部件包括： 权限及完整性管理器(authorization and integrity manager)：检测是否满足完整性约束，并检查试图访问数据的用户的权限； 事务管理器( transaction manager )：保证数据库及事故障时也保持在一致的状态，保证并发事务的执行不发生冲突； 文件管理器( file manager )：它管理磁盘存储空间的分配，管理用于表示磁盘上存储信息的数据结构； 缓存处理器( buffer manager )：负责将数据从磁盘上取到内存中，决定哪些数据应被缓存。 存储管理器实现了几种数据结构，作为系统物理实现的一部分： 数据文件 存储数据库自身 数据字典 ：存储关于数据库结构的元数据，尤其是数据库模式； 索引：提供对数据项的快速访问。 1.7.2 查询处理器查询处理器组件包括： DDL解释器（DDL interpreter）：他解释DDL语句并将这些定义记录在数据字典中。 DML编译器（DML compiler）：将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。 一个查询通常可翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行查询优化，也就是从几种选择中选出代价最小的一种。 查询执行引擎（query evaluation engine）：执行由DML编译器产生的低级指令； 1.8 事务管理对数据库的几个操作合起来形成一个逻辑单元； 原子性（atomicity）：要求这些操作要么全部完成要么不发生的； 一致性（consistency）：要求结果这种正确性；例如转账后两账户余额之和不变； 持久性（durability）：要求即使发生系统故障，事务完成后的结果依然保持不变； 事务 是数据库应用中完成单一逻辑功能的操作集合； 每个事务是既具有原子性又具有一致性的单元；因此要求事务不违反任何的数据库一致性约束； 如果事务启动时数据库是一致的，那么事务完成结束时也应该时一致的。 而事务执行过程中，必要时允许暂时的不一致；（转账总有转出与转入总得有个顺序） 虽然暂时的不一致时必需的，但故障发生时，很可能导致问题产生； 事务管理器 包括 并发控制管理器 和 恢复管理器； 原子性和持久性的保证是 恢复管理器 的职责；使得系统故障时保证数据的原子性和持久性； 并发控制管理器 控制并发事务间的相互影响， 保证数据库一致性； 1.9 数据库体系结构 数据库系统可以是集中式的、客户/服务器式的（一台服务器为多个客户机执行任务）；也可以针对并行计算机体系结构设计数据库系统；分布式数据库包含地理上分离的多台计算机； 在一个 两层体系结构 中，应用程序驻留在客户机上，通过查询语言表达式来调用服务器上的数据库系统功能； 在一个 三层体系结构 中，客户机只作为一个前端并且不包含任何直接的数据库调用。客户端通常通过一个表单界面与应用服务器进行通信。应用服务器与数据库系统通信以访问数据。 1.10 数据挖掘与信息检索数据挖掘（data mining）指半自动地分析大型数据库并从中找出有用的模式的过程；从数据库中找到的发现的某些类型地只是可以用一套 规则 表示。 1.11 特种数据库数据库系统的一些应用领域收到关系数据库的限制。基于对象的数据模型和半结构化数据模型； 1.12 数据库用户和管理员","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库系统概念","slug":"数据库/数据库系统概念","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"第三章 数据库编程","slug":"database-principle-and-application-chapter-03","date":"2020-11-09T03:17:43.000Z","updated":"2020-11-09T03:19:56.745Z","comments":true,"path":"2020/11/09/database-principle-and-application-chapter-03/","link":"","permalink":"http://zenner006.github.io/2020/11/09/database-principle-and-application-chapter-03/","excerpt":"标准SQL是非过程化的查询语言，具有操作统一，面向集合、功能丰富、使用简单等多项优点； 但它的缺点在于——缺少流程控制能力，难以实现应用业务中的逻辑控制；所以引入了SQL编程； 3.1 MySQL编程基础需要将频繁使用的业务逻辑封装成存储程序； MySQL提供了用于编写结构化程序的数据类型、常量、变量、运算符和表达式等； 3.1.1 常量与变量程序本身不能改变的数据成为常量；程序运行中可以改变其值的数据成为变量； 1. 常量常量的格式取决于其数据类型，常用的常量包括字符串常量、数值常量、日期和时间常量、布尔值常量和NULL值； 1）字符串常量 ​ 用单引号与双引号括起来的字符序列。推荐使用单引号； 2）数值常量","text":"标准SQL是非过程化的查询语言，具有操作统一，面向集合、功能丰富、使用简单等多项优点； 但它的缺点在于——缺少流程控制能力，难以实现应用业务中的逻辑控制；所以引入了SQL编程； 3.1 MySQL编程基础需要将频繁使用的业务逻辑封装成存储程序； MySQL提供了用于编写结构化程序的数据类型、常量、变量、运算符和表达式等； 3.1.1 常量与变量程序本身不能改变的数据成为常量；程序运行中可以改变其值的数据成为变量； 1. 常量常量的格式取决于其数据类型，常用的常量包括字符串常量、数值常量、日期和时间常量、布尔值常量和NULL值； 1）字符串常量 ​ 用单引号与双引号括起来的字符序列。推荐使用单引号； 2）数值常量 ​ 可以分为整数常量和小数常量； 3）日期和时间常量 ​ 使用特定格式的字符日期值表示，单引号括起来。例如：’2018/0717’、’2018-07-17 10:30:20’ 4）布尔值常量 ​ 只有 true 和 false 两个值，SQL命令的运行结果用1代表 true ，用0代表 false 5）NULL 值 ​ 适用于各种字段类型，表示“不确定的值”。NULL值参与的运算，结果仍为 NULL 值； 2. 变量变量有名字和数据类型两个属性。MySQL中存在两种变量，一种是系统定义和维护的全局变量，通常名称前加 @@ 符号；另一种是用户定义的用来存放中间结果的局部变量，通常在名称前加 @ 符号； 1）局部变量 ​ 局部变量作用范围限制在程序内部 ​ （1）局部变量的定义与赋值：使用 SET 语句定义局部变量，并为其赋值；语法格式： 1SET @局部变量名 = 表达式1[, @局部变量名 = 表达式2，··· ]; ​ 注意：可同时定义多个变量； ​ （2）局部变量的显示：使用 SELECT 语句显示局部变量。语法格式： 1SELECT @局部变量名 [ ,@局部变量名,··· ]; 【例】查询emp中雇员SMITH的sal值赋给变量salary，并显示其值 12SET @salary = (SELECT sal FROM emp WHERE ename = 'SMITH');SELECT @salary; 【例】查询emp中雇员SMITH的job和hiredate值赋给变量job_v，hiredate_v并显示两个变量的值； 123SELECT job,hiredate INTO @job_v, @hiredate_v FROM emp WHERE ename = 'SMITH';SELECT @job_v, @hiredate_v; 2）全局变量 全局变量是MySQL系统提供并赋值的变量。用户不能定义全局变量，只能使用。 常用系统全局变量及说明如下表： 全局变量名称 说 明 @@back_log 返回MySQL主要连接请求的数量 @@basedir 返回MySQL安装基准目录 @@license 返回服务器的许可类型 @@port 返回服务器侦听TCP/IP连接所用的端口 @@storage_engine 返回存储引擎 @@version 返回服务器版本号 3.1.2 常用系统函数函数是一组编译好的SQL语句，定义了一组操作，返回数值、数值集合，或执行一些操作； MySQL 的系统函数包括：字符串函数、数学函数、日期和时间函数、系统信息函数等； 1. 字符串函数1）计算字符串字符数和字符串长度的函数 CHAR_LENGTH(str) ：返回字符串 str 所包含的字符个数； LENGTH(str) ：返回字符串的字节长度。一个汉字是3个字节，一个数字或字母是1个字节； 【例】计算字符串字符数和字符串长度 12345SELECT `CHAR_LENGTH('CHINA'), LENGTH('CHINA');% 5 5 %SELECT `CHAR_LENGTH('中国'), LENGTH('中国');% 2 6 % 2）合并字符串函数 CONCAT(s1,s2,···) ：返回连接参数产生的字符串，若任一参数为NULL，则返回NULL； 1SELECT CONCAT('MySQL版本： ', @@version); 3）字符串大小写转换函数 LOWER(str) ：把str中字母字符串全转换成小写字母 UPPER(str) ：把str中字母字符串全转换成大写字母 4）删除空格函数 LTRIM(str) ：返回删除前导空格的字符串 RTRIM(str) ：返回删除后导空格的字符串 TRIM(str) ：返回删除两侧空格的字符串 5）取子串函数 SUBSTRING(str, start, length) 2. 数学函数 ABS(x) PI() SQRT() ：非复数的二次方根 mod(m,n) ：返回m被n除后的余数 ROUND(x,y) ：把 x 四舍五入到 y 指定的精度返回。y 为负数，则将保留 x 值到小数点左边 y 位； 3. 日期和时间函数1）获取当前系统的日期及取日期的年、月、日的函数； CURDDATE year(d)、MONTH(d)、DAY(d) ：分别返回日期或日期时间 d 的年、月、日的值； 2）获取当前系统的日期时间的函数； CURRENT_TIMESTAMP() LOCALTIME() NOW() SYSDATE() 上面几个函数作用相同，均返回当前系统的日期时间；格式为：YYYY-MM-DD HH:MM:SS ； 4. 系统信息函数 USER() ：返回当前登录的用户名 DATABASE() ：返回当前所使用数据库的名 VERSION() ：返回 MySQL 服务器版本号 5. 条件控制函数1）IF()函数：格式为 IF(条件表达式, v1, v2) ，如果表达式为真，则函数返回 v1 值，否则返回 v2 值。 12SELECT ename, IF(comm IS NULL, 0, comm) 奖金 FROM emp LIMIT 5; 2）CASE()函数 123456CASE 表达式 WHEN v1 THEN r1 WHEN v2 THEN r2 ... [ ELSE rn ]END 6. 数据类型转换函数CASE(x AS 新类型) 和 CONVERT(x 新类型) 两个函数作用相同，都是把一种类型的值转换为另一种类型的值； 3.2 程序控制流语句MySQL有编写过程化代码的语法结构，可进行顺序、分支、循环、存储过程、存储函数、触发器等程序设计； 3.2.1 语句块、注释和重置命令结束标记1. 语句块​ BEGIN ··· END 用于定义SQL语句块，语法格式： 123BEGIN SQL语句 | SQL语句块END 说明： （1）BEGIN ··· END 语句块包含了该程序块的所有处理操作，允许语法块嵌套 （2）单独使用 BEGIN ··· END 语法块没有任何意义，主要用于存储过程、存储函数、触发器等存储程序内部才有意义； 2. 注释单行注释和多行注释 1）单行注释 ：使用 “ # ” 符号 2）多行注释： /* 和 */ 括起来是多行注释 3. 重置命令结束标记为什么要重置命令结束标记？ 因为MySQL中，服务器处理的语句是以分号为结束标记的；但在创建存储函数、存储过程的时候，在函数体或存储过程体中可以包含多个SQL语句，每个SQL语句都是以分号为结尾的，而服务器处理程序遇到分号则结束程序的执行；所以需要重置命令结束标记； MySQL使用 DELIMITER 语句将MySQL语句的结束标记修改为其他符号 1DELIMITER 符号 说明 （1）符号可以是一些特殊符号，例如两个“#”、两个“@”、两个“$”、两个“%”等。 （2）恢复使用分号为结束标记，执行 “ DELIMITER ; ” 即可； 3.2.2 存储函数用MySQL编写程序可以根据应用程序的需要创建存储函数 1. 存储函数的创建创建存储函数的，要用到 CREATE FUNCTION 语句， 语法为: 123456CREATE FUNCTION 函数名 ( [ 参数名 参数数据类型 [ ,··· ] ] )RETURNS 函数返回值的数据类型BEGIN 函数体; RETURN 语句;END 2. 调用存储函数对新创建的存储函数，调用方法与调用系统函数相同，语法格式： 1SELECT 函数名 ( [ 参数值 [ ,··· ] ] ) 接下来的例子涉及了 delimeter 在定义存储函数时的使用： 12345678910DELIMITER @@CREATE FUNCTION name_fn(dno DECIMAL(2))RETURNS VARCHAR(14)BEGIN RETURN(SELECT dname FROM dept WHERE deptno = dno );END@@DELIMITER ;SELECT name_fn(20); 3. 删除存储函数用 DROP FUNCTION 语句删除： 1DROP FUNCTION 函数名; 3.2.3 条件判断语句1. 程序中变量的使用局部变量可在程序中声明并使用，这些变量的作用范围是 BEGIN···END 语法块 1） 声明变量 在存储程序（例如存储函数、存储过程、触发器等）中需要使用 DECLARE 语句声明局部变量，语法格式： 1DECLARE 局部变量名 [ ,局部变量名,··· ] 数据类型 [ DEFAULT 默认值 ]; 说明 （1）DECLARE 声明的局部变量，变量名前不能加 @ （2）DEFAULT 子句提供了一个默认值，如果没有给默认值，则局部变量的初始值默认为 NULL ； 2）为变量赋值 变量声明后，用 SET 命令为变量赋值； 1SET 局部变量名 = 表达式1 [, 局部变量名 = 表达式2,··· ]; 2. IF语句IF 有两种形式： 1）形式一 12345IF &lt;条件&gt; THEN SQL语句块 1;[ELSE SQL语句块 2; ]END IF; 2）形式二 12345678IF &lt;条件1&gt; THEN SQL语句块 1;ELSEIF &lt;条件2&gt; THEN SQL语句块 2;···ELSE SQL语句块n;END IF; 3. CASE语句1）形式一 1234567CASE &lt;表达式&gt; WHEN &lt;表达式1&gt; THEN SQL语句块1; WHEN &lt;表达式2&gt; THEN SQL语句块2； ··· WHEN &lt;表达式n&gt; THEN SQL语句块n; [ ELSE SQL语句块n+1; ]END; 2）形式二 1234567CASE WHEN &lt;条件1&gt; THEN SQL语句1; WHEN &lt;条件2&gt; THEN SQL语句2; ··· WHEN &lt;条件n&gt; THEN SQL语句n; ELSE SQL语句块 n+1;END; 3.2.4 循环语句1. LOOP循环LOOP循环为无条件循环，如果没有指定 LEAVE 语句，循环将一直运行，成为死循环；通常是结合条件语句使用；条件语句里嵌入 LEAVE 语句；条件为真，跳出循环； 123456标签: LOOP # # 标签 是自定义的 SQL语句块; IF &lt;条件表达式&gt; THEN LEAVE 标签; # # 通过自己定义的标签结束 LOOP 循环 END IF;END LOOP; 2. WHILE循环123WHILE &lt;条件表达式&gt; DO SQL语句块END WHILE; 3. REPEAT循环1234REPEAT SQL语句块; UNTIL &lt;条件表达式&gt;END REPEAT; 3.3 存储过程概念：存储过程就是一条或多条SQL语句的集合；利用这些SQL语句完成一个或多个逻辑功能； 环境：存储过程可以被赋予参数，存储在数据库中，可以被用户调用，也可以被JAVA 或 C# 等调用； 特性：并且存储过程都是编译好的，调用时不用再次编译，提高了程序的运行效率； 3.3.1 创建存储过程要用 CREATE PROCEDURE 语句 1234CREATE PROCEDURE 存储过程名()BEGIN 过程体;END 3.3.2 调用存储过程使用 CALL 语句直接调用存储过程。 1CALL 存储过程名(); 3.3.3 存储过程的参数存储过程可以接受和返回 0 到多个参数，使程序变得灵活； MySQL 有3种参数模式，即 IN、 OUT、 INOUT。 创建带参数的存储过程的语法格式如下： 12345678CREATE PROCEDURE 存储过程名( [ IN|OUT|INOUT ] 参数1 数据类型 [ IN|OUT|INOUT ] 参数2 数据类型 ...)BEGIN 过程体;END 1. IN参数IN 参数作为输入参数，该参数值由调用者传入，并且只能够被存储过程读取； 1234567891011121314DELIMITER @@CREATE PROCEDURE dept_pl( IN p_deptno DECIMAL(2,0), IN p_dname VARCHAR(14), IN p_loc VARCHAR(13))BEGININSERT INTO dept VALUES (p_deptno, p_name, p_loc);END@@DELIMITER ;CALL dept_pl(50, &#39;HR&#39;, &#39;CHINA&#39;);SELECT * FROM dept WHERE deptno &#x3D; 50; 2. OUT参数OUT参数为输出参数，该类型的参数值由存储过程写入； 比较适合于向调用者返回多条信息的过程； 1234567891011121314DELIMITER @@CREATE PROCEDURE dept_p2( IN i_no DECIMAL(2,0), OUT o_name VARCHAR(14), OUT o_loc VARCHAR(13))BEGINSELECT dname, loc INTO o_name, o_loc FROM dept WHERE deptno &#x3D; i_no;END@@DELIMITER ;CALL dept_p2(10, @v_name, @v_loc);SELECT @v_dname, @v_loc; 3. INOUT参数INOUT 类型得参数同时具有 IN , OUT 的特性，在过程中可以读取和写入该类型参数； IN 参数可以接收一个值，但不能修改这个值； OUT参数被调用时为空，在执行过程中将这个参数指定一个值，过程执行结束后返回； 使用 INOUT 参数实现两个数的交换 1234567891011121314151617DELIMITER @@CREATE PROCEDURE swap( INOUT p_num1 int, INOUT p_num2 int)BEGIN DECLARE var_temp int; SET var_temp &#x3D; p_num1; SET p_num1 &#x3D; p_num2; SET p_num2 &#x3D; var_temp;END@@DELIMITER ;SET @v_num1 &#x3D; 1;SET @v_num2 &#x3D; 2;CALL swap(@V_num1, @v_num2);SELECT @v_num1, @v_num2; 3.3.4 删除存储过程指删除数据库中已存在的存储过程；使用 DROP PROCEDUER 语句来删除存储过程； 1DROP PROCEDURE 存储过程名; 3.4 游标当通过 SELECT 语句查询时，返回的是一个由多行记录组成的集合；而程序设计语言不能处理以集合形式返回的数据，为此SQL提供了游标机制； 游标充当指针使用，使应用程序设计语言一次只能处理查询结果中的一行； 3.4.1 游标的定义和使用游标是在存储程序中使用包含 SELECT 语句 1. 声明游标使用 DECLARE 语句；语法形式： 12DECLARE 游标名 CURSOR FOR SELECT 语句; 说明： （1）声明游标的作用是得到一个 SELECT 查询结果集。游标为用户提供逐行处理的途径； （2）SELECT 语句是对表或视图的擦汗寻语句；可以带 WHERE，ORDER BY，GROUP BY 等子句；但不能使用INTO 2. 打开游标打开游标使用OPEN语句，语句形式： 1OPEN 游标名; 游标必须先声明后打开，在打开游标时，SELECT语句的查询结果被传送到了游标工具区，供用户读取； 3. 提取数据打开游标后，使用 FETCH 语句将游标工作区中的数据读取到变量中，语法格式如下： 1FETCH 游标名 INTO 变量名1[, 变量名2···]; 成功打开游标时，游标指针在第一行之前，而 FETCH 语句使游标指向下一行。 可以在循环中使用 FETCH 语句，每次循环都会从表中读取一行数据； 4. 关闭游标游标使用完后，需要用 CLOSE 语句关闭，语法形式: 1CLOSE 游标名; 3.4.2 异常处理在存储过程中出现错误可能导致程序终止。 错误发生时希望不要终止执行，而是通过MySQL的错误处理机制帮助控制程序流程； 存储过程中的错误处理通过 DECLARE HANDLER 语句实现，语法如下： 1DECLARE 错误处理类型 HANDLER FOR 错误触发条件 自定义错误处理程序; 说明 （1）一般情况下，异常处理语句置于存储程序中才有意义； （2）异常处理语句必须放在所有变量和游标定义之后，所有MySQL表达式之前； （3）错误处理类型：错误处理类型只有 CONTINUE 和 EXIT 两种； CONTINUE 表示错误发生后MySQL立即执行自定义错误处理程序，然后忽略该错误继续执行其他的程序； EXIT 表示错误发生后 MySQL 立即执行自定义错误处理程序，然后立即停止其他MySQL语句的执行； （4）错误触发条件：错误除法条件定义了自定义错误处理程序运行的时机；错误触发条件的形式： 12345SQLSTATE &#39;ANSI标准错误代码&#39;|MySQL错误代码|SQLWARNING|NOT FOUND|SQLEXCEPTION 错误触发条件支持标准的SQLSTATE定义，也支持MySQL的错误代码； SQLWARNING表示对所有以01开头的SQLSTATE代码的速记； NOT FOUND表示对所有以02开头的SQLSTATE代码的速记 SQLEXCEPTION 表示对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记； （5）自定义错误处理程序 错误发生后，MySQL会立即执行自定义错误处理程序中的 MySQL 语句； // 这个过程比较抽象；我觉得需要结合代码来认识； 123456789101112131415161718192021222324DELIMITER @@CREATE PROCEDURE emp_up_pro() BEGIN DECLARE v_empno DECIMAL(4,0); DECLARE v_sal DECIMAL(7,2); DECLARE v_comm DECIMAL(7,2); DECLARE flag BOOLEAN DEFAULT TRUE; DECLARE comm_cur CURSOR FOR SELECT empno, sal FROM emp_c; DECLARE CONTINUE HANDLER FOR NOT FOUND SET flag &#x3D; FALSE; OPEN comm_cur; WHILE flag DO FETCH comm_cur INTO v_empno, v_sal; IF v_sal &lt; 500 THEN SET v_comm &#x3D; v_sal * 0.25; ELSEIF v_sal &lt; 1000 THEN SET v_comm &#x3D; v_sal * 0.2; ELSEif v_sal &lt; 3000 THEN SET v_comm &#x3D; v_sal * 0.15; ELSE SET v_comm &#x3D; v_sal * 0.12; END IF; UPDATE emp_c SET comm &#x3D; v_comm WHERE empno &#x3D; v_empno; END WHILE; CLOSE comm_cur; END@@ 这里面的异常处理用于处理在游标到达空指针时使得程序正常结束； 3.5 嵌入式SQL被嵌入的程序设计语言被称为宿主语言，简称主语言； 3.5.1 SQL与宿主语言接口嵌入式SQL语句一般采用预编译方法处理，由RDBMS的预处理程序对源程序进行扫描，识别出ESQL语句，把他们转换成主语言调用语句，以使主语言编译程序能够识别它们，最后由主语言的编译程序将整个源程序编译成目标码；（SQL语句被转为了一种供主语言调用的语句） 1. 区分主语言语句与SQL语句在嵌入式SQL中需要区分主语言语句与SQL语句；所以需要把所有的SQL语句加前缀；C语言时的形式为： 1EXEC SQL SQL语句; 2. 嵌入式SQL语句与主语言的通信程序执行过程中，主语言需要与SQL语句进行信息交换，其间的通信过程如下： SQL语句将执行状态信息传递给主语言； 主语言得到状态信息后，可以根据这个状态信息来控制程序流程； 向主语言传递SQL执行信息，主要用SQL通信区实现； 主语言需要提供一些变量参数给SQL语句； 在主语言中定义主变量，在SQL语句中使用主变量，将参数值传递给SQL语句； 将SQL语句查询数据库的结果返回给主语言做进一步处理； 如果SQL语句返回的时一条数据库记录，可使用主变量；若返回值为多条记录的集合，则使用游标； 3.5.2 SQL通信区SQL语句执行后要返回给应用程序若干信息，主要包括描述系统当前状态和运行环境的各种参数；这些信息被送到SQL通信区——SQLCA中。 主语言的应用程序从SQLCA中取出这些状态信息，据此决定后面语句的执行； SQLCA是一个数据结构，其中有一个系统变量SQLCODE，用来存放每次执行SQL语句后返回的代码； 应用程序每执行一条SQL语句后均测试一下SQLCODE的值，了解SQL语句的执行情况并作相应的处理；如果SQLCODE等于预定义的常量SUCCESS，则表示成功，否则在SQLCODE中存放错误代码。 3.5.3 主变量的定义与使用在嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据。在SQL语句中使用的主语言程序变量简称为主变量。 主变量根据作用不同，分为输入变量和输出变量； 在 SELECT INTO 和 FETCH 语句之后的主变量称为“输出主变量” 除了SELECT INTO 和 FETCH 语句以外的其他SQL语句称为“输入主变量” 1. 主变量的定义在使用主变量之前，必须在SQL语句 BEGIN DECLARE SECTION 与 END DECLARE SECTION 之间声明； 声明后可以在SQL语句中任何一个能够使用表达式的地方出现，为了与数据库对象名区别，应在SQL语句中的主变量名前加冒号（:）； 注意 （1）主变量使用前，必须在嵌入SQL语句的说明部分明确定义； （2）主变量定义时，所用的数据类型为主语言提供的数据类型；注意大小写； （3）在SQL语句中使用主变量时，必须在主变量前加一个冒号（:），在主语言语句中不需要加冒号 （4）主变量不能是SQL命令的关键字； （5）在一条SQL语句中，主变量只能使用一次； 2. 在SELECT语句中使用主变量在嵌入式SQL中，如果查询结果为单记录，则 SELECT 语句需要用 INTO 子句指定查询结果的存放地点——主变量； 3. 在INSERT语句中使用主变量在 INSERT 语句的 VALUES 子句中，可以使用主变量指定插入的值： 12EXEC SQL INSERT INTO grade(学号,课号,分数) VALUES(:hsno, :hcno, :hgrade); 4. 在UPDATE语句中使用主变量在 UPDATE 语句的 SET 子句和 WHERE 子句中，均可使用主变量； 123EXEC SQL UPDATE grade SET 分数 = :mgrade WHERE 学号 = :msno AND 课号 = :mcno; 5. 在DELETE语句中使用主变量在 DELETE 语句的 WHERE 子句中，可以使用主变量指定删除条件： 12EXEC SQL DELETE FROM grade WHERE 学号 = :msno; 3.5.4 嵌入式SQL中游标的定义与使用用嵌入式 SQL 语句查询数据分为两类情况：一类是多行结果，一类是多行结果； 对于单行结果，可以使用 SELECT INTO 语句； 对于多行结果，必须使用游标来完成； 包括四步：声明游标，打开游标，提取数据，关闭游标； 1. 声明游标12EXEC SQL DECLARE 游标名 CURSOR FOR SELECT 语句; 2. 打开游标1EXEC SQL OPEN 游标名; 3. 提取数据1EXEC SQL FETCH 游标名 INTO 主变量[,主变量，···]; 4. 关闭游标1EXEC SQL CLOSE 游标名; 3.5.5 动态SQL语句动态SQL技术主要有以下两个SQL语句； 1）动态SQL预备语句； 1EXEC SQL PREPARE 动态 SQL 语句名 FROM 共享变量或字符串; 2）动态SQL执行语句 1EXEC SQL EXECUTE 动态 SQL 语句名;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库原理及应用","slug":"数据库/数据库原理及应用","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"name":"数据库基础知识","slug":"数据库/数据库原理及应用/数据库基础知识","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"第二章 关系数据库标准语言 SQL","slug":"database-principle-and-application-chapter-02","date":"2020-10-24T07:01:21.000Z","updated":"2020-10-24T07:13:58.979Z","comments":true,"path":"2020/10/24/database-principle-and-application-chapter-02/","link":"","permalink":"http://zenner006.github.io/2020/10/24/database-principle-and-application-chapter-02/","excerpt":"2.1 SQL语言介绍SQL（Structured Query Language）语言是一种在关系数据库中定义和操纵数据的标准语言，是用户与数据库之间进行交流的接口。 2.1.1 SQL数据库的体系结构SQL语言支持关系数据库的三级模式、二级映像的结构，二级映像保证了数据库的数据独立性； SQL的关系数据库具有的特点： SQL用户可以是应用程序，也可以是终端用户。（嵌入应用程序中，也可以直接访问） SQL用户可以用SQL语言对基本表和视图进行查询。 一个视图是从若干基本表或其他视图上导出的表。在数据库中只存放该视图的定义，不存放该视图所对应的数据。数据都是来自于基本表。视图是一个虚表； 一个或一些基本表对应一个数据文件 一个基本表也可以放在若干数据文件中。 一个数据文件对应存储设备上的一个存储文件； 一个基本表可以带若干索引。索引也放在数据文件中。 一个表空间可以由若干数据文件组成； 一个数据库可以由多个存储文件组成；","text":"2.1 SQL语言介绍SQL（Structured Query Language）语言是一种在关系数据库中定义和操纵数据的标准语言，是用户与数据库之间进行交流的接口。 2.1.1 SQL数据库的体系结构SQL语言支持关系数据库的三级模式、二级映像的结构，二级映像保证了数据库的数据独立性； SQL的关系数据库具有的特点： SQL用户可以是应用程序，也可以是终端用户。（嵌入应用程序中，也可以直接访问） SQL用户可以用SQL语言对基本表和视图进行查询。 一个视图是从若干基本表或其他视图上导出的表。在数据库中只存放该视图的定义，不存放该视图所对应的数据。数据都是来自于基本表。视图是一个虚表； 一个或一些基本表对应一个数据文件 一个基本表也可以放在若干数据文件中。 一个数据文件对应存储设备上的一个存储文件； 一个基本表可以带若干索引。索引也放在数据文件中。 一个表空间可以由若干数据文件组成； 一个数据库可以由多个存储文件组成； 2.1.2 SQL的特点SQL语言是一个综合的、通用的、功能极强的同时简洁易学的语言；集数据定义、数据查询、数据操纵和数据控制于一体； 综合统一：风格统一，可以完成数据生命周期中的全部活动。 高度非过程化：指示做什么，而与去做的过程无关； 面向集合的操作方式：一次操作得到若干记录； 同一种语法结构提供两种使用方式：SQL既可以是独立式语言，又是嵌入式语言； 语言简洁，易学易用 Sql功能 动词 数据定义 CREATE、DROP、ALTER 数据操纵 INSERT、DELETE、UPDATE、SELECT 数据控制 COMMIT、ROLLBACK、GRANT、REVOKE 2.1.3 SQL语言的组成1. 数据定义语言（DDL）​ 创建、修改、删除和重命名数据库（CREATE、DROP、ALTER、RENAME）；还有删除表中所有行，但不删除表（TRUNCATE） 2. 数据操作语言（DML）​ 增删改查现有数据行 3. 数据控制语言（DCL）​ 用于事务控制，并发控制，完整性和安全性控制等； 2.2 数据定义SQL的数据定义包括数据库定义、表的定义、视图和索引的定义； 2.2.1 数据库的定义和删除1. 创建数据库1CREATE DATABASE 数据库名 2. 选则数据库1USE 数据库名 3. 删除数据库1DROP DATABASE 数据库名 2.2.2 数据类型Mysql支持的数据库类型主要分为4类，即字符串类型、数值类型、日期和时间类型，布尔类型。 1. 字符串类型常用字符类型式CHAR, VARCHAR类型 CHAR：描述定长的字符串，说明格式的语法为：CHAR(L)；L表示字符串最大长度，取值范围为 1 ~ 255；比L大截断，小了补空格填补； VARCHAR：描述变长的字符串，说明格式为：VARCHAR(L)；L表示字符串长度，取值范围为 1 ~ 255；比L大截断，小了不会用空格填补，按实际长度存储； ​ 字符串要用单引号或双引号括起来； 2. 数值类型常用数值类型是INT,DECIMAL类型 INT：表示整数，存储长度默认为4个字节。说明格式为INT; DECIMAL：用来表示所有的数值数据，说明格式为DECIMAL(p,s)，p表示数值数据的最大长度， s表示数值数据中小数点后的数组位数，p，s在定义时可以省略； 3. 日期和时间类型常用的日期和时间类型时DATA，TIME，DATETIME类型 DATE：用来保存固定长度的日期数据，说明格式为DATE; 日期值格式为YYYY-MM-DD; TIME：保存固定长度的时间数据，说明格式为TIME；时间值格式为HH:MM:SS; DATETIME：保存固定长度的日期时间数据，说明格式为DATETIME；日期时间值格式为YYYY-MM-DD HH:MM:SS； 4. 布尔类型布尔类型BOOLEAN类型只有两个值——TRUE和FALSE，即真值和假值； 2.2.3 基本表的定义、删除和修改表是数据库存储数据的基本单元； 表中存储数据的逻辑结构是一张二维表，即表由行、列两部分组成。 称表中的一行 为 一条记录； 称表中的一列 为 一个属性； 1. 创建表graph TD A[创建表] -->B(定义表的结构) B -->C[表名] B -->D[各个列] D -->E[列名] D -->F[列的数据类型] D -->H[列上的约束] B -->G[表上的约束] 12345CREATE TABLE 表名( &lt;列明&gt; &lt;数据类型&gt; [DEFAULT&lt;默认值&gt;] [,···])； TIP： 使用 DESC 显示表的结构 设置了自增类型的字段，需将其设置为主键，否则创建失败。 表明日期时间可用当下系统时间补充，用CURRENT_TIMESTAMP; 2. 利用子查询来创建表12CREATE TABLE &lt;表名&gt; SELECT 语法； 例如： 12CREATE TABLE dept_c SELECT * FROM dept； 3. 修改表的结构对表的修改包括：增加新的列，删除原有的列或修改列的数据类型，宽度等； ​ 1）增加一个新列 12ALTER TABLE &lt;表名&gt; ADD [COLUMN] &lt;列名&gt; &lt;数据类型&gt; [DEFAULT &lt;默认值&gt;]; 一次只能增加一个新列 ​ 2）修改一个表中已有的列 12ALTER TABLE &lt;表名&gt; MOIFY [COLUMN] &lt;列名&gt; &lt;数据类型&gt; [DEFAULT &lt;默认值&gt;]; ​ 3）从一个表中删除一列 12ALTER TABLE &lt;表名&gt; DROP [COLUMN] &lt;列名&gt;； 4. 截断表和删除表​ 1）截断表：删除数据保留表结构 1TRUNCATE TABLE &lt;表名&gt;； ​ 2）删除表：删除数据和表结构 1DROP TABLE &lt;表名&gt;； 2.3 数据查询SELECT语句的基本语法如下： 123456SELECT * | &lt;列名 | 列表达式&gt;[,&lt;列名 | 列表达式&gt;]···FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt;]···[ WHERE &lt;条件表达式&gt; ][ GROUP BY &lt;分组列名1&gt;[,&lt;分组列名2&gt;]]··· [ HAVING &lt;组条件表达式&gt; ][ ORDER BY &lt;排序列名1 [ ASC| DESC ]&gt;[,&lt;排序列名2 [ ASC| DESC ]&gt;]···]; []表示该部分可选；&lt;&gt;表示该部分必有。 执行过程如下 读取FROM子句中的表、视图的数据，如果是多个表或视图，执行笛卡尔积操作； 选择满足WHERE子句中给出的条件表达式的记录； 按GROUP BY子句中指定列的值对记录进行分组，同时提取满足HAVING子句中组条件表达式的那些组； 按SELECT子句中给出的列名或列表达式求值输出； ORDER BY子句对输出的记录进行排序； 2.3.1 基本查询1. SELECT子句的规定SELECT子句用于描述输出值的列明或表达式； 1SELECT [ ALL | DISTINCT ] * | &lt;列名或列名表达式&gt; DISTINCT：表示输出无重复结果的记录； ALL：选项是默认的表示输出所有记录，包括重复记录 1）查询所有列 1SELECT * FROM dept; 2）查询指定的列 1SELECT deptno, dname FROM dept; 3）去掉重复的行 1SELECT deptno, job FROM emp; 上面的这个语句会把所有的输出出来，有重复的行值出现，需要去掉重复的记录，则可以用下面的语句： 1SELECT DISTINCT deptno, job FROM emp; 2. 为列起别名的操作1原字段名 [AS] 列别名 3. 使用WHERE子句指定查询条件WHERE子句后的行表达式可以由运算符组合而成，常用的比较运算符： 运算符名称 符号及格式 说明 算术比较判断 &lt;、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、= 比较两个表达式的值 逻辑比较判断 NOT、AND、OR 非与或操作（优先级高低排序） 之间判断 &lt;表达式&gt;[ NOT ] BETWEEN &lt;值1&gt; AND &lt;值2&gt; 搜索（不）在指定范围里的值 字符串模糊判$断^1$ &lt;字符串&gt; [ NOT ] LIKE &lt;匹配模式&gt; 查找（不）在给定模式的值 空值判断 &lt;表达式&gt; IS [ NOT ] NULL 判断是否为空值 之内判断 &lt;表达式&gt; [ NOT ] IN (&lt;集合&gt;) 判断表示式的值是否在集合内 模糊判断匹配字符串模式使用通配符 % 和 _ 。%用于表示0个或任意多个字符，_表示任意一个字符； 4. 使用ORDER BY子句对查询结果排序使用ORDER BY子句对查询结果进行排序时要注意一下两点： （1）当SELECT语句中包含多个子句时，ORDER BY 必须是最后一个； （2）可以使用列的别名、列的位置（SELECT子句中的顺序）进行排序； 2.3.2 分组查询数据分组市容过在SELECT语句中加入GROUP BY子句完成的。通常用聚合函数对每个组的数据进行汇总、统计；用 HAVING 子句来限定查询结果集中只显示分组后的、其聚合函数的值满足指定条件的那些组； 1. 聚合函数 函数 说明 COUNT(*) COUNT(&lt;列名&gt;) 记录的个数；对一列中的值计算个数 SUM(&lt;列名&gt;) 求某一列的总和 AVG(&lt;列名&gt;) 求某一列的平均值 MAX(&lt;列名&gt;) 求某一列的最大值 MIN() 求某一列的最小值 使用聚合函数要注意的点： （1）聚合函数只能出现在所查询的列、ORDER BY子句、HAVING子句中，不能出现在WHERE子句、GROUP BY子句中。 （2）除了COUNT(*)之外，其他聚合函数都忽略对列值为NULL的统计； 2. 使用GROUP BY子句1）按单列分组 【例】查询emp表中每个部门的平均工资和最高工资，按部门编号升序排列； 123SELECT deptno, AVG(sal) 平均工资，MAX(sal) 最高工资 FROM emp GROUP BY deptno ORDER BY deptno； 2）按多列分组 【例】查询emp表中每个部门、每种岗位的平均工资和最高工资； 123SELECT deptno, AVG(sal) 平均工资，MAX(sal) 最高工资 FROM emp GROUP BY deptno, job ORDER BY deptno； 3. 使用HAVING子句【例】查询部门编号在30以下的各个部门的部门编号、平均工资，要求只显示平均工资大于等于2000的信息； 1234SELECT deptno, AVG(sal) 平均工资 FROM emp WHERE deptno&lt;30 GROUP BY deptno HAVING AVG(sal)&gt;=2000; 2.3.3 连接查询连接查询是指对两个或两个以上的表或视图的查询。连接查询是关系数据库中最主要、最有意义的查询，是关系数据库的一项核心功能； MySql提供了4种类型的连接，即相等连接、自身连接、不等连接和外连接； 1. 相等连接也称为简单连接或内连接，是把两个表中指定列的值相等的行连接起来； 【例】查询工资大于等于3000的员工的信息 12345SELECT empno, ename, sal, e.deptno, loc FROM emp e, dept d WHERE e.deptno = d.deptno AND sal &gt;= 3000 ORDER BY e.deptno; 可用ON子句来实现内连接 12345SELECT empno, ename, sal, e.deptno, loc FROM emp e INNER JOIN dept d ON e.deptno = d.deptno WHERE sal &gt;= 3000 ORDER BY e.deptno; 2. 自身连接是通过把一个表定义为两个不同别名的方法来完成自身连接的； 【例】一个雇员表，含有雇员编号，管理员编号。管理员也是雇员；所以这两列有参照关系； 1234SELECT e.ename 雇员, m.ename 管理员 FROM emp e, emp m WHERE m.empno = e.mgr AND e.deptno = 20; 3. 不等连接用其他运算符产生的连接叫做不等连接； 4. 左外连接左外连接的格式如下： 1FROM 表 1 LEFT OUTER JOIN 表 2 ON 表1.列 = 表2.列; 左外连接的结果是显示表1中的所有记录和表2中与表1.列相同的记录； 5. 右外连接右外连接的格式如下： 1FROM 表1 RIGHT OUTER JOIN 表2 ON 表1.列 = 表2.列; 左外连接的结果是显示表2中的所有记录和表1中与表2.列相同的记录； 2.3.4 子查询子查询是指嵌入在其他SQL语句中的一个查询。最多可以嵌套255层； 使用子查询可以用一系列简单的查询构成复杂的查询，从而增强SQL语句的功能； 执行步骤 （1）首先取外层查询中表的第一个记录，根据它与内存查询相关列值进行内层查询的处理，若处理结果为真，则取此记录放入结果集。 （2）然后取外层表的下一个记录进行内层查询的处理 （3）重复这一过程，直到外层查询中表的全部记录处理完为止； 1. 返回单值的子查询单值子查询向外层查询值返回一个值； 2. 返回多值的子查询多值子查询可以向外层查询返回多个值；在WHERE子句中使用多值子查询时必须使用多值比较运算符，例如 [not] IN，[not] EXISTS，ANY，ALL，其中ANY，ALL必须与比较运算符结合使用； 1）使用 IN 操作符的多值子查询 比较运算符IN的含义为子查询返回列表中的任何一个。 IN操作符比较子查询返回列表中的每一个值，并且显示任何相等的数据行； 【例】查询所在岗位工资最高的员工信息，不包括CLERK和PRESIDENT； 123SELECT empno, ename, job, sal FROM emp WHERE sal IN (SELECT MAX(sal) FROM emp GROUP BY job) AND job&lt;&gt;'CLERK' AND job&lt;&gt;'PRESIDENT'; 注：这个例子的答案是错误的；根据薪资不能成立某岗薪资最高员工的参照关系； 大约应该写成这样才是正确的，不过这已经失去了展示 IN 操作符的意义了； 123SELECT empno, ename, job, sal FROM emp, (SELECT job, MAX(sal) as MAXsal FROM emp GROUP BY job) as M WHERE job = M.job AND sal = M.Maxsal AND job&lt;&gt;'CLERK' AND job&lt;&gt;'PRESIDENT'; 2）使用ALL操作符的多值子查询 ALL操作符比较子查询返回列表中的每一个值。 &lt; ALL 为小于最小的， &gt; ALL 为大于最大的； 【例】查询高于部门20的所有雇员工资的雇员信息 12SELECT ename, sal, job FROM emp WHERE sal &gt; ALL(SELECT sal FROM emp WHERE deptno = 20); 3）使用ANY操作符的多值子查询 ANY操作符比较子查询返回列表中的每一个值。 &lt; ALL 为小于最大的， &gt; ALL 为大于最小的； 【例】查询高于部门20的任何雇员工资的信息 12SELECT ename, sal, job FROM emp WHERE sal &gt; ANY(SELECT sal FROM emp WHERE deptno = 10); 4）使用EXISTS操作符的多行查询 EXISTS操作符比较子查询返回列表中的每一个行。 使用 EXISTS 时应注意外层查询的 WHERE 子句格式为 WHERE EXISTS； 在内层子查询必须有WHERE 子句； 2.3.5 合并查询结果当两个 SELECT 查询结果的结构完全一致时，可以对这两个查询执行合并运算，运算符为 UNION； UNION 的语法格式如下： 1234SELECT 语句1 UNION [ALL]SELECT 语句2 ORDER BY XXX; UNION 在连接数据表的查询结果时，结果会删除重复的行，返回的行都是唯一的； 在使用 UNION ALL 的时候，结果不会删除重复行； 对合并查询结果进行排序，要排序的列名一定是来自第一个表中的列名（即使是别名）； 2.4 数据的维护数据维护是指用INSERT, DELETE，UPDATE语句来插入、删除、更新数据库表中记录行的数据，由DML语言实现； 2.4.1 插入数据1. INSERT语句123INSERT INTO 表名 [ ( 列名1[, 列名2···]) ] VALUES (值1[,值2···]) [,(值1[,值2···]),···,(值1[,值2···])] 说明： （1）插入数据时，列的个数、数据类型、顺序必须要和所提供数据的个数、数据类型，顺序保持一致或匹配； （2）如果省略了表名后面列的列名表，即表示要为所有列插入数据，则必须根据表结构定义中的顺序为所有列提供数据，否则会出错； 【例】复制另一个表 12CREATE TABLE dept_c SELECT * FROM dept; 【例】插入数据示例 12INSERT INTO dept_c(deptno, dname, loc) VALUES(50, 'PERSONNEL', 'HONGKONG'); 12INSERT INTO dept_c VALUES(50, 'PERSONNEL', 'HONGKONG'); 2. 利用子查询向表中插入数据12INSERT INTO 表名[ ( 列名1 [ ,列名2··· ] ) ] SELECT 语句; 2.4.2 更新数据1. UPDATE语句123UPDATE 表名 SET 列名 = 值 [,列名=值,··· ] [ where &lt;条件&gt; ]; 说明：如果不用WHERE子句先定要更新的数据行，则会更新整个表的数据行； 注意：MySql运行在 SAFE_UPDATES 模式下，该模式会导致在非主键条件下无法执行 UPDATE 或 DELETE 命令，需要执行 SET SAFE_UPDATES = 0 修改数据库模式； 【例】更新 dept_c 表中部门10的地址为 CHINA 1234SET SAFE_UPDATES = 0UPDATE dept_c SET loc = 'CHINA' WHERE deptno = 10; 【例】将 dept_c 表中所有部门的地址改为 CHICAGO 12UPDATE dept_c SET loc &#x3D; &#39;CHICAGO&#39;; 2. 利用子查询修改记录【例】更新部门40的部门名称 123UPDATE dept_c SET dname = (SELECT dname FROM dept WHERE deptno=40) WHERE deptno = 40; 2.4.3 删除数据1. DELETE语句12DELETE FROM 表名 [ WHERE &lt;条件&gt; ]; 说明： （1）DELETE 是按行删除数据，不是删除行中某些列的数据； （2）如果不用WHERE子句限定要删除的数据行，则会删除整个表的数据行。 （也可以用截断表的语句实现，格式为 TRUNCATE TABLE 表名 ) 2. 利用子查询删除行2.5 索引和视图索引可以帮助用户提高查询数据的效率，类似于书中的目录。 视图是一张虚拟表，是基于一个或几个数据表生成的逻辑表； 2.5.1 索引的创建与删除1. 创建索引创建索引有两种办法： （1）系统自动建立：当用户在一个表上建立主键（PRIMARY KEY）或唯一（UNIQUE）约束时，系统会自动创建唯一索引（UNIQUE INDEX）； （2）手工建立：用户在一个表中的一列或多列上用CREATE INDEX语句来创建非唯一索引（NONUNIQUE INDEX）。 创建索引的语句格式 1CREATE [ UNIQUE ] INDEX 索引名 ON 表名(列名[ ,列名 ]···); 【例】为 emp_c 表按员工的名字建立索引，索引名为emp_ename_idx; 12CREATE INDEX emp_ename_idx ON emp_c(ename); 【例】为 emp_c 表按工作和工资建立索引，索引名为emp_job_sal_idx 12CREATE INDEX emp_job_sal_idx ON emp_c(job,sal); 索引名的命名一般采用 表名_列名_idx 方式； 2. 查看索引查看索引的语法： 1SHOW INDEX FROM &lt;表名&gt;; 【例】查看emp_c的索引信息 1SHOW INDEX FROM emp_c; 3. 删除索引当一个索引不再需要时，应该删除它； 删除索引的语句格式 1DROP INDEX 索引名 ON 表名 4. 使用索引时应注意的问题一条DML只要涉及到索引关键字，DBMS就得调整索引； 索引是需要消耗磁盘空间的；如果表很大，其索引消耗磁盘空间的量也会很大。 满足以下条件之一，就可以为该列建立索引 （1）表上的 INSERT , DELETE， UPDATE操作较少； （2）一列或多列经常出现在WHERE子句或连接条件中； （3）一列或多列经常出现在 GROUP BY 或 ORDER BY 操作中； （4）如果表很大，但大多数查询返回的数据量很少。因为如果返回数据量很大，就不如顺序地扫描这个表了； （5）刺裂的取值范围很广，一般为随机分布； （6）表中包含了大量的NULL值； 2.5.2 视图视图（View）是由 SELECT 子查询语句定义的一个逻辑表；只有定义没有数据，是一个“虚表”； 视图的使用和管理是可以被创建、更改和删除； 视图是查看和操作表中数据的一种方法。除了 SELECT 之外，视图在 INSERT、 UPDATE、DELETE方面受到某些限制； 1. 为什么建立视图1）提供各种数据表现形式，隐藏数据的逻辑复杂性并简化查询语句； ​ 可以使用各种不同的方式将基础表的数据展现在数据面前，以便符合用户的使用习惯；（比如提供多表查询视图。让用户在视图上操作，隐藏了多表数据的复杂逻辑，简化了用户查询语句） 2）提供某些安全性保证，简化用户权限管理 ​ 视图可以实现让不同的用户看见不同的列，从而保证某些敏感数据不被某些用户看到；可以面向视图的对象权限授予用户，简化用户的权限定义； 3）对重构数据库提供了一定的逻辑独立性 ​ 视图是数据库三级模式中外模式在具体 DBMS 中的体现；概念模式发生改变，外模式具有逻辑独立性； 2. 创建视图通过 CREATE VIEW 语句创建视图，创建视图的语句格式如下： 1234CREATE [OR REPLACE] VIEW 视图名[ (别名 [ ,别名 ] ) ] ASSELECT 语句 [WITH CHECK OPTION]; 说明： （1）OR REPLACE : 创建的视图已存在，MySQL系统会重建这个视图。 （2）别名 ：为视图所产生的列定义的列名 （3）WITH CHECK OPTION ： 所插入或修改的数据行必须满足视图所定义的约束条件； （4）在子查询语句中不能包含 ORDER BY 子句 【例】创建带有 WITH CHECK OPTION 选项的视图 12345CREATE VIEW v_dept AS SELECT empno, ename, job, deptno FROM emp WHERE deptno = 10 WITH CHECK OPTION; 这个条件的限制了只能插入deptno为10的； 3. 修改视图MySQL中可以通过 CREATE OR REPLACE VIEW 语句和 ALTER语句来修改视图； CREATE OR REPLACE VIEW 是用创建视图的语句将原来的视图覆盖掉； 【例】修改上一例中的视图。取消约束条件检查 1234CREATE OR REPLACE VIEW v_dept AS SELECT empno, ename, job, deptno FROM emp WHERE deptno = 10; 使用 ALTER 语句修改视图，语句格式如下： 1234ALTER VIEW 视图名[ (别名 [ ,别名 ]···) ] AS SELECT 语句 [WITH CHECK OPTION]; 【例】修改上上一例中的视图。取消约束条件检查 1234ALTER VIEW v_dept_chk AS SELECT empno, ename, job, deptno FROM emp WHERE deptno = 10; 4. 删除视图使用 DROP VIEW 语句删除视图，删除视图对创建该视图的基础表或视图没有任何影响。其语句格式如下： 1DROP VIEW 视图名 [, 视图,···] 5. 使用视图进行DML操作用户通过视图对基本表中的数据进行 DML 的UPDATE、 INSERT、 DELETE 操作。 视图分为 简单视图 和 复杂视图 它们的区别如下： 1）简单视图 （1）数据是仅从一个表中提取的 （2）不包含函数和分组数据 （3）可以通过该视图进行DML操作 2）复杂视图 （1）数据是从多个表中提取的 （2）包含函数和分组数据 （3）不一定能够通过该视图进行DML操作 下面给出通过视图进行 DML 操作的规则 （1）可以在简单视图上执行 DML 操作 （2）如果在一个视图中包含了分组函数，GROUP BY子句，或 DISTINCT关键字，则不能通过该视图进行增删改操作； （3）如果在一个视图中包含了由表达式组成的列，则不能通过该视图进行 UPDATE、INSERT操作 （4）如果在一个视图中没有包含引用表中那些不能为空的列，则不能通过该视图进行 INSERT 操作","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库原理及应用","slug":"数据库/数据库原理及应用","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"name":"数据库基础知识","slug":"数据库/数据库原理及应用/数据库基础知识","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"左神算法-基础课-02-代码","slug":"zuoshen-basic-class-2-code","date":"2020-10-19T03:13:05.000Z","updated":"2020-12-11T10:00:09.348Z","comments":true,"path":"2020/10/19/zuoshen-basic-class-2-code/","link":"","permalink":"http://zenner006.github.io/2020/10/19/zuoshen-basic-class-2-code/","excerpt":"快速排序123456public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; quickSort(arr, 0, arr.length-1);&#125;","text":"快速排序123456public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; quickSort(arr, 0, arr.length-1);&#125; 12345678public static void quickSort(int[] arr, int l, int r) &#123; if (l &lt; r)&#123; swap(arr, l + (int)(Math.random() * (r - l + 1)), r); // 随机找一个数作为分割的数字； int[] p = partition(arr,l, r); // 返回less部分后一位和more部分前一位组成的数组； quickSort(arr, l, p[0] - 1); quickSort(arr, p[1] + 1, r); &#125;&#125; 123456789101112131415public static int[] partition(int[] arr, int l, int r) &#123; // 荷兰国旗式的partition int less = l - 1; int more = r; while (l &lt; more)&#123; if (arr[l] &lt; arr[r]) &#123; swap(arr, ++less, l++); &#125; else if (arr[l] &gt; arr[r]) &#123; swap(arr, --more, l); &#125; else &#123; l ++; &#125; &#125; swap(arr, more, r); return new int[] &#123;less + 1, more&#125;;&#125; 12345public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; 堆排序1234567891011121314public static void heapSort(int[] arr) &#123; if (arr == null || arr.length&lt;2)&#123; return; &#125; for (int i = 0; i &lt;arr.length ; i++) &#123; heapInsert(arr, i); &#125; int size = arr.length; swap(arr, 0, --size); while (size &gt; 0)&#123; heapify(arr, 0, size); swap(arr, 0, --size); &#125;&#125; 123456public static void heapInsert(int[] arr, int index) &#123; while(arr[index] &gt; arr[(index-1)/2])&#123; swap(arr, index, (index-1)/2); index = (index-1)/2; &#125;&#125; 12345678910111213public static void heapify(int[] arr, int index, int size) &#123; int left = 2 * index + 1; while (left &lt; size)&#123; int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[index] &lt; arr[largest] ? largest : index; if (largest == index)&#123; break; &#125; swap(arr, index, largest); index = largest; left = 2 * index + 1; &#125;&#125; 12345public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"排序","slug":"algorithm/左神算法/初级/排序","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"排序","slug":"排序","permalink":"http://zenner006.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://zenner006.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://zenner006.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}]},{"title":"第一章 数据库系统的基本原理","slug":"database-principle-and-application-chapter-01","date":"2020-10-09T02:25:19.000Z","updated":"2020-10-09T02:32:03.645Z","comments":true,"path":"2020/10/09/database-principle-and-application-chapter-01/","link":"","permalink":"http://zenner006.github.io/2020/10/09/database-principle-and-application-chapter-01/","excerpt":"1.1 数据库系统概述1.1.2 数据库系统的概念数据库的总目标就是使用户能有效且方便的管理和使用数据库数据。 1. 数据（Data）数据是数据库存储的基本对象；描述现实世界中各种具体事务或抽象概念的、可存储并具有明确意义的符号记录。 2. 数据库（Database. DB）数据库是长期存储在计算机内、有组织的、可共享的（1）大量数据的集合。数据库中的数据按一定的数据模型组织，描述和存储，具有（2）较小的冗余、（3）较高的数据独立性和（4）易扩展性。 3. 数据库管理系统（Database Management System， DBMS）数据库管理系统是数据库系统的核心； 它位于用户和操作系统之间的一层数据库管理软件； 它为用户或应用程序提供访问数据库的方法，包括数据库的（1）定义、（2）建立、（3）查询、（4）更新及各种数据控制等。","text":"1.1 数据库系统概述1.1.2 数据库系统的概念数据库的总目标就是使用户能有效且方便的管理和使用数据库数据。 1. 数据（Data）数据是数据库存储的基本对象；描述现实世界中各种具体事务或抽象概念的、可存储并具有明确意义的符号记录。 2. 数据库（Database. DB）数据库是长期存储在计算机内、有组织的、可共享的（1）大量数据的集合。数据库中的数据按一定的数据模型组织，描述和存储，具有（2）较小的冗余、（3）较高的数据独立性和（4）易扩展性。 3. 数据库管理系统（Database Management System， DBMS）数据库管理系统是数据库系统的核心； 它位于用户和操作系统之间的一层数据库管理软件； 它为用户或应用程序提供访问数据库的方法，包括数据库的（1）定义、（2）建立、（3）查询、（4）更新及各种数据控制等。 数据定义语言 DBMS提供了数据定义语言（Data Definition Language， DDL）； 通过它可以定义：（1）数据对象（包括表，视图，索引，存储过程等）（2）数据的完整约束 等 ​ 数据的完整性约束主要有实体完整性、参照完整性和用户定义的完整性； 数据操纵语言 DBMS提供了数据操纵语言（Data Manipulation Language，DML），用户可以通过它对数据库数据进行增加，删除，修改和查询操作，简称为“增删改查”； 数据控制语言 DBMS提供了数据控制语言（Data Control Language， DCL） （1）用户可以通过它完成对用户访问权限的授予和撤销，即安全性控制； （2）解决多用户对数据库的并发使用所产生的事务处理问题，即并发控制； （3）数据库的转储，恢复功能； （4）数据库的性能监视、分析功能； 数据的组织、存储和管理 DBMS要分类组织、存储和管理各种数据；确定以何种存储方式存储数据，以何种方法来提取存取效率；这些都要由DBMS来自动实现； 4. 数据库系统（DataBase System，DBS）​ 数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库（DB）、数据库管理系统、应用系统和数据库管理员构成； 5. 数据库应用系统（DataBase Application System，DBAS）数据库应用系统主要是指实现业务逻辑的应用程序； 1.1.3 数据管理技术的发展阶段数据管理技术的发展经历了人工管理、文件管理系统、数据库系统和高级数据库系统4个阶段。 1. 人工发展阶段这阶段计算机主要用于科学计算。外存储器只有磁带、卡片和纸袋等；软件只有汇编语言；数据处理方式基本上是批处理。具有的特点： 1）数据不保存 2）数据不具有独立性（数据与程序没有解耦合） 3）数据不共享：数据是面向程序的； 4）只有程序的概念，没有文件的概念； 2. 文件管理系统阶段这一阶段，计算机不仅仅用于科学计算，还用于信息管理。 也已经有了外存储器，可以进行长期保存。 软件方面有了操作系统进行文件管理； 数据处理方式不仅有批处理还有联机实时处理； 这个阶段，数据被存储在不同的文件中，程序开发人员需要编写不同的应用程序将记录从不同的文件中提取出来进行访问，或者将记录加入到相应的文件中。 文件管理系统阶段存储、组织信息的主要弊端如下： 1）数据的冗余和不一致 ​ 相同信息可能在多个文件中重复存储，并且可能出些不一致的情况 2）数据独立性差 ​ 数据与程序之间存在关联。通常是一个程序管理一份数据文件，而难以再扩充功能。 3）数据孤立 ​ 这些数据分散在不同的文件中，文件又可能具有不同的格式，所以编写新应用程序检索多个文件中的数据是很困难的； 3. 数据库系统阶段数据库系统的特点 数据结构化 数据库系统中实现了整体数据的结构化，即不仅要考虑某个应用的数据结构，还要考虑整个组织的数据结构，而且数据之间时具有联系的；比如：学生数据的组织不仅仅只是面向教务处的学生选课系统，而是应该面向各个与学生相关的部门的不同应用； 数据的共享性高，冗余度低，易扩充 数据库系统是从整体角度来看待和描述数据的，数据可以被多个用户、多个应用共享使用。 数据共享可以大大减少数据冗余，节约存储空间，数据共享还可以避免数据之间的不一致性问题； 并且数据是面向系统的，可以很容易的增加新应用。 数据独立性高 数据独立性是指应用程序与数据库的数据结构之间相互独立，其包括物理独立性和逻辑独立性； 物理独立性 指当数据的物理结构改变时尽量不影响整体逻辑结构及应用程序； 逻辑独立性 指当数据的整体逻辑结构改变时尽量不影响应用程序，这样就认为数据库达到了逻辑独立性； 数据和程序的独立把数据的定义从程序中分离出来，加上存取数据的方法由DBMS负责提供； 数据由DBMS统一管理和控制 数据库中数据的共享使得DBMS必须提供以下数据控制功能 数据的完整性检查：数据的完整性指数据的正确性、有效性和相容性。把数据控制在有效的范围内，保证数据之间满足一定的关系； 并发控制：多个用户同时操作数据时可能会相互干扰而得到错误结果；因此对多用户的并发擦破做加以控制和协调。 数据的安全性保护：数据库安全性是防止不合法的使用造成数据的泄露和破坏，使每个用户只能按规定对某些数据以某些方式进行使用和处理； 数据库的恢复：DBMS提供了数据的备份和恢复功能，可将数据库从错误状态恢复到某一已知的正确状态； 1.1.4 数据库系统的用户1. 数据库管理员（Database Administrator,DBA）职责如下： 参与数据库的设计 定义数据的安全性要求和完整性约束条件 日常维护 定期备份数据库 监视数据库运行 确保正常运行所需的空余磁盘空间，并且需要时升级磁盘空间； 数据库的改进和重组、重构 监视系统与性期间的各个性能指标，对运行情况进行记录、统计分析，不断改进数据库设计 数据库运行过程中，大量数据不断插入、删除和修改，时间一长，会影响系统的性能。因此DBA要定期对数据库进行重组，以提高系统性能； 当用户需求增加或改变时，要对数据库进行较大改造，包括修改部分设计，即进行数据库的重构； 2. 数据库用户根据工作性质及人员的技能把数据库用户分为四类： 最终用户 专业用户 系统分析员和数据库设计人员 应用程序员 1.2 数据模型在数据库技术中，用数据模型的概念来描述数据库的结构和语义，对现实世界的数据进行抽象； 1.2.1 数据抽象过程根据数据抽象的级别定义了4种模型，即概念模型、逻辑模型，外部模型和内部模型 概念模型 是表达用户需求观点的数据库全局逻辑结构的模型； 逻辑模型 是表达计算机实现观点的数据库全局逻辑结构的模型； 外部模型 是表达用户使用观点的数据库局部逻辑结构的模型； 内部模型 是表达数据库物理结构的模型 数据抽象的过程即数据库设计的过程： step - 1：根据用户需求设计数据库的概念模型，这是”综合“的过程； step - 2：根据转换规则把概念模型转换成数据库的逻辑模型，这是一个”转换“的过程； step - 3：根据用户的业务特点设计不同的外部模型，给应用程序使用。 step - 4：实现数据库式，要根据逻辑模型设计其内部模型； 1. 概念模型抽象的最高级别； 概念模型的特点： 概念模型表达了数据库的整体逻辑结构，是实体管理人员面对实体的全面描述； 概念模型是从用户需求的观点出发对数据建模； 概念模型独立于软件和硬件； 概念模型是数据库设计人员和用户之间进行交流的工具 概念模型主要采用的是 实体-联系模型，即E-R模型。 实体是客观世界可以相互区别的对象，这种对象可以是具体的，也可以是抽象的； 联系是两个或多个实体之间的关联。两个实体之间的联系可以分为三种：一对一(1:1)，一对多(1:n)，多对多（n:m）； 2. 逻辑模型选定DBMS后，就要将概念模型按照选定的DBMS的特点转换成逻辑模型； 逻辑模型的特点： 逻辑模型表达了数据库的整体逻辑结构，是设计人员面对实体数据库的全面描述； 逻辑模型是从数据库实现的观点出发对数据建模； 逻辑模型硬件独立，但软件依赖； 逻辑模型是数据库设计人员和应用程序员之进行交流的工具； 逻辑模型有三种：层次模型，网状模型，关系模型； 层次模型的数据结构是树状结构； 网状模型的数据结构是有向图； 关系模型采用二维表格存储数据； 3. 外部模型根据不同业务特点，可以分别设计不同的外部模型； 外部模型的特点： 外部模型是逻辑模型的一个逻辑子集； 硬件独立，软件依赖； 外部模型反映了用户使用数据库的特点； 从整个系统考查，外部模型具有下列特点： 简化了用户的观点；外部模型是根据应用需要设计的，无关数据不放入，使用户更为简便的使用数据库； 有助于数据库的安全保护；无关数据不会放入，保证了数据安全； 外部模型是对概念模型的支持； 4. 内部模型内部模型又称为物理模型，是数据库最底层的抽象，它描述数据在磁盘上的存储方式、存取设备和存取方式。 内部模型是与硬件和软件紧密相连的。但目前的计算机系统的发展使得人们不必考虑内部级的设计细节，由系统自动实现； 1.2.2 关系模型1. 数据模型的三要素数据模型是数据库概念的核心和基础，精确的描述了系统的静态特性、动态特性和完整性约束条件； 数据模型通常由数据结构、数据操作和数据完整性约束3个部分组成； 数据结构 常见的数据模型有层次模型、网状模型和关系模型，关系模型占统治地位； 数据结构是所描述的对象类型的集合，是对系统静态特性的描述； 数据操作 是对数据库表中记录的值允许执行的操作集合，包括操作及有关的操作规则。 数据库对数据操作主要有增删改查4种操作；数据模型必须定义这些操作的含义，符号，操作规则及实现语言； 数据操作是对系统动态特性的描述； 数据的完整性约束 完整性规则是给定的数据模型种数据及其联系所具有的制约和依存规则，用于限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容； 在关系模型中，任何关系都必须满足实体完整性和参照完整性； 2. 关系数据模型的数据结构关系模型中的一些术语： 关系（Relation） 一个关系就是一张规范的二维表；一个规范化的关系必须满足的最基本的一条是关系的每一列不可再分； 元组（Tuple) 表中的一行即为一个元组； 属性（Attribute） 表中的一列即为一个属性； 码（Key） 码也称为关键字或关键码； 表中的某个属性或者属性的组合能唯一的确定一个元组，那么这个属性或者属性的组合就成为码； 在一个关系中可以有多个码； 关系模式 对关系的描述一般表示为： 关系名（属性1，属性2，属性3，… ,属性n） 3. 关系数据模型的操作与完整性约束关系数据模型的操作主要包括查询、插入、删除和更新数据。这些操作必须满足关系的完整性约束条件； 1.3 数据库体系结构数据库系统的设计目标是允许用户逻辑地处理数据，而不涉及数据在计算机内部的存储，在数据组织和用户应用之间提供某种程度的独立性； 1.3.1 数据库系统的三级结构 数据库分为3个抽象级，用户级，概念级和物理级； 1. 用户级数据库用户级对应于外模式，是用户看到和使用的数据库； 2. 概念级数据库概念级数据库对应于概念模式。介于用户级和物理级之间，是数据库管理员看到和管理的数据库，又称为DBA视图； 概念级模式把用户视图有机地结合成一个整体，综合、平衡考虑所有用户要求，实现数据的一致性，最大限度地降低数据冗余，准确反映数据之间的联系； 3. 物理级数据库物理级数据库对应用内模式，是数据库的底层表示，是描述数据的实际存储组织，是最接近物理存储的级，又称为内部视图； 物理级数据库由内部记录组成，物理级数据库不是真正的物理存储，而是最接近物理存储的级； 1.3.2 数据库系统的三级模式数据库系统包括三级模式，即概念模式、外模式和内模式； 1. 概念模式概念模式又称为模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图； 一个数据库仅有一个概念模式； 定义概念模式时，不仅要定义数据的逻辑结构（数据记录的数据项，数据项名字，类型，取值范围等），而且还要定义数据之间的联系，定义与数据有关的安全性、完整性要求； 2. 外模式外模式又称为子模式或用户模式，是数据库用户能看到和使用局部数据的逻辑结构和特征的描述，是数据库用户的数据视图； 他与某一应用有关的数据的逻辑表示； 一个数据库可以有多个外模式； 外模式主要描述用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件； 3. 内模式内模式又称为存储模式或物理模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。 一个数据库只有一个内模式； 内模式定义的是 存储记录的类型、存储域的表示、存储记录的物理顺序、 索引和存储路径等数据的存储组织； 1.3.3 数据库系统的二级映射和数据独立性1. 数据库系统的二级映射二级映射是：外模式/概念模式映射 和 概念模式/内模式映射 三个抽象级通过二级映射相互转换。 2. 数据独立性数据独立性是指应用程序和数据之间的独立性；包括物理独立性和逻辑独立性； 数据独立性 物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是独立的。通过概念模式/内模式映射来实现； 当数据库存储结构改变时，由DBA对模式/内模式映射作相应的改变，可以使概念模式保持不变； 逻辑独立性 逻辑独立性是指用户的应用程序与逻辑结构是相互独立的。逻辑独立性是通过外模式/概念模式映射来实现的； 当概念模式改变时，由DBA对外模式/概念模式映射作相应改变，可使外模式保持不变；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库原理及应用","slug":"数据库/数据库原理及应用","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"name":"数据库基础知识","slug":"数据库/数据库原理及应用/数据库基础知识","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"左神算法-基础课-02-笔记","slug":"zuoshen-basic-class-2-note","date":"2020-10-08T08:43:08.000Z","updated":"2020-12-11T09:59:37.625Z","comments":true,"path":"2020/10/08/zuoshen-basic-class-2-note/","link":"","permalink":"http://zenner006.github.io/2020/10/08/zuoshen-basic-class-2-note/","excerpt":"快速排序问题一：partition 给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，大于$num$的数放在数组的右边。 要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$; 解决答案","text":"快速排序问题一：partition 给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，大于$num$的数放在数组的右边。 要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$; 解决答案 问题二：荷兰国旗问题 给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，等于$num$的数放在中间，大于$num$的数放在数组的右边。 要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$; 解决答案 三个变量$less$, $cur$ 和 $more$; $less$ 表示 $0$ ~ $less $为小于$num$的区域；初始为 -1； $cur$ 表示 当前判断的数在数组的下标；初始为0；并且 0 ~ $cur$的数组区域都是小于等于$num$的值； $more$ 表示 $more$ ~ $arr.length-1$为大于$num$的区域；初始为 $arr.length$； graph TD A[开始] -->B(less初始值为-1) A -->F(cur初始值为0) A -->G(more初始值为arr.length) F -->I{cur是否小于more} G -->I B --> I C{判断arr的cur上的值} -->|小于num| D[cur位置和less+1位置交换 less+=1] C -->|等于num| H[cur= cur+1] C -->|大于num| E[cur位置和more-1位置交换 more-=1] D --> H H --> I E --> I I -->|是| C I -->|否| J[结束 返回less+1,more-1] 要考虑一下一些情况： 如果等于区域不存在 小于区域不存在 大于区域不存在 小于等于区域不存在 大于等于区域不存在 小于大于不存在（全是等于） 经典快速排序原始经典快速排序； 荷兰国旗问题来改进； 经典快排的问题 划分出来的区域不是等规模的：特别在差不多有序情况下进行经典快排则会导致$O(N^2)$；本质上和数据状况是有关系的； 随机快速排序随机快速排序的细节和复杂度分析和经典快排不同的地方在于选择partition的num值；经典快排都是选择一个确定位置的值（第一个值或者最后一个值）来对整个数组进行划分；而这样就和数据状况存在关系。所以随机快速排序随机选择划分整个过程的num值。虽然这样选择的值也可能出现划分出来的区域不是等规模的。但是这只是一个概率事件，我们不能得知其时间复杂度的最差情况；只能用长期期望的方式算出它的时间复杂度。我们长期期望得到的时间复杂度为：$O(N*log N)$； 随机快速排序的组成 主函数：输入一个要排序的数组 123456/* 快排主函数： 先判断数组需不需要排序 然后对 0 ~ arr.length-1 区间里调用2函数*/public static void quickSort(int[] arr) 对区间里进行快速排序 12345678/* 如果左边界小于右边界 在数组中随机选一个数作为分割数num，将其交换到l最后一个位置去 按上一步找的数用 3 partition 把数组分为三部分：[小于num的，等于num的，大于num的]，返回 [等于num的] 的边界，方便后两步 对 [小于num的] 执行快速排序 对 [大于num的] 执行快速排序*/public static void quickSort(int[] arr, int l, int r) 分割数组 123456789101112/* partition需要 less = l-1记录小于num的区域的边界，more = r记录大于num区域的边界 cur=l arr[r]保存着分割数num 这个思想与框图里的一样： 【l~less：小于num的区域， less+1~cur-1：等于num的区域， cur~more-1：未分类的区域， more~r-1：大于num的区域】 只要未分类的区域还存在循环不停止： 如果arr[cur] &lt; arr[r]:要把它换到小于区域的下一个，而这个值是等于num区域的值；交换 ++less 和 cur++； 如果arr[cur] &gt; arr[r]:把他换到大于区域前一个，交换过来的这个是未知区域的值；则要继续对cur位置做判断； 如果arr[cur] = arr[r]:当前数要划分进等于num的区域，直接cur++； 直接结束，交换more与r位置的数； 返回：[less+1, more]*/public static int[] partition(int[] arr, int l, int r) 规避数据状况对算法的影响的方法 随机 哈希函数 时间复杂度$O(N*log N)$，额外空间复杂度$O(log N)$ 空间复杂度为什么是$O(log N)$？为了记录大于num和小于num的位置，并且需要递归记录。所以额外的空间承了一颗二叉树一样得。所以是$O(log N)$ 题外话：任何递归函数都可以改写为非递归函数； 递归函数的压栈是对函数进行压栈，消耗的常数级空间和资源都比较大。并且系统栈是有限的，深度递归会造成不安全。 堆排序堆的表示堆的数据结构：完全二叉树 物理表示：一个数组，分为以0位置为根节点和以1位置为根节点两种表示方式； 以0位置为根节点： i位置的左孩子：$2*i+1$ ​ 右孩子：$2*i+2$； i位置的父节点： $\\frac{i-1}{2}$ 以1位置为根节点： i位置的左孩子：$2*i$ ​ 右孩子：$2*i+1$ i位置的父节点：$\\frac{i}{2}$ 堆的分类分为大顶堆和小顶堆 大根堆：在这个完全二叉树中任何一个子树的最大值都在子树的根上。 小根堆：在这个完全二叉树中任何一个子树的最小值都在子树的根上。 建立堆以大顶堆为例； 思想：给定一个数组把它构建为一个大顶堆； 1234567宏观：我们认为0 ~ i-1间已构成大顶堆，然后插入第i个数；i初始值为0，不断插入堆中，不断增长，一直到N-1；中层： 把一个数插入进完全二叉树： 循环判断：if i是否有父节点 并且 i位置数大于父节点： 与父结点进行交换 else: 结束； 123for (int i = 0; i &lt;arr.length ; i++) &#123; heapInsert(arr, i);&#125; tip：这里看到左神代码，可以符合i没有父节点和大于父节点两种情况的判断 1234// 判断i位置和其父节点while (arr[i] &gt; arr[(i-1)/2])&#123; // 在i=0时是否合适？ &#125; ​ 经过验证java中的整除除法的整除，如果是负值则会往比较大的方向贴 1234-1 / 4 ： 0-3 / 4 ： 0-4 / 4 ： -1-5 / 4 ： -1 ​ 而python不同： 123-1 // 4 ： -1-3 // 4 ： -1-5 // 4 ： -2 插入堆（heapinsert）1public static void heapInsert(int[] arr, int index) 插入堆就是要不停的与父节点进行比较。如果大于就交换，小于则停止； 调整堆（heapify）1public static void heapify(int[] arr, int index, int size) 大顶堆中的一个数变小了，要对这样的情况进行调整；把它与他的两个子节点进行比较；如果大于它的左右节点那么就不调整了，如果小于就与较大的子节点进行交换。直到其大于他的左右子节点。当然结束条件不仅仅是大于两个子节点，也有子节点越界的情况。 已知：堆数组arr，调整数的下标 index，堆大小 heapsize graph TD A[开始] -->B[左节点下标 left = index * 2 + 1] B --> C{left < heapsize} C -->|yes|D[获得左右节点的较大值] C -->|no|E[结束] D -->F{index大于子节点} F -->|yes|G G -->E F -->|no|H H -->I[交换子节点较大值与index] I -->J[index=较大值] J -->B 堆的使用例一：一个数据流不停的输出数；求当前输出数字的中位数； 分析：请求中位数是随时可能出现的；所以用普通线性容器对其进行排序所需的时间复杂度很高。 所以用堆来实现这个过程就很方便： 题解： ​ 需要：一个大根堆存放较小的$\\frac{N}{2}$个数；用大根堆把他们的最大值放在根部； ​ 一个小根堆存放较大的$\\frac{N}{2}$个数；用小根堆把他们的最小值放在根部； ​ 大根堆和小根堆中元素的个数差不超过1； ​ 分析：当大根堆和小根堆元素个数相同时：中位数为两个堆顶部元素的均方； ​ 当大根堆和小根堆元素个数差1时：中位数为元素较多所在堆的根部； ​ 维护堆： ​ 初始：把元素加入进大顶堆； ​ 插入元素： ​ a. 判断插入元素是否小于大顶堆根部，如果是则插入大顶堆，否则插入小顶堆 ​ b. 再判断大顶堆和小顶堆元素个数的差；如果大于1，则弹出元素数较大的堆的根，再插入元素数较小的堆中；使其平衡； 堆排序graph TD A[开始] --> B{数组大小大于1} B -->|是|H[构建堆] H -->C[将堆中最后一个数与根交换] C --> D[堆大小减1] D --> F{堆大小不为空} F --> |是|E[调整堆做一次heapify] E -->C F --> |否|G B -->|否| G[排序完成] 排序算法的稳定性及其汇总稳定性：相同的值经过排序之后他们在序列中的相对顺序会不会被打乱；不被打乱就是稳定的； 冒泡排序：可以实现稳定，大数沉底，但是遇到相等的时候不交换就可以实现稳定； 插入排序：可以实现稳定；从后往前插入，遇到相等的就停止。 选择排序：不是稳定的；需要与i位置往后最小值交换，使得其相对顺序会变化； 归并排序：可以实现稳定；元素相等情况下，先把左边数组的相等值优先拷贝进辅助数组，再拷贝右边数组的相等值； 快速排序：不是稳定的；partition的过程也有随机交换的地方； 堆排序：不是稳定的； 稳定性有什么意义？ 现实世界有可能需要保证他的原始顺序； 工程中的综合排序算法工程中使用的排序算法则不是利用某种排序算法，它是一个综合考虑各种情况各种排序算法优劣的算法； 如果需要排序的数组长度很长 先判断里面装的是基础类型，还是自定义类型？因为基础类型不需要考虑稳定性； 基础类型：用快排 自定义类型：归并排序 数组长度很短则直接用插入排序；因为插入排序所需的常数项操作很低。 有关排序问题的补充 归并排序所需的时间复杂度O(n)的可以变成O(1)的，可以学习：“ 归并排序 内部缓存法 ”；非常难； 快速排序可以做到稳定性，可以学习：“ 01 stable sort ”；非常难； 认识比较器的使用Arrays.sort 里有一个比较器接口： 1public static void sort(T[] a,int fromIndex,int toIndex, Comparator c) 通过自定义比较类型的比较器可以实现 12345678public static class IdAscendingComparator implements Comparator&lt;T&gt;&#123; @Override public int compare(T o1, T o2)&#123; return 负数; // 比较时第一个数o1放在o2前面 return 正数； // 比较时第二个数o2放在o1前面 return 0； // 认为这样个数一样大 &#125;&#125; 因为自定义类型不告诉排序函数它用什么比较器，那么排序函数就会用内存地址对他们进行比较； 同样的java里还有优先队列；优先队列也就是一个堆；堆是大顶堆还是小顶堆都是需要用比较器来说明的； 1PriorityQueue&lt;Student&gt; heap = new PriorityQueue&lt;&gt;(new IdAscendingComparator()); 还有TreeSet&lt;Student&gt; treeset = new TreeSet&lt;&gt;(new IdAscendingComparator()); 桶排序、计数排序、基数排序【例】一串数字，他们都是0~60范围里的数。要对这串数字进行排序； 可以实现一个数组用来统计相应位置上的数出现的个数。在利用整个数组得到排序后的结果； 而这里数组中的 i 位置保存数字 i 的个数。这就是一个桶； 桶保存了一种数据状况出现的词频，是容器； 桶排序而桶排序是一种思想，它不是具体的某一个排序算法。而基数排序与计数排序都是对它的具体实现； 但是可以看到这种排序是有局限性的，它的使用与数据状况关联很大； 计数排序要求被排序的数字在某一个范围里面；不然的话所需的范围极大，所需的桶也极多。这是它不好的地方； 补充问题 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序。 step-1 : 排序数组有N个数，那么准备N+1个桶 step-2 : 遍历整个数组找到其最大值与最小值 step-3 : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0； step-4 : 如果不相等则分别把最小值放在0号桶里，把最大值放在N号桶里。 step-5 : 把桶按最小值与最大值之间的范围等分为N+1份 分析： ​ 设一个桶能装的范围是p，它是由 $\\frac{最大值 - 最小值}{N-1}$ 计算而来 ​ 由于有N个数放进N+1个桶里。那么起码会出现一个空桶； ​ 相邻的两个数会出现在两个地方：在同一个桶里，在不同的桶里； ​ 相邻的两个数在一个桶里他们的差值不会大于桶的范围：$(1, p-1)$； ​ 两个数在相邻两个桶，他们的差值范围在 $(1, 2*p-1)$； ​ 而两个数中间有一个空桶的相邻数一定大于桶的范围 $(p+1, 3p-1)$； ​ 因为起码会出现一个空桶，所以相邻数的差的最大值不会出现在同一个桶里。所以只需要查看桶之间的差值就好了。 对这个过程进行完整的描述： step-1 : 排序数组有N个数，那么准备N+1个桶；这个桶只保存有没有进来过数，进来数中最大值，最小值，这三样信息； step-2 : 遍历整个数组找到其最大值与最小值 step-3 : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0； step-4 : 如果不相等则分别用最小值更新0号桶布尔值，最大值和最小值，用最大值更新N号桶的布尔值，最大值和最小值。 step-5 : 然后依次把数组中的数字填入相对应的桶中； step-6 : 对桶进行遍历，依次比较当前桶的最小值与上一个非空桶最大值的差，找到其中最大的值；","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"排序","slug":"algorithm/左神算法/初级/排序","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"排序","slug":"排序","permalink":"http://zenner006.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://zenner006.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://zenner006.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}]},{"title":"左神算法-基础课-01-代码","slug":"zuoshen-basic-class-1-code","date":"2020-10-07T03:39:21.000Z","updated":"2020-12-11T09:59:59.337Z","comments":true,"path":"2020/10/07/zuoshen-basic-class-1-code/","link":"","permalink":"http://zenner006.github.io/2020/10/07/zuoshen-basic-class-1-code/","excerpt":"对数器常用的获取随机数组的技巧： 1Math.random()*(n-m)+m //生成大于等于m小于n的随机数； 因为这个课程开始针对对数器的认识就是排序。它有自身的输入输出的特点。所以对数器是这样写的。但是针对不同的数据结构类型，对数器的写法是不同的。","text":"对数器常用的获取随机数组的技巧： 1Math.random()*(n-m)+m //生成大于等于m小于n的随机数； 因为这个课程开始针对对数器的认识就是排序。它有自身的输入输出的特点。所以对数器是这样写的。但是针对不同的数据结构类型，对数器的写法是不同的。 交换函数i==j时这个交换功能会出错； 12345public static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];&#125; 冒泡排序123456789101112public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return ; &#125; for (int end = arr.length - 1; end &gt; 0 ; end--) &#123; for (int i = 1; i &lt;= end; i++) &#123; if (arr[i-1] &gt; arr[i])&#123; swap(arr,i-1, i); &#125; &#125; &#125;&#125; 插入排序12345678910public static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return ; &#125; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j--) &#123; swap(arr, j, j-1); &#125; &#125;&#125; 选择排序123456789101112public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return ; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i; j &lt; arr.length; j++) &#123; minIndex = arr[minIndex] &gt; arr[j] ? j : minIndex; &#125; swap(arr, i, minIndex); &#125;&#125; 归并排序123456public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return ; &#125; sortProcess(arr, 0, arr.length-1);&#125; 123456789public static void sortProcess(int[] arr, int L, int R) &#123; if (L == R)&#123; return ; &#125; int mid = L + ((R - L) &gt;&gt; 1); // 位运算优先级低于加减，所以一定要加上括号 sortProcess(arr, L, mid); sortProcess(arr,mid+1, R); merge(arr, L, mid, R);&#125; 1234567891011121314151617public static void merge(int[] arr, int L, int mid, int R)&#123; int help[] = new int[R-L+1]; int p1 = L, p2 = mid + 1; int i = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= mid)&#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[i + L] = help[i]; &#125;&#125; 小和问题1234567891011121314151617181920212223242526272829303132333435public static int smallSum(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; return mergeSort(arr, 0, arr.length - 1);&#125;public static int mergeSort(int[] arr, int l, int r) &#123; if (l == r)&#123; return 0; &#125; int m = l + ((r-l) &gt;&gt; 1); return mergeSort(arr, l, m) + mergeSort(arr, m + 1, r) + merge(arr, l, m, r);&#125;public static int merge(int[] arr, int l, int m, int r) &#123; int help[] = new int[r - l + 1]; int p1 = l, p2 = m + 1; int i = 0; int res = 0; while (p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123; res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + 1) : 0; // 最重要的一句 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= m)&#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= r)&#123; help[i++] = arr[p2++]; &#125; for (i = 0; i &lt; help.length; i++) &#123; arr[l + i] = help[i]; &#125; return res;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"排序","slug":"algorithm/左神算法/初级/排序","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"排序","slug":"排序","permalink":"http://zenner006.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://zenner006.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://zenner006.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"http://zenner006.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://zenner006.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"对数器","slug":"对数器","permalink":"http://zenner006.github.io/tags/%E5%AF%B9%E6%95%B0%E5%99%A8/"}]},{"title":"左神算法-基础课-01-笔记","slug":"zuoshen-basic-class-1","date":"2020-10-07T03:34:15.000Z","updated":"2020-12-11T09:59:47.209Z","comments":true,"path":"2020/10/07/zuoshen-basic-class-1/","link":"","permalink":"http://zenner006.github.io/2020/10/07/zuoshen-basic-class-1/","excerpt":"排序冒泡排序每次把当前数组最大值通过交换放到最后；时间复杂度：$O(N^2)$ 对这个算法描述分为三个层面 1234宏观： 用end控制前面数组中的最大值存放的位置；它的初始值为N-1，结束值为1；中层： 把0 ~ end里的最大值传递到end位置；微观： 从&#96;0 ~ end-1&#96; 针对于相邻两个元素进行比较（位置0 和 位置1 比较； 然后位置1 和 位置2 比较；直到位置end-1 和 位置end 比较；）； 前面的大于后面的则交换; 微观层面的算法是对中层的具体实现；中层又是宏观中的一部分；","text":"排序冒泡排序每次把当前数组最大值通过交换放到最后；时间复杂度：$O(N^2)$ 对这个算法描述分为三个层面 1234宏观： 用end控制前面数组中的最大值存放的位置；它的初始值为N-1，结束值为1；中层： 把0 ~ end里的最大值传递到end位置；微观： 从&#96;0 ~ end-1&#96; 针对于相邻两个元素进行比较（位置0 和 位置1 比较； 然后位置1 和 位置2 比较；直到位置end-1 和 位置end 比较；）； 前面的大于后面的则交换; 微观层面的算法是对中层的具体实现；中层又是宏观中的一部分； 选择排序0 ~ N-1范围内找到最小的放在 0 位置 1 ~ N-1范围内找到最小的放在 1 位置 2 ~ N-1范围内找到最小的放在 2 位置 每次找到i ~ N-1位置里的最小值的下标，与i位置进行交换。 1231： 第 i 位置后的最小值放在 i 位置；于是 i 取值范围为 0 ~ N-2 ； （因为 N - 1 之后没有数了， 也就是它自己了）2： 需要一个变量 minIndex 来保存最小值的下标；在 i ~ N-1 范围里找最小值；3： 交换 i 位置上的数和 minIndex 上的数； 插入排序0 ~ 0范围内的数只有一个，认为是已排序的； 0 ~ 1 范围里的数，如果判断 1 位置上的数小于 0 位置上数则进行交换， 否则不交换； 0 ~ 2 范围里的数，把 2 位置上的数从后往前依次比较，如果小于则，交换，如果大于则停止； 从已排序的部分最大值往前比较，如果大与它前一个值就不交换。如果小于则与他前一个值交换。 差不多已经排序了的数组可以用插入排序。这个和数据状况有关系。完全有序O(N) ；完全逆序就是 O(N^2) ; 12341： 变量 i 表示要插入数的位置； i 的范围是 1 ~ N-12： 要把 i 位置数插入到 0 ~ i-1 范围里面去；3： 变量 j 表示要插入值目前的位置： 如果 j 大于 0 且 j 位置上的数小于 j-1 位置上的数， 则交换， j--； 否则停止； j 的范围是 1 ~ i 时间复杂度 ​ 最好情况 O(N) 最差情况 O(N^2) 平均情况 O(N) ~ O(N^2) ​ 对数器对数器的作用1. 无测试样例时可以用对数器测试代码 2. 小样本测试过了，但是面对大样本测试出错，可以用对数器帮助修改bug 3. 如何证明贪心策略是对的？这是很难的。所以用对数器可以试贪心策略是对是错。 对数器的构成1. 产生随机样本的函数 123456/* 生成随机长度， 随机内容的数组*/public static int[] generateRandomArray(int size, int maxValue) 2. 一个绝对正确的方法 那么这个方法可能是来自于系统提供的； 或者是自己写的一个绝对正确但是时间复杂度过不了的方法； 3. 大样本测试 我们把自动生成的测试样例输入进 绝对正确的方法 和 想要测得方法 ； 然后判断他们的输出是否一致；把这个过程重复很多次，可以是很大的值，也就是说可以也许穷尽所有的可能性； 对数器的概念和使用 有一个你想要测的方法a， 实现一个绝对正确但是复杂度不好的方法b， 实现一个随机样本产生器 实现比对的方法 把方法a和方法b比对很多次来验证方法a是否正确。 如果有一个样本使得比对出错，打印样本分析是哪个方法出错； 当样本数量很多时比对测试依然正确，可以确定方法a已经 正确。 笔试的时候要准备对数器我大概想到要写一个类；然后由各种继承得到；要覆写的东西也是很多； python的话，有使输入格式规范的包； 剖析递归行为和递归行为时间复杂度的估算剖析递归行为 ​ 把当前运行函数压进系统栈中，保留当前函数的所有信息。调用的函数就在栈顶。 ​ 任何递归行为都可以改为非递归； 递归行为时间复杂度的估算 ​ 大部分的递归过程都可以用这个公式来表示 T(N) = aT( \\frac{N}{b} ) + O(N^d)$N$表示样本量，$T(N)$表示时间复杂度；那么这个复杂度分成了$a$个$T(N/b)$个子问题的过程加上一个$O(N^d)$剩余时间过程的时间； 满足这个公式的递归过程的时间复杂度的计算如下： T(N) = \\begin{cases} O(N^{log_ba}), & {log_ba} > d \\\\ O(N^d*{logN}), & {log_ba} = d \\\\ O(N^d), & {log_ba} < d \\end{cases}但是像$T(N)=T(\\frac{N}{5})+T(\\frac{2}{3}N)+O(N^2)$这样的公式就不符合上面的这个过程； 补充阅读：算法的复杂度与 Master 定理 归并排序把一个数组分为左右两个部分。先把左侧的排好序，再把右侧的排好序。最后用外排的方式排好序。这个过程的时间复杂度是下式： T(N) = 2 *T(\\frac{N}{2})+O(N)把这个公式带入到上一节，就可以查到它的时间复杂度为 $O(N*logN)$ 。并且归并排序的过程仅仅需要用到一个和原数组长度一样的数组，那么它的空间复杂度为$O(N)$ 归并排序的思想针对一个数组将其分为两个部分，分别对这两个部分用归并排序。然后对整个数组进行一个外部排序。 外部排序：针对有序的两个数组；分别用两个指针指向他们的头部。然后依次往一个辅助数组里填入两个指针中更小的值；直到两个部分都填入了辅助数组后，再把已排序好的填回原数组。 归并排序的组成部分 主函数用来对整个数组进行排序，它调用第二个组成 123456public static void mergeSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return ; &#125; sortProcess(arr, 0, arr.length - 1);&#125; 对未排序的数组L到R部分的排序过程 12345/* 如果L==R则范围里只有一个数，那么直接返回就好了。可以认定他是有序的； 如果有多余一个的数则把它分为前后两部分，分别进行归并排序。然后再对这两部分进行外部排序；*/public static void sortProcess(int[] arr, int L, int R) 合并L到mid 和 mid+1到R两个排序好的部分：把她两排序整合到一个辅助数组里，然后再拷贝回去； 123456789/* 外部排序需要：一个辅助数组（大小为：R-L+1），两个指针（分别指向已排序好的两部分的头部），辅助数组下标； 过程： 1. 谁小填谁：进行一个循环（两个指针都不超过他们的边界的情况下），谁小就把谁填进辅助数组中； 2. 谁没了把另一个剩下的全部填入辅助数组中：因为上一个循环已经破除则一定有且只有一个指针越界（因为每次只填入一个数，一次只可能有一个越界） 所以这里会分别对两个指针进行判断是否到边界。他们是非此即彼的关系，即只会执行一个。 3. 最后需要把 辅助数组拷贝回 L到R之间的位置；*/public static void merge(int[] arr, int L, int mid, int R) 归并排序的应用：小和问题和逆序对问题小和问题在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 123456789101112131415例子[1,3,4,2,5] 1左边比1小的数，没有； 3左边比3小的数，1； 4左边比4小的数，1、3； 2左边比2小的数，1； 5左边比5小的数，1、3、4、2； 所以小和为1+1+3+1+1+3+4+2&#x3D;16 注意这个题不是算一个数之前有多少比它小的个数，而是算比它小的数的和。 普通思路这个笨办法就是进行遍历看这个数之前有几个数比它小；可以把它做对数器； 123456789101112public static int comparator(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; int res = 0; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; res += arr[j] &lt; arr[i] ? arr[j] : 0; &#125; &#125; return res;&#125; 归并排序的思路graph TD A[1,3,4,2,5] --> B[1,3,4] B --> D[1,3] D --> H[1] D --> I[3] B --> E[4] A --> C[2,5] C --> F[2] C --> G[5] H -->|产生一个小和| J[1,3] I -->|数字1*后面长度1| J J -->| 数字1*长度1| K[1,3,4] E -->| 数字3*长度1| K F -->| 数字2*长度1| L[2,5] G --> L K -->|数字1*长度2 + 不产生小和| M[1,2,3,4,5] L -->|数字3*长度1 + 数字4*长度1| M 归并排序求小和的组成部分 主函数，主要就是判断输入进来的数组是否符合规定 1public static int smallSum(int[] arr) 归并排序求得数组小范围内的小和 1public static int mergeSort(int[] arr, int l, int r) 合并 1public static int merge(int[] arr, int l, int m, int r) 这里代码与归并排序都是一样的不过在比较时多了一句算小和的代码： 1res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + 1) : 0; 逆序对问题在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"排序","slug":"algorithm/左神算法/初级/排序","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"排序","slug":"排序","permalink":"http://zenner006.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://zenner006.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://zenner006.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"http://zenner006.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://zenner006.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"对数器","slug":"对数器","permalink":"http://zenner006.github.io/tags/%E5%AF%B9%E6%95%B0%E5%99%A8/"}]},{"title":"python装饰器","slug":"python-decorator","date":"2020-08-31T03:28:16.000Z","updated":"2020-09-01T07:21:30.475Z","comments":true,"path":"2020/08/31/python-decorator/","link":"","permalink":"http://zenner006.github.io/2020/08/31/python-decorator/","excerpt":"1. 装饰器的原型12345678910111213141516import timedef showtime(func): def wrapper(): start_time = time.time() func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapperdef foo(): print('foo..') time.sleep(3)foo = showtime(foo)foo() 对foo函数进行增强；","text":"1. 装饰器的原型12345678910111213141516import timedef showtime(func): def wrapper(): start_time = time.time() func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapperdef foo(): print('foo..') time.sleep(3)foo = showtime(foo)foo() 对foo函数进行增强； 2. 不带参数的装饰器:(装饰器,被装饰函数都不带参数)12345678910111213141516171819202122import timedef showtime(func): def wrapper(): start_time = time.time() func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapper@showtime #foo = showtime(foo)def foo(): print('foo..') time.sleep(3)@showtime #doo = showtime(doo)def doo(): print('doo..') time.sleep(2)if __name__ == '__main__': foo() doo() 3. 带参数的被装饰的函数1234567891011121314151617181920212223242526272829import timedef showtime(func): def wrapper(a, b): start_time = time.time() func(a,b) end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapper@showtime #add = showtime(add)def add(a, b): print(a+b) time.sleep(1)@showtime #sub = showtime(sub)def sub(a,b): print(a-b) time.sleep(1)if __name__ == '__main__': add(5,4) sub(3,2)'''9spend is 1.00082588195800781spend is 1.0002799034118652 ''' 4. 带参数的装饰器(装饰函数)实际是对原有装饰器的一个函数的封装,并返回一个装饰器(一个含有参数的闭包函数),当使用@time_logger(3)调用的时候,Python能发现这一层封装,并将参数传递到装饰器的环境去 12345678910111213141516171819202122import timedef time_logger(flag = 0): def showtime(func): def wrapper(a, b): start_time = time.time() func(a,b) end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) if flag: print('将此操作保留至日志') return wrapper return showtime@time_logger(2) #得到闭包函数showtime,add = showtime(add)def add(a, b): print(a+b) time.sleep(1)if __name__ == '__main__': add(3,4) 多加一层闭包，把参数传进去 5. 类装饰器:一般依靠类内部的call方法123456789101112131415161718192021import timeclass Foo(object): def __init__(self, func): self._func = func def __call__(self): start_time = time.time() self._func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time))@Foo #bar = Foo(bar)def bar(): print('bar..') time.sleep(2)if __name__ == '__main__': bar()'''bar..spend is 2.000215768814087''' 6. 使用装饰器的缺点1.位置错误的代码 不能在装饰器之外添加逻辑功能2.不能装饰@staticmethod 或者 @classmethod已经装饰过的方法3.装饰器会对原函数的元信息进行更改,比如函数的docstring,name,参数列表 12345678910111213141516171819202122232425import timedef showtime(func): def wrapper(): start_time = time.time() func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapper@showtime #foo = showtime(foo)def foo(): print('foo..') time.sleep(3)def doo(): print('doo..') time.sleep(2)if __name__ == '__main__': print(foo.__name__) print(doo.__name__) ''' wrapper doo ''' 由此可以看出,装饰器会对原函数的元信息进行更改,可以使用wraps,进行原函数信息的添加 注解:wraps本身也是一个装饰器,他能把函数的元信息拷贝到装饰器函数中使得装饰器函数与原函数有一样的元信息 以下是一个wraps的例子: 1#6.4. 使用wraps把被装饰的函数信息绑定进装饰器 12345678910111213141516171819202122232425262728import timefrom functools import wrapsdef showtime(func): @wraps(func) def wrapper(): start_time = time.time() func() end_time = time.time() print('spend is &#123;&#125;'.format(end_time - start_time)) return wrapper@showtime #foo = showtime(foo)def foo(): print('foo..') time.sleep(3)def doo(): print('doo..') time.sleep(2)if __name__ == '__main__': print(foo.__name__) print(doo.__name__)'''foodoo''' 常用的内置装饰器 staticmethod: 类似实现了静态方法 注入以后,可以直接 : 类名.方法 property: 经过property装饰过的函数 不再是一个函数,而是一个property, 类似实现get,set方法 1234567@propertydef width(self): return self.__width@width.setterdef width(self, newWidth): self.__width &#x3D; newWidth classmethod: 与staticmethod很相似,貌似就只有这一点区别:第一个参数需要是表示自身类的 cls 参数， 可以来调用类的属性，类的方法，实例化对象等。 详解Python的装饰器 理解Python装饰器(Decorator) python 闭包，装饰器","categories":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://zenner006.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"}]},{"title":"python闭包","slug":"python-closure","date":"2020-08-31T03:06:55.000Z","updated":"2020-08-31T03:27:23.231Z","comments":true,"path":"2020/08/31/python-closure/","link":"","permalink":"http://zenner006.github.io/2020/08/31/python-closure/","excerpt":"​ python 闭包如果在一个函数的内部定义了另一个函数，外部的函数叫它外函数，内部的函数叫它内函数。 1. 闭包条件 在一个外函数中定义了一个内函数。 内函数里运用了外函数的临时变量。 并且外函数的返回值是内函数的引用。 一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。","text":"​ python 闭包如果在一个函数的内部定义了另一个函数，外部的函数叫它外函数，内部的函数叫它内函数。 1. 闭包条件 在一个外函数中定义了一个内函数。 内函数里运用了外函数的临时变量。 并且外函数的返回值是内函数的引用。 一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。 12345678910111213141516171819202122#闭包函数的实例# outer是外部函数 a和b都是外函数的临时变量def outer( a ): b = 10 # inner是内函数 def inner(): #在内函数中 用到了外函数的临时变量 print(a+b) # 外函数的返回值是内函数的引用 return innerif __name__ == '__main__': # 在这里我们调用外函数传入参数5 #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数 demo = outer(5) # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量 # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数 demo() # 15 demo2 = outer(7) demo2()#17 A 外函数返回了内函数的引用返回内函数，对于闭包，在外函数outer中 最后return inner，在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来再进行使用demo() 的时候，相当于使用了inner函数。 一个函数，如果函数名后紧跟一对括号，说明现在就要调用这个函数，如果不跟括号，只是一个函数的名字，里面存了函数所在位置的引用。 B 外函数把临时变量绑定给内函数一个函数结束的时候，会把自己的临时变量都释放给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量和内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。 2. 闭包中内函数修改外函数局部变量在闭包内函数中，可以随意使用外函数绑定来的临时变量，但是如果想修改外函数临时变量数值的时候发现出问题了！ 在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法: global 声明全局变量 全局变量是可变类型数据的时候可以修改 在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候： 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。 在python2中，没有nonlocal这个关键字，可以把闭包变量改成可变类型数据进行修改，比如列表。 12345678910111213141516171819202122#修改闭包变量的实例# outer是外部函数 a和b都是外函数的临时变量def outer( a ): b = 10 # a和b都是闭包变量 c = [a] #这里对应修改闭包变量的方法2 # inner是内函数 def inner(): #内函数中想修改闭包变量 # 方法1 nonlocal关键字声明 nonlocal b b+=1 # 方法二，把闭包变量修改成可变数据类型 比如列表 c[0] += 1 print(c[0]) print(b) # 外函数的返回值是内函数的引用 return innerif __name__ == '__main__': demo = outer(5) demo() # 6 11 从上面代码中能看出来，在内函数中，分别对闭包变量进行了修改，打印出来的结果也确实是修改之后的结果。以上两种方法就是内函数修改闭包变量的方法。 还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量 123456789101112#coding:utf8def outer(x): def inner(y): nonlocal x x+=y return x return innera = outer(10)print(a(1)) //11print(a(3)) //14 外部函数的变量会跟着变 3. 闭包用途3.1 装饰器！装饰器是做什么的？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。 3.2 面向对象！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程 3.3 实现单利模式！ 其实这也是装饰器的应用。单利模式毕竟比较高大，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了。","categories":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"闭包","slug":"闭包","permalink":"http://zenner006.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"python和java的垃圾回收机制","slug":"garbage_Collection","date":"2020-08-31T02:01:33.000Z","updated":"2020-08-31T02:14:11.643Z","comments":true,"path":"2020/08/31/garbage_Collection/","link":"","permalink":"http://zenner006.github.io/2020/08/31/garbage_Collection/","excerpt":"Python垃圾回收机制详解一、引用计数Python垃圾回收主要以引用计数为主，分代回收为辅。 1.引用计数增加的情况当发生以下四种情况的时候，该对象的引用计数器+1 对象被创建 a=14 对象被引用 b=a 对象被作为参数,传到函数中 func(a) 对象作为一个元素，存储在容器中 List={a,”a”,”b”,2} 2. 引用计数减少的情况与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1 当该对象的别名被显式销毁时 del a 当该对象的引别名被赋予新的对象， a=26 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会） 将该元素从容器中删除时，或者容器被销毁时。 当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁","text":"Python垃圾回收机制详解一、引用计数Python垃圾回收主要以引用计数为主，分代回收为辅。 1.引用计数增加的情况当发生以下四种情况的时候，该对象的引用计数器+1 对象被创建 a=14 对象被引用 b=a 对象被作为参数,传到函数中 func(a) 对象作为一个元素，存储在容器中 List={a,”a”,”b”,2} 2. 引用计数减少的情况与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1 当该对象的别名被显式销毁时 del a 当该对象的引别名被赋予新的对象， a=26 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会） 将该元素从容器中删除时，或者容器被销毁时。 当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁 3.引用计数法有很明显的优点： 高效 运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 对象有确定的生命周期 易于实现 4. 原始的引用计数法也有明显的缺点： 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。循环引用的示例： 1234list1 &#x3D; []list2 &#x3D; []list1.append(list2)list2.append(list1) 二、标记-清除『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？ 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。 三、分代回收分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象 深入理解java垃圾回收机制一、垃圾回收机制的意义Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。 ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。 二、垃圾回收机制中的算法Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。 1.引用计数法(Reference Counting Collector)1.1算法分析 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 1.2优缺点优点： 引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。 缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 1.3引用计数算法无法解决循环引用问题123456789101112public class Main &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; ​ 最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。 2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)2.1 根搜索算法 根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 java中可作为GC Root的对象有 1.虚拟机栈中引用的对象（本地变量表） 2.方法区中静态属性引用的对象 3. 方法区中常量引用的对象 4.本地方法栈中引用的对象（Native对象） 2.2 tracing算法的示意图 2.3标记-清除算法分析标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。 3.compacting算法 或 标记-整理算法 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。 4.copying算法(Compacting Collector) 该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。 它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。 一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。 5.generation算法(Generational Collector) 分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。 年轻代（Young Generation） 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发) 年老代（Old Generation） 1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 持久代（Permanent Generation） ​ 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 三.GC（垃圾收集器）新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS Serial收集器（复制算法) 新生代单线程收集器，标记和清理都是单线程，优点是简单高效。 Serial Old收集器(标记-整理算法) 老年代单线程收集器，Serial收集器的老年代版本。 ParNew收集器(停止-复制算法) 新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。 Parallel Scavenge收集器(停止-复制算法) 并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。 Parallel Old收集器(停止-复制算法) Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先 CMS(Concurrent Mark Sweep)收集器（标记-清理算法） 高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择 四、GC的执行机制由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。 Scavenge GC 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 Full GC 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： &lt;div style=color:red&gt; 1.年老代（Tenured）被写满&lt;br&gt; 2.持久代（Perm）被写满 &lt;br&gt; 3.System.gc()被显示调用 &lt;br&gt; 4.上一次GC之后Heap的各域分配策略动态变化 &lt;/div&gt; 五、Java有了GC同样会出现内存泄露问题1. 静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。 1234567Static Vector v &#x3D; new Vector(); for (int i &#x3D; 1; i&lt;100; i++) &#123; Object o &#x3D; new Object(); v.add(o); o &#x3D; null; &#125; 在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。 2. 各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。 3. 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/tags/java/"},{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://zenner006.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]},{"title":"python中的锁","slug":"python_GIL","date":"2020-08-31T02:01:33.000Z","updated":"2020-08-31T02:11:11.933Z","comments":true,"path":"2020/08/31/python_GIL/","link":"","permalink":"http://zenner006.github.io/2020/08/31/python_GIL/","excerpt":"Python中的锁一、全局解释器锁（GIL）1、什么是全局解释器锁在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才能使用全局解释器（cpu）, 即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。 GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU 上运行该进程的一个线程。 CPython中 IO密集型，某个线程阻塞，就会调度其他就绪线程； CPU密集型，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。 在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL。 Python中绝大多数内置数据结构的读、写操作都是原子操作。 由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是 线程安全类型。","text":"Python中的锁一、全局解释器锁（GIL）1、什么是全局解释器锁在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才能使用全局解释器（cpu）, 即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。 GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU 上运行该进程的一个线程。 CPython中 IO密集型，某个线程阻塞，就会调度其他就绪线程； CPU密集型，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。 在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL。 Python中绝大多数内置数据结构的读、写操作都是原子操作。 由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是 线程安全类型。 2、全局解释器锁的好处1、避免了大量的加锁解锁的好处 2、使数据更加安全，解决多线程间的数据完整性和状态同步 3、全局解释器的缺点多核处理器退化成单核处理器，只能并发不能并行。 1同一时刻的某个进程下的某个线程只能被一个cpu所处理，所以在GIL锁下的线程只能被并发，不能被并行。 二、同步锁1、什么是同步锁？ 同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。 2、为什么用同步锁？ 因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程 序结果的完整性。 3、怎么使用同步锁？ 只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。 4、实例：123456789101112131415161718192021222324import timeimport threadingR = threading.Lock()def sub(): global num R.acquire() # 加锁，保证同一时刻只有一个线程可以修改数据 num -= 1 R.release() # 修改完成就可以解锁 time.sleep(1)num = 100 # 定义一个全局变量l = [] # 定义一个空列表，用来存放所有的列表for i in range(100): # for循环100次 t = threading.Thread(target=sub) # 每次循环开启一个线程 t.start() # 开启线程 l.append(t) # 将线程加入列表lfor i in l: i.join() # 这里加上join保证所有的线程结束后才运行下面的代码print(num)# 输出结果为0 5、扩展知识 1、GIL的作用：多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。 2、同步锁的作用：为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。 三、递归锁和死锁1、什么是死锁？指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源而相互等待的一个现象 12345678910111213141516171819202122232425262728293031323334import timeimport threadingA = threading.Lock()B = threading.Lock()import threadingclass obj(threading.Thread): def __init__(self): super().__init__() def run(self): self.a() # 如果两个锁同时被多个线程运行，就会出现死锁现象 self.b() def a(self): A.acquire() print('123') B.acquire() print(456) time.sleep(1) B.release() print('qweqwe') A.release() def b(self): B.acquire() print('asdfaaa') A.acquire() print('(⊙o⊙)哦(⊙v⊙)嗯') A.release() B.release()for i in range(2): # 循环两次，运行四个线程，第一个线程成功处理完数据，第二个和第三个就会出现死锁 t = obj() t.start() 这是python里写一个死锁的标准写法了吧；当b获取了B锁，a获取了A锁，a想要B锁继续，b想要A锁继续，于是就产生了死锁； 2、什么是递归锁？​ 在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import timeimport threadingA = threading.RLock() # 这里设置锁为递归锁import threadingclass obj(threading.Thread): def __init__(self): super().__init__() def run(self): self.a() self.b() def a(self): # 递归锁，就是将多个锁的钥匙放到一起，要拿就全拿，要么一个都拿不到 # 以实现锁 A.acquire() print(str(threading.currentThread().name) + ' 123') print(str(threading.currentThread().name) +\" 456\") time.sleep(1) print(str(threading.currentThread().name) +' qweqwe') A.release() def b(self): A.acquire() print(str(threading.currentThread().name) +' asdfaaa') print(str(threading.currentThread().name) +' (⊙o⊙)哦(⊙v⊙)嗯') A.release()if __name__ == '__main__': for i in range(2): t = obj() t.start()'''有锁时的输出：Thread-1 123Thread-1 456Thread-1 qweqweThread-1 asdfaaaThread-1 (⊙o⊙)哦(⊙v⊙)嗯Thread-2 123Thread-2 456Thread-2 qweqweThread-2 asdfaaaThread-2 (⊙o⊙)哦(⊙v⊙)嗯去掉锁的输出Thread-1 123Thread-1 456Thread-2 123Thread-2 456Thread-2 qweqweThread-1 qweqwe # 这里说明，线程2把数据写入了输出缓冲区，还没来得及输出呢，就被线程1给抢了，随着线程1一起输出了；Thread-1 asdfaaaThread-1 (⊙o⊙)哦(⊙v⊙)嗯 # 这一个空行就是线程2为打印出来的，它回来接着这里打印 Thread-2 asdfaaaThread-2 (⊙o⊙)哦(⊙v⊙)嗯之所以能被抢还是因为这是IO操作，释放了全局解释器锁''' 四、信号量（semaphore）1、什么是信号量？同进程的一样，semaphore管理一个内置的计数器，每当调用acquire()时内置函数-1，每当调用release()时内置函数+1。 计数器不能为0，当计数器为0时acquire（）将阻塞线程，直到其他线程调用release（）。 12345678910111213141516import threadingimport timemysf = threading.Semaphore(5) # 创建信号量对象,(5表示这个锁同时支持的个数)def func(): if mysf.acquire(): # 因为使用了信号量，下面的输出就会5个5个的同时输出 print(threading.currentThread().getName() + ' get semaphore') time.sleep(1) mysf.release()if __name__ == '__main__': for i in range(20): t = threading.Thread(target=func) t.start() 为什么在python中推荐使用多进程而不是多线程每个CPU在同一时间只能执行一个线程在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生 在Python多线程下，每个线程的执行方式1、获取GIL 2、执行代码直到sleep或者是python虚拟机将其挂起。 3、释放GIL 可见，某个线程想要执行，必须先拿到GIL，GIL会根据执行的字节码行数以及时间片释放，并且在遇到io操作的时候会主动释放。我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。 而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。 那么是不是python的多线程就完全没用了呢？在这里我们进行分类讨论： 1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。 2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。 而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。 请注意：多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低 回到最开始的问题：经常我们会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？ 原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。","categories":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"全局解释器锁","slug":"全局解释器锁","permalink":"http://zenner006.github.io/tags/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"name":"同步锁","slug":"同步锁","permalink":"http://zenner006.github.io/tags/%E5%90%8C%E6%AD%A5%E9%94%81/"},{"name":"递归锁","slug":"递归锁","permalink":"http://zenner006.github.io/tags/%E9%80%92%E5%BD%92%E9%94%81/"},{"name":"死锁","slug":"死锁","permalink":"http://zenner006.github.io/tags/%E6%AD%BB%E9%94%81/"},{"name":"信号量","slug":"信号量","permalink":"http://zenner006.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"redis","slug":"redis","date":"2020-08-07T03:20:32.000Z","updated":"2020-08-31T02:14:31.080Z","comments":true,"path":"2020/08/07/redis/","link":"","permalink":"http://zenner006.github.io/2020/08/07/redis/","excerpt":"[TOC] Redis一、 概念redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。","text":"[TOC] Redis一、 概念redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 二、下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 三、命令操作1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 四、持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 五、Java客户端 Jedis一、Jedis一款java操作redis数据库的工具. 123456789* 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(\"localhost\",6379); //2. 操作 jedis.set(\"username\",\"zhangsan\"); //3. 关闭连接 jedis.close(); 二、Jedis操作各种redis中的数据结构1) 字符串类型 string1234567891011121314151617setget //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 //存储 jedis.set(\"username\",\"zhangsan\"); //获取 String username = jedis.get(\"username\"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式123456789101112131415161718192021222324252627hsethgethgetAll//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // 存储hash jedis.hset(\"user\",\"name\",\"lisi\"); jedis.hset(\"user\",\"age\",\"23\"); jedis.hset(\"user\",\"gender\",\"female\"); // 获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(\"user\"); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + \":\" + value); &#125; //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素12345678910111213141516171819202122232425262728lpush / rpushlpop / rpoplrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // list 存储 jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存 jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(\"mylist\");//c System.out.println(element1); String element2 = jedis.rpop(\"mylist\");//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素1234567891011121314saddsmembers:获取所有元素//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // set 存储 jedis.sadd(\"myset\",\"java\",\"php\",\"c++\"); // set 获取 Set&lt;String&gt; myset = jedis.smembers(\"myset\"); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序12345678910111213141516zaddzrange//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // sortedset 存储 jedis.zadd(\"mysortedset\",3,\"亚瑟\"); jedis.zadd(\"mysortedset\",30,\"后裔\"); jedis.zadd(\"mysortedset\",55,\"孙悟空\"); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(\"mysortedset\", 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); ​ 三、jedis连接池： JedisPool使用：123456789101112131415161. 创建JedisPool连接池对象2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,\"localhost\",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(\"hehe\",\"heihei\"); //4. 关闭 归还到连接池中 jedis.close(); 连接池工具类123456789101112131415161718192021222324252627282930public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 ​","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"数据库/redis","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"}],"tags":[]},{"title":"AJAX_JSON","slug":"AJAX-JSON","date":"2020-08-07T00:47:37.000Z","updated":"2020-08-31T02:15:04.328Z","comments":true,"path":"2020/08/07/AJAX-JSON/","link":"","permalink":"http://zenner006.github.io/2020/08/07/AJAX-JSON/","excerpt":"AJAX：一、概念ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验","text":"AJAX：一、概念ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 二、实现方式：1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } 2. JQeury实现方式$.ajax()12345678910111213141516* 语法：$.ajax(&#123;键值对&#125;); //使用$.ajax()发送异步请求 $.ajax(&#123; url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(\"出错啦...\") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式 &#125;); $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON：一、概念JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;}; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。 二、语法：1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用{}定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &#39;gender&#39;: true}; var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}]; //获取person对象中所有的键和值 //for in 循环 /* for(var key in person){ //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); }*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) { var p = ps[i]; for(var key in p){ alert(key+&quot;:&quot;+p[key]); } } 三、JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 案例：* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[]},{"title":"JQuery","slug":"JQuery-beginning","date":"2020-08-06T06:37:54.000Z","updated":"2020-08-31T02:16:12.461Z","comments":true,"path":"2020/08/06/JQuery-beginning/","link":"","permalink":"http://zenner006.github.io/2020/08/06/JQuery-beginning/","excerpt":"JQuery 基础：一、概念 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 二、快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 三、JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象)","text":"JQuery 基础：一、概念 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 二、快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 三、JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 四、选择器筛选具有相似特征的元素(标签) 1. 基本操作学习：（1） 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); （2） 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 （3） 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类（1） 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 (2) 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 (3) 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器 (4) 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 (5) 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 五、DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 六、案例JQuery 高级一、动画1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 二、遍历1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式(1) jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) (2) $.each(object, [callback])(3) for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 三、 事件绑定1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 四、案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } ​​ &lt;/script&gt;​ &lt;/head&gt;​ ​ ​ ​ ​ ​ ​ ​ &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); ​​​ &lt;/script&gt;​ &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 五、插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery ​","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/tags/web/"},{"name":"JQuery","slug":"JQuery","permalink":"http://zenner006.github.io/tags/JQuery/"}]},{"title":"Filter_Listener","slug":"Filter-Listener","date":"2020-08-05T06:53:38.000Z","updated":"2020-08-05T11:37:43.655Z","comments":true,"path":"2020/08/05/Filter-Listener/","link":"","permalink":"http://zenner006.github.io/2020/08/05/Filter-Listener/","excerpt":"Filter：过滤器一、 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 二、 快速入门：1. 步骤： 1. 定义一个类，实现接口Filter 2. 覆写方法 3. 配置拦截路径 1. web.xml 2. 注解","text":"Filter：过滤器一、 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 二、 快速入门：1. 步骤： 1. 定义一个类，实现接口Filter 2. 覆写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码：1234567891011121314151617181920@WebFilter(\"/*\")//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"filterDemo1被执行了....\"); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125; &#125; 三、过滤器细节：1. web.xml配置123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解* 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源c 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 四、案例：1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。 ​ 2. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 * 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 Listener：监听器一、 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[]},{"title":"JSP_MVC_EL_JSTL","slug":"JSP-MVC-EL-JSTL","date":"2020-08-03T01:11:00.000Z","updated":"2020-08-03T07:19:18.674Z","comments":true,"path":"2020/08/03/JSP-MVC-EL-JSTL/","link":"","permalink":"http://zenner006.github.io/2020/08/03/JSP-MVC-EL-JSTL/","excerpt":"JSP:一、指令1. 作用 用于配置JSP页面，导入资源文件 2. 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 3. 分类：page ： 配置JSP页面的 * contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） * import：导包 * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 * isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception","text":"JSP:一、指令1. 作用 用于配置JSP页面，导入资源文件 2. 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 3. 分类：page ： 配置JSP页面的 * contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） * import：导包 * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 * isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 * &lt;%@include file=&quot;top.jsp&quot;%&gt; taglib ： 导入资源 * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; * prefix：前缀，自定义的 二、注释: 1. html注释： &lt;!-- --&gt;:只能注释html代码片段 2. jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有 三、内置对象 * 在jsp页面中不需要创建，直接使用的对象 * 一共有9个： 变量名 真实类型 作用 * pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 * request HttpServletRequest 一次请求访问的多个资源(转发) * session HttpSession 一次会话的多个请求间 * application ServletContext 所有用户间共享数据 * response HttpServletResponse 响应对象 * page Object 当前页面(Servlet)的对象 this * out JspWriter 输出对象，数据输出到页面上 * config ServletConfig Servlet的配置对象 * exception Throwable 异常对象 ​ MVC：开发模式一、 jsp演变历史 1. 早期只有servlet，只能使用response输出标签数据，非常麻烦 2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、 MVC 1. M：Model，模型。JavaBean * 完成具体的业务操作，如：查询数据库，封装对象 2. V：View，视图。JSP * 展示数据 3. C：Controller，控制器。Servlet * 获取用户的输入 * 调用模型 * 将数据交给视图进行展示 * 优缺点： 1. 优点： 1. 耦合性低，方便维护，可以利于分工协作 2. 重用性高 2. 缺点： 1. 使得项目架构变得复杂，对开发人员要求高 EL表达式一、概念 Expression Language 表达式语言 二、作用 替换和简化jsp页面中java代码的编写 三、语法 ${表达式} 四、注意： * jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. \\${表达式} ：忽略当前这个el表达式 五、使用：1. 运算： * 运算符： 1. 算数运算符： + - * /(div) %(mod) 2. 比较运算符： &gt; &lt; &gt;= &lt;= == != 3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 4. 空运算符： empty * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 2. 获取值 1. el表达式只能从域对象中获取值 2. 语法： 1. ${域名称.键名}：从指定域中获取指定键的值 * 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext） * 举例：在request域中存储了name=张三 * 获取：${requestScope.name} 2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 3. 获取对象、List集合、Map集合的值 1. 对象：${域名称.键名.属性名} * 本质上会去调用对象的getter方法 2. List集合：${域名称.键名[索引]} 3. Map集合： * ${域名称.键名.key名称} * ${域名称.键名[&quot;key名称&quot;]} 3. 隐式对象： * el表达式中有11个隐式对象 * pageContext： * 获取jsp其他八个内置对象 * ${pageContext.request.contextPath}：动态获取虚拟目录 ​ JSTL一、概念 JavaServer Pages Tag Library JSP标准标签库 * 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 二、作用用于简化和替换jsp页面上的java代码 三、使用步骤： 1. 导入jstl相关jar包 2. 引入标签库：taglib指令： &lt;%@ taglib %&gt; 3. 使用标签 四、常用的JSTL标签1. if相当于java代码的if语句 1. 属性： * test 必须属性，接受boolean表达式 * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 * 一般情况下，test属性值会结合el表达式一起使用 2. 注意： * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 12345678910111213141516171819202122232425262728&lt;% //判断request域中的一个list集合是否为空，如果不为null则显示遍历集合 List list = new ArrayList(); list.add(\"aaaa\"); request.setAttribute(\"list\",list); request.setAttribute(\"number\",4);%&gt;&lt;c:if test=\"$&#123;not empty list&#125;\"&gt; 遍历集合...&lt;/c:if&gt;&lt;br&gt;&lt;c:if test=\"$&#123;number % 2 != 0&#125;\"&gt; $&#123;number&#125;为奇数&lt;/c:if&gt;&lt;c:if test=\"$&#123;number % 2 == 0&#125;\"&gt; $&#123;number&#125;为偶数&lt;/c:if&gt; 2. choose相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default 12345678910&lt;c:choose&gt; &lt;c:when test=\"$&#123;number == 1&#125;\"&gt;星期一&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 2&#125;\"&gt;星期二&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 3&#125;\"&gt;星期三&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 4&#125;\"&gt;星期四&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 5&#125;\"&gt;星期五&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 6&#125;\"&gt;星期六&lt;/c:when&gt; &lt;c:when test=\"$&#123;number == 7&#125;\"&gt;星期天&lt;/c:when&gt; &lt;c:otherwise&gt;数字输入有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; 3. foreach相当于java代码的for语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%-- foreach:相当于java代码的for语句 1. 完成重复的操作 for(int i = 0; i &lt; 10; i ++)&#123; &#125; * 属性： begin：开始值 end：结束值 var：临时变量 step：步长 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始 2. 遍历容器 List&lt;User&gt; list; for(User user : list)&#123; &#125; * 属性： items:容器对象 var:容器中元素的临时变量 varStatus:循环状态对象 index:容器中元素的索引，从0开始 count:循环次数，从1开始--%&gt;&lt;c:forEach begin=\"1\" end=\"10\" var=\"i\" step=\"2\" varStatus=\"s\"&gt; $&#123;i&#125; &lt;h3&gt;$&#123;s.index&#125;&lt;h3&gt; &lt;h4&gt; $&#123;s.count&#125; &lt;/h4&gt;&lt;br&gt;&lt;/c:forEach&gt; &lt;hr&gt; &lt;% List list = new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); request.setAttribute(\"list\",list); %&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"str\" varStatus=\"s\"&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125;&lt;br&gt; &lt;/c:forEach&gt; 五、练习： * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;%@ page import=\"java.util.ArrayList\" %&gt;&lt;%@ page import=\"java.util.List\" %&gt;&lt;%@ page import=\"cn.itcast.domain.User\" %&gt;&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%-- Created by IntelliJ IDEA. User: zenner Date: 2020/8/3 Time: 11:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--准备数据--%&gt;&lt;% List list = new ArrayList(); list.add(new User(\"张三\",23,new Date())); list.add(new User(\"李四\",24,new Date())); list.add(new User(\"王五\",25,new Date())); request.setAttribute(\"list\", list);%&gt;&lt;table border=\"1\" width=\"500\" align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;/tr&gt; &lt;%-- 数据行 --%&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"user\" varStatus=\"s\"&gt; &lt;c:if test=\"$&#123;s.count%2==0&#125;\"&gt; &lt;tr bgcolor=\"red\"&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.birStr&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;s.count%2!=0&#125;\"&gt; &lt;tr bgcolor=\"green\"&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.birStr&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三层架构：软件设计架构1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 2. 业务逻辑层：处理业务逻辑的。 3. 数据访问层：操作数据存储文件。 案例：用户信息列表展示1. 需求：用户信息的增删改查操作 2. 设计： 1. 技术选型：Servlet + JSP + MySQL + JDBCTemplate + Duird + BeanUtilS + tomcat 2. 数据库设计： create database day17; -- 创建数据库 use day17; -- 使用数据库 create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) ); 3. 开发： 1. 环境搭建 1. 创建数据库环境 2. 创建项目，导入需要的jar包 2. 编码 4. 测试 5. 部署运维","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[]},{"title":"Cookie_Session_JSP","slug":"Cookie-Session-JSP","date":"2020-08-02T01:40:47.000Z","updated":"2020-08-02T06:46:53.764Z","comments":true,"path":"2020/08/02/Cookie-Session-JSP/","link":"","permalink":"http://zenner006.github.io/2020/08/02/Cookie-Session-JSP/","excerpt":"会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：Session","text":"会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：Session Cookie：一、概念客户端会话技术，将数据保存到客户端 二、 快速入门：1234567* 使用步骤： 1. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() 三、实现原理 * 基于响应头set-cookie和请求头cookie实现 * 响应头里的set-cookie会使得客户端自动保存cookie内容 * 然后浏览器再次请求的请求头里就有一个 Cookie: msg=hello 四、cookie的细节1. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 五、Cookie的特点和作用 1. cookie存储数据在客户端浏览器：容易丢失也容易被篡改 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别 六、案例：记住上一次访问时间1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123; for (Cookie cookie : cookies) &#123; //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(\"lastTime\".equals(name))&#123; //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(\"解码前：\"+value); //URL解码： value = URLDecoder.decode(value,\"utf-8\"); System.out.println(\"解码后：\"+value); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间为:\"+value+\"&lt;/h1&gt;\"); //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); System.out.println(\"编码前：\"+str_date); //URL编码 str_date = URLEncoder.encode(str_date,\"utf-8\"); System.out.println(\"编码后：\"+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); break; &#125; &#125; &#125; if(cookies == null || cookies.length == 0 || flag == false)&#123; //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); System.out.println(\"编码前：\"+str_date); //URL编码 str_date = URLEncoder.encode(str_date,\"utf-8\"); System.out.println(\"编码后：\"+str_date); Cookie cookie = new Cookie(\"lastTime\",str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; JSP：入门学习一、概念： * Java Server Pages： java服务器端页面 * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 * 用于简化书写！！！ 二、原理 * JSP本质上就是一个Servlet 三、JSP的脚本：JSP定义Java代码的方式 1. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 四、JSP的内置对象： * 在jsp页面中不需要获取和创建，可以直接使用的对象 * jsp一共有9个内置对象。 * 今天学习3个： * request * response * out：字符输出流对象。可以将数据输出到页面上。和 response.getWriter() 类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前 五、案例:改造Cookie案例Session：主菜一、概念服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 二、快速入门： 1. 获取HttpSession对象： HttpSession session = request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 三、原理 * Session的实现是依赖于Cookie的。 * 把Session对象生成的id通过Cookie响应给浏览器，然后浏览器再传回服务器，谁要获取Session就能通过Cookie中保存的id获取 ​ 四、细节：1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 五、session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析： ​","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/tags/web/"},{"name":"cookie","slug":"cookie","permalink":"http://zenner006.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://zenner006.github.io/tags/session/"},{"name":"JSP","slug":"JSP","permalink":"http://zenner006.github.io/tags/JSP/"}]},{"title":"request","slug":"request","date":"2020-07-30T12:47:28.000Z","updated":"2020-08-01T12:20:27.282Z","comments":true,"path":"2020/07/30/request/","link":"","permalink":"http://zenner006.github.io/2020/07/30/request/","excerpt":"HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常)","text":"HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Response对象一、功能：设置响应消息1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：1setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 二、案例：1. 完成重定向重定向：资源跳转的方式 代码实现：12345678//1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\"); //简单的重定向方法 response.sendRedirect(\"/day15/responseDemo2\"); 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 上面这两个遇到面试题就可能被问到：forward 和 redirect 区别 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：（重定向是给浏览器用） 需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：（请求转发是给服务器端使用的） 不需要加虚拟目录 * 转发路径 ​​ 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 1response.setContentType(\"text/html;charset=utf-8\"); 1234567891011121314151617181920@WebServlet(\"/responseDemo4\")public class ResponseDemo4 extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取流对象之前，设置流的默认编码，ISO-8859-1 设置为GBK// resp.setCharacterEncoding(\"utf-8\"); // 告诉浏览器，服务器发送的消息数据的编码。建议浏览器使用该编码解码 //resp.setHeader(\"content-type\",\"text/html;charset=utf-8\"); // 这一行不但设置了浏览器的编码而且也设置了流的编码， // 简单形式，设置编码 resp.setContentType(\"text/html;charset=utf-8\"); // 1. 获取字符输出流 PrintWriter pw = resp.getWriter(); // 2. 输出数据 //pw.write(\"&lt;h1&gt;Hello response&lt;/h1&gt;\"); pw.write(\"&lt;h1&gt;你好啊 response&lt;/h1&gt;\"); &#125; ...&#125; 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 123456789@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html;charset=utf-8\"); // 获取字节输出流 ServletOutputStream sos = resp.getOutputStream(); // 输出数据 sos.write(\"霓虹呀\".getBytes(\"utf-8\"));&#125; 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.zenner.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int width = 200; int height = 100; // 1. 创建一个对象能在内存画图（验证码图片对象） BufferedImage Image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); // 2. 美化图片 // 2.1 填充背景色 Graphics g = Image.getGraphics(); g.setColor(Color.pink); g.fill3DRect(0, 0, width, height, true); // 2.2 画边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width-1, height-1); // 2.3 写验证码 String str = \"ABCDEFGHIGKLMNOPQRSTUVWXYabcdefghigklmnopqrstuvwxyz0123456789\"; // 生成随机角标 Random ran = new Random(); for (int i = 0; i &lt; 4; i++) &#123; int j = ran.nextInt(str.length()); char c = str.charAt(j); g.drawString(c+\"\", width/5*(i+1), height/2); &#125; // 2.4 画干扰线 g.setColor(Color.GREEN); // 2.4.1 随机生成坐标点 for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; // 3. 将图片输出到页面展示 ImageIO.write(Image,\"jpg\", resp.getOutputStream()); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req,resp); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; /* 分析： 点击超链接或者图片，需要换一张验证码图片 1.给超链接和图片绑定单击事件 2. 重新设置图片的src属性值 */ window.onload = function () &#123; var img = document.getElementById(\"checkCode\"); img.onclick = function () &#123; // 加时间戳 var date = new Date().getTime(); img.src = \"/day15/checkCodeServlet?\"+date; &#125; var a = document.getElementById(\"check\"); &#125; function b() &#123; var img = document.getElementById(\"checkCode\"); var date = new Date().getTime(); img.src = \"/day15/checkCodeServlet?\"+date; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=\"checkCode\" src=\"/day15/checkCodeServlet\" alt=\"\" /&gt;&lt;a id=\"change\" href=\"#\" onclick=\"b()\"&gt;看不清换一张？&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ServletContext对象：1. 概念 代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能：(1) 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) (2) 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 (3) 获取文件的真实(服务器)路径1234567891. 方法：String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问 System.out.println(b); String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.zenner.web.download;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;@WebServlet(\"/downloadServlet\")public class DownloadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1. 获取请求参数，文件名称 String filename = req.getParameter(\"filename\"); // 2. 使用字节输入流加载文件进内存 // 2.1 找到文件服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(\"/img/\"+filename); // 2.2 使用字节输入流关联 FileInputStream fis = new FileInputStream(realPath); // 3. 设置response响应头 // 3.1 设置响应头类型：content-type String mimeType = servletContext.getMimeType(filename); resp.setHeader(\"content-type\",\"mimeType\"); // 3.2 设置响应头打开方式: content-disposition resp.setHeader(\"content-disposition\",\"attachment;filename=\"+filename); // 3. 将输入流的数据写出到输出流中 ServletOutputStream sos = resp.getOutputStream(); byte[] buff = new byte[1024*8]; int len = 0; while((len = fis.read(buff)) != -1)&#123; sos.write(buff,0,len); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/tags/web/"},{"name":"http","slug":"http","permalink":"http://zenner006.github.io/tags/http/"},{"name":"request","slug":"request","permalink":"http://zenner006.github.io/tags/request/"}]},{"title":"IDEA的开发环境配置","slug":"IDEA","date":"2020-07-30T02:49:57.000Z","updated":"2020-08-03T07:20:48.117Z","comments":true,"path":"2020/07/30/IDEA/","link":"","permalink":"http://zenner006.github.io/2020/07/30/IDEA/","excerpt":"配置项目第一步配置项目环境是在箭头指的地方设置。这里叫做 project structure 打开后可以看到一些东西： 一、project Project里设置SDK和你编译后的输出位置。一般需要明确的输出这个out地址。如果不设置可能Tomcat报错，也可以等Tomcat报错的时候再设置。","text":"配置项目第一步配置项目环境是在箭头指的地方设置。这里叫做 project structure 打开后可以看到一些东西： 一、project Project里设置SDK和你编译后的输出位置。一般需要明确的输出这个out地址。如果不设置可能Tomcat报错，也可以等Tomcat报错的时候再设置。 二、Modules 在Midule里设置source，path和Dependencies； 如果是要打开别人的项目。在source里可以直接指定src文件夹的位置就可以。 如果直接报错比如：javax.Servlet不存在这个时候，就需要在Dependencies里加入依赖包。不过这个错误一般在自己新建后的项目里都不会出现。或者作死自己删除了这个 Module设置。 三、facets这里要设置成项目的web文件夹 如果成了别的什么就404访问不到web文件夹下的资源文件。 四、Artifacts这个地方设置的是整个项目生成的结果。Tomcat在工作时不会访问你写这个项目的地方但是它是要访问这个项目部署的地方： 这个只要设置了就没什么问题 但是在后面的Tomcat设置时 deployment，也就是部署这一步就是告诉你这个项目部署的是啥。他不会找你的工作目录，这里需要告诉Tomcat这个Artifacts到底在哪里。 所以点加号设置Artifacts 如果这里只有External Source那么就要返回上一步查看Artifaces设置好了没。 设置TomcatTomcat是要为每一个项目单独设置一个的。所以新的项目就不要用之前的了，在这里要选+号。 之所以要用单独设置可以看看配置文件。在启动Tomcat后，输出的信息里有这个： 这个文件夹下就是Idea单独为这个项目搞得一个设置目录 这个文件夹下保存着之前部署的项目位置，也就是Artifaces设置的位置。 所以这个文件夹会告诉Tomcat要去哪里找请求的东西。 而这个设置文件夹则是IDEA与Tomcat进行关联设置的。","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"环境配置","slug":"web/环境配置","permalink":"http://zenner006.github.io/categories/web/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://zenner006.github.io/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://zenner006.github.io/tags/Tomcat/"}]},{"title":"http 和 request","slug":"http","date":"2020-07-30T00:15:09.000Z","updated":"2020-08-03T07:20:23.622Z","comments":true,"path":"2020/07/30/http/","link":"","permalink":"http://zenner006.github.io/2020/07/30/http/","excerpt":"HTTP：概念Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接,对缓存的支持","text":"HTTP：概念Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接,对缓存的支持 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式 Request：一. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 二. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 三. request功能：1. 获取请求消息数据（1） 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 演示：获取请求行数据 在新建文件时可以选择：create new servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.zenner.web.request;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 演示Request对象获取请求行数据 */@WebServlet(\"/requestDemo1\")public class RequestDemo1 extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /* 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /requestDemo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/requestDemo1 * StringBuffer getRequestURL() :http://localhost/day14/requestDemo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() */ //1. 获取请求方式 ：GET String method = request.getMethod(); System.out.println(method); //2.(*)获取虚拟目录：/day14 String contextPath = request.getContextPath(); System.out.println(contextPath); //3. 获取Servlet路径: /demo1 String servletPath = request.getServletPath(); System.out.println(servletPath); //4. 获取get方式请求参数：name=zhangsan String queryString = request.getQueryString(); System.out.println(queryString); //5.(*)获取请求URI：/day14/demo1 String requestURI = request.getRequestURI(); StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURI); System.out.println(requestURL); //6. 获取协议及版本：HTTP/1.1 String protocol = request.getProtocol(); System.out.println(protocol); //7. 获取客户机的IP地址： String remoteAddr = request.getRemoteAddr(); System.out.println(remoteAddr); &#125;&#125; （2） 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 （3） 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 ​ 2. 其他功能：（1） 获取请求参数通用方式 不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game hobby可能有好几个，所以返回数组 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); ​ （2） 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 （3） 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 （4） 获取ServletContext： * ServletContext getServletContext() 案例：用户登录一、 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 二、 开发步骤1. 创建项目，导入html页面，配置文件，jar包2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.domain;/** * 用户的实体类 */public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; 4. 创建包cn.itcast.util,编写工具类JDBCUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import javax.xml.crypto.Data;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * JDBC工具类 使用Durid连接池 */public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法123456789101112131415161718192021222324252627282930313233343536package cn.itcast.dao; import cn.itcast.domain.User;import cn.itcast.util.JDBCUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * 操作数据库中User表的类 */public class UserDao &#123; //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser)&#123; try &#123; //1.编写sql String sql = \"select * from user where username = ? and password = ?\"; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace();//记录日志 return null; &#125; &#125;&#125; 6. 编写cn.itcast.web.servlet.LoginServlet类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast.web.servlet;import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; 7. 编写FailServlet和SuccessServlet类12345678910111213141516171819202122232425262728293031323334353637@WebServlet(\"/successServlet\")public class SuccessServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) request.getAttribute(\"user\"); if(user != null)&#123; //给页面写一句话 //设置编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\"); &#125; ​ &#125; @WebServlet(\"/failServlet\") public class FailServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //给页面写一句话 //设置编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; &#125; 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： # 这两个方法是按照setter和getter方法名上的name来进行设置。 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/tags/web/"},{"name":"http","slug":"http","permalink":"http://zenner006.github.io/tags/http/"},{"name":"request","slug":"request","permalink":"http://zenner006.github.io/tags/request/"}]},{"title":"剑指 Offer 06. 从尾到头打印链表","slug":"Slash-offer-06","date":"2020-07-28T13:49:27.000Z","updated":"2020-10-07T09:19:27.839Z","comments":true,"path":"2020/07/28/Slash-offer-06/","link":"","permalink":"http://zenner006.github.io/2020/07/28/Slash-offer-06/","excerpt":"题目剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 12输入：head &#x3D; [1,3,2]输出：[2,3,1]","text":"题目剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 12输入：head &#x3D; [1,3,2]输出：[2,3,1] 题解python还是很好写的。很多数据结构的变换都不需要考虑。 1234567891011121314151617181920212223242526# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def reversePrint(self, head): res = [] root = head while root: res.insert(0,root.val) root = root.next return resif __name__ == '__main__': L = [1,2,3,4,5] Head = ListNode(1) R = Head i = 1 while i &lt; len(L): R.next = ListNode(L[i]) i += 1 R = R.next a = Solution() print(a.reversePrint(Head)) Java这里用到了Stack类 123456789101112131415161718192021222324252627282930313233343536373839404142package Slash_offer.easy;import java.util.Stack;//Definition for singly-linked list.class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Slash_offer_06_从尾到头打印链表 &#123; public static void main(String[] args) &#123; Slash_offer_06_从尾到头打印链表 slash_offer_06_从尾到头打印链表 = new Slash_offer_06_从尾到头打印链表(); int [] L = new int[]&#123;1,2,3,4,5&#125;; ListNode Head = new ListNode(1); ListNode R = Head; int i = 1; while (i&lt;L.length)&#123; R.next = new ListNode(L[i++]); R = R.next; &#125; for (int i1 : slash_offer_06_从尾到头打印链表.reversePrint(Head)) &#123; System.out.println(i1); &#125; &#125; public int[] reversePrint(ListNode head) &#123; Stack&lt;Integer&gt; integers = new Stack&lt;&gt;(); ListNode R = head; while (R!=null)&#123; integers.push(R.val); R = R.next; &#125; int length = integers.size(); int[] ints = new int[length]; for (int i = 0; i &lt; length ; i++) &#123; ints[i] = integers.pop(); &#125; return ints; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"},{"name":"简单","slug":"algorithm/剑指offer/简单","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://zenner006.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指 Offer 05. 替换空格","slug":"Slash-offer-05","date":"2020-07-28T13:21:40.000Z","updated":"2021-06-28T08:44:12.862Z","comments":true,"path":"2020/07/28/Slash-offer-05/","link":"","permalink":"http://zenner006.github.io/2020/07/28/Slash-offer-05/","excerpt":"题目剑指 Offer 05. 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 12输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;","text":"题目剑指 Offer 05. 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 12输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 题解python解法12345678910111213141516class Solution: def replaceSpace(self, s): L = [] last = 0 for i in range(len(s)): if s[i] == \" \": L.append(s[last:i]+\"%20\") last = i+1 if last &lt; len(s): L.append(s[last:len(s)]) return \"\".join(L)if __name__ == '__main__': a = Solution() print(a.replaceSpace(\"I am the Only King!\")) print(a.replaceSpace(\" \")) java解法1234567891011121314151617181920212223242526package Slash_offer.easy;public class Slash_offer_05 &#123; public static void main(String[] args) &#123; Slash_offer_05 slash_offer_05 = new Slash_offer_05(); System.out.println(slash_offer_05.replaceSpace(\"I am the king\")); System.out.println(slash_offer_05.replaceSpace(\" \")); &#125; public String replaceSpace(String s) &#123; int length = s.length(); char [] res = new char[3 * length]; int j = 0 ; for (int i = 0; i &lt; length; i++) &#123; if (' '==(s.charAt(i)))&#123; res[j++] = '%'; res[j++] = '2'; res[j++] = '0'; &#125;else&#123; res[j++] = s.charAt(i); &#125; &#125; return new String(res,0,j); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"},{"name":"简单","slug":"algorithm/剑指offer/简单","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符","slug":"字符","permalink":"http://zenner006.github.io/tags/%E5%AD%97%E7%AC%A6/"}]},{"title":"Tomcat&SerVlet","slug":"Tomcat-SerVlet","date":"2020-07-28T03:28:50.000Z","updated":"2020-07-29T09:36:47.465Z","comments":true,"path":"2020/07/28/Tomcat-SerVlet/","link":"","permalink":"http://zenner006.github.io/2020/07/28/Tomcat-SerVlet/","excerpt":"web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp....","text":"web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 找到占用自己端口的进程 杀死进程就好了 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\\hello&quot; /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet1. 概念运行在服务器端的小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 2. 快速入门 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名 4. tomcat会将字节码文件加载进内存，并且创建其对象 5. 调用其方法 4. Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 5. Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用 @WebServlet注解，进行配置 * @WebServlet(&quot;资源路径&quot;) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; } 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配 IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 * 查看控制台的log：Using CATALINA_BASE: &quot;C:\\Users\\fqy\\.IntelliJIdea2018.1\\system\\tomcat\\_itcast&quot; 2. 工作空间项目 和 tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java web","slug":"java/java-web","permalink":"http://zenner006.github.io/categories/java/java-web/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://zenner006.github.io/tags/Tomcat/"},{"name":"java","slug":"java","permalink":"http://zenner006.github.io/tags/java/"},{"name":"java web","slug":"java-web","permalink":"http://zenner006.github.io/tags/java-web/"},{"name":"SerVlet","slug":"SerVlet","permalink":"http://zenner006.github.io/tags/SerVlet/"}]},{"title":"leetcode_0104","slug":"leetcode-0104","date":"2020-07-28T00:45:14.000Z","updated":"2020-10-07T09:21:04.172Z","comments":true,"path":"2020/07/28/leetcode-0104/","link":"","permalink":"http://zenner006.github.io/2020/07/28/leetcode-0104/","excerpt":"题目104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回它的最大深度 3 。","text":"题目104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回它的最大深度 3 。 题解12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Tree: ''' 用来从数组中得到整个树的方法 ''' def getTreeFromList(self, L, index): if index &lt; len(L) and L[index] != None: root = TreeNode(L[index]) root.right = self.getTreeFromList(L, (index+1)*2) root.left = self.getTreeFromList(L, (index+1)*2-1) return root else: return Noneclass Solution: ''' 主要的方法，其实很简单 ''' def maxDepth(self, root): if not root: return 0 else: return 1 + max(self.maxDepth(root.right),self.maxDepth(root.left))if __name__ == '__main__': L = [3,9,20,None,None,15,7] T = Tree() root = T.getTreeFromList(L,0) print(root) a = Solution() print(a.maxDepth(root))","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"},{"name":"简单","slug":"algorithm/leetcode/简单","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://zenner006.github.io/tags/%E6%A0%91/"}]},{"title":"xml","slug":"xml","date":"2020-07-27T03:01:46.000Z","updated":"2020-07-28T03:22:21.603Z","comments":true,"path":"2020/07/27/xml/","link":"","permalink":"http://zenner006.github.io/2020/07/27/xml/","excerpt":"XML：1. 概念Extensible Markup Language 可扩展标记语言 * 可扩展：标签都是自定义的。 &lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 * w3c:万维网联盟","text":"XML：1. 概念Extensible Markup Language 可扩展标记语言 * 可扩展：标签都是自定义的。 &lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 * w3c:万维网联盟 2. 语法：基本语法：1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭： 也可以定义自闭合标签 6. xml标签名称区分大小写 快速入门：123456789101112131415&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA 区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; ​ 约束 规定xml文档的书写规则 * 作为框架的使用者(程序员)： 1. 能够在xml中引入约束文档 2. 能够简单的读懂约束文档 * 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 * DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; * Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; ​ 3. 解析操作xml文档，将文档中的数据读取到内存中 * 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 ​ * xml常见的解析器： 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 Jsoupjsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码：12345678910111213//2.1获取student.xml的pathString path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath();//2.2解析xml文档，加载文档进内存，获取dom树---&gt;DocumentDocument document = Jsoup.parse(new File(path), \"utf-8\");//3.获取元素对象 ElementElements elements = document.getElementsByTag(\"name\");System.out.println(elements.size());//3.1获取第一个name的Element对象Element element = elements.get(0);//3.2获取数据String name = element.text();System.out.println(name); 对象的使用：1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements元素Element对象的集合。可以当做 ArrayList来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值，不区分大小写 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括子标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 ​ 快捷查询方式：1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 2. XPathXPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 代码：12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(\"//student\"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(\"//student/name\"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(\"//student/name[@id]\"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(\"//student/name[@id='itcast']\"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125;","categories":[{"name":"xml","slug":"xml","permalink":"http://zenner006.github.io/categories/xml/"}],"tags":[]},{"title":"leetcode_0392","slug":"leetcode-0392","date":"2020-07-27T01:37:27.000Z","updated":"2020-10-07T09:21:28.161Z","comments":true,"path":"2020/07/27/leetcode-0392/","link":"","permalink":"http://zenner006.github.io/2020/07/27/leetcode-0392/","excerpt":"题目392. 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: 1s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot; 返回 true. 示例 2: 1s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot; 返回 false.","text":"题目392. 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: 1s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot; 返回 true. 示例 2: 1s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot; 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 答案双指针12345678910111213141516class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: n = len(s) m = len(t) i = 0 j = 0 while i&lt;n and j &lt; m: if s[i] == t[j]: i += 1 j += 1 else: j += 1 if i == n: return True else: return False 动态规划官方题解里给出了一个动态规划的解法。 思路： 每个位置之后遇到26个小写字母的情况是如何的？ 位置是0 ~ m-1​ ; 最后再加上一个全 m 的向量（26个小写字母）表示在 m 这个越界位置，遇到某个字母是不可能的。 那么对于 m-1 位置上的表示 m-1开始往后某个字母的位置，因为m-1 开始只有一个字母，其他的都不可能出现了，所以这一列只有有的那个字母表示为 m-1，其他的都是m；以此往前完成 $f[i][j]$ 最终得到一个转换表。 后来不论来什么字符串在第一个位置查，从第一个位置开始出现那这个字符串第一个字符的位置。所以这个方法虽然复杂了一点，但是完全适用于问题中的后续挑战。 题解： 思路及算法 考虑前面的双指针的做法，我们注意到我们有大量的时间用于在 tt 中找到下一个匹配字符。 这样我们可以预处理出对于 tt 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。 我们可以使用动态规划的方法实现预处理，令 $f[i][j]$ 表示字符串 tt 中从位置 $i$ 开始往后字符 $j$ 第一次出现的位置。在进行状态转移时，如果 $t$ 中位置 $i$ 的字符就是 $j$，那么 $f[i][j]=if[i][j]=i$，否则 $j$ 出现在位置 i+1i+1 开始往后，即 $f[i][j]=f[i+1][j]$，因此我们要倒过来进行动态规划，从后往前枚举 $i$。 这样我们可以写出状态转移方程： f[i][j]=\\left\\{ \\begin{aligned} i, & &t[i]=j\\\\ f[i+1][j],& & t[i]\\neq j\\\\ \\end{aligned} \\right.1234567891011121314151617class Solution: def isSubsequence(self, s: str, t: str) -&gt; bool: n, m = len(s), len(t) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): f[i][j] = i if ord(t[i]) == j + ord('a') else f[i + 1][j] add = 0 for i in range(n): if f[add][ord(s[i]) - ord('a')] == m: return False add = f[add][ord(s[i]) - ord('a')] + 1 return True","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"},{"name":"容易","slug":"algorithm/leetcode/容易","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E5%AE%B9%E6%98%93/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"双指针","slug":"双指针","permalink":"http://zenner006.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"Bootstrap","slug":"Bootstrap","date":"2020-07-26T11:44:07.000Z","updated":"2020-07-27T02:56:13.179Z","comments":true,"path":"2020/07/26/Bootstrap/","link":"","permalink":"http://zenner006.github.io/2020/07/26/Bootstrap/","excerpt":"Bootstrap：1. 概念一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 * 好处： 1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 2. 响应式布局。 * 同一套页面可以兼容不同分辨率的设备。","text":"Bootstrap：1. 概念一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 * 好处： 1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 2. 响应式布局。 * 同一套页面可以兼容不同分辨率的设备。 2. 快速入门 1. 下载Bootstrap 2. 在项目中将Bootstrap解压后的这三个文件夹复制 3. 创建html页面，引入必要的资源文件 下面的代码是Bootstap的模板。只是简单的引入了各种资源文件。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局* 同一套页面可以兼容不同分辨率的设备。 * 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 * 步骤： 1. 定义容器。相当于之前的table、 * 容器分类： 1. container：两边留白 2. container-fluid：每一种设备都是100%宽度 2. 定义行。相当于之前的tr 样式：row 3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 * 设备代号： 1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12 2. sm：小屏幕 平板 (≥768px) 3. md：中等屏幕 桌面显示器 (≥992px) 4. lg：大屏幕 大桌面显示器 (≥1200px) * 注意： 1. 一行中如果格子数目超过12，则超出部分自动换行。 2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 CSS样式和JS插件1. 全局CSS样式： * 按钮：class=&quot;btn btn-default&quot; * 图片： * class=&quot;img-responsive&quot;：图片在任意尺寸都占100% * 图片形状 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 * &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 * 表格 * table * table-bordered * table-hover * 表单 * 给表单项添加：class=&quot;form-control&quot; 2. 组件： * 导航条 * 分页条 3. 插件： * 轮播图 案例&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246 &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style&gt; .paddtop&#123; padding-top: 10px; &#125; .search-btn&#123; float: left; border:1px solid #ffc900; width: 90px; height: 35px; background-color:#ffc900 ; text-align: center; line-height: 35px; margin-top: 15px; &#125; .search-input&#123; float: left; border:2px solid #ffc900; width: 400px; height: 35px; padding-left: 5px; margin-top: 15px; &#125; .jx&#123; border-bottom: 2px solid #ffc900; padding: 5px; &#125; .company&#123; height: 40px; background-color: #ffc900; text-align: center; line-height:40px ; font-size: 8px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1.页眉部分--&gt; &lt;header class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; &lt;img src=\"img/top_banner.jpg\" class=\"img-responsive\"&gt; &lt;/div&gt; &lt;div class=\"row paddtop\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;img src=\"img/logo.jpg\" class=\"img-responsive\"&gt; &lt;/div&gt; &lt;div class=\"col-md-5\"&gt; &lt;input class=\"search-input\" placeholder=\"请输入线路名称\"&gt; &lt;a class=\"search-btn\" href=\"#\"&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;img src=\"img/hotel_tel.png\" class=\"img-responsive\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class=\"row\"&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Link &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class=\"row\"&gt; &lt;div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;!-- Indicators --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=\"carousel-inner\" role=\"listbox\"&gt; &lt;div class=\"item active\"&gt; &lt;img src=\"img/banner_1.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/banner_2.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img src=\"img/banner_3.jpg\" alt=\"...\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;!-- 2.主体部分--&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row jx\"&gt; &lt;img src=\"img/icon_5.jpg\"&gt; &lt;span&gt;黑马精选&lt;/span&gt; &lt;/div&gt; &lt;div class=\"row paddtop\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row jx\"&gt; &lt;img src=\"img/icon_6.jpg\"&gt; &lt;span&gt;国内游&lt;/span&gt; &lt;/div&gt; &lt;div class=\"row paddtop\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;img src=\"img/guonei_1.jpg\"&gt; &lt;/div&gt; &lt;div class=\"col-md-8\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"img/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3.页脚部分--&gt; &lt;footer class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; &lt;img src=\"img/footer_service.png\" class=\"img-responsive\"&gt; &lt;/div&gt; &lt;div class=\"row company\"&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882 &lt;/div&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"Bootstrap","slug":"web/Bootstrap","permalink":"http://zenner006.github.io/categories/web/Bootstrap/"}],"tags":[]},{"title":"leetcode 42. 接雨水","slug":"leetcode-0042","date":"2020-07-26T11:24:33.000Z","updated":"2020-10-07T09:20:49.355Z","comments":true,"path":"2020/07/26/leetcode-0042/","link":"","permalink":"http://zenner006.github.io/2020/07/26/leetcode-0042/","excerpt":"题目42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6","text":"题目42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution: ''' 首先这个题目让我想起了之前做过的一些题目的感觉 好像是股票那个题目。 求得收益 分析这个题目：首先是要接水。 思路： 事实上要是有两个最高的柱子，就可以支起一个水池子。 但是在遍历过程中一般都是走到这山望得那山高这个山柱子担当水柱子，在下一个池子里也可以担当水池子。 但是，一旦在后面遇到了一个更高的山可能就把这个山头给淹没了。 这里计算得到的结果就没用了。 所以用一个列表把这些水柱子的位置都记住。然后计算了盛的水后，可以把它给填了。 在后面遇到更高的山时就不会计算两边 也想到可以用栈来实现： 如果要入栈的柱子比栈顶高就出栈： 如果碰到栈底则直接弹出把当前要入栈的入栈就好了。 出栈一次后，如果此时栈顶与之前栈顶相等接着出栈 如果（此时栈顶大于之前栈顶）并且（此时栈顶小于等于要入栈的柱子）就在接的雨水值加上 ： （此时栈顶- 之前栈顶）*他们的距离，然后出栈，再把要入栈的入栈 如果（此时栈顶大于之前栈顶）并且（此时栈顶大于要入栈的柱子）就在接的雨水值加上 ： （要入栈的柱子-之前栈顶）*他们的距离，然后要入栈的入栈 直到可以蓄水也就是比中间的值大一点（入栈是非递增的:增减+持续相等） 如果比栈顶低或者等于栈底就入栈 ''' def trap(self, height): # 在栈中保存的是柱子的索引 stack = [] res = 0 # 储存的水量 flag = True # 栈为空表示为真 for i in range(len(height)): if flag: stack.append(i) flag = False elif height[i] &lt;= height[stack[-1]]: stack.append(i) else: while height[i] &gt; height[stack[-1]]: temp = stack[-1] while height[stack[-1]] == height[temp]: print(temp) temp = stack.pop() if not stack: # 到栈底了 （因为已经出来了一个了，此时也很有可能为空的） # 这时也就是要进来的这个水柱在之前是无法储水的 flag = True break # 直到栈顶和之前出栈的不相等时,计算中间能存多少水 # 此时有两种情况： # 1. 栈空了 # 2. 值更大了。 # a. 此时栈顶小于等于要入栈的柱子 # b. 此时栈顶大于要入栈的柱子 if flag: break else: if height[stack[-1]] &lt;= height[i]: res += (i - stack[-1] -1) * (height[stack[-1]] - height[temp]) else: res += (i - stack[-1] - 1) * (height[i] - height[temp]) stack.append(i) if flag: flag = False; return resif __name__ == \"__main__\": a = Solution() print(a.trap([0,5,6,4,6,1,0,0,2,7]))","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"},{"name":"困难","slug":"algorithm/leetcode/困难","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E5%9B%B0%E9%9A%BE/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zenner006.github.io/tags/%E6%A0%88/"}]},{"title":"leetcode_0329 矩阵中的最长递增路径","slug":"leetcode-0329","date":"2020-07-26T09:03:14.000Z","updated":"2020-10-07T09:21:21.313Z","comments":true,"path":"2020/07/26/leetcode-0329/","link":"","permalink":"http://zenner006.github.io/2020/07/26/leetcode-0329/","excerpt":"题目给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 12345678输入: nums &#x3D; [ [9,9,4], [6,6,8], [2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2: 12345678输入: nums &#x3D; [ [3,4,5], [3,2,6], [2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。","text":"题目给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 12345678输入: nums &#x3D; [ [9,9,4], [6,6,8], [2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2: 12345678输入: nums &#x3D; [ [3,4,5], [3,2,6], [2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 答案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: def longestIncreasingPath(self, matrix): # 设置一个矩阵 每个元素表示由该节点出发最远到别的地方的长度 先把初始值都为一个空字符串\"；表示这个是没有被检测过的位置 if not matrix: return 0; m = len(matrix) n = len(matrix[0]) dp = [[\"\"]*n for _ in range(m)] # 这个函数用来得到一个元素点最远所能达到的距离。 def getDPElement(i,j): # 1. 如果再dp矩阵中已经有了的就直接返回 # 2. 如果没有的现场算一下 if dp[i][j] != \"\": return dp[i][j] else: # 此时矩阵中这个位置的值还没求出，想要外延展，则需要要那周围四个位置的值要大于（i，j）的值为前提才可以 D_x = [0,1,0,-1] D_y = [1,0,-1,0] res = 0 # 用这个值获取周围有比它大的数字的最大长度。 for x,y in zip(D_x,D_y): # 判断边界，再比较大小，同时满足后对邻居调用本函数 if not (i+x &lt; 0 or i+x &gt;= m or j+y &lt; 0 or j+y &gt;= n): if matrix[i][j] &lt; matrix[i+x][j+y]: res = max(res, getDPElement(i+x,j+y)) dp[i][j] = res + 1 # 此时包括了该位置 return dp[i][j] # 主函数里调用 res = 1 for i in range(m): for j in range(n): temp = getDPElement(i,j) if res &lt; temp: res = temp return resif __name__ == \"__main__\": nums_1 =[ [9, 9, 4], [6, 6, 8], [2, 1, 1]] nums_2 =[ [3, 4, 5], [3, 2, 6], [2, 2, 1]] a = Solution() print(a.longestIncreasingPath(nums_1)) print(a.longestIncreasingPath(nums_2))","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"},{"name":"困难","slug":"algorithm/leetcode/困难","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E5%9B%B0%E9%9A%BE/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"注解与反射","slug":"Annotation-reflection","date":"2020-07-25T03:24:21.000Z","updated":"2020-07-26T02:59:36.294Z","comments":true,"path":"2020/07/25/Annotation-reflection/","link":"","permalink":"http://zenner006.github.io/2020/07/25/Annotation-reflection/","excerpt":"注解1.什么是注解？ Annotation 的作用 不是程序本身，可以对程序作出解释。 可以被其他程序读取 Annotation的格式： 注解是以“@注释名”在代码中存在的，还可以添加一些参数值；例如：@SuppressWarnings(value = “unchecked”) Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问","text":"注解1.什么是注解？ Annotation 的作用 不是程序本身，可以对程序作出解释。 可以被其他程序读取 Annotation的格式： 注解是以“@注释名”在代码中存在的，还可以添加一些参数值；例如：@SuppressWarnings(value = “unchecked”) Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 12345678910package com.polly.annotation;//什么是注解public class Test01 extends Object&#123; //@Override 重写的注解 @Override public String toString() &#123; return super.toString(); &#125;&#125; ​ @Deprecated的程序元素是程序员不鼓励使用的程序元素，通常是因为它是危险的，或者因为存在更好的替代方法。编译器在不被弃用的代码中使用或覆盖不推荐使用的程序元素时发出警告。 ​ @SuppressWarnings表示在注释元素（以及注释元素中包含的所有程序元素）中应该抑制命名的编译器警告。 2. 内置注解 3.元注解 1234567891011121314151617181920212223package com.polly.annotation;import java.lang.annotation.*;//测试元注解public class Test02 &#123; @MyAnnotation public void test()&#123; &#125;&#125;//定义一个注解//Target 表示我们的注解可以用在哪些地方@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 表示我们的注解在什么地方还有效（默认runtime）//runtime&gt;class&gt;sources@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示是否将我们的注解生成在JAVAdoc中@Documented//Inherited 子类可以继承父类的注解@Inherited@interface MyAnnotation&#123;&#125; 3.自定义注解 12345678910111213141516171819202122232425262728293031package com.polly.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//自定义注解public class Test03 &#123; //注解可以显式赋值，如果没有默认值，我们就必须给注解赋值 @MyAnnotation2(age=18) public void test()&#123;&#125; @MyAnnotation3(\"polly\") //只有value可以省略 public void test2()&#123;&#125;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; //注解的参数：参数类型+参数名（）； String name() default \"\"; int age(); int id() default -1;//如果默认值为-1.代表不存在 String[] schools() default &#123;\"电大\",\"武汉理工\"&#125;;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation3&#123; String value(); &#125; 反射 1.反射概述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.polly.reflection;//什么叫反射public class test02 extends Object&#123; public static void main(String[] args) throws ClassNotFoundException &#123; //通过反射获取类的Class对象 Class c1 = Class.forName(\"com.polly.reflection.User\"); System.out.println(c1); Class c2 = Class.forName(\"com.polly.reflection.User\"); Class c3 = Class.forName(\"com.polly.reflection.User\"); Class c4 = Class.forName(\"com.polly.reflection.User\"); //一个类在内存中只有一个Class对象 //一个类被加载后，类的整个结构都会被封装在Class对象中 System.out.println(c2.hashCode()); System.out.println(c3.hashCode()); System.out.println(c4.hashCode()); &#125;&#125;//实体类：pojo，entityclass User&#123; private String name; private int id; private int age; public User()&#123;&#125; public User(String name, int id, int age) &#123; this.name = name; this.id = id; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", id=\" + id + \", age=\" + age + '&#125;'; &#125;&#125; 2.得到Class类的几种方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.polly.reflection;//测试Class类的创建方法有哪些public class test03 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Person person = new Student(); System.out.println(\"这个人是\"+person.name); //方式一：通过对象获得 Class c1 = person.getClass(); System.out.println(c1.hashCode()); //方式二：forname获得 Class c2 = Class.forName(\"com.polly.reflection.Student\"); System.out.println(c2.hashCode()); //方式三：通过类名.class获得 Class c3 = Student.class; System.out.println(c3.hashCode()); //方式四：基本内置类型包装类都有一个Type属性 Class&lt;Integer&gt; c4 = Integer.TYPE; System.out.println(c4); //获得父类类型 Class c5 = c1.getSuperclass(); System.out.println(c5); &#125;&#125;class Person&#123; public String name; public Person()&#123;&#125; public Person(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125;class Student extends Person&#123; public Student()&#123; this.name = \"学生\"; &#125;&#125;class Teacher extends Person&#123; public Teacher()&#123; this.name = \"老师\"; &#125;&#125; 3.哪些类型可以有Class对象 123456789101112131415161718192021222324252627282930313233343536package com.polly.reflection;import com.sun.management.VMOption;import java.lang.annotation.ElementType;//所有类型的Classpublic class Test04 &#123; public static void main(String[] args) &#123; Class c1 = Object.class; //类 Class c2 = Comparable.class; //接口 Class c3 = String[].class; //一维数组 Class c4 = int[][].class; //二维数组 Class c5 = Override.class; //注解 Class c6 = ElementType.class; //枚举 Class c7 = Integer.class; //基本数据类型 Class c8 = void.class; //void Class c9 = Class.class; //Class System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); //只要元素类型与维度一样，就是同一个Class int[] a = new int[10]; int[] b = new int[100]; System.out.println(a.getClass().hashCode()); System.out.println(b.getClass().hashCode()); &#125;&#125; 4.类加载内存分析 1234567891011121314151617181920212223242526272829package com.polly.reflection;public class test05 &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(A.m); /* 1.加载到内存，会产生一个类对应Class对象 2.链接，链接结束后m=0 3.初始化 &lt;clinit&gt;()&#123; System.out.println(\"A类静态代码块初始化\"); m = 300; m = 100; &#125; m = 100 */ &#125;&#125;class A&#123; static &#123; System.out.println(\"A类静态代码块初始化\"); m = 300; &#125; static int m = 100; public A()&#123; System.out.println(\"A类的无参构造初始化\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.polly.reflection;//测试类什么时候会初始化public class test06 &#123; static &#123; System.out.println(\"main类被加载\"); &#125; public static void main(String[] args) throws ClassNotFoundException &#123; //1.主动引用 Son son = new Son(); //2.反射也会产生主动引用 Class.forName(\"com.polly.reflection.Son\"); //不会产生类的引用的方法:通过子类去调用父类的静态变量 System.out.println(Son.b); //不会产生类的引用的方法:通过数组定义类引用，不会触发此类的初始化 Son[] array = new Son[5]; //不会产生类的引用的方法:引用常量不会触发此类的初始化 System.out.println(Son.M); &#125;&#125;class Father&#123; static int b = 2; static &#123; System.out.println(\"父类被加载\"); &#125;&#125;class Son extends Father&#123; static &#123; System.out.println(\"子类被加载\"); m = 300; &#125; static int m = 100; static final int M = 1;&#125; 5.类加载器 123456789101112131415161718192021222324252627282930package com.polly.reflection;public class test07 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类加载器的父类加载器--&gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器--&gt;根加载器（C/C++） ClassLoader parent1 = parent.getParent(); System.out.println(parent1); //测试当前类是那个加载器加载的 ClassLoader classLoader = Class.forName(\"com.polly.reflection.test07\").getClassLoader(); System.out.println(classLoader); //测试JDK内部类是那个加载器加载的 classLoader = Class.forName(\"java.lang.Object\").getClassLoader(); System.out.println(classLoader); //如何获得系统类加载器可以加载的路径 System.out.println(System.getProperty(\"java.class.path\")); &#125;&#125;/*jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733djdk.internal.loader.ClassLoaders$PlatformClassLoader@10f87f48nulljdk.internal.loader.ClassLoaders$AppClassLoader@3fee733dnull*/ 6.获得类的运行时结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.polly.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;//获得类的信息public class test08 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123; Class c1 = Class.forName(\"com.polly.reflection.User\"); //获得类的名字 System.out.println(c1.getName()); //获得包名+类名 System.out.println(c1.getSimpleName()); //获得类名 //获得类的属性 System.out.println(\"===================================\"); Field[] fields = c1.getFields(); //只能找到public属性，还有父类的； fields = c1.getDeclaredFields(); //可以找到所有属性 for (Field field : fields) &#123; System.out.println(field); &#125; //获得指定属性的值 Field name = c1.getDeclaredField(\"name\"); System.out.println(name); //获得类的方法 System.out.println(\"===================================\"); Method[] methods = c1.getMethods(); //获得本类及其父类的全部public方法 for (Method method : methods) &#123; System.out.println(\"正常的：\"+method); &#125; methods = c1.getDeclaredMethods(); //获得本类的所有方法 for (Method method : methods) &#123; System.out.println(\"getDeclaredMethods：\"+method); &#125; //获得指定方法 //重载，所以需要参数 Method getName = c1.getMethod(\"getName\", null); Method setName = c1.getMethod(\"setName\", String.class); System.out.println(getName); System.out.println(setName); //获得指定构造器 System.out.println(\"===================================\"); Constructor[] constructors = c1.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(\"#\"+constructor); &#125; Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(declaredConstructor); &#125;&#125; 7.动态创建对象执行方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.polly.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//动态的创建对象，通过反射public class test09 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123; //获得Class对象 Class c1 = Class.forName(\"com.polly.reflection.User\"); //构造一个对象 User user = (User) c1.newInstance(); //本质上是调用了类的无参构造 System.out.println(user); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); User user2 = (User) constructor.newInstance(\"polly\", 001, 18); System.out.println(user2); //通过反射调用普通方法 User user3 = (User) c1.getDeclaredConstructor().newInstance(); //通过反射获取一个方法 Method setName = c1.getDeclaredMethod(\"setName\", String.class); setName.invoke(user3,\"panyan\"); //invoke：激活的意思 //（对象，“方法的值”） System.out.println(user3.getName()); System.out.println(\"==============================================\"); //通过反射操作属性 User user4 = (User) c1.getDeclaredConstructor().newInstance(); Field name = c1.getDeclaredField(\"name\"); //不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true) name.setAccessible(true); name.set(user4,\"panyan2\"); System.out.println(user4.getName()); &#125;&#125; 性能分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.polly.reflection;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class Test10 &#123; //普通方式调用 public static void test01()&#123; User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; user.getName(); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"普通方法执行10亿次：\"+(endTime-startTime)+\"ms\"); &#125; //反射方式调用 public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\",null); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; getName.invoke(user,null); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"反射方法执行10亿次：\"+(endTime-startTime)+\"ms\"); &#125; //反射方式调用 关闭检测 public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\",null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; getName.invoke(user,null); &#125; long endTime = System.currentTimeMillis(); System.out.println(\"关闭检测de反射方法执行10亿次：\"+(endTime-startTime)+\"ms\"); &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; test01(); test02(); test03(); &#125;&#125;/*普通方法执行10亿次：3ms反射方法执行10亿次：256ms关闭检测de反射方法执行10亿次：113ms* */ 8.获取泛型信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.polly.reflection;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;//通过反射获取泛型public class Test11 &#123; public void test01(Map&lt;String,User&gt; map, List&lt;User&gt; list)&#123; System.out.println(\"test01\"); &#125; public Map&lt;String,User&gt; test02()&#123; System.out.println(\"test02\"); return null; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; Method method = Test11.class.getMethod(\"test01\", Map.class, List.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); for (Type genericParameterType : genericParameterTypes) &#123; System.out.println(\"#\"+genericParameterType); if (genericParameterType instanceof ParameterizedType)&#123; Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125; &#125; &#125; System.out.println(\"=======================================\"); method = test11.class.getMethod(\"test02\",null); Type genericReturnType = method.getGenericReturnType(); if (genericReturnType instanceof ParameterizedType)&#123; Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125; &#125; &#125;&#125;/*#java.util.Map&lt;java.lang.String, com.zenner.reflection.User&gt;class java.lang.Stringclass com.zenner.reflection.User#java.util.List&lt;com.zenner.reflection.User&gt;class com.zenner.reflection.User=======================================class java.lang.Stringclass com.zenner.reflection.User*? 9.获取注解信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.polly.reflection;import java.lang.annotation.*;import java.lang.reflect.Field;//练习反射操作注解public class test12 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; Class c1 = Class.forName(\"com.polly.reflection.Student2\"); //通过反射获得注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation); &#125; //获得注解的value的值 Tablepan tablepan = (Tablepan) c1.getAnnotation(Tablepan.class); String value = tablepan.value(); System.out.println(value); //获得类指定的注解 Field f = c1.getDeclaredField(\"id\"); Fieldpan annotation = f.getAnnotation(Fieldpan.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); &#125;&#125;@Tablepan(\"db_student\")class Student2&#123; @Fieldpan(columnName = \"db_id\",type = \"int\",length = 10) private int id; @Fieldpan(columnName = \"db_age\",type = \"int\",length = 10) private int age; @Fieldpan(columnName = \"db_name\",type = \"varchar\",length = 3) private String name; public Student2()&#123;&#125; public Student2(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Tablepan&#123; String value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface Fieldpan&#123; String columnName(); String type(); int length();&#125; 反射应用案例原本的这两个都有问题； 1. 反射与工厂设计模式工厂类每有一个子类都要写一个工厂类，这样的工厂类不能重复使用。所以我们使用反射中的Class.forName(&quot;包.类&quot;)，再用newInstance方法获得；进一步的可以使用泛型，通过传入想要的类的Class是的这个工厂类天下通行； 2. 反射与单例设计模式单例设计模式是饿汉式的； 构造方法私有化，只有一个static方法 但在多线程下，同时获取这种单例的实例化对象就可能出现多个对象；所以在这里使用synchronic关键字同步构造方法的结构，再用volate关键字使得私有的类属性（本类的对象索引属性）直接使用内存中的，而不是副本； 反射与类操作1. 获取类结果信息获取类：四种 3. 反射调用普通方法获取方法：四种 然后再通过反射获取方法的结构； 最重要的方法：invoke 4. 反射调用属性获取成员 Field类中的方法 设置属性内容： set 获取属性内容：get 解除封装：setAccessible； 5. Unsafe工具类Unsafe的获取过程需要反射： 因为它构造方法私有化，类属性有一个static unsafe类型的也是私有化的。但是不是单例设计模式那种。所以就是一个完全封闭的类。要进去就得开上帝视角，也就是解除封装获取那个属性就好了。 他能绕过实例化的管理。 然后利用这个实例化对象里的：allocateInstance方法给别的单例设计模式弄一个实例化对象；并未这种方式不调用构造方法； 反射与简单Java类1. 传统属性赋值弊端属性太多时，类里的方法大部分都是setter和getter；本质上他们都是重复的；可以用反射来解决这个问题 2. 属性自动赋值的实现思路要给一个类传属性的值。要通过反射的方式。这里就是在主方法获得class对象然后得到很多相应的信息。这里讲的东西把反射的过程集成到一个ClassInstanceFactory 类里。希望它是一个万能的东西：接受反射对象和属性内容并获取指定类的实例化对象； 3. 设置各种数据类型在这里实现了所有可能出现的类型；包括：Long,int,double,Date 4. 级联对象实例化也就是各种类相互融合在了一起；比如部门属于一个公司，部门类里就有公司属性，公司类里就有部门属性。然后公司类，部门类里也都有name属性； 外部获取时也就是：getDept().getDname()，getDept().getCompany().setName(&quot;sdsf&quot;)； 而这里级联里可能就写很长，如果其中一个对象的实例化得不到。那么就影响整个代码运行。所以这里他想要自动实现对象实例化 级联对象一般都用“.”来取。以这个为判断； 5. 级联属性赋值ClassLoader类加载器1. 类加载器简介java提供了一个环境变量：CLASSPATH，这个环境变量的作用主要在JVM进程启动的时候进行类加载路径的定义； Class类是反射的根源：他里面有一个getClassLoader方法 获得类加载器，就可以实现类的反射加载处理： 2. 自定义类加载器自定义加载器是在所有加载器之后；之前他们都得用classPath，有了自定义加载器就可以在系统内任意位置都可以进行加载； 写了一个简单类，放在D盘路径上不打包：javac Message.java，并且不打包（使得classpath无法加载）。 自定义一个类加载器，并继承自classLoader类： 1234567public class&lt;?&gt; loadData(String className) throws Exception&#123; byte [] data = this.loadClassData; // 读来的二进制数据文件 if (data != null)&#123; return super.dafindClass(className, data, 0, data.length); // 重要的一步 &#125; return null;&#125; 在这里获取的Class对象就可以用Class里面的方法实例化，实现后续操作 java提供了双亲加载机制：系统类有由系统加载器加载。自定义的加载器不能够加载；自定义类才可以有自定义加载器加载； 反射与代理设计模式1. 静态代理设计模式代理设计模式必须要有一个接口，接着实现； 传统设计模式弊端：客户端和接口子类产生了耦合问题，最好再引入工厂设计模式 一个代理类，只为一个接口服务；这里想要一个代理类，满足所有的业务接口 2. 代理设计模式 不管是真实代理类还是静态代理类都一定要接收真实业务实现子类对象； 由于动态代理类不再与某一个具体的接口进行捆绑应该可以动态获取类的接口； 这里要用到一个invocationHandle的接口来处理，他有一个invoke方法 还有 1public static Object newProxyInstance​(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 3. CGLIB实现代理设计可以实现基于类的代理设计模式。不再与接口联系 反射与Annotation1. 获取Annotation信息2. 自定义Annotation3. 工厂设计模式与Annotation","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"注解与反射","slug":"java/java高级编程/注解与反射","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"}],"tags":[]},{"title":"leetcode 410. 分割数组的最大值","slug":"leetcode-0410","date":"2020-07-25T01:31:21.000Z","updated":"2020-10-07T09:21:36.504Z","comments":true,"path":"2020/07/25/leetcode-0410/","link":"","permalink":"http://zenner006.github.io/2020/07/25/leetcode-0410/","excerpt":"题目Split Array Largest Sum 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例: 输入:nums = [7,2,5,10,8]m = 2 输出:18 解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。","text":"题目Split Array Largest Sum 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例: 输入:nums = [7,2,5,10,8]m = 2 输出:18 解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 题解动态规划通过看答案看到了这样的动态规划转移公式： f[i][j]=\\min_{k = 0}^{i-1}\\{\\max(f[k][j−1],sub(k+1,i))\\}$f[i][j]$ 表示在前i个节点分为j个子数组时的最小值；要得到他就得是遍历 $0-i$ 中的所有情况；然而在 $ k &lt; j-1 $ 的情况下也就是k个节点不够 $j-1$ 个子数组分。这种情况下的值属于不可能的情况，一般给他一个很大的值。它给$min$提供了一个不可能的选项，所以不会选到它。 12345678910111213class Solution: def splitArray(self, nums, m): n = len(nums) f = [[10**18] * (m + 1) for _ in range(n+1)] sub = [0] for elem in nums: sub.append(sub[-1] + elem) f[0][0] = 0 for i in range(1,n+1): for j in range(1, min(i, m) + 1): for k in range(i): f[i][j] = min(f[i][j], max(f[k][j-1], sub[i] - sub[k])) return f[n][m] 二分查找这里想要找到一个值x，这个值是分成的cnt个子数组和的最大值，所以每一个子数组都不大于他。 我们先不管能分成几个子数组。就先用数组中的最大值x来卡，来把数组分开 A = [a_1, a_2, ... , a_3 ]如果连续数组不大于x， 如果$n$个连续元素的和不大于x，那么他们就可以分到一个子数组中，如果再往后，$n+1$个元素之和大于x。那么从第$n+1$个元素分开，另放入一个子数组。由于最大值x在数组中前后加起来都一定大于x，所以他单独一个在一个子数组里。如果此时分成的子数组的数量大于所想要的m个子数组。那么我们就需要提高x的值，来使得子数组数量减少到刚好m。或者x值太高了，使得子数组的数量太少了。我们就需要减少x的值，使得子数组增多到m。之前这是贪心算法的思想。而后面调节x则可以用二分查找的方式。 1234567891011121314151617181920212223class Solution: def splitArray(self, nums: List[int], m: int) -&gt; int: def check(x: int) -&gt; bool: total, cnt = 0, 1 for num in nums: if total + num &gt; x: cnt += 1 total = num else: total += num return cnt &lt;= m left = max(nums) right = sum(nums) while left &lt; right: mid = (left + right) // 2 if check(mid): right = mid else: left = mid + 1 return left","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://zenner006.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"剑指 Offer 04. 二维数组中的查找","slug":"slash-offer-04","date":"2020-07-24T11:28:44.000Z","updated":"2021-06-28T08:45:40.370Z","comments":true,"path":"2020/07/24/slash-offer-04/","link":"","permalink":"http://zenner006.github.io/2020/07/24/slash-offer-04/","excerpt":"题目剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。","text":"题目剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 题解这里可以看到对角的性质。 比如二维数组中的(2,2),也就是9的位置。行（0，2）及列（0，2）没有一个大于9的；也就是（x,y）位置上的值，（x,y）矩阵内的值都比（x,y）位置上的值小。但这之外的不一定全都大。虽然上的矩阵是这么弄得。所以target只要一直找到刚好大于的值，再确定范围。 但是还是要考虑一下不同的情况： m == n ：这个情况下就可以顺着对角线一路找下去 m &gt; n : 行多于列。那么顺着对角线找下去：1. 小于对角线上最后一个值。那么他就在那个矩阵里。 12345678910111213141516171819public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; // 暴力法走一波 int m = matrix.length; int n; if (m != 0)&#123; n = matrix[0].length; &#125;else&#123; return false; &#125; for (int i = 0 ; i &lt; m; i++)&#123; for ( int j = 0 ; j &lt; n ; j ++)&#123; if (matrix[i][j] == target)&#123; return true; &#125; &#125; &#125; return false; &#125; 看答案 标志数引入： 此类矩阵中左下角和右上角元素有特殊性，称为标志数。 左下角元素： 为所在列最大元素，所在行最小元素。 右上角元素： 为所在行最大元素，所在列最小元素。 标志数性质： 将 matrix 中的左下角元素（标志数）记作 flag ，则有: 若 flag &gt; target ，则 target 一定在 flag 所在行的上方，即 flag 所在行可被消去。 若 flag &lt; target ，则 target 一定在 flag 所在列的右方，即 flag 所在列可被消去。 本题解以左下角元素为例，同理，右上角元素 也具有行（列）消去的性质。 123456789101112131415class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; int i = matrix.length-1, j = 0; while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length)&#123; if (target &lt; matrix[i][j])&#123; i --; &#125;else if (target &gt; matrix[i][j])&#123; j ++; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二维数组","slug":"二维数组","permalink":"http://zenner006.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"}]},{"title":"深入理解JVM第二章：自动内存管理","slug":"JVM-C2","date":"2020-07-24T09:18:53.000Z","updated":"2020-07-24T10:54:06.726Z","comments":true,"path":"2020/07/24/JVM-C2/","link":"","permalink":"http://zenner006.github.io/2020/07/24/JVM-C2/","excerpt":"一、运行时数据区前面两个部分都是了解了的。 3. HotSpot虚拟机对象探秘：3.1 对象的创建 JVM遇到一个new关键字后： 在常量池中看能够定位 类的符号引用， 并检查这个符号引用代表的类是否被加载，解析和初始化过。没有的话就加载这个类； 接着为新生对象分配内存：这里讨论了三种分配内存的方式 假设内存绝对规整: 一端使用过的,另一端是没用过的: 把指针向空闲的那边移动需要空间大小就好 (指针碰撞) 使用过的内存和空闲内存交错在一起, 就需要维护一个内存空闲列表; 从中挑选出需要大小的一片内存,进行分配; 给每个线程划分一块自己的私有内存区域: 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB) 虚拟机使用TLAB: -XX:+/-UseTLAB JVM给对象进行必要的设置: Object.Class, Hashcode, 类的元数据信息, 对象的GC分代年龄 ( 放在对象的对象头里) 这些做完JVM就创建了一个对象; 但JAVA程序才开始用构造函数初始化这个实例化对象","text":"一、运行时数据区前面两个部分都是了解了的。 3. HotSpot虚拟机对象探秘：3.1 对象的创建 JVM遇到一个new关键字后： 在常量池中看能够定位 类的符号引用， 并检查这个符号引用代表的类是否被加载，解析和初始化过。没有的话就加载这个类； 接着为新生对象分配内存：这里讨论了三种分配内存的方式 假设内存绝对规整: 一端使用过的,另一端是没用过的: 把指针向空闲的那边移动需要空间大小就好 (指针碰撞) 使用过的内存和空闲内存交错在一起, 就需要维护一个内存空闲列表; 从中挑选出需要大小的一片内存,进行分配; 给每个线程划分一块自己的私有内存区域: 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB) 虚拟机使用TLAB: -XX:+/-UseTLAB JVM给对象进行必要的设置: Object.Class, Hashcode, 类的元数据信息, 对象的GC分代年龄 ( 放在对象的对象头里) 这些做完JVM就创建了一个对象; 但JAVA程序才开始用构造函数初始化这个实例化对象 3.2 对象的内存布局一个对象在堆中的存在可以划分为三个部分：对象头（Header），实例数据（Instance data）和对齐填充； 对象头 存储两类信息“ 对象自身的运行时数据 类型指针：对象指向它的类型元数据的指针；（可确定这个对象是哪个类的实例） 实例数据 真正存储对象实例信息的地方，无论父类的还是子类定义的都得放在这里面； 存储顺序受虚拟机分配策略参数（-XX:FieldsAllocationStyle 参数）和字段在Java源码中定义顺序的影响； 对齐填充 对象必须是8字节的倍数；所以满足这个要求就填充一下； 3.3 对象的访问定位java会通过栈上的 reference 数据来操作堆上的对象。 主流的访问方式主要有使用句柄和直接指针两种方式。 使用句柄访问，java堆中就会划分出一块内存作为句柄池 ，reference 保存的就是句柄地址。而句柄包含了 对象实例数据 和 对象类型数据 各自的具体地址信息； 直接用指针访问的话， Java堆中对象的内存布局就必须考虑 对象类型数据 的相关信息（地址）放在哪里；","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"jvm","slug":"java/jvm","permalink":"http://zenner006.github.io/categories/java/jvm/"}],"tags":[]},{"title":"leetcode 1025. 除数博弈","slug":"leetcode-1025","date":"2020-07-24T00:07:51.000Z","updated":"2020-10-07T09:21:44.013Z","comments":true,"path":"2020/07/24/leetcode-1025/","link":"","permalink":"http://zenner006.github.io/2020/07/24/leetcode-1025/","excerpt":"题目爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 1234567891011示例 1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。示例 2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。","text":"题目爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 1234567891011示例 1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。示例 2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 题解貌似又是一个动态规划问题； 那么首先就要看N到底能被谁整除。把它减掉后，它又能被谁整除？他肯定还能被它减去的那个值整除。也就是记住中间值就可以。也可以用递归。 不论对爱丽丝而言还是对bob；只要形势一致，比如对他们都是3时那么他们都会输。所以他能赢还是有一定的依赖性的。 每个人的策略有减去一个除数后的值对对方而言是不是输； 1234567891011121314151617181920212223242526272829class Solution &#123; public static HashMap&lt;Integer, Boolean&gt; dp = new HashMap&lt;Integer, Boolean&gt;(); static &#123; dp.put(2, true); dp.put(3, false); &#125; public boolean divisorGame(int N) &#123; if (dp.containsKey(N))&#123; return dp.get(N); &#125; // 查找可以整除N的数字（小于N） ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); int i = 1; while (i&lt;=N/2)&#123; if (N % i == 0)&#123; integers.add(i); &#125; i++; &#125; Boolean res = false; for (Object j:integers.toArray())&#123; res = res || !divisorGame(N-(int)j); &#125; dp.put(N,res); return res; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"剑指 Offer 14- I. 剪绳子","slug":"Slash-offer-14-1","date":"2020-07-23T08:39:21.000Z","updated":"2020-10-07T09:19:43.186Z","comments":true,"path":"2020/07/23/Slash-offer-14-1/","link":"","permalink":"http://zenner006.github.io/2020/07/23/Slash-offer-14-1/","excerpt":"题目给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 12345678910示例 1：输入: 2输出: 1解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1示例 2:输入: 10输出: 36解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36","text":"题目给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 12345678910示例 1：输入: 2输出: 1解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1示例 2:输入: 10输出: 36解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36 题解这里就自己手动算了几个值； 1 是没法分的 2 可以分为 1 和 1 积为 1 3 可分为 1 和 2 积为 2 4 可分为 (2,2),(1,3) 最大积为4 5 可分为(1,4),(2,3) 最大积为 6 6 可分为(1,5)(2,4),(3,3) 最大积为9 虽然可以分为多个但是多个也是由几个值加在一起的。比如分的时候分出来了5以上那么一定会把他再分。而前期算出来了每个值的最大值都可以后面再利用。 比如再计算7，它可分为(1,6)(2,5)(3,4); 虽然其中5和6还可以再分。但此时我们就不管它分不分了，直接在上面查表。 发现5分之后的最大值是6，6分之后的最大值是9； 明显这是比5或6在原来的贡献更大，并且已知是他所能分开的最大贡献了。于是后面维护这个表就好了。 当然还有别的更好的算法吧。但这个是可以求得结果的。 HashMap 123456789101112131415161718192021222324252627public int cuttingRope(int n) &#123; HashMap&lt;Integer, Integer&gt; integerIntegerHashMap = new HashMap&lt;&gt;(); integerIntegerHashMap.put(1,1); integerIntegerHashMap.put(2,2); integerIntegerHashMap.put(3,3); integerIntegerHashMap.put(4,4); if (n &lt; 5)&#123; if (n == 2)&#123; return 1; &#125; else if (n == 3)&#123; return 2; &#125; else if (n == 4)&#123; return 4; &#125; &#125; for (int i = 5 ; i &lt;= n ; i ++)&#123; int MAX = 0; for (int j = 1; j &lt;= i/2 ; j++)&#123; int temp = integerIntegerHashMap.get(j) * integerIntegerHashMap.get(i-j); if (temp &gt; MAX)&#123; MAX = temp; &#125; &#125; integerIntegerHashMap.put(i,MAX); &#125; return integerIntegerHashMap.get(n);&#125; 数组： 12345678910111213141516171819202122232425262728293031class Solution &#123; public int cuttingRope(int n) &#123; if (n &lt; 5)&#123; if (n == 2)&#123; return 1; &#125; else if (n == 3)&#123; return 2; &#125; else if (n == 4)&#123; return 4; &#125; &#125; int[] ints = new int[n + 1]; for (int i = 1; i&lt;5; i++)&#123; ints[i] = i; &#125; for (int i = 5 ; i &lt; ints.length ; i ++) &#123; int MAX = 0; for (int j = 1; j &lt;= i / 2; j++) &#123; int temp = ints[j] * ints[i - j]; if (MAX &lt; temp) &#123; MAX = temp; &#125; &#125; ints[i] = MAX; &#125; for (int i = 1; i &lt; ints.length; i++)&#123; System.out.println(ints[i]); &#125; return ints[n]; &#125;&#125; 分别写了下hashmap和数组，结果HashMap高一点点 看答案看到了一个挺好的动态规划。他把剪绳子分成了两种。眼下手里已经剪了的部分乘上剩下部分；剩下部分有两种命运： 不剪了； 接着剪；他要从里面选较大的那个； F(n)=max(i×(n−i),i×F(n−i)), i=1,2,...,n−2。我们发现任何大于 3 的数都可以拆分为数字 1，2，3的和，且它们对 3 的余数总是 0，1，2，因此我们可以仅用 dp[0]，dp[1]，dp[2] 表示所有大于 3 的值，这样空间复杂度可降到 O(1)。 12345678class Solution: def cuttingRope(self, n): dp = [0, 1, 1] for i in range(3, n + 1): dp[i % 3] = max(max(dp[(i - 1) % 3], i - 1), 2 * max(dp[(i - 2) % 3], i - 2), 3 * max(dp[(i - 3) % 3], i - 3)) return dp[n % 3]","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"http://zenner006.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"leetcode_0064：最小路径和","slug":"leetcode-0064","date":"2020-07-23T07:32:33.000Z","updated":"2020-10-07T09:20:56.104Z","comments":true,"path":"2020/07/23/leetcode-0064/","link":"","permalink":"http://zenner006.github.io/2020/07/23/leetcode-0064/","excerpt":"题目：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678910输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。","text":"题目：给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678910输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 题解这道题是之前做过的一道。现在当时用了回溯法。但是这里只是求数字总和最小。所以回溯法还是有点浪费这里应该还是能用动态规划的。 看一下他要的是从左上到右下的路径的数字总和最小。也就是针对最后一格而言他只能从他的上面或者左边来。右下角的代价是确定的。只需要求得相对应的最小值就好了。这个应该是一个比较简单的动态规划问题了。 应该用一个dp[m][n]来保存中间结果。 从左上角出发。 12345678910111213141516171819class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; for (int i = 0 ; i &lt; m; i++)&#123; dp[i][0] = grid[i][0] + (i!=0 ? dp[i-1][0]:0); &#125; for (int i = 1 ; i &lt; n ; i++)&#123; dp[0][i] = grid[0][i] + dp[0][i-1]; &#125; for (int i = 1 ; i &lt; m ; i++)&#123; for (int j = 1 ; j &lt; n ; j++)&#123; dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[m-1][n-1]; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"leetcode-0209:长度最小的子数组","slug":"leetcode-0209","date":"2020-07-22T12:27:28.000Z","updated":"2020-10-07T09:21:13.073Z","comments":true,"path":"2020/07/22/leetcode-0209/","link":"","permalink":"http://zenner006.github.io/2020/07/22/leetcode-0209/","excerpt":"题目：leetcode-0209:长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 12345示例：输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。","text":"题目：leetcode-0209:长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 12345示例：输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 题解暴力法直接给整出来了。明天想想别的方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution0209 &#123; /* * 题目：209. 长度最小的子数组 * * 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 * * 思考过程： * * 因为这个数组因为是不确定的。要求的其中满足和大于等于s的连续子数组。所以这么说来直接的想法就是针对每个点都往前计算它刚好大于s的长度。 * */ public static void main(String[] args) &#123; Solution0209 solution0209 = new Solution0209(); System.out.println(solution0209.minSubArrayLen(7, new int[]&#123;2, 3, 1, 2, 4, 3&#125;)); System.out.println(solution0209.minSubArrayLen(4, new int[]&#123;1,4,4&#125;)); &#125; public int minSubArrayLen(int s, int[] nums) &#123; int min_length = nums.length+1; int cur_sum = 0; for (int i = 0; i &lt; nums.length; i++)&#123; // 以这个节点向左边出发找刚好大于s的长度 cur_sum = nums[i]; if (cur_sum &gt;= s)&#123; return 1; &#125; for (int j = i-1; j&gt;-1;j--)&#123; cur_sum +=nums[j]; if (cur_sum &gt;= s)&#123; if(i-j+1&lt;min_length)&#123; min_length = i-j+1; &#125; break; &#125; &#125; &#125; if (min_length == nums.length+1)&#123; return 0; &#125; return min_length; &#125;&#125; 队列这个方法也是刚开始也就能够想到的，其实和滑窗也是类似。 但是这里它写的更为巧妙地里外两个循环，分别控制left和right； 1234567891011121314public int minSubArrayLen2(int s, int[] nums) &#123; int right = 0; int left = 0; int sum = 0; int min = nums.length+1; while (left &lt; nums.length)&#123; sum += nums[left++]; while (sum&gt;=s)&#123; min = Math.min(min, left - right); sum -= nums[right++]; &#125; &#125; return min == nums.length+1 ? -1:min;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"}],"tags":[{"name":"暴力法","slug":"暴力法","permalink":"http://zenner006.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"http://zenner006.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://zenner006.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"剑指offer_11","slug":"Slash-offer-11","date":"2020-07-22T01:35:01.000Z","updated":"2020-10-07T09:19:34.528Z","comments":true,"path":"2020/07/22/Slash-offer-11/","link":"","permalink":"http://zenner006.github.io/2020/07/22/Slash-offer-11/","excerpt":"题目：1234567891011121314151617/** * 剑指 Offer 11. 旋转数组的最小数字 * * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 * * 示例 1： * * 输入：[3,4,5,1,2] * 输出：1 * * 示例 2： * * 输入：[2,2,2,0,1] * 输出：0 */","text":"题目：1234567891011121314151617/** * 剑指 Offer 11. 旋转数组的最小数字 * * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 * * 示例 1： * * 输入：[3,4,5,1,2] * 输出：1 * * 示例 2： * * 输入：[2,2,2,0,1] * 输出：0 */ 题解：1234567891011121314151617181920212223242526272829303132/** * 解题： 二分查找 * * 这里把前部分数组叫做递增数组，把后部分数组叫做旋转数组。 * * 由于不是一个严格递增的数组所以需要对原来的二分查找有所修改。 * 当然开始也是求出位置为一半的值：mid * number[mid]和 number[left] 与 number[right] 相比较。考虑： * 情况一：number[mid] 小于 number[left] 说明mid在被旋转的数组区域， * 那么mid之后的就可以被舍弃了，最小值不在这里，但mid不能被舍弃，因为它还有可能是最小值。right = mid * 情况二：number[mid] 大于等于 number[left] 说明mid在递增的前一部分区间。 * 那么mid之前的被舍弃，最小值不在这部分，mid也可以被舍弃。 left = mid + 1 * 情况三：被舍弃后可能会出现完全递增的情况，即递增数组部分完全被舍弃了。 * 此时也是需要判断 number[left] 与 number[right] ； * 如果 number[left] 小于 number[right]： 直接返回 number[left] * 情况四：一轮舍弃之后还可能出现 number[right] 是最小值的情况，即之前的都递增，到 right位置掉了下来。 * 这种情况可以在下一轮自动找出来。 * 比如[1,2,0] left会编程0位置上，那么left==right跳出循环。 * 但是如果是 [1,2,3,0] 那么mid是2的位置属于情况二,left变成3的位置，数组成了[3,0]。 * 此时再求mid是3的位置，number[mid] 等于 number[left] 属于情况二，left变为0的位置跳出循环。 * 所以二分查找的重点在于左右游标的一个只管mid另一个要舍掉更多。 * * 如果思考一个完全递增数组的二分查找的话。也可以分析出这样的多种情况； * 求出位置为一半的值：mid * number[mid]和 要查找的 target 相比较。考虑： * 情况一：number[mid] 小于 target；那么肯定 target 在 mid之后； * 情况二：number[mid] 大于 target；那么 target在 mid 之前。 * 情况三：number[mid] 等于 target；那么 target就在 mid 位置，直接返回mid * 情况一和情况二下，这个舍弃 mid，那边都可以选择不要，还是要考虑最后怎么跳出循环： * 例如数组：[1,2,3] 查找 3 ；mid找到是2的位置，小于 target 3，此时让left = mid + 1那么就能直接跳出循环。 * 查找 1 ；同样的mid在 2 的位置， 大于 target 3 让 right = mid - 1 直接就能跳出循环。 * 在数组：[1,2] 查找 2 ： mid 在1的位置，小于target 2， 让 left = mid + 1 也能跳出循环。 有重复数字报错了； 补救1234567891011121314 /** * 以上的题解都是在假设数组中没有重复元素的情况下如何去二分查找 * 解决重复数字方法一：赋值 left 和 right 后把她两往前滑一滑： * 在依然 left &lt; right 的情况下： * 判断 right 左边的 numbers[right - 1] 是否等于 numbers[right]，等于就往左滑 * 判断 left 右边的 numbers[left + 1] 是否等于 numbers[left], 等于就往右滑 * 其实这种处理办法还是在把重复的数字块当作一个数字，也就是说把 [10,1,10,10,10] 当作 [10,1,10] * * 解决重复数组的方法二：就是把等于这一项单列出来上面分析把大于和等于放在一起考虑。但是后来发现他们是不能放在一起考虑的： * 比如： [10, 1, 10, 10, 10], 这里mid在索引为 2 的位置，把大于等于放在一起考虑则就默认中间是没有小于1这种情况存在的。 * 不如就等于时把high慢慢往下放，直到循环条件不满足时； * * */ 补救代码一：12345678910111213141516171819202122232425262728public int minArray(int[] numbers) &#123; int left = 0; int right = numbers.length-1; while(left &lt; right &amp;&amp; (numbers[right-1] == numbers[right]))&#123; right = right-1; &#125; while(left &lt; right &amp;&amp; (numbers[left+1] == numbers[left]))&#123; left = left+1; &#125; while (left &lt; right)&#123; int mid = left + (right - left) /2; if (numbers[left] &lt; numbers[right])&#123; return numbers[left]; &#125; if (numbers[mid] &lt; numbers[left] )&#123; right = mid; while(left &lt; right &amp;&amp; (numbers[right-1] == numbers[right]))&#123; right = right-1; &#125; &#125; else if (numbers[mid] &gt;= numbers[left])&#123; left = mid + 1; while(left &lt; right &amp;&amp; (numbers[left+1] == numbers[left]))&#123; left = left+1; &#125; &#125; &#125; return numbers[left];&#125; 补救代码二：123456789101112131415161718public int minArray(int[] numbers) &#123; int left = 0; int right = numbers.length-1; while (left &lt; right)&#123; int mid = left + (right - left) /2; if (numbers[left] &lt; numbers[right])&#123; return numbers[left]; &#125; if (numbers[mid] &lt; numbers[left] )&#123; right = mid; &#125; else if (numbers[mid] &gt;= numbers[left])&#123; left = mid + 1; &#125; else&#123; left += 1; &#125; &#125; return numbers[left];&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://zenner006.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"javascript","slug":"javascript","date":"2020-07-20T07:26:04.000Z","updated":"2020-07-26T02:58:59.591Z","comments":true,"path":"2020/07/20/javascript/","link":"","permalink":"http://zenner006.github.io/2020/07/20/javascript/","excerpt":"JavaScript：一、JavaScript简述* 概念： 一门客户端脚本语言 * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 * 脚本语言：不需要编译，直接就可以被浏览器解析执行了 * 功能： * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。","text":"JavaScript：一、JavaScript简述* 概念： 一门客户端脚本语言 * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 * 脚本语言：不需要编译，直接就可以被浏览器解析执行了 * 功能： * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 二 、JavaScript发展史： 1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C-- ，后来更名为：ScriptEase 2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 3. 1996年，微软抄袭JavaScript开发出JScript语言 4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) * ECMAScript：客户端脚本语言的标准 三、 ECMAScript：客户端脚本语言的标准1. 基本语法(1) 与html结合方式 1. 内部JS： * 定义&lt;script&gt;，标签体内容就是js代码 2. 外部JS： * 定义&lt;script&gt;，通过src属性引入外部的js文件 * 注意： 1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 2. &lt;script&gt;可以定义多个。 (2) 注释 1. 单行注释：//注释内容 2. 多行注释：/*注释内容*/ (3) 数据类型： 1. 原始数据类型(基本数据类型)： 1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) 2. string：字符串。 字符串 &quot;abc&quot; &quot;a&quot; &#39;abc&#39; 3. boolean: true和false 4. null：一个对象为空的占位符 5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 2. 引用数据类型：对象 (4) 变量 * 变量：一小块存储数据的内存空间 * Java语言是强类型语言，而JavaScript是弱类型语言。 * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 * 语法： * var 变量名 = 初始化值; * var 变量名; * typeof运算符：获取变量的类型。 * 注：null运算后得到的是object (5) 运算符a. 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) * ++ --: 自增(自减) * ++(--) 在前，先自增(自减)，再运算 * ++(--) 在后，先运算，再自增(自减) * +(-)：正负号 * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 * 其他类型转number： * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）; * NaN和任何数做运算都是NaN * boolean转number：true转为1，false转为0 12345678910111213var num = 3;var a = num ++ ;document.write(num);// 4document.write(a); // 3document.write(\"&lt;hr&gt;\");var num = 3;var a = ++ num ;document.write(num);// 4document.write(a); // 4document.write(\"&lt;hr&gt;\"); b. 算数运算符 + - * / % ... c. 赋值运算符 = += -+.... d. 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) * 比较方式 1. 类型相同：直接比较 * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较: &quot;123&quot;==123:true * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false e. 逻辑运算符 &amp;&amp; || ! * 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true 12345678obj = \"123\";if(obj != null &amp;&amp; obj.length &gt; 0)&#123;//防止空指针异常 alert(123);&#125;//js中可以这样定义，简化书写。if(obj)&#123;//防止空指针异常 // 这样写是可以同时判断多种类型的,包括null,\"\"; alert(111);&#125; f. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; * 语法： * 表达式? 值1:值2; * 判断表达式的值，如果是true则取值1，如果是false则取值2； 123456var a = 3;var b = 4;var c = a &gt; b ? 1:0;alert(c); // 0 (6) 流程控制语句： 1. if...else... 2. switch: * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) * switch(变量): case 值: * 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for (7) JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 * 用： 定义的变量是局部变量 * 不用：定义的变量是全局变量(不建议) (8) 练习：99乘法表1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td&#123; border: 1px solid; &#125; &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) &#123; document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt;=i ; j++) &#123; document.write(\"&lt;td&gt;\"); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); &#125; /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); &#125; //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2. 基本对象：(1) Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表){ 方法体 } 3. var 方法名 = function(形式参数列表){ 方法体 } 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 方法名称(实际参数列表); (2) Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 (3) Boolean(4) Date：日期对象 1. 创建： var date = new Date(); 2. 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 (5) Math：数学对象 1. 创建： * 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 floor(x)：对数进行下舍入。 round(x)：把数四舍五入为最接近的整数。 3. 属性： PI (6) Number(7) String(8) RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 3. 开始结束符号 * ^:开始 * $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(&quot;正则表达式&quot;); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 (9) Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： encodeURI():url编码 decodeURI():url解码 encodeURIComponent():url编码,能够编码的字符更多,比如各种//,.,在encodeURL中都没有 decodeURIComponent():url解码 parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 * BOM * DOM DOM简单学习：为了满足案例要求* 功能：控制html文档的内容 * 获取页面标签(元素)对象：Element * document.getElementById(&quot;id值&quot;):通过元素的id获取元素对象 * 操作Element对象： 1. 修改属性值： 1. 明确获取的对象是哪一个？ 2. 查看API文档，找其中有哪些属性可以设置 2. 修改标签体内容： * 属性：innerHTML 1. 获取元素对象 2. 使用innerHTML属性修改标签体内容 事件简单学习 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 造句： xxx被xxx,我就xxx * 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 1. 事件：onclick--- 单击事件 2. 通过js获取元素对象，指定事件属性，设置一个函数 代码：123456789101112131415161718192021&lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt;&lt;script&gt; function fun()&#123; alert('我被点了'); alert('我又被点了'); &#125; function fun2()&#123; alert('咋老点我？'); &#125; //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2;&lt;/script&gt;&lt;/body&gt; 案例1：电灯开关123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function()&#123; if(flag)&#123;//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; &#125;else&#123; //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; BOM:1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象。 2. 组成： * Window：窗口对象 * History：历史记录对象 * Location：地址栏对象 * Navigator：浏览器对象 * Screen：显示器屏幕对象 3. Window：窗口对象 1. 创建 2. 方法 1. 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 * 如果用户点击确定按钮，则方法返回true * 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 * 返回值：获取用户输入的值 2. 与打开关闭有关的方法： close() 关闭浏览器窗口。 * 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 * 返回新的Window对象 3. 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 * 参数： 1. js代码或者方法对象 2. 毫秒值 * 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 3. 属性： 1. 获取其他BOM对象： history location Navigator Screen: 2. 获取DOM对象 document 4. 特点 * Window对象不需要创建可以直接使用 window使用。 window.方法名(); * window引用可以省略。 方法名(); 4. Location：地址栏对象 1. 创建(获取)： 1. window.location 2. location 2. 方法： * reload() 重新加载当前文档。刷新 * assign() 加载新的文档。 * replace() 用新的文档替换当前文档。 3. 属性 * href 设置或返回完整的 URL。 5. History：历史记录对象 1. 创建(获取)： 1. window.history 2. history 2. 方法： * back() 加载 history 列表中的前一个 URL。 * forward() 加载 history 列表中的下一个 URL。 * go(参数) 加载 history 列表中的某个具体页面。 * 参数： * 正数：前进几个历史记录 * 负数：后退几个历史记录 3. 属性： * length 返回当前窗口历史列表中的 URL 数量。 DOM：概念： Document Object Model 文档对象模型 * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 组成* W3C DOM 标准被分为 3 个不同的部分： * 核心 DOM - 针对任何结构化文档的标准模型 * Document：文档对象 * Element：元素对象 * Attribute：属性对象 * Text：文本对象 * Comment:注释对象 * Node：节点对象，其他5个的父对象 * XML DOM - 针对 XML 文档的标准模型 * HTML DOM - 针对 HTML 文档的标准模型 核心DOM模型：Document：文档对象 1. 创建(获取)：在html dom模型中可以使用window对象来获取 1. window.document 2. document 2. 方法： 1. 获取Element对象： 1. getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 2. 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 3. 属性 Element：元素对象 1. 获取/创建：通过document来获取和创建 2. 方法： 1. removeAttribute()：删除属性 2. setAttribute()：设置属性 Node：节点对象，其他5个的父对象 * 特点：所有dom对象都可以被认为是一个节点 * 方法： * CRUD dom树： * appendChild()：向节点的子节点列表的结尾添加新的子节点。 * removeChild() ：删除（并返回）当前节点的指定子节点。 * replaceChild()：用新节点替换一个子节点。 * 属性： * parentNode 返回节点的父节点。 HTML DOM 1. 标签体的设置和获取：innerHTML 1234567var div = document.getElementById(\"div1\");var innerHTML = div.innerHTML;//alert(innerHTML);//div标签中替换一个文本输入框div.innerHTML = \"&lt;input type='text'&gt;\";//div标签中追加一个文本输入框div.innerHTML += \"&lt;input type='text'&gt;\"; 2. 使用html元素对象的属性 3. 控制元素样式 1. 使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制：概念：某些组件被执行了某些操作后，触发某些代码的执行。 * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 * 事件源：组件。如： 按钮 文本输入框... * 监听器：代码。 * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件 1. 点击事件： 1. onclick：单击事件 2. ondblclick：双击事件 2. 焦点事件 1. onblur：失去焦点。 * 一般用于表单验证 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 * 定义方法时，定义一个形参，接受event对象。 * event对象的button属性可以获取鼠标按钮键被点击了。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。 ​ 5. 键盘事件： 1. onkeydown 某个键盘按键被按下。 2. onkeyup 某个键盘按键被松开。 3. onkeypress 某个键盘按键被按下并松开。 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 * 可以阻止表单的提交 * 方法返回false则表单被阻止提交。 2. onreset 重置按钮被点击。","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"javascript","slug":"web/javascript","permalink":"http://zenner006.github.io/categories/web/javascript/"}],"tags":[]},{"title":"HEML_CSS","slug":"HEML-CSS","date":"2020-07-20T01:43:27.000Z","updated":"2020-07-20T03:31:56.957Z","comments":true,"path":"2020/07/20/HEML-CSS/","link":"","permalink":"http://zenner006.github.io/2020/07/20/HEML-CSS/","excerpt":"HTML标签：表单标签表单：* 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性","text":"HTML标签：表单标签表单：* 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性 表单项标签：input：可以通过type属性值，改变元素展示的样式 * type属性： * text：文本输入框，默认值 * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 * password：密码输入框 * radio:单选框 * 注意： 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 3. checked属性，可以指定默认值 * checkbox：复选框 * 注意： 1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 2. checked属性，可以指定默认值 * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * color:取色器 * date : 生日 * datetime-local:生日 * email:邮箱 * * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 select: 下拉列表 * 子元素：option，指定列表项 * 添加一个 selected 即表示默认。 textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 CSS：页面美化和布局控制1. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效 2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 CSS的使用：CSS与html结合方式1. 内联样式12* 在标签内使用style属性指定css代码* 如：&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2. 内部样式123456789* 在head标签内，定义style标签，style标签的标签体内容就是css代码* 如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div{ color:green; } &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt; 4. css语法： * 格式： 选择器 { 属性名1:属性值1; 属性名2:属性值2; ... } * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 5. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值{} * 注意：id是下面优先级最高的。 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称{} * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值{} * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *{} 2. 并集选择器： * 选择器1,选择器2{} 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2{} 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2{} 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=&quot;属性值&quot;]{} 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态{} * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态 6. 属性（1） 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 （2） 背景 * background： （3） 边框 * border：设置边框，复合属性 （4） 尺寸 * width：宽度 * height：高度 （5） 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 案例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; box-sizing: border-box; } body{ background: url(&quot;img/register_bg.png&quot;) no-repeat center; padding-top: 25px; } .rg_layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; } .rg_left{ /*border: 1px solid red;*/ float: left; margin: 15px; } .rg_left &gt; p:first-child{ color:#FFD026; font-size: 20px; } .rg_left &gt; p:last-child{ color:#A6A6A6; font-size: 20px; } ​ .rg_center{ float: left; /* border: 1px solid red;*/ } .rg_right{ /*border: 1px solid red;*/ float: right; margin: 15px; } .rg_right &gt; p:first-child{ font-size: 15px; } .rg_right p a { color:pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 50px ; } #username,#password,#email,#name,#tel,#birthday,#checkcode{ width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; } #checkcode{ width: 110px; } #img_check{ height: 32px; vertical-align: middle; } #btn_sub{ width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;rg_layout&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;!--定义表单 form--&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt; &lt;/td&gt; &lt;/tr&gt; ​ &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; ​ &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; ​ &lt;/div&gt; ​ &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"CSS","slug":"web/CSS","permalink":"http://zenner006.github.io/categories/web/CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://zenner006.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://zenner006.github.io/tags/CSS/"}]},{"title":"HTML","slug":"HTML","date":"2020-07-19T07:01:22.000Z","updated":"2020-07-19T08:58:28.718Z","comments":true,"path":"2020/07/19/HTML/","link":"","permalink":"http://zenner006.github.io/2020/07/19/HTML/","excerpt":"web概念概述 JavaWeb： 使用Java语言开发基于互联网的项目 软件架构： 1. C/S: Client/Server 客户端/服务器端 * 在用户本地有一个客户端程序，在远程有一个服务器端程序 * 如：QQ，迅雷... * 优点： 1. 用户体验好 * 缺点： 1. 开发、安装，部署，维护 麻烦 2. B/S: Browser/Server 浏览器/服务器端 * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 * 优点： 1. 开发、安装，部署，维护 简单 * 缺点： 1. 如果应用过大，用户的体验可能会受到影响 2. 对硬件要求过高","text":"web概念概述 JavaWeb： 使用Java语言开发基于互联网的项目 软件架构： 1. C/S: Client/Server 客户端/服务器端 * 在用户本地有一个客户端程序，在远程有一个服务器端程序 * 如：QQ，迅雷... * 优点： 1. 用户体验好 * 缺点： 1. 开发、安装，部署，维护 麻烦 2. B/S: Browser/Server 浏览器/服务器端 * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 * 优点： 1. 开发、安装，部署，维护 简单 * 缺点： 1. 如果应用过大，用户的体验可能会受到影响 2. 对硬件要求过高 B/S架构详解 资源分类： 静态资源： 使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频、视频, HTML,CSS,JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源： 使用动态网页及时发布的资源。 特点： 所有用户访问，得到的结果可能不一样。 如：jsp/servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源！ * 静态资源： * HTML：用于搭建基础网页，展示页面的内容 * CSS：用于美化页面，布局页面 * JavaScript：控制页面的元素，让页面有一些动态的效果 HTML1. 概念：是最基础的网页开发语言 * Hyper Text Markup Language 超文本标记语言 * 超文本: * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. * 标记语言: * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml * 标记语言不是编程语言 2. 快速入门：语法： 1. html文档后缀名 .html 或者 .htm 2. 标签分为 1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 3. 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 5. html的标签不区分大小写，但是建议使用小写。 代码：1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 3. 标签学习：(1) 文件标签：构成html最基本的标签 * html:html文档的根标签 * head：头标签。用于指定html文档的一些属性。引入外部的资源 * title：标题标签。 * body：体标签 * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档 (2) 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 有一些特殊符号需要标记来写出来： (3) 图片标签： * img：展示图片 * 属性： * src：指定图片的位置 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt; &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt; (4) 列表标签： * 有序列表： * ol: * li: * 无序列表： * ul: * li: 1234567891011121314151617早上起床干的事情&lt;ol type=\"A\" start=\"5\"&gt; &lt;li&gt;睁眼&lt;/li&gt; &lt;li&gt;看手机&lt;/li&gt; &lt;li&gt;穿衣服&lt;/li&gt; &lt;li&gt;洗漱&lt;/li&gt;&lt;/ol&gt;早上起床干的事情 E. 睁眼 F. 看手机 G. 穿衣服 H. 洗漱无序列表：type可以设置列表前是圆还是方框&lt;ul type=\"disc\"&gt;&lt;ul type=\"circle\"&gt;&lt;ul type=\"square\"&gt; ​ (5) 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * 代码： &lt;!--超链接 a--&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt; (6) div和span： * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签 (7) 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 1. &lt;header&gt;：页眉 2. &lt;footer&gt;：页脚 (8) 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 案例：旅游网站首页1. 确定使用table来完成布局 2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 3. 如果某一行有多个单元格，则使用 &lt;tr&gt; &lt;td&gt; &lt;table&gt;&lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; 4. 代码实现 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;黑马旅游网&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--采用table来完成布局--&gt; &lt;!--最外层的table，用于整个页面的布局--&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;!-- 第1行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第2行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第3行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt; &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第4行 轮播图 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第5行 黑马精选--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt; 黑马精选 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第6行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第7行 国内游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt; 国内游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第8行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; ​ &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第9行 境外游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt; 境外游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第10行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; ​ &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第11行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第12行 --&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ​ &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"HTML","slug":"web/HTML","permalink":"http://zenner006.github.io/categories/web/HTML/"}],"tags":[]},{"title":"JDBC连接池和JDBC template","slug":"JDBC-connection-pool-JDBC-template","date":"2020-07-19T02:36:37.000Z","updated":"2020-07-19T06:50:14.593Z","comments":true,"path":"2020/07/19/JDBC-connection-pool-JDBC-template/","link":"","permalink":"http://zenner006.github.io/2020/07/19/JDBC-connection-pool-JDBC-template/","excerpt":"数据库连接池1. 概念其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现：（1） 标准接口：DataSource javax.sql包下的","text":"数据库连接池1. 概念其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现：（1） 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 （2） 数据库连接池实现技术一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection 代码：1234//1.创建数据库连接池对象DataSource ds = new ComboPooledDataSource();//2. 获取连接对象Connection conn = ds.getConnection(); 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.datasource.c3p0;import com.mchange.v2.c3p0.ComboPooledDataSource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * c3p0演示 */public class C3P0Demo2 &#123; public static void main(String[] args) throws SQLException &#123; //1. 获取DataSource，使用默认配置 DataSource ds = new ComboPooledDataSource(); //2.获取连接 for (int i = 1; i &lt;= 11 ; i++) &#123; Connection conn = ds.getConnection(); System.out.println(i+\":\"+conn); if(i == 5)&#123; conn.close();//归还连接到连接池中 &#125; &#125; //testNamedConfig(); &#125; public static void testNamedConfig() throws SQLException &#123; // 1.1 获取DataSource，使用指定名称配置 DataSource ds = new ComboPooledDataSource(\"otherc3p0\"); //2.获取连接 for (int i = 1; i &lt;= 10 ; i++) &#123; Connection conn = ds.getConnection(); System.out.println(i+\":\"+conn); &#125; &#125;&#125; 5. Druid：数据库连接池实现技术，由阿里巴巴提供的(1) 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); (2) 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; 使用定义好的工具类 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast.datasource.druid;import cn.itcast.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 使用新的工具类 */public class DruidDemo2 &#123; public static void main(String[] args) &#123; /* * 完成添加操作：给account表添加一条记录 */ Connection conn = null; PreparedStatement pstmt = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"insert into account values(null,?,?)\"; //3.获取pstmt对象 pstmt = conn.prepareStatement(sql); //4.给？赋值 pstmt.setString(1,\"王五\"); pstmt.setDouble(2,3000); //5.执行sql int count = pstmt.executeUpdate(); System.out.println(count); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6. 释放资源 JDBCUtils.close(pstmt,conn); &#125; &#125;&#125; Spring JDBCSpring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 小试牛刀 1234567891011121314151617181920package cn.itcast.jdbctemplate;import cn.itcast.utils.JDBCUtils;import org.springframework.jdbc.core.JdbcTemplate;/** * JdbcTemplate入门 */public class JdbcTemplateDemo1 &#123; public static void main(String[] args) &#123; //1.导入jar包 //2.创建JDBCTemplate对象 JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //3.调用方法 String sql = \"update account set balance=5000 where id=?;\"; int count = template.update(sql,3); System.out.println(count); &#125;&#125; 练习 需求 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import cn.itcast.domain.Emp;import cn.itcast.utils.JDBCUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.Date;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import java.util.Map;public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; /** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); ​ for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"JDBC","slug":"java/java高级编程/JDBC","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/JDBC/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://zenner006.github.io/tags/JDBC/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-07-18T10:58:18.000Z","updated":"2020-07-25T01:27:29.205Z","comments":true,"path":"2020/07/18/JDBC/","link":"","permalink":"http://zenner006.github.io/2020/07/18/JDBC/","excerpt":"JDBC：概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 二、快速入门：1. 步骤：1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 2. 代码实现：","text":"JDBC：概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 二、快速入门：1. 步骤：1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 2. 代码实现： 12345678910111213141516//1. 导入驱动jar包//2.注册驱动Class.forName(\"com.mysql.jdbc.Driver\");//3.获取数据库连接对象Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");//4.定义sql语句String sql = \"update account set balance = 500 where id = 1\";//5.获取执行sql的对象 StatementStatement stmt = conn.createStatement();//6.执行sqlint count = stmt.executeUpdate(sql);//7.处理结果System.out.println(count);//8.释放资源stmt.close();conn.close(); 三、详解各个对象：1. DriverManager：驱动管理对象功能：(1) 注册驱动：告诉程序该使用哪一个数据库驱动jar123static void registerDriver(Driver driver) //注册与给定的驱动程序 DriverManager 。 //写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125;&#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 (2) 获取数据库连接：方法：static Connection getConnection(String url, String user, String password) 参数： url：指定连接的路径 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 例子：jdbc:mysql://localhost:3306/db3 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 user：用户名 password：密码 2. Connection：数据库连接对象功能：(1) 获取执行sql 的对象12Statement createStatement()PreparedStatement prepareStatement(String sql) (2) 管理事务：开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 3. Statement：执行sql的对象执行sql boolean execute(String sql) ：可以执行任意的sql （了解） int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句练习 题目： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.itcast.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * account表 添加一条记录 insert 语句 */public class JDBCDemo2 &#123; public static void main(String[] args) &#123; Statement stmt = null; Connection conn = null; try &#123; //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2. 定义sql String sql = \"insert into account values(null,'王五',3000)\"; // 添加 // String sql = \"update account set balance = 1500 where id = 3\"; // 更改 // String sql = \"delete from account where id = 3\"; // 删除 // String sql = \"create table student (id int , name varchar(20))\"; // 创建表，DDL语句，不过不常用； //3.获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println(\"添加成功！\"); &#125;else&#123; System.out.println(\"添加失败！\"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4. ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 12345678910//循环判断游标是否是最后一行末尾。while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance);&#125; * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll(){} 3. 实现方法 select * from emp; 5. PreparedStatement：执行sql的对象(1) SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a 2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39; (2) 解决sql注入问题：使用PreparedStatement对象来解决 (3) 预编译的SQL：参数使用?作为占位符 (4) 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 (5) 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 抽取JDBC工具类 ： JDBCUtils* 目的：简化书写 * 分析： 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\")); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 练习： 需求： 通过键盘录入用户名和密码 判断用户是否登录成功 select * from user where username = “” and password = “”; 如果这个sql有查询结果，则成功，反之，则失败 步骤： 创建数据库表 user 12345678CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32));INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;); 2. 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class JDBCDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(\"登录成功！\"); &#125;else&#123; System.out.println(\"用户名或密码错误！\"); &#125; &#125; /** * 登录方法 */ public boolean login(String username ,String password)&#123; if(username == null || password == null)&#123; return false; &#125; //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try &#123; conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next())&#123;//如果有下一行，则返回true return true; &#125;else&#123; return false; &#125;*/ return rs.next();//如果有下一行，则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; return false; &#125;&#125; JDBC控制事务：1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务 3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务 4. 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 设置事务开始 //2.定义sql //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); //！！！！！！！！！！！！！！！！！！！！！！ 提交事务 &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); // ！！！！！！！！！！！！！！！！！！在异常并且conn存在时回滚！！ &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"JDBC","slug":"java/java高级编程/JDBC","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/JDBC/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"java","slug":"java","permalink":"http://zenner006.github.io/tags/java/"}]},{"title":"matlab竟有这种特性！","slug":"surprise-bug","date":"2020-07-18T08:20:35.000Z","updated":"2020-07-18T10:30:32.080Z","comments":true,"path":"2020/07/18/surprise-bug/","link":"","permalink":"http://zenner006.github.io/2020/07/18/surprise-bug/","excerpt":"","text":"matlab竟然可以对一个从未声明过的变量的索引进行赋值。很明显是一种很自由，开放的数据操作模式。 12345678910111213&gt;&gt; A(1,2) = 1A = 0 1 &gt;&gt; A(2,5) = 1A = 0 1 0 0 0 0 0 0 0 1&gt;&gt; 我写的一个算AUC的代码中，有一个变量未注意大小写。对其进行的赋值导致未起作用。这个bug一直存在。而程序也未提醒。他就当作了一个新变量的赋值。而我认为它对我的数据进行了处理。哎，心累。","categories":[{"name":"matlab","slug":"matlab","permalink":"http://zenner006.github.io/categories/matlab/"}],"tags":[{"name":"essay","slug":"essay","permalink":"http://zenner006.github.io/tags/essay/"}]},{"title":"mysql多表&事务","slug":"mysql-multiTable-transaction","date":"2020-07-18T02:19:18.000Z","updated":"2020-07-19T06:32:46.757Z","comments":true,"path":"2020/07/18/mysql-multiTable-transaction/","link":"","permalink":"http://zenner006.github.io/2020/07/18/mysql-multiTable-transaction/","excerpt":"多表查询：查询语法：select 列名列表 from 表名列表 where.... 准备sql","text":"多表查询：查询语法：select 列名列表 from 表名列表 where.... 准备sql 123456789101112131415161718192021# 创建部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20));INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);# 创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键));INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1); 笛卡尔积：* 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 多表查询的分类：1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 例子： -- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别。部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 2. 显式内连接： * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询： 1. 从哪些表中查询数据 2. 条件是什么 3. 查询哪些字段 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 3. 子查询：概念：查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于9000的SELECT * FROM emp WHERE emp.&#96;salary&#96; &#x3D; 9000;-- 一条sql就完成这个操作。子查询SELECT * FROM emp WHERE emp.&#96;salary&#96; &#x3D; (SELECT MAX(salary) FROM emp); 子查询不同情况(1) 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = * -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); (2) 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息 SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;); (3) 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &#39;2011-11-11&#39; 多表查询练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210 -- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,&#39;教研部&#39;,&#39;北京&#39;), (20,&#39;学工部&#39;,&#39;上海&#39;), (30,&#39;销售部&#39;,&#39;广州&#39;), (40,&#39;财务部&#39;,&#39;深圳&#39;); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;), (2, &#39;经理&#39;, &#39;管理部门员工&#39;), (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;), (4, &#39;文员&#39;, &#39;使用办公软件&#39;); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20), (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30), (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30), (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20), (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30), (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30), (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10), (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20), (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10), (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30), (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20), (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30), (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20), (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); -- 需求： -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 &#x2F;* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id &#x3D; job.id *&#x2F; SELECT t1.&#96;id&#96;, -- 员工编号 t1.&#96;ename&#96;, -- 员工姓名 t1.&#96;salary&#96;,-- 工资 t2.&#96;jname&#96;, -- 职务名称 t2.&#96;description&#96; -- 职务描述 FROM emp t1, job t2 WHERE t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96;; -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 &#x2F;* 分析： 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept 2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id *&#x2F; SELECT t1.&#96;id&#96;, -- 员工编号 t1.&#96;ename&#96;, -- 员工姓名 t1.&#96;salary&#96;,-- 工资 t2.&#96;jname&#96;, -- 职务名称 t2.&#96;description&#96;, -- 职务描述 t3.&#96;dname&#96;, -- 部门名称 t3.&#96;loc&#96; -- 部门位置 FROM emp t1, job t2,dept t3 WHERE t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96; AND t1.&#96;dept_id&#96; &#x3D; t3.&#96;id&#96;; -- 3.查询员工姓名，工资，工资等级 &#x2F;* 分析： 1.员工姓名，工资 emp 工资等级 salarygrade 2.条件 emp.salary &gt;&#x3D; salarygrade.losalary and emp.salary &lt;&#x3D; salarygrade.hisalary emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary *&#x2F; SELECT t1.ename , t1.&#96;salary&#96;, t2.* FROM emp t1, salarygrade t2 WHERE t1.&#96;salary&#96; BETWEEN t2.&#96;losalary&#96; AND t2.&#96;hisalary&#96;;​ ​ -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 &#x2F;* 分析： 1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade 2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary *&#x2F; SELECT t1.&#96;ename&#96;, t1.&#96;salary&#96;, t2.&#96;jname&#96;, t2.&#96;description&#96;, t3.&#96;dname&#96;, t3.&#96;loc&#96;, t4.&#96;grade&#96; FROM emp t1,job t2,dept t3,salarygrade t4 WHERE t1.&#96;job_id&#96; &#x3D; t2.&#96;id&#96; AND t1.&#96;dept_id&#96; &#x3D; t3.&#96;id&#96; AND t1.&#96;salary&#96; BETWEEN t4.&#96;losalary&#96; AND t4.&#96;hisalary&#96;;​ ​ -- 5.查询出部门编号、部门名称、部门位置、部门人数 &#x2F;* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 *&#x2F; SELECT t1.&#96;id&#96;,t1.&#96;dname&#96;,t1.&#96;loc&#96; , t2.total FROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2 WHERE t1.&#96;id&#96; &#x3D; t2.dept_id;​ -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 &#x2F;* 分析： 1.姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 2.条件 emp.id &#x3D; emp.mgr 3.查询左表的所有数据，和 交集数据 * 使用左外连接查询 *&#x2F; &#x2F;* select t1.ename, t1.mgr, t2.&#96;id&#96;, t2.ename from emp t1, emp t2 where t1.mgr &#x3D; t2.&#96;id&#96;; *&#x2F; SELECT t1.ename, t1.mgr, t2.&#96;id&#96;, t2.&#96;ename&#96; FROM emp t1 LEFT JOIN emp t2 ON t1.&#96;mgr&#96; &#x3D; t2.&#96;id&#96;; 事务一. 事务的基本介绍1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子：12345678910111213141516171819202122232425CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);SELECT * FROM account;UPDATE account SET balance &#x3D; 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance &#x3D; balance - 500 WHERE NAME &#x3D; &#39;zhangsan&#39;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance &#x3D; balance + 500 WHERE NAME &#x3D; &#39;lisi&#39;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0; 二. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 三. 事务的隔离级别（了解）1. 概念多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 2. 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 3. 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; 4. 演示123456789 set global transaction isolation level read uncommitted; start transaction;-- read uncommitted： 这里开了两个start transaction; 其中一个运行了以下语句（未提交），另一个进行读取，发现能读到修改。-- read committed： 这里开了两个start transaction; 其中一个运行了以下语句（未提交），另一个进行读取，发现未能到修改。等提交后，另一方读取时才能读到修改。-- repeatable read: 和上一个不同的是，运行转账的提交后，另一方读取未能读到修改。直到它也提交后，再查询时，才能读到修稿。-- serializable： 两个开了start transaction，其中一个运行了转账语句（未提交），另一个进行读取，发现读取不到，被阻塞了。直到转账方提交后，这一方会显示先前的那个读取操作的结果，而此时的结果就是转账后的结果。 -- 转账操作 update account set balance &#x3D; balance - 500 where id &#x3D; 1; update account set balance &#x3D; cccbalance + 500 where id &#x3D; 2; DCL：SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 DBA：数据库管理员DCL：管理用户，授权一. 管理用户1. 添加用户： * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 2. 删除用户： * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 3. 修改用户密码：123456-- 两种方式UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;新密码&#39;) WHERE USER &#x3D; &#39;用户名&#39;; UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;abc&#39;) WHERE USER &#x3D; &#39;lisi&#39;; SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; &#x3D; PASSWORD(&#39;新密码&#39;); SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;); mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 二. 权限管理：1. 查询权限：123-- 查询权限SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;; 2. 授予权限：1234-- 授予权限grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;-- 给张三用户授予所有权限，在任意数据库任意表上GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;; 3. 撤销权限：123-- 撤销权限：revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;REVOKE UPDATE ON db3.&#96;account&#96; FROM &#39;lisi&#39;@&#39;%&#39;;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[]},{"title":"MySql约束","slug":"MySql-constraint","date":"2020-07-17T09:24:44.000Z","updated":"2020-07-18T10:27:02.234Z","comments":true,"path":"2020/07/17/MySql-constraint/","link":"","permalink":"http://zenner006.github.io/2020/07/17/MySql-constraint/","excerpt":"第一章 约束一、概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 二、分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key 三、非空约束not null，某一列的值不能为null","text":"第一章 约束一、概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 二、分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key 三、非空约束not null，某一列的值不能为null 1. 创建表时添加约束1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空); 2. 创建表完后，添加非空约束1ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束1ALTER TABLE stu MODIFY NAME VARCHAR(20); 四、唯一约束unique，某一列的值不能重复 1. 注意： * 唯一约束可以有NULL值，但是只能有一条记录为null 2. 在创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 手机号 ); 3. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 4. 在表创建完后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 五、主键约束：primary key。1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束1234create table stu( id int primary key,-- 给id添加主键约束 name varchar(20)); 3. 删除主键123-- 错误 alter table stu modify id int ;ALTER TABLE stu DROP PRIMARY KEY;-- 删除主键只能去除主键描述，不能去除not null的描述。这是在添加主键时一块看到的 4. 创建完表后，添加主键1ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长：1. 概念如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长1234create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20)); 3. 删除自动增长1ALTER TABLE stu MODIFY id INT; 4. 添加自动增长1ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 5. 实例：添加了的UNIQUE： 删除UNIQUE： 添加主键和自动增长： 删除自动增长： 删除主键： 再删除null： 六、 外键约束：foreign key让表与表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 语法：12345create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键1ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键1ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作外键表想要修改id那么用了这个列的表也能同时一块修改，这样的操作就是级联操作。也就是凡是引用了它的表都能修改了。 1. 添加级联操作12ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE ：一块能更新 2. 级联删除：ON DELETE CASCADE ：一块能删除 5. 实例外键： 作为外键自身还不知道： 删除外键后，那一列也无太大反应： 但是可以加入一些department表中没有的部门了： 添加外键： 但由于其中含有department表中没有的项，所以把它删除掉后才可以再次设置外键： 数据库的设计一、多表之间的关系1. 分类： （1） 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 （2） 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 （3） 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一非空外键指向另一方的主键（UNIQUR，not null）。 3. 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-- 创建旅游线路分类表 tab_category-- cid 旅游线路分类主键，自动增长-- cname 旅游线路分类名称非空，唯一，字符串 100CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE);-- 创建旅游线路表 tab_route&#x2F;*rid 旅游线路主键，自动增长rname 旅游线路名称非空，唯一，字符串 100price 价格rdate 上架时间，日期类型cid 外键，所属分类*&#x2F;CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid));&#x2F;*创建用户表 tab_useruid 用户主键，自增长username 用户名长度 100，唯一，非空password 密码长度 30，非空name 真实姓名长度 100birthday 生日sex 性别，定长字符串 1telephone 手机号，字符串 11email 邮箱，字符串长度 100*&#x2F;CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &#39;男&#39;, telephone VARCHAR(11), email VARCHAR(100));&#x2F;*创建收藏表 tab_favoriterid 旅游线路 id，外键date 收藏时间uid 用户 id，外键rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次*&#x2F;CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid)); ​ 二、数据库设计的范式1. 概念设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 2. 分类 1. 第一范式（1NF）：每一列都是不可分割的原子数据项 2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原一、命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 二、图形化工具：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[]},{"title":"数据库基础","slug":"Databases","date":"2020-07-17T00:26:19.000Z","updated":"2020-07-18T10:26:01.766Z","comments":true,"path":"2020/07/17/Databases/","link":"","permalink":"http://zenner006.github.io/2020/07/17/Databases/","excerpt":"数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQL","text":"数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQL 4. 常见的数据库软件 * 参见《MySQL基础.pdf》 MySQL数据库软件1. 安装 * 参见《MySQL基础.pdf》 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -h[ip] -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据 SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) （--后应有空格才起作用） * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表一、操作数据库：CRUD1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 二、操作表1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录* select * from 表名; ​ 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询(1) where子句后跟条件(2) 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! 1234567891011121314151617181920212223242526272829303132333435363738394041-- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;&#x3D; 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age &#x3D; 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age !&#x3D; 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;&#x3D; 20 &amp;&amp; age &lt;&#x3D;30;SELECT * FROM student WHERE age &gt;&#x3D; 20 AND age &lt;&#x3D;30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age &#x3D; 22 OR age &#x3D; 18 OR age &#x3D; 25SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english &#x3D; NULL; -- 不对的。null值不能使用 &#x3D; （!&#x3D;） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english IS NOT NULL;-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;; DQL:查询语句1. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2. 聚合函数将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 例：SELECT count(name) FROM student; 3. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; ​ 4. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[]},{"title":"网络编程","slug":"network-prigramming","date":"2020-07-16T02:46:56.000Z","updated":"2020-07-16T14:05:30.102Z","comments":true,"path":"2020/07/16/network-prigramming/","link":"","permalink":"http://zenner006.github.io/2020/07/16/network-prigramming/","excerpt":"第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。","text":"第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计 算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 1Socket s1 = server.accecpt(); 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 12345678910111213141516171819202122public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); //5.关闭资源. is.close(); server.close(); &#125;&#125; 客户端实现： 1234567891011121314public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.获取流对象 . 输出流 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // 4. 关闭资源 . os.close(); client.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端启动 , 等待连接 .... \"); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write(\"我很好,谢谢你\".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： 12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"客户端 发送数据\"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket(\"localhost\", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write(\"你好么? tcp ,我来了\".getBytes()); // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 12345678910111213141516171819202122232425public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取输入流,读取文件数据 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流,保存到本地 . BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.jpg\")); // 4. 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425public class FileUPload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); bos.flush(); &#125; System.out.println(\"文件发送完毕\"); // 3.释放资源 bos.close(); socket.close(); bis.close(); System.out.println(\"文件上传完毕 \"); &#125;&#125; 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+\".jpg\") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现12345678910111213141516171819202122232425262728293031323334353637public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //4. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 信息回写分析图解前四步与基本文件上传一致. 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 回写实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务器 启动..... \"); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + \".jpg\"); BufferedOutputStream bos = new BufferedOutputStream(fis); ) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; // 4.=======信息回写=========================== System.out.println(\"back ........\"); OutputStream out = accept.getOutputStream(); out.write(\"上传成功\".getBytes()); out.close(); //================================ //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println(\"文件上传已保存\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425262728293031public class FileUpload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"test.jpg\")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket(\"localhost\", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); &#125; // 关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); // 3. =====解析回写============ InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // ============================ // 4.释放资源 socket.close(); bis.close(); &#125;&#125; 3.2 模拟B\\S服务器(扩展知识点)模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到我们Module中，比如复制到day08中 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(\" \");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： 1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"服务端 启动 , 等待连接 .... \"); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(\" \"); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(\" \"); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); out.write(\"Content-Type:text/html\\r\\n\".getBytes()); out.write(\"\\r\\n\".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125; 访问效果： 图解：","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"网络编程","slug":"java/java高级编程/网络编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"Stream","slug":"Stream","date":"2020-07-16T01:48:59.000Z","updated":"2020-07-16T03:18:06.554Z","comments":true,"path":"2020/07/16/Stream/","link":"","permalink":"http://zenner006.github.io/2020/07/16/Stream/","excerpt":"第一章 Stream流1.1 Stream流基本操作类集里支持有数据的流式分析处理操作，为此专门提供了一个Stream的接口，同时Collection接口里也提供有为此接口实例化的方法： public default Stream&lt;E&gt; straem() : 获得Stream接口对象。 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)：一个断言里面写一个lambda表达式 Stream主要功能是进行数据的分析处理，同时主要是针对于集合中的数据进行分析操作： 1234567891011121314151617181920212223package com.itheima.demo08.Stream;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo01Stream &#123; public static void main(String[] args) &#123; // Stream的基本操作 List&lt;String&gt; all = new ArrayList&lt;String&gt;(); Collections.addAll(all, \"java\",\"javascript\",\"python\",\"Ruby\",\"go\"); Stream&lt;String&gt; stream = all.stream(); // 输出元素的个数// System.out.println(stream.count()); // 5 // 输出满足条件的元素，用filter方法// System.out.println(stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).count()); // 2 上一句输出了这句输出就会报错：IllegalStateException: stream has already been operated upon or closed List&lt;String&gt; result = stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).collect(Collectors.toList()); System.out.println(result); //[java, javascript] &#125;&#125; public Stream&lt;T&gt; limit(long maxSize)：设置取出的最大数据量 public Stream &lt;T&gt; skip(long n) ：跳过指定数据量","text":"第一章 Stream流1.1 Stream流基本操作类集里支持有数据的流式分析处理操作，为此专门提供了一个Stream的接口，同时Collection接口里也提供有为此接口实例化的方法： public default Stream&lt;E&gt; straem() : 获得Stream接口对象。 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)：一个断言里面写一个lambda表达式 Stream主要功能是进行数据的分析处理，同时主要是针对于集合中的数据进行分析操作： 1234567891011121314151617181920212223package com.itheima.demo08.Stream;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo01Stream &#123; public static void main(String[] args) &#123; // Stream的基本操作 List&lt;String&gt; all = new ArrayList&lt;String&gt;(); Collections.addAll(all, \"java\",\"javascript\",\"python\",\"Ruby\",\"go\"); Stream&lt;String&gt; stream = all.stream(); // 输出元素的个数// System.out.println(stream.count()); // 5 // 输出满足条件的元素，用filter方法// System.out.println(stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).count()); // 2 上一句输出了这句输出就会报错：IllegalStateException: stream has already been operated upon or closed List&lt;String&gt; result = stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).collect(Collectors.toList()); System.out.println(result); //[java, javascript] &#125;&#125; public Stream&lt;T&gt; limit(long maxSize)：设置取出的最大数据量 public Stream &lt;T&gt; skip(long n) ：跳过指定数据量 1234567891011121314151617181920212223242526package com.itheima.demo08.Stream;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo01Stream &#123; public static void main(String[] args) &#123; // Stream的基本操作 List&lt;String&gt; all = new ArrayList&lt;String&gt;(); Collections.addAll(all, \"java\",\"javascript\",\"JSP\",\"Json\",\"python\",\"Ruby\",\"go\"); Stream&lt;String&gt; stream = all.stream(); // 输出元素的个数// System.out.println(stream.count()); // 5 /* 输出满足条件的元素，用filter方法 2 上一句输出了这句输出就会报错：IllegalStateException: stream has already been operated upon or closed */// System.out.println(stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).count()); List&lt;String&gt; result = stream.filter((ele) -&gt; ele.toLowerCase().contains(\"j\")).skip(2).limit(2).collect(Collectors.toList()); System.out.println(result); //[java, javascript] &#125;&#125; Stream 只要是利用自身的特点实现数据的分析处理操作。 1.2 MapReduce基础模型同样是很多的对象进行过滤,选择其中包含“强”的。并且进行商品单价和数量的处理，随后分析汇总 123456DoubleSummaryStatistics stat = all.stream().filter((ele)-&gt;ele.getName().contains(\"强\")).mapToDouble((orderObject)-&gt;orderObject.getPrice() * orderObject.getAmout().summaryStatistics());System.out.println(\"购买数量： \" + stat.getCount());System.out.println(\"购买总价： \" + stat.getSum());System.out.println(\"平均价格： \" + stat.getAverage());System.out.println(\"最高花费： \" + stat.getMax());System.out.println(\"最低花费： \" + stat.getMin()); 1.3 各种类型获得Stream流的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima.demo02.Stream;import java.util.*;import java.util.stream.Stream;/* java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： - 所有的Collection集合都可以通过stream默认方法获取流； default Stream&lt;E&gt; stream​() - Stream接口的静态方法of可以获取数组对应的流。 static &lt;T&gt; Stream&lt;T&gt; of​(T... values) 参数是一个可变参数,那么我们就可以传递一个数组 */public class Demo01GetStream &#123; public static void main(String[] args) &#123; //把集合转换为Stream流 List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream2 = set.stream(); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); //获取键,存储到一个Set集合中 Set&lt;String&gt; keySet = map.keySet(); Stream&lt;String&gt; stream3 = keySet.stream(); //获取值,存储到一个Collection集合中 Collection&lt;String&gt; values = map.values(); Stream&lt;String&gt; stream4 = values.stream(); //获取键值对(键与值的映射关系 entrySet) Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream(); //把数组转换为Stream流 Stream&lt;Integer&gt; stream6 = Stream.of(1, 2, 3, 4, 5); //可变参数可以传递数组 Integer[] arr = &#123;1,2,3,4,5&#125;; Stream&lt;Integer&gt; stream7 = Stream.of(arr); String[] arr2 = &#123;\"a\",\"bb\",\"ccc\"&#125;; Stream&lt;String&gt; stream8 = Stream.of(arr2); &#125;&#125; 1.4 常用方法 延迟方法：返回值依然是Stream接口自身类型的方法，所以可以支持链式调用 终结方法：返回值类型不再是Stream接口自身类型方法。终结方法包括：count和foreach 逐一处理：forEach 1void forEach(consumer&lt;? super T&gt; action); 接受一个Consumer接口函数，会将每一个流元素交给该函数进行 处理 基本使用1234567891011121314151617181920212223242526package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_forEach void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。 Consumer接口是一个消费型的函数式接口,可以传递Lambda表达式,消费数据 简单记: forEach方法,用来遍历流中的数据 是一个终结方法,遍历之后就不能继续调用Stream流中的其他方法 */public class Demo02Stream_forEach &#123; public static void main(String[] args) &#123; //获取一个Stream流 Stream&lt;String&gt; stream = Stream.of(\"张三\", \"李四\", \"王五\", \"赵六\", \"田七\"); //使用Stream流中的方法forEach对Stream流中的数据进行遍历 /*stream.forEach((String name)-&gt;&#123; System.out.println(name); &#125;);*/ stream.forEach(name-&gt;System.out.println(name)); &#125;&#125; 过滤：filter1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 复习Predicate接口这个接口是一个函数式接口，其中唯一的抽象方法为： 1boolean test(T t); 基本使用12345678910111213141516171819202122232425262728293031package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_filter:用于对Stream流中的数据进行过滤 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); filter方法的参数Predicate是一个函数式接口,所以可以传递Lambda表达式,对数据进行过滤 Predicate中的抽象方法: boolean test(T t); */public class Demo03Stream_filter &#123; public static void main(String[] args) &#123; //创建一个Stream流 Stream&lt;String&gt; stream = Stream.of(\"张三丰\", \"张翠山\", \"赵敏\", \"周芷若\", \"张无忌\"); //对Stream流中的元素进行过滤,只要姓张的人 Stream&lt;String&gt; stream2 = stream.filter((String name)-&gt;&#123;return name.startsWith(\"张\");&#125;); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); /* Stream流属于管道流,只能被消费(使用)一次 第一个Stream流调用完毕方法,数据就会流转到下一个Stream上 而这时第一个Stream流已经使用完毕,就会关闭了 所以第一个Stream流就不能再调用方法了 IllegalStateException: stream has already been operated upon or closed */ //遍历stream流 stream.forEach(name-&gt; System.out.println(name)); &#125;&#125; 映射：map1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型数据。 复习Function接口其中唯一的抽象方法为： 1R apply(T t); 可以将一种T类型转换成为R类型,而这种转换的动作就称为映射。 基本使用123456789101112131415161718192021222324package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_map:用于类型转换 如果需要将流中的元素映射到另一个流中，可以使用map方法. &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 Function中的抽象方法: R apply(T t); */public class Demo04Stream_map &#123; public static void main(String[] args) &#123; //获取一个String类型的Stream流 Stream&lt;String&gt; stream = Stream.of(\"1\", \"2\", \"3\", \"4\"); //使用map方法,把字符串类型的整数,转换(映射)为Integer类型的整数 Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;&#123; return Integer.parseInt(s); &#125;); //遍历Stream2流 stream2.forEach(i-&gt; System.out.println(i)); &#125;&#125; 统计个数：count1long count() 返回一个long值代表元素个数。 123456789101112131415161718192021222324252627package com.itheima.demo02.Stream;import java.util.ArrayList;import java.util.stream.Stream;/* Stream流中的常用方法_count:用于统计Stream流中元素的个数 long count(); count方法是一个终结方法,返回值是一个long类型的整数 所以不能再继续调用Stream流中的其他方法了 */public class Demo05Stream_count &#123; public static void main(String[] args) &#123; //获取一个Stream流 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); list.add(7); Stream&lt;Integer&gt; stream = list.stream(); long count = stream.count(); System.out.println(count);//7 &#125;&#125; 取用前几个： limit1Stream&lt;T&gt; limit(long maxSize) 12345678910111213141516171819202122package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_limit:用于截取流中的元素 limit方法可以对流进行截取，只取用前n个。方法签名： Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作 limit方法是一个延迟方法,只是对流中的元素进行截取,返回的是一个新的流,所以可以继续调用Stream流中的其他方法 */public class Demo06Stream_limit &#123; public static void main(String[] args) &#123; //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream = Stream.of(arr); //使用limit对Stream流中的元素进行截取,只要前3个元素 Stream&lt;String&gt; stream2 = stream.limit(3); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); &#125;&#125; 跳过前几个方法：skip1Stream&lt;T&gt; skip(long n); 123456789101112131415161718192021package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_skip:用于跳过元素 如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流： Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。 */public class Demo07Stream_skip &#123; public static void main(String[] args) &#123; //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream = Stream.of(arr); //使用skip方法跳过前3个元素 Stream&lt;String&gt; stream2 = stream.skip(3); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); // 灰太狼,红太狼 &#125;&#125; 合并：concat1static &lt;T&gt; Stream&lt;T&gt; concat(stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 12345678910111213141516171819202122package com.itheima.demo02.Stream;import java.util.stream.Stream;/* Stream流中的常用方法_concat:用于把流组合到一起 如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) */public class Demo08Stream_concat &#123; public static void main(String[] args) &#123; //创建一个Stream流 Stream&lt;String&gt; stream1 = Stream.of(\"张三丰\", \"张翠山\", \"赵敏\", \"周芷若\", \"张无忌\"); //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream2 = Stream.of(arr); //把以上两个流组合为一个流 Stream&lt;String&gt; concat = Stream.concat(stream1, stream2); //遍历concat流 concat.forEach(name-&gt; System.out.println(name)); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"Stream","slug":"java/java高级编程/Stream","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/Stream/"}],"tags":[]},{"title":"io","slug":"io","date":"2020-07-14T11:49:51.000Z","updated":"2020-08-12T07:42:53.416Z","comments":true,"path":"2020/07/14/io/","link":"","permalink":"http://zenner006.github.io/2020/07/14/io/","excerpt":"文件操作 在java语言里有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，也就是说整个的Java.io包里面File类是唯一一个与文件本身操作（创建，删除，重命名）有关的类，如果要想进行File类的操作，要必须提供完成的路径，而后才可以调用相应的方法进行处理： 1. File类的基本使用打开JDK文档可以发现，File类是Comparable接口的子类，所以File类的对象是可以进行排序处理的；在对File类处理的时候需要为其设置访问路径，那么对于路径的配置主要通过File类的构造方法来处理 构造方法：设置要操作完整路径； 1public File​(String pathname) 构造方法：设置父路径与子目录 1public File​(String parent, String child) 现在要想进行文件的基本操作可以使用如下的方法： 创建新的文件","text":"文件操作 在java语言里有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，也就是说整个的Java.io包里面File类是唯一一个与文件本身操作（创建，删除，重命名）有关的类，如果要想进行File类的操作，要必须提供完成的路径，而后才可以调用相应的方法进行处理： 1. File类的基本使用打开JDK文档可以发现，File类是Comparable接口的子类，所以File类的对象是可以进行排序处理的；在对File类处理的时候需要为其设置访问路径，那么对于路径的配置主要通过File类的构造方法来处理 构造方法：设置要操作完整路径； 1public File​(String pathname) 构造方法：设置父路径与子目录 1public File​(String parent, String child) 现在要想进行文件的基本操作可以使用如下的方法： 创建新的文件 1public boolean createNewFile​() throws IOException 判断文件是否存在 1public boolean exists​() 删除文件 1public boolean delete​() 范例：使用File类创建一个文件（） 12345678910111213import java.io.File;import java.io.IOException;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"./zenner.txt\"); if (file.exists()) &#123; file.delete(); &#125;else &#123; System.out.println(file.createNewFile()); &#125; &#125;&#125; 通过代码发现，File类本身就是文件本身的处理； 2. File类操作深入现在已实现了文件的基础操作，但是对于这个操作里也存在一些问题；下面用之前的代码进行优化处理： 在实际的软件项目开发和运行的过程之中，往往都会在windows中进行项目开发，而在项目部署的时候基于Linux或Unix系统来进行项目的发布以保证生产环节的安全性； 在不同的操作系统中有不同的路径分割符：Windows分隔符“\\”、Linux分隔符“/”； 所以在最初进行开发时就必须考虑到不同系统的路径分隔符的问题； File类中提供了一个常量： 1public static final String separator 范例：正常的路径编写 1File file = new File(\".\"+File.separator+\"zenner.txt\"); 随着系统的适应性的不断加强，对于当前的路径操作，win风和Linux风也都可以随意使用了； 在使用File类进行文件处理的时候需要注意的是：程序 → JVM → 操作系统函数 → 文件处理；所以对同一文件进行反复的删除或创建时有可能会出现延迟的问题，所以这个时候最好的方案是别重名; 在进行文件创建的时候有一个重要前提：文件的父路径必须首先存在； 如何获取父路径 12public String getParent​() // 返回父路径的字符串public File getParentFile​() // 返回父路径的File类对象 如果父路径不存在，需要创建路径： 12public boolean mkdir​() // 创建单级目录public boolean mkdirs​() // 创建多级目录 范例：文件创建的标准形式 12345678910111213141516import java.io.File;import java.io.IOException;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\".\"+File.separator+\"zenner.txt\"); if (!file.getParentFile().exists()) &#123; // 判断父路径不存在 file.getParentFile().mkdirs(); // 不存在要创建 &#125; if (file.exists()) &#123; // 文件是否存在 file.delete(); &#125;else &#123; System.out.println(file.createNewFile()); &#125; &#125;&#125; 这种父目录是否存在的判断很多情况下只需要使用一次，但是如果将其留在代码中就可能造成时间复杂度的提升；如果想要提升性能，就先保证目录已经创建。 3. 获取文件信息通过File类获取文件本身的一些信息 是否可执行 1public boolean canExecute​() 是否可读 1public boolean canRead​() 是否可写 1public boolean canWrite​() 获取文件大小，返回字节长度 1public long length​() 最有一次修改日期时间 1public long lastModified​() 1234567891011121314151617import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\".\"+File.separator+\"Ohwo\"+File.separator+\"zenner.txt\"); System.out.println(file.getParent()); if (!file.getParentFile().exists()) &#123; // 父路径不存在 file.getParentFile().mkdirs(); &#125; if (!file.exists()) &#123; file.createNewFile(); &#125; System.out.println(\"最后修改时间： \"+ new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(file.lastModified())); &#125;&#125; 判断是否是目录 1ublic boolean isDirectory​() 判断是否是文件 1public boolean isFile​() 列出所有文件 1public File[] listFiles​() 12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"d:\"+File.separator); if (file.isDirectory()) &#123; File result [] = file.listFiles(); for (File f:result) &#123; System.out.println(f); &#125; &#125; &#125;&#125;/*d:\\$RECYCLE.BINd:\\audiod:\\BaiduNetdiskDownloadd:\\Downloadd:\\filed:\\pagefile.sysd:\\Program Files (x86)d:\\softwared:\\System Volume Informationd:\\technologyd:\\Tempd:\\videod:\\迅雷下载 */ 4. 综合案例：列出目录结构任意设置的一个目录路径，然后把这个目录中所有的文件列出，包括子目录中的 递归输出目录下的所有文件，并且按层次输出文件目录 123456789101112131415161718192021222324252627282930import java.io.File;import java.io.IOException;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\" + File.separator+\"technology\"+File.separator+\"java\"+File.separator+\"三,高级编程\\\\note\\\\java高级编程（上）\"); listDir(file,\"\"); &#125; private static void listDir(File file,String head) &#123; System.out.println(head + file.getName()); if (file.isDirectory()) &#123; File results [] = file.listFiles(); if (results!=null) &#123; String t = head + \" \"; for (File f : results) &#123; listDir(f,t); &#125; &#125; &#125; &#125;&#125;/*java高级编程（上） java高级编程 image-20200620094308218.png ... image-20200621114310743.png java高级编程.md */ 5. 综合案例：文件批量改名输入目录名称，并把该目录下所有文件名后缀改为txt 对于这类操作必须设置一些假设的约定，能够重命名的文件都是由后缀的；如果没有后缀要为其追加路径，如果由后缀的路径，则必须以最后一个”.”进行截取； 改名为，参数是一个File类的实例化对象，这个file的名字就是改名为的名字 1public boolean renameTo​(File dest) 范例： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.IOException;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\technology\\\\java\\\\三,高级编程\\\\note\\\\java高级编程（下）\\\\task\"); long start = System.currentTimeMillis(); renameDir(file); long end = System.currentTimeMillis(); System.out.println(\"本次操作花费的时间： \"+(end - start)); &#125; private static void renameDir(File file) &#123; if (file.isDirectory()) &#123; File results [] = file.listFiles(); if (results!=null) &#123; for (File f:results) &#123; renameDir(f); &#125; &#125; &#125;else &#123; if (file.isFile()) &#123; String filename = file.getName(); if (filename.contains(\".\")) &#123; filename = file.getName().substring(0,file.getName().lastIndexOf(\".\")); &#125; filename = filename + \".txt\"; file.renameTo(new File(file.getParent(),filename)); // 改名的关键步骤 &#125; &#125; &#125;&#125; 字节流与字符流File类只能处理文件本身不能操作文件内容；而开发之中IO的核心意义在于：输入与输出操作；对程序而言，输入与输出可能来自不同的环境。 1. 流的基本概念 对于服务器或者客户端而言实质上传递的就是一种数据流的处理形式，而所谓的数据流指的就是比特数据；而对于这种流的处理形式java.io包里面提供由两种类的支持 字节处理流：OutputStream（输出字节流）、 InputStream（输入字节流）； 字符处理流：Writer （输出字符流）、Reader（输入字符流）； 所有的流操作都应该采用如下的统一的步骤进行，下面以文件处理的流程为例： 如果要进行的是文件的读写操作，则一定要通过File类找到一个文件路径； 通过字节流或字符流的子类为父类对象进行实例化 利用字节流或字符流中的方法实现数据的输入与输出； 流的操作属于资源操作，资源操作必须进行关闭； 2. OutputStream字节输出流​ 字节的数据是以byte类型为主实现的操作，在进行字节内容输出的时候可以使用 OutputStream 类来完成, 1public abstract class OutputStream extends Object implements Closeable, Flushable ​ 这个类实现了两个接口，于是基本的对应关系如下： Closeable接口： 123public interface Closeable extends AutoCloseable&#123; public void close() throws IOException;&#125; Flushable接口： 123public interface Flushable&#123; public void flush() throws IOException;&#125; OutputStream类里定义的是一个公共的输出操作标准，这个标准里定义了三个内容输出的方法： No 方法名称 类型 描述 1 public abstract void write(int b) throws IOException 普通 输出单个字节数据 2 public void write(byte[] b) throws IOException 普通 输出一组字节数据 3 public void write(byte[] b, int off, int len) 普通 输出部分字节数据 （第二种方法用的最多）OutputStream类毕竟是一个抽象类，而这个抽象类按传统认识应该通过子类的实例的向上转型完成抽象类的实例化。如果说要进行文件处理操作，则可以使用FileOutputStream子类 ​ 因为最终还是要发生向上转型的处理关系，所以此时对于FileOutputStream子类核心关注点就可以放在构造方法上了； [覆盖文件】构造方法： 1public FileOutputStream​(File file) throws FileNotFoundException 【可追加文件】构造方法 1public FileOutputStream​(File file, boolean append) throws FileNotFoundException 范例：使用Output类实现内容的输出 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); // 1. 指定操作路径 if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; OutputStream output = new FileOutputStream(file); // 2. 通过子类实例化 String str = \"abcdefg\"; output.write(str.getBytes()); // 3. 将字符串变为字节数组并输出 output.close(); // 4. 关闭输出； &#125;&#125; 本程序采用了最为标准的形式实现了输出的操作处理，只是创建了程序的父目录没有创建文件，所以可以看出输出操作可以自动创建文件； 另外，由于OutPutStream类也是AutoCloseable 的接口子类，所以close方法也可以简化使用 范例：自动关闭处理 12345678910111213141516171819import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; try(OutputStream output = new FileOutputStream(file,true))&#123; // 追加文件 String str = \"abcdefg\\r\\n\"; // 标准换行 output.write(str.getBytes()); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 这里的\\r\\n是标准换行 3. InputStream字节输入流​ InputStream类主要实现的就是字节数据读取； 1public abstract class InputStream extends Object implements Closeable ​ 在InputStream类里面有这么几个核心方法： No 方法名称 类型 描述 1 public abstract int read() throws IOException 普通 读取单个字节数据 2 public abstract int read() throws IOException 普通 读取一组字节数据 3 public int read(byte[] b,int off, int len) 普通 读取一组字节数据的部分内容 第一种读方法读单个字节数据，读到文件底部会返回-1： 第二个方法读取一组字节数据，读取的是读取的个数，如果数据读取到底则返回-1： InputStream类是一个抽象类，这时应该依靠它的子类来实例化对象，如果要从文件读取一定使用FileInputStream子类； 对子类而言，我们只关心父类对象实例化，构造方法： 构造方法 1public FileInputStream​(File file) throws FileNotFoundException 范例： 读取数据 1234567891011121314151617181920212223import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); InputStream input = new FileInputStream(file); byte data [] = new byte[1024]; int Length = input.read(data); input.close(); System.out.println(\"【\"+new String(data,0,Length)+\"】 \"+Length); &#125;&#125;/*【abcdefgabcdefgabcdefg】 27*/ data的输出需要注意不能全部输出1024个字节；应当按照读进来的个数来读取相应的； 对于字节输入流里最为麻烦的问题在于：使用read()方法读取的时候以字节数组为主进行接收； JDK 1.9 ，InputStream类里推出了一个新的方法： 1public byte[] readAllBytes​() throws IOException 范例：新方法 12345678910111213141516171819202122import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); InputStream input = new FileInputStream(file); byte data [] = input.readAllBytes(); input.close(); System.out.println(\"【\"+new String(data)+\"】 \"); &#125;&#125;/*【abcdefgabcdefgabcdefg】 */ ​ 如果现在想要读的内容很大很大，这个方法可能会搞死程序； 4. Writer字符输出流很多情况下用字符串输出是比较方便的。所以推出了Writer，这个类的定义如下: 1public abstract class Writer extends Object implements Appendable, Closeable, Flushable 重点看两个Writer类里的输出操作方法： 输出字符数组 1public void write​(char[] cbuf) throws IOException 输出字符串 1public void write​(String str) throws IOException 范例：使用Writer输出 123456789101112131415161718192021import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; Writer out = new FileWriter(file,true); // true打开追加开关 String str = \"www.zenner.com\\r\\n\"; out.write(str); out.append(\"What dose the fox say?\"); // 也可以用append out.close(); &#125;&#125; 使用Writer的最大优势在于可以直接利用字符串完成。 5. Reader字符输入流Reader是实现字符输入流的一种类型，本身属于一个抽象类，这个类定义如下： 1public abstract class Reader extends Object implements Readable, Closeable Reader类里面并没有像Writer类一样提供有整个字符串的输入处理操作，只能通过字符数组来实现我们的接收： 接收数据 1public int read​(char[] cbuf) throws IOException 范例：实现数据读取 12345678910111213141516171819202122232425import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); if (file.exists()) &#123; Reader in = new FileReader(file); char data[] = new char[1024]; int len = in.read(data); in.close(); System.out.println(\"读取内容： \"+ new String(data,0,len)); &#125; &#125;&#125;/*读取内容： www.zenner.comWhat dose the fox say?*/ 字符流读取的时候只能够按照数组的形式来实现处理： 6. 字节流与字符流的区别他们的区别重点从输出处理操作来分析；在OutputStream 和 Writer 输出的最后发现都使用了 close() 方法进行了关闭处理。 OutPutStream在未使用close方法关闭后文件内容依然输出了在文件里； 而Writer不使用close方法关闭，内容将无法进行输出，因为Writer使用到了缓冲区；当使用了close的方法的时候实际上会有强制刷新缓冲区的情况，这时会将内容进行输出，没有关闭就不能进行关闭操作；所以此时如果在不关闭的情况下想要实现全部内容的输出可以使用flush()方法强制清空; 范例：使用writer并强制清空 12345678910111213141516171819import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; Writer out = new FileWriter(file,true); // true打开追加开关 String str = \"www.zenner.com\\r\\n\"; out.write(str); out.append(\"What dose the fox say?\"); // 也可以用append out.flush(); // 强制刷新 &#125;&#125; 字节流进行处理时不会使用缓冲区，而字符流会使用到缓冲区；另外使用字符流的缓冲区更加适合中文数据的处理。开发中涉及到中文信息的输出都会用到字符流； 7. 转换流所谓转换是指实现字节流和字符流的功能转换；例如：进行输出的时候OutputStream需要将内容变为字节数组后才可以输出，而writer可以直接输出字符串，所以就需要一种不同流之间的转换操作。 在java.io里提供了两个类：InputStreamReader，OutputStreamWriter; OutputStreamWriter 定义 1public class OutputStreamWriter extends Writer 构造方法： 1public OutputStreamWriter​(OutputStream out) InputStreamReader 定义 1public class InputStreamReader extends Reader 构造方法： 1public InputStreamReader​(InputStream in) 通过类的继承结构可以发现，所谓的转换处理就是将接收到的字节流对象通过向上转型变为字符流对象； 范例：观察转换 1234567891011121314151617181920import java.io.File;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.Writer;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\hello\\\\a.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; OutputStream output = new FileOutputStream(file); Writer out = new OutputStreamWriter(output); // 字节流变为字符流 out.write(\"www.zenner.com\"); out.close(); &#125;&#125; 讲解转换流的主要目的是进行结构的分析处理; 在InputStream类有他的直接子类FileInputStream，OutputStream有他的直接子类FileOutputStream,而观察FileWriter和FileReader时可以看到的： FileWriter 定义 1public class FileWriter extends OutputStreamWriter 构造方法： 1public OutputStreamWriter(OutputStream out) FileReader 定义 1public class FileReader extends InputStreamReader 构造方法： 1public InputStreamReader(InputStream in) 8. 综合实战：文件拷贝模拟拷贝命令：通过初始化参数输入拷贝的源文件路径与拷贝的目标路径实现文件的拷贝处理； 需求分析： 需要实现文件的拷贝，首先文件就可以是各种文件所以肯定使用字节流； 拷贝时应考虑到大文件的拷贝问题； 实现方案： 方案一：使用InputStream将全部要拷贝的内容直接读取到程序里面，而后一次性输出到目标文件 缺点：如果拷贝的文件很大，基本程序就死了 方案二：采用部分拷贝，读取一部分，输出一部分； 采用第二种方案核心的方法： InputStream ： ` 1public int read(byte[] b) throws IOException OutputStream ： 1public void write(byte[] b, int off, int len) 范例：实现文件拷贝处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;class FileUtil&#123; // 文件操作工具类 private File srcFile; private File desFile; public FileUtil(String src,String des) &#123; this(new File(src),new File(des)); &#125; public FileUtil(File srcFile, File desFile) &#123; super(); this.srcFile = srcFile; this.desFile = desFile; &#125; public boolean copy() throws IOException,FileNotFoundException &#123; // 文件拷贝处理 try &#123; if (!this.srcFile.exists()) &#123; // 源文件必须存在！！ throw new FileNotFoundException(\"拷贝源文件不存在\"); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; if (!this.desFile.getParentFile().exists()) &#123; this.desFile.getParentFile().mkdirs(); &#125; byte data [] = new byte[1024]; InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(this.srcFile); output = new FileOutputStream(this.desFile); int len = 0; do &#123; len = input.read(data); // if (len != -1) &#123; output.write(data,0,len); &#125; &#125; while (len != -1); return true; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (input!= null) &#123; input.close(); &#125; if (output != null) &#123; output.close(); &#125; &#125; &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; if (args.length != 2) &#123; System.out.println(\"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath\"); System.exit(1); &#125; long start = System.currentTimeMillis(); FileUtil fu = new FileUtil(args[0],args[1]); System.out.println(fu.copy() ? \"文件拷贝成功\":\"文件拷贝失败\"); long end = System.currentTimeMillis(); System.out.println(\"拷贝完成的时间： \" + (end-start)); &#125;&#125;/*文件拷贝成功拷贝完成的时间： 11*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;class FileUtil&#123; // 文件操作工具类 private File srcFile; private File desFile; public FileUtil(String src,String des) &#123; this(new File(src),new File(des)); &#125; public FileUtil(File srcFile, File desFile) &#123; super(); this.srcFile = srcFile; this.desFile = desFile; &#125; public boolean copy() throws IOException,FileNotFoundException &#123; // 文件拷贝处理 try &#123; if (!this.srcFile.exists()) &#123; // 源文件必须存在！！ throw new FileNotFoundException(\"拷贝源文件不存在\"); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; if (!this.desFile.getParentFile().exists()) &#123; this.desFile.getParentFile().mkdirs(); &#125; byte data [] = new byte[1024]; InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(this.srcFile); output = new FileOutputStream(this.desFile); int len = 0; // 1. 读取数据到数组之中，随后返回读取的个数// do &#123;// len = input.read(data); //// if (len != -1) &#123;// output.write(data,0,len);// &#125;// &#125; while (len != -1); // 2. 判断个数是否是-1，如果不是则进行读写 while ((len = input.read(data)) != -1) &#123; output.write(data,0, len); &#125; return true; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (input!= null) &#123; input.close(); &#125; if (output != null) &#123; output.close(); &#125; &#125; &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; if (args.length != 2) &#123; System.out.println(\"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath\"); System.exit(1); &#125; long start = System.currentTimeMillis(); FileUtil fu = new FileUtil(args[0],args[1]); System.out.println(fu.copy() ? \"文件拷贝成功\":\"文件拷贝失败\"); long end = System.currentTimeMillis(); System.out.println(\"拷贝完成的时间： \" + (end-start)); &#125;&#125;/*文件拷贝成功拷贝完成的时间： 11*/ ​ 以上的实现是拷贝文件的最原始的实现，而从JDK1.9开始InputStream和Reader类中都追加有数据转存的处理操作方法： InputStream 1public long transferTo​(OutputStream out) throws IOException Reader 1public long transferTo(Writer out) throws IOException 范例：使用转存的方式处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;class FileUtil&#123; // 文件操作工具类 private File srcFile; private File desFile; public FileUtil(String src,String des) &#123; this(new File(src),new File(des)); &#125; public FileUtil(File srcFile, File desFile) &#123; super(); this.srcFile = srcFile; this.desFile = desFile; &#125; public boolean copy() throws IOException,FileNotFoundException &#123; // 文件拷贝处理 try &#123; if (!this.srcFile.exists()) &#123; // 源文件必须存在！！ throw new FileNotFoundException(\"拷贝源文件不存在\"); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; if (!this.desFile.getParentFile().exists()) &#123; this.desFile.getParentFile().mkdirs(); &#125; InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(this.srcFile); output = new FileOutputStream(this.desFile); input.transferTo(output); return true; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (input!= null) &#123; input.close(); &#125; if (output != null) &#123; output.close(); &#125; &#125; &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args) throws IOException &#123; if (args.length != 2) &#123; System.out.println(\"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath\"); System.exit(1); &#125; long start = System.currentTimeMillis(); FileUtil fu = new FileUtil(args[0],args[1]); System.out.println(fu.copy() ? \"文件拷贝成功\":\"文件拷贝失败\"); long end = System.currentTimeMillis(); System.out.println(\"拷贝完成的时间： \" + (end-start)); &#125;&#125; 此时要注意程序运行环境的版本问题；此时进一步扩展，要实现文件目录的拷贝。拷贝了文件目录还需要拷贝所有的子目录中的文件。 范例：文件夹拷贝操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;class FileUtil&#123; // 文件操作工具类 private File srcFile; private File desFile; public FileUtil(String src,String des) &#123; this(new File(src),new File(des)); &#125; public FileUtil(File srcFile, File desFile) &#123; super(); this.srcFile = srcFile; this.desFile = desFile; &#125; public boolean copy() throws Exception &#123; // 文件拷贝处理 return this.copyFileImpl(this.srcFile, this.desFile); &#125; private boolean copyFileImpl(File srcFile,File desFile) throws Exception&#123; try &#123; if (!srcFile.exists()) &#123; // 源文件必须存在！！ throw new FileNotFoundException(\"拷贝源文件不存在\"); &#125; &#125;catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; if (!desFile.getParentFile().exists()) &#123; desFile.getParentFile().mkdirs(); &#125; InputStream input = null; OutputStream output = null; try &#123; input = new FileInputStream(srcFile); output = new FileOutputStream(desFile); input.transferTo(output); return true; &#125; catch (IOException e) &#123; throw e; &#125;finally &#123; if (input!= null) &#123; input.close(); &#125; if (output != null) &#123; output.close(); &#125; &#125; &#125; public boolean copyDir() throws Exception&#123; try &#123; this.copyImpl(this.srcFile); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; private void copyImpl(File file) throws Exception &#123; if (file.isDirectory()) &#123; File results [] = file.listFiles(); if (results!=null) &#123; for (File f:results) &#123; copyImpl(f); &#125; &#125; &#125;else &#123; String newFilePath = file.getPath().replace(this.srcFile.getPath()+File.separator,\"\"); File newFile = new File(this.desFile,newFilePath); System.out.println(newFile); this.copyFileImpl(file, newFile); &#125; &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.out.println(\"命令执行错误，执行结构：java JavaApiDemo srcFilePath desFilePath\"); System.exit(1); &#125; long start = System.currentTimeMillis(); FileUtil fu = new FileUtil(args[0],args[1]); if (!new File(args[0]).isDirectory()) &#123; System.out.println(fu.copy() ? \"文件拷贝成功\":\"文件拷贝失败\"); &#125;else &#123; System.out.println(fu.copyDir() ? \"文件夹拷贝成功\":\"文件夹拷贝失败\"); &#125; ong end = System.currentTimeMillis(); System.out.println(\"拷贝完成的时间： \" + (end-start)); &#125;&#125; IO深入操作1. 字符编码实际开发中常用的编码有以下几种： GBK/GB2312：国标；GB2312只描述简体中文，而GBK包含有简体中文与繁体中文； ISO8859-1：国际通用编码，可以用其描述所有的字母信息，如果是象形文字则需要进行编码处理； UNICODE编码：采用十六进制的方式存储，可以描述所有的文字信息； UTF 编码：象形文字部分使用十六进制编码，而普通的字母采用的是IOS8859-1编码，优势在于可以快速地传输，节约带宽，也就是开发之中的首选编码，主要使用“UTF-8” 如果想知道当前系统中支持的编码规则，则可以采用如下代码列出全部的本机属性： 范例：列出本机属性 12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; System.getProperties().list(System.out); &#125;&#125;/*获取的部分信息file.encoding=UTF-8file.separator=\\*/ 范例：程序编码与系统编码 12345678910111213141516import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; OutputStream output = new FileOutputStream(\"D:\"+File.separator+\"a.txt\"); output.write(\"中华人民共和国万岁！\".getBytes()); output.close(); &#125;&#125;/*程序编码与系统编码一致都是UTF-8，即使写入了字节流，系统仍可以正确编码而其他的编码就可能在文件中出现乱码；当然也是不一定都会出现那乱码*/ 项目中出现乱码问题就是编码和解码标准不统一，而解决方法就是采用UTF-8 2. 内存操作流之前都是文件操作流，文件操作流的特点就是读取文件，写入文件，以文件为终端 假设需要IO操作又不希望产生文件，就可以以内存为终端进行处理；这个时候的流程 ​ 在java里提供有两类的内存操作流： 字节内存操作流：ByteArrayOutputStream、ByteArrayInputStream; 字符内存操作流：CharArrayWriter、CharArrayReader ​ 下面以 ByteArrayOutputStream 和 ByteArrayInputStream 类为主进行内存的使用分析，先分析他们各自的构造方法： ByteArrayInputStream ： 1public ByteArrayInputStream​(byte[] buf) ByteArrayOutputStream 1public ByteArrayOutputStream​() 在 ByteArrayOutputStream 类里面有一个重要的方法，这个方法可以获取全部保存在内存流中的数据信息，该方法为： 获取数据： 1public byte[] toByteArray​() 使用字符串的形式来获取数据： 1public String toString​() 范例：利用内存流实现一个小写字母转大写字母的操作 12345678910111213141516171819import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; String str = \"www.zenner.com\"; InputStream input = new ByteArrayInputStream(str.getBytes()); // 将数据保存在内存流 OutputStream output = new ByteArrayOutputStream(); int data = 0; while((data = input.read())!= -1) &#123; // 每次读取一个字节 output.write(Character.toUpperCase((char)data)); // 保存数据 &#125; System.out.println(output); input.close(); output.close(); &#125;&#125; ​ 如果不希望只是以字符串的形式返回，因为存放的还可能是二进制数据，那么就可以用子类的扩展功能获取全部字节数据 范例： 12345678910111213141516171819202122import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.OutputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; String str = \"www.zenner.com\"; InputStream input = new ByteArrayInputStream(str.getBytes()); // 将数据保存在内存流 // 必须使用子类来调用子类自己的扩展方法 ByteArrayOutputStream output = new ByteArrayOutputStream(); int data = 0; while((data = input.read())!= -1) &#123; // 每次读取一个字节 output.write(Character.toUpperCase((char)data)); // 保存数据 &#125; byte result [] = output.toByteArray(); System.out.println(new String(result)); input.close(); output.close(); &#125;&#125; 3. 管道流管道流之遥的功能是实现两个线程之间的IO处理操作； 同样也有两类： 字节管道流：PipedOutputStream 、 PipedInputStream ; 连接操作 1public void connect(PipedInputStream snk) throws IOException 字符管道流：PipedReader、 PipedWriter ; 连接处理： 1public void connect(PipedReader snk) throws IOException 范例：实现管道操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;class SendThread implements Runnable&#123; private PipedOutputStream output; public SendThread() &#123; super(); this.output = new PipedOutputStream(); &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; this.output.write((\"【\"+Thread.currentThread().getName()+\"信息发送】www.zenner.com\").getBytes()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; this.output.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public PipedOutputStream getOutput() &#123; return output; &#125;&#125;class ReceiveThread implements Runnable&#123; private PipedInputStream input; public ReceiveThread() &#123; super(); this.input = new PipedInputStream(); &#125; @Override public void run() &#123; byte data[] = new byte[1024]; try &#123; int len = this.input.read(data); System.out.println(\"&#123;\"+Thread.currentThread().getName()+\"接收消息&#125;\"+new String(data,0,len)); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; this.input.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public PipedInputStream getInput() &#123; return input; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; SendThread send = new SendThread(); ReceiveThread receive = new ReceiveThread(); send.getOutput().connect(receive.getInput()); new Thread(send,\"消息发送线程\").start() ; new Thread(receive,\"消息接收线程\").start() ; &#125;&#125; 输入与输出支持1. 打印流要进行数据输出一般都用outputStream类；这个类的数据输出操作功能有限： 1public void write(byte[] b) throws IOException 所有的输出都要转为字节字节后才能输出；而项目里的输出都是其他类型所以还要再转换为字节的形式来处理，这样比较麻烦；所以为了开发者会开发一些功能类来简化这个过程；不过这些包装起来的输出操作如何进行，核心使用的就是OutputStream； 范例：自己弄这样一个打印流；打印流的设计思想 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;class PrintUtil implements AutoCloseable&#123; // 实现一些常用数据的输出 private OutputStream output; public PrintUtil(OutputStream output) &#123; // 由外部来决定输出的位置 super(); this.output = output; &#125; public void print(String str) &#123; try &#123; this.output.write(str.getBytes()); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; public void println(String str) &#123; this.print(str+ \"\\n\"); &#125; @Override public void close() throws Exception &#123; this.output.close(); &#125; public void println(long i) &#123; this.println(String.valueOf(i)); &#125; public void print(long i) &#123; this.print(String.valueOf(i)); &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"d:\"+File.separator + \"zenner.txt\"); PrintUtil pu = new PrintUtil(new FileOutputStream(file)); // 通过传递类的类型使得各种类型的输出都能由这个类来输出 pu.println(\"姓名啊哈哈哈\"); pu.print(\"年龄：\"); pu.println(78); pu.close(); &#125;&#125; 打印流的设计思想的本质在于提高已有类的功能；例如：OutputStream类是唯一可以实现输出的操作功能类，所以应该以其为核心根本，但是这个类输出的操作功能有限，所以不方便进行输出各个数据类型，所以为他做出一层包装，此时用到的设计思想就是“装饰设计模式”； java.io包中有两种打印流：printStream、printWriter; printStream 继承关系： 1public class PrintStream extends FilterOutputStream implements Appendable, Closeable 构造方法 1public PrintStream​(OutputStream out) printWriter 继承关系 12public class PrintWriterextends Writer 构造方法： 12public PrintWriter​(OutputStream out)public PrintWriter​(Writer out) 下面使用PrintWriter来实现数据的输出操作： 范例： 123456789101112131415import java.io.File;import java.io.FileOutputStream;import java.io.PrintWriter;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"d:\"+File.separator + \"zenner.txt\"); PrintWriter pu = new PrintWriter(new FileOutputStream(file)); // 通过传递类的类型使得各种类型的输出都能由这个类来输出 pu.println(\"姓名啊哈哈哈\"); pu.print(\"年龄：\"); pu.println(78); pu.close(); &#125;&#125; JDK 1.5开始Printwriter类里面追加有格式化输出的操作支持： 1public PrintWriter printf(String format, Object... args) 范例：格式化输出 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.PrintWriter;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"d:\"+File.separator + \"zenner.txt\"); PrintWriter pu = new PrintWriter(new FileOutputStream(file)); // 通过传递类的类型使得各种类型的输出都能由这个类来输出 String name = \"小兵吱吱\"; int age = 78; double salary = 4324.42; pu.printf(\"姓名：%s、年龄：%d、收入：%9.2f\", name,age,salary); pu.close(); &#125;&#125;/*姓名：小兵吱吱、年龄：78、收入： 4324.42*/ 这个类输出起来比OutputStream类要简单；以后输出的时候就是用打印流； 2. System类对IO的支持System是一个系统类；系统类里有三个和输出输出相关的常量： 标准输出：显示器输出 1public static final PrintStream out 错误输出 1public static final PrintStream err 标准输入： 1public static final InputStream in 范例： 12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; try &#123; Integer.parseInt(\"s\"); &#125; catch (Exception e) &#123; System.out.println(e); System.err.println(e); &#125; &#125;&#125; java.lang.NumberFormatException: For input string: “s” ava.lang.NumberFormatException: For input string: “s” System.out和System.err都是同一类型的； 最早这么设置是因为out是希望用户看到信息；err是不希望用户看到的； 范例：实现键盘输入 12345678910111213141516import java.io.InputStream;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; InputStream input = System.in; System.out.println(\"请输出信息:\"); byte [] data = new byte[1024]; int len = input.read(data); System.out.println(\"输入内容为：\" + new String(data,0,len)); &#125;&#125;/*请输出信息:fdsafdsafdsa输入内容为：fdsafdsafdsa*/ 这样的键盘输入处理是有缺陷的；如果长度不足只能接收部分数据；在接收的时候可能接受中文造成编码不当； 3. BufferReader缓冲输入流BufferReader提供的是一个缓冲字符输入流的概念；可以很好的解决输入流数据的读取问题； 12public BufferedReader(Reader in, int sz)public BufferedReader​(Reader in) 该类有一个重要的方法： 读取一行数据 1public String readLine() throws IOException 用这个类实现键盘输入数据的标准化定义 范例：实现键盘数据输入 1234567891011121314import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"请输入信息： \"); String msg = input.readLine(); System.out.println(\"输入内容为： \"+msg); &#125;&#125; 这个类是之前最好的，后面 JDK 1.5以后有一个更好的类； 4. Scanner扫描流java.util.Scanner是为了解决输入流的访问问题；可以理解为BufferedReader的替代功能类，在Scanner类里有如下的几种操作方法： 构造方法： 12public Scanner(InputStream source)public Scanner​(File source) throws FileNotFoundException 继承关系： 123public final class Scannerextends Objectimplements Iterator&lt;String&gt;, Closeable 是否有数据： 1public boolean hasNext() 取出数据 1public String next​() 设置分隔符： 1public Scanner useDelimiter(String pattern) 范例：使用Scanner实现键盘数据输入 123456789101112public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入年龄： \"); if (sc.hasNextInt()) &#123; // 是否有整数输入 int age = sc.nextInt(); System.out.println(\"您的年龄： \" + age); &#125; else &#123; System.out.println(\"输入正确格式\"); &#125; &#125;&#125; 范例：持续输入 12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入年龄： \"); while(sc.hasNextInt()) &#123; // 是否有整数输入 int age = sc.nextInt(); System.out.println(\"您的年龄： \" + age); &#125; &#125;&#125; Scanner实现键盘输入是比较简单的； 范例： 12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入： \"); if(sc.hasNext()) &#123; // 是否有整数输入 System.out.println(\"您的年龄： \" + sc.next()); &#125; sc.close(); &#125;&#125; 还有一个特点是可以直接利用正则济宁验证判断； 范例：验证一个人的生日（yyyy-MM-dd） 1234567891011121314import java.text.SimpleDateFormat;import java.util.Scanner;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的生日： \"); // 验证一个人的生日（yyyy-MM-dd） if(sc.hasNext(\"\\\\d&#123;4&#125;-\\\\d&#123;1,2&#125;-\\\\d&#123;2&#125;\")) &#123; // 是否有整数输入 System.out.println(\"您的年龄： \" + new SimpleDateFormat(\"yyyy-MM-dd\").parse(sc.next(\"\\\\d&#123;4&#125;-\\\\d&#123;1,2&#125;-\\\\d&#123;2&#125;\"))); &#125; sc.close(); &#125;&#125; 范例：用Scanner读文件（我读我自己） 1234567891011121314package cn.jubingyi.Demo;import java.io.File;import java.util.Scanner;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123;// System.out.println(new File(\"\").getAbsolutePath()); Scanner sc = new Scanner(new File(\"./src/cn/jubingyi/Demo/JavaApiDemo.java\")); sc.useDelimiter(\"\\n\"); while (sc.hasNext()) &#123; System.out.println(sc.next()); &#125; sc.close(); &#125;&#125; 如果程序需要输出数据一定使用打印流，输入数据使用Scanner(BufferedReader) 对象序列化​ 几乎只要是java开发就一定存在序列化的概念，而正是因为序列化的概念逐步发展，慢慢也有了更多的序列化标准； 1. 对象序列化的基本概念​ 所谓的对象序列化只是将内存中保存的对象以二进制数据流的形式进行处理，可以实现对象的保存或者网络传输；（什么你要把对象发送到远程服务器上？） 然后并不是所有的对象都可以被序列化，在java里有一个强制性的要求：如果要序列化的对象，那么序列化的类一定要实现 java.io.Serializable 父接口，作为序列化的标记。 但是这个方法没有任何的方法，因为它描述的是一种类的能力； 范例：定义一个可以被序列化的类 12345678910111213141516171819import java.io.Serializable;class Person implements Serializable&#123; // 可以被序列化 /** * */ private static final long serialVersionUID = 1L; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; 此时Person类产生的每一个对象都可以实现二进制的数据传输，属于可以被序列化的程序类； 2. 序列化与反序列化​ 有了序列化的支持类之后如果想要实现序列化与反序列化的操作则就可以利用以下的两个类完成 类名称 序列化：objectOutputStream 反序列化：objectInputStream 类定义 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants 构造方法 public ObjectOutputStream(OutputStream out)throws IOException public ObjectInputStream(InputStream in) throws IOException 操作方法 public final void writeObject(Object obj) throws IOException public final Object readObject() throws IOException, ClassNotFoundException 范例：实现序列化与反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.jubingyi.Demo;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class JavaApiDemo &#123; private final static File SAVE_FILE = new File(\"./fileOperation/zenner.person\"); public static void main(String[] args) throws Exception &#123; if (!SAVE_FILE.getParentFile().exists()) &#123; SAVE_FILE.getParentFile().mkdirs(); &#125; saveobject(new Person(\"笑喷涕\",78)); System.out.println(loadObject()); &#125; public static void saveobject(Object obj) throws FileNotFoundException, IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE)); oos.writeObject(obj); // 序列化 oos.close(); &#125; public static Object loadObject() throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE)); Object obj = ois.readObject(); // 反序列化 ois.close(); return obj; &#125;&#125;@SuppressWarnings(\"serial\")class Person implements Serializable&#123; // 可以被序列化 /** * */ private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; &#125;/*Person [name=笑喷涕, age=78] */ 在java中的对象序列化与反序列化必须使用内部提供的对象操作流，因为里面牵扯到二进制数据的格式，这是不能够自定义处理，如果想要实现一组对象的序列化，则可以使用对象数组完成； ​ 在很多的实际项目开发之中，开发者就很少能够见到这两个类，因为有许多容器的帮助开发者自动实现； 3. transient关键字​ 默认情况下执行了对象序列化的时候会将类中的全部属性的内容进行全部序列化，但很多情况下，并不需要进行序列化的处理，这时就可以在属性定义上使用transient关键字来完成； ​ 在进行序列化处理的时候name属性的内容是不会被保存下来的，也就是说，读取的数据name将是其对应数据的默认值“null”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class JavaApiDemo &#123; private final static File SAVE_FILE = new File(\"./fileOperation/zenner.person\"); public static void main(String[] args) throws Exception &#123; if (!SAVE_FILE.getParentFile().exists()) &#123; SAVE_FILE.getParentFile().mkdirs(); &#125; saveobject(new Person(\"笑喷涕\",78)); System.out.println(loadObject()); &#125; public static void saveobject(Object obj) throws FileNotFoundException, IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(SAVE_FILE)); oos.writeObject(obj); // 序列化 oos.close(); &#125; public static Object loadObject() throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(SAVE_FILE)); Object obj = ois.readObject(); // 反序列化 ois.close(); return obj; &#125;&#125;@SuppressWarnings(\"serial\")class Person implements Serializable&#123; // 可以被序列化 /** * */ private transient String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; &#125;/*Person [name=null, age=78] */ ​ 如果假设类之中有一些是需要计算保存的属性内容往往是不需要被序列化的，这时就可以使用 transient关键字，在实际开发之中大部分需要被序列化的类往往都是简单java类，所以这一个关键字出现的频率并不高。 javaIO编程案例1. 数字大小比较编写程序，输入3个整数，并求出3个整数的最大值和最小值： 想要进行数字输入处理，那么应该保证输入错误的时候可以重新输入；那么为了达到重用的设计，我们应该准备一个单独的输入数据类。 定义一个输入工具类（Scanner实现） 1234567891011121314151617181920package cn.jubingyi.Demo.util;import java.util.Scanner;public class InputUtil &#123; public static int getInt(String prompt) &#123; int num = 0; boolean flag = true; while (flag) &#123; System.out.println(prompt); @SuppressWarnings(\"resource\") Scanner input = new Scanner(System.in); // 这里用的是 Scanner if (input.hasNext(\"\\\\d+\")) &#123; num = Integer.parseInt(input.next(\"\\\\d+\")); flag = false; &#125;else &#123; System.out.println(\"输入的内容不是数字！\"); &#125; &#125; return num; &#125;&#125; 用BufferedReader来实现 1234567891011121314151617181920212223242526272829303132package cn.jubingyi.Demo.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;public class InputUtil &#123; public static int getInt(String prompt) &#123; BufferedReader buf = new BufferedReader(new InputStreamReader(System.in)); int num = 0; boolean flag = true; while (flag) &#123; System.out.println(prompt); String str = null ; try &#123; str = buf.readLine(); if (str.matches(\"\\\\d+\")) &#123; num = Integer.parseInt(str); flag = false; &#125;else &#123; System.out.println(\"输入的内容不是数字！\"); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block System.out.println(\"输入的内容不是数字！\"); &#125; &#125; return num; &#125;&#125; 定义数据的输入处理 123456789package cn.jubingyi.Demo.service; public interface INumberService &#123; /** * 输入数据并且返回输入数据的最大值与最小值 * @param count 表示输入数据的个数 * @return 整数数组，包含两项，第一个是最大值，第二个是最小值 */ public int [] stat(int count);&#125; 实现接口的子类 12345678910111213141516171819202122232425package cn.jubingyi.Demo.service.impl;import cn.jubingyi.Demo.service.INumberService;import cn.jubingyi.Demo.util.InputUtil;public class NumberServiceImpl implements INumberService &#123; @Override public int[] stat(int count) &#123; int result [] = new int[2]; int data [] = new int[count]; for (int x = 0 ; x &lt; data.length ; x ++) &#123; // 信息循环输入 data[x] = InputUtil.getInt(\"请输入第“\" + (x + 1) + \"”个数字\"); &#125; result[0] = data[0]; result[1] = data[1]; for (int x = 0 ; x &lt; data.length ; x ++) &#123; if (data[x] &gt; result[0]) &#123; result[0] = data[x]; &#125; if (data[x] &lt; result[1]) &#123; result[1] = data[x]; &#125; &#125; return result; &#125;&#125; 定义工厂类获取接口对象 1234567891011package cn.jubingyi.Demo.factory;import cn.jubingyi.Demo.service.INumberService;import cn.jubingyi.Demo.service.impl.NumberServiceImpl;public class Factory &#123; private Factory() &#123;&#125; public static INumberService getInstance() &#123; return new NumberServiceImpl(); &#125;&#125; 编写测试类 12345678910111213package cn.jubingyi.Demo;import cn.jubingyi.Demo.factory.Factory;import cn.jubingyi.Demo.service.INumberService;public class IOcaseDemo &#123; public static void main(String[] args) &#123; INumberService numberService = Factory.getInstance(); int result [] = numberService.stat(5); System.out.println(\"最大值： \" + result[0] + \"、最小值： \" + result[1]); &#125;&#125; 2.文件保存处理​ 从键盘输入文件的内容和要保存的文件名称，然后根据输入的名称创建文件，并将内容保存到文件中。 在这里可以看出文件路径在文件启动之前就应该启动好。 1234567891011public class IOcaseDemo &#123; private static final String SAVE_DIR = \"D:\" + File.separator + \"zenner\" + File.separator; static &#123; File file = new File(SAVE_DIR); if (!file.exists()) &#123; file.mkdirs(); &#125; &#125; public static void main(String[] args) &#123; &#125;&#125; 定义一个文件操作的服务接口： 12345678package cn.jubingyi.Demo.service;public interface IFileService &#123; /** * 定义文件的保存处理方法 * @return 保存成功返回true,否则返回false */ public boolean save();&#125; 在InputUtil类里面追加有输入字符串的处理方法 12345678910111213141516171819202122232425262728package cn.jubingyi.Demo.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;public class InputUtil &#123; private InputUtil() &#123;&#125; public static String getString(String prompt) &#123; String str = null; boolean flag = true; while (flag) &#123; Scanner input = new Scanner(System.in); System.out.println(prompt); if (input.hasNext()) &#123; str = input.next().trim(); if (!\"\".equals(str)) &#123; // 不是空字符串 flag = false; &#125;else &#123; System.out.println(\"输入的内容不允许为空！\"); &#125; &#125; else &#123; System.out.println(\"输入的内容不允许为空！\"); &#125; &#125; return str; &#125;&#125; 实现文件名字与内容输入的实现类 1234567891011121314151617181920212223242526272829303132333435package cn.jubingyi.Demo.service.impl;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintWriter;import cn.jubingyi.Demo.service.IFileService;import cn.jubingyi.Demo.util.InputUtil;public class FileServiceImpl implements IFileService &#123; private String name; private String content; public FileServiceImpl() &#123; this.name = InputUtil.getString(\"请输入保存文件名称\"); this.content = InputUtil.getString(\"请输入保存文件的内容\"); &#125; @Override public boolean save() &#123; File file = new File(IFileService.SAVE_DIR + this.name); PrintWriter out = null; try &#123; out = new PrintWriter(new FileOutputStream(file)); out.print(this.content); &#125;catch (FileNotFoundException e) &#123; return false; &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125; return true; &#125;&#125; 工厂类 12345678910111213package cn.jubingyi.Demo.factory;import cn.jubingyi.Demo.service.IFileService;import cn.jubingyi.Demo.service.INumberService;import cn.jubingyi.Demo.service.impl.FileServiceImpl;import cn.jubingyi.Demo.service.impl.NumberServiceImpl;public class Factory &#123; private Factory() &#123;&#125; public static IFileService getInstance() &#123; return new FileServiceImpl(); &#125;&#125; 范例：测试类里有一个static使得其启动时就会提前执行； 1234567891011121314151617181920package cn.jubingyi.Demo;import java.io.File;import cn.jubingyi.Demo.factory.Factory;import cn.jubingyi.Demo.service.IFileService;import cn.jubingyi.Demo.service.INumberService;public class IOcaseDemo &#123; static &#123; File file = new File(IFileService.SAVE_DIR); if (!file.exists()) &#123; file.mkdirs(); &#125; &#125; public static void main(String[] args) &#123; IFileService fileService = Factory.getInstance(); fileService.save(); &#125;&#125; 3. 字符串逆序显示从键盘传入的多个字符串到程序中，并将它们按逆序输出在屏幕上。 程序之中应该考虑到如下的几种设计： 既然字符串的内容可以随时修改，最好建立一个StringBuffer做保存； 在进行数据处理的时候应由用户来决定是否继续输入 定义字符串的操作标准 123456package cn.jubingyi.Demo.service;public interface IStringService &#123; public void append(String str) ; public String[] reverse();&#125; 实现子类里就使用StringBuffer 123456789101112131415161718192021222324252627package cn.jubingyi.Demo.service.impl;import cn.jubingyi.Demo.service.IStringService;public class StringServiceImpl implements IStringService &#123; private StringBuffer data = new StringBuffer(); @Override public void append(String str) &#123; this.data.append(str).append(\"|\"); &#125; @Override public String[] reverse() &#123; String result [] = this.data.toString().split(\"\\\\|\"); int center = result.length/2; int head = 0; int tail = result.length-1; for(int x = 0 ; x &lt; center ; x ++) &#123; String temp = result[head] ; result[head] = result[tail] ; result[tail] = temp ; head ++; tail --; &#125; return result; &#125;&#125; 定义工厂类 1234567891011package cn.jubingyi.Demo.factory;import cn.jubingyi.Demo.service.IStringService;import cn.jubingyi.Demo.service.impl.StringServiceImpl;public class Factory &#123; private Factory() &#123;&#125; public static IStringService getInstance() &#123; return new StringServiceImpl(); &#125;&#125; 定义一个Menu处理类，采用交互式的界面完成处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.jubingyi.Demo.Menu;import java.util.Arrays;import cn.jubingyi.Demo.factory.Factory;import cn.jubingyi.Demo.service.IStringService;import cn.jubingyi.Demo.util.InputUtil;public class Menu &#123; private IStringService stringservice; public Menu() &#123; this.stringservice = Factory.getInstance(); this.choose(); &#125; private void choose() &#123; this.show(); String choose = InputUtil.getString(\"请进行选择:\"); switch(choose) &#123; // 接受输入数据 case \"1\" :&#123; String str = InputUtil.getString(\"请输入字符串数据：\"); this.stringservice.append(str); choose(); &#125;case \"2\" :&#123; // 逆序显示数据 String str = InputUtil.getString(\"数据反转：\"); String result [] = this.stringservice.reverse(); System.out.println(Arrays.toString(result)); choose(); &#125;case \"0\":&#123; System.out.println(\"Bye\"); System.exit(1); &#125;default:&#123; System.out.println(\"未接受到选项\\n\\n\\n\"); choose(); &#125; &#125; &#125; public void show() &#123; System.out.println(\"*******************************\"); System.out.println(\"【1】追加字符串数据\"); System.out.println(\"【2】逆序显示所有字符串数据\"); System.out.println(\"【0】结束程序进行\"); System.out.println(\"\\n\\n\\n\"); &#125;&#125; 主函数 123456789package cn.jubingyi.Demo;import cn.jubingyi.Demo.Menu.Menu;public class IOcaseDemo &#123; public static void main(String[] args) &#123; new Menu(); &#125; &#125; 交互式整个比较容易 4. 数据排序处理​ 从键盘输入以下数据：“TOM:89|JERRY:90|TONY:95”，数据格式为“姓名：成绩|姓名：成绩|姓名：成绩” 对于排序要用Comparable接口完成，同时利用Arrays类来处理，这里面唯一不同的地方就在于此时的数据显示要用键盘输入 建立Student程序类，并且进行排序规则的配置； 123456789101112131415161718192021222324package cn.jubingyi.Demo.vo;public class Student implements Comparable&lt;Student&gt; &#123; private String name; private double score; public Student(String name,double score) &#123; this.name = name ; this.score = score ; &#125; @Override public String toString() &#123; return \"Student [name=\" + name + \", score=\" + score + \"]\"; &#125; @Override public int compareTo(Student o) &#123; if (this.score &gt; o.score) &#123; return -1; &#125; else if (this.score &lt; o.score) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 建立数据的输入处理操作，因为牵扯到拆分问题： 123456package cn.jubingyi.Demo.service;import cn.jubingyi.Demo.vo.Student;public interface IStudentService &#123; public Student [] getData(); // 获取排序后的数据 &#125; 建立IStudentService子类 12345678910111213141516171819202122232425262728293031package cn.jubingyi.Demo.service.impl;import java.util.Arrays;import cn.jubingyi.Demo.service.IStudentService;import cn.jubingyi.Demo.vo.Student;public class StudentService implements IStudentService &#123; private String content; private Student [] students; public StudentService(String content) &#123; super(); this.content = content; this.handle(); &#125; private void handle() &#123; // 进行字符串数据的处理操作 String result [] = this.content.split(\"\\\\|\"); this.students = new Student[result.length]; for (int x = 0 ; x &lt; this.students.length ; x ++) &#123; String temp [] = result[x].split(\":\"); this.students[x] = new Student(temp[0],Double.parseDouble(temp[1])); &#125; &#125; @Override public Student[] getData() &#123; Arrays.sort(this.students); return this.students; &#125;&#125; 定义Factory工厂类 12345678910import cn.jubingyi.Demo.service.IStringService;import cn.jubingyi.Demo.service.impl.StudentServiceImpl;import cn.jubingyi.Demo.util.InputUtil;public class Factory &#123; private Factory() &#123;&#125; public static IStringService getInstance() &#123; return (IStringService) new StudentServiceImpl(InputUtil.getString(\"请输入数据信息： \")); &#125;&#125; 5.编写测试类 1234567891011package cn.jubingyi.Demo;import java.util.Arrays;import cn.jubingyi.Demo.factory.Factory;public class IOcaseDemo &#123; public static void main(String[] args) &#123; System.out.println(Arrays.toString(Factory.getInstance().getData())); &#125; &#125; 5. 数据排序处理深入把全部输入信息保存在文件中，还可以添加信息，并可以显示全部信息 要进行内容保存，首先要确认好所有输入数据的保存位置，所有的数据之间如果要想沿用之前的设计结构，则数据文件里的保存应做到格式统一； 添加的时候还应考虑到有时添加的是“单独的内容”、“一组内容”；暂不考虑数据过大； fds 1 fds 1 fds 1 类名称 序列化：objectOutputStream 反序列化：objectInputStream 类定义 public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants public class ObjectInputStream extends InputStream implements ObjectInput, ObjectStreamConstants 构造方法 public ObjectOutputStream(OutputStream out)throws IOException public ObjectInputStream(InputStream in) throws IOException No 方法名称 类型 描述 1 2 3 4","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"io","slug":"java/java高级编程/io","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/io/"}],"tags":[]},{"title":"map","slug":"map","date":"2020-07-14T09:17:24.000Z","updated":"2020-07-15T02:04:37.401Z","comments":true,"path":"2020/07/14/map/","link":"","permalink":"http://zenner006.github.io/2020/07/14/map/","excerpt":"第一章 Map集合1.1 概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。","text":"第一章 Map集合1.1 概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 1.2 Map常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量的数据类型可以相同，也可以不同。 1.3 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.HashMap;import java.util.Map;/* java.util.Map&lt;k,v&gt;集合 Map集合的特点: 1.Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) 2.Map集合中的元素,key和value的数据类型可以相同,也可以不同 3.Map集合中的元素,key是不允许重复的,value是可以重复的 4.Map集合中的元素,key和value是一一对应 java.util.HashMap&lt;k,v&gt;集合 implements Map&lt;k,v&gt;接口 HashMap集合的特点: 1.HashMap集合底层是哈希表:查询的速度特别的快 JDK1.8之前:数组+单向链表 JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 2.hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 java.util.LinkedHashMap&lt;k,v&gt;集合 extends HashMap&lt;k,v&gt;集合 LinkedHashMap的特点: 1.LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) 2.LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的 */public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱：可能发生 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 1.4 Map集合遍历键找值方式 （keyset方法）键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合的第一种遍历方式:通过键找值的方式 Map集合中的方法: Set&lt;K&gt; keySet() 返回此映射中包含的键的 Set 视图。 实现步骤: 1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 2.遍历set集合,获取Map集合中的每一个key 3.通过Map集合中的方法get(key),通过key找到value */public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : map.keySet())&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 遍历图解： 1.5 Entry键值对对象 （entrySet方法）我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 1.6 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.demo01.Map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* Map集合遍历的第二种方式:使用Entry对象遍历 Map集合中的方法: Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的 Set 视图。 实现步骤: 1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 2.遍历Set集合,获取每一个Entry对象 3.使用Entry对象中的方法getKey()和getValue()获取键与值 */public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 遍历图解： tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 1.7 HashMap存储自定义类型键值练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 注意，学生姓名相同并且年龄相同视为同一名学生。 编写学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 编写测试类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.demo02.Map;import java.util.HashMap;import java.util.Map;import java.util.Set;/* HashMap存储自定义类型键值 Map集合保证key是唯一的: 作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一 */public class Demo01HashMapSavePerson &#123; public static void main(String[] args) &#123; show02(); &#125; /* HashMap存储自定义类型键值 key:Person类型 Person类就必须重写hashCode方法和equals方法,以保证key唯一 value:String类型 可以重复 */ private static void show02() &#123; //创建HashMap集合 HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(new Person(\"女王\",18),\"英国\"); map.put(new Person(\"秦始皇\",18),\"秦国\"); map.put(new Person(\"普京\",30),\"俄罗斯\"); map.put(new Person(\"女王\",18),\"毛里求斯\"); //使用entrySet和增强for遍历Map集合 Set&lt;Map.Entry&lt;Person, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;Person, String&gt; entry : set) &#123; Person key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"--&gt;\"+value); &#125; &#125; /* HashMap存储自定义类型键值 key:String类型 String类重写hashCode方法和equals方法,可以保证key唯一 value:Person类型 value可以重复(同名同年龄的人视为同一个) */ private static void show01() &#123; //创建HashMap集合 HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;(); //往集合中添加元素 map.put(\"北京\",new Person(\"张三\",18)); map.put(\"上海\",new Person(\"李四\",19)); map.put(\"广州\",new Person(\"王五\",20)); map.put(\"北京\",new Person(\"赵六\",18)); //使用keySet加增强for遍历Map集合 Set&lt;String&gt; set = map.keySet(); for (String key : set) &#123; Person value = map.get(key); System.out.println(key+\"--&gt;\"+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 1.8 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 12345678910111213141516171819202122232425262728package com.itheima.demo03.Map;import java.util.HashMap;import java.util.LinkedHashMap;/* java.util.LinkedHashMap&lt;K,V&gt; entends HashMap&lt;K,V&gt; Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 底层原理: 哈希表+链表(记录元素的顺序) */public class Demo01LinkedHashMap &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"a\",\"a\"); map.put(\"c\",\"c\"); map.put(\"b\",\"b\"); map.put(\"a\",\"d\"); System.out.println(map);// key不允许重复,无序 &#123;a=d, b=b, c=c&#125; LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;(); linked.put(\"a\",\"a\"); linked.put(\"c\",\"c\"); linked.put(\"b\",\"b\"); linked.put(\"a\",\"d\"); System.out.println(linked);// key不允许重复,有序 &#123;a=d, c=c, b=b&#125; &#125;&#125; 结果: 12&#123;a&#x3D;d, b&#x3D;b, c&#x3D;c&#125;&#123;a&#x3D;d, c&#x3D;c, b&#x3D;b&#125; 1.9 HashTable实现一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用作键或值。 123456789101112131415161718192021222324252627282930package com.itheima.demo03.Map;import java.util.HashMap;import java.util.Hashtable;/* java.util.Hashtable&lt;K,V&gt;集合 implements Map&lt;K,V&gt;接口 Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢 HashMap:底层是一个哈希表,是一个线程不安全的集合,是多线程的集合,速度快 HashMap集合(之前学的所有的集合):可以存储null值,null键 Hashtable集合,不能存储null值,null键 Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了 Hashtable的子类Properties依然活跃在历史舞台 Properties集合是一个唯一和IO流相结合的集合 */public class Demo02Hashtable &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(null,\"a\"); map.put(\"b\",null); map.put(null,null); System.out.println(map);//&#123;null=null, b=null&#125; Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;(); //table.put(null,\"a\");//NullPointerException //table.put(\"b\",null);//NullPointerException table.put(null,null);//NullPointerException &#125;&#125; 1.10 Map集合练习需求： 计算一个字符串中每个字符出现次数。 分析： 获取一个字符串对象 创建一个Map集合，键代表字符，值代表次数。 遍历字符串得到每个字符。 判断Map中是否有该键。 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。 打印最终结果 代码： 1234567891011121314151617181920212223242526272829public class MapTest &#123;public static void main(String[] args) &#123; //友情提示 System.out.println(\"请录入一个字符串:\"); String line = new Scanner(System.in).nextLine(); // 定义 每个字符出现次数的方法 findChar(line); &#125; private static void findChar(String line) &#123; //1:创建一个集合 存储 字符 以及其出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); //2:遍历字符串 for (int i = 0; i &lt; line.length(); i++) &#123; char c = line.charAt(i); //判断 该字符 是否在键集中 if (!map.containsKey(c)) &#123;//说明这个字符没有出现过 //那就是第一次 map.put(c, 1); &#125; else &#123; //先获取之前的次数 Integer count = map.get(c); //count++; //再次存入 更新 map.put(c, ++count); &#125; &#125; System.out.println(map); &#125;&#125; 第二章 补充知识点2.1 JDK9对集合添加的优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。 123456789public class Demo01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); list.add(\"def\"); list.add(\"ghi\"); System.out.println(list); &#125;&#125; Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 例子： 1234567891011public class HelloJDK9 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str1=Set.of(\"a\",\"b\",\"c\"); //str1.add(\"c\");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of(\"a\",1,\"b\",2); System.out.println(str2); List&lt;String&gt; str3=List.of(\"a\",\"b\"); System.out.println(str3); &#125; &#125; 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待； 2:返回的集合是不可变的； 2.2 Debug追踪使用IDEA的断点调试功能，查看程序的运行过程 12345678910111213141516171819202122232425262728293031323334353637/* Debug调试程序: 可以让代码逐行执行,查看代码执行的过程,调试程序中出现的bug 使用方式: 在行号的右边,鼠标左键单击,添加断点(每个方法的第一行,哪里有bug添加到哪里) 右键,选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序: f8:逐行执行程序 f7:进入到方法中 shift+f8:跳出方法 f9:跳到下一个断点,如果没有下一个断点,那么就结束程序 ctrl+f2:退出debug模式,停止程序 Console:切换到控制台 */public class Demo01Debug &#123; public static void main(String[] args) &#123; /*int a = 10; int b = 20; int sum = a + b; System.out.println(sum);*/ /*for (int i = 0; i &lt;3 ; i++) &#123; System.out.println(i); &#125;*/ print(); &#125; private static void print() &#123; System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); System.out.println(\"HelloWorld\"); &#125;&#125; 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示 第三章 模拟斗地主洗牌发牌3.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3 3.2 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 3.3 实现代码步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class Poker &#123; public static void main(String[] args) &#123; /* * 1组装54张扑克牌 */ // 1.1 创建Map集合存储 HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;(); // 1.2 创建 花色集合 与 数字集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); // 1.3 存储 花色 与数字 Collections.addAll(colors, \"♦\", \"♣\", \"♥\", \"♠\"); Collections.addAll(numbers, \"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); // 设置 存储编号变量 int count = 1; pokerMap.put(count++, \"大王\"); pokerMap.put(count++, \"小王\"); // 1.4 创建牌 存储到map集合中 for (String number : numbers) &#123; for (String color : colors) &#123; String card = color + number; pokerMap.put(count++, card); &#125; &#125; /* * 2 将54张牌顺序打乱 */ // 取出编号 集合 Set&lt;Integer&gt; numberSet = pokerMap.keySet(); // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中 ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;(); numberList.addAll(numberSet); // 打乱顺序 Collections.shuffle(numberList); // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌 // 3.1 发牌的编号 // 创建三个玩家编号集合 和一个 底牌编号集合 ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;(); // 3.2发牌的编号 for (int i = 0; i &lt; numberList.size(); i++) &#123; // 获取该编号 Integer no = numberList.get(i); // 发牌 // 留出底牌 if (i &gt;= 51) &#123; dipaiNo.add(no); &#125; else &#123; if (i % 3 == 0) &#123; noP1.add(no); &#125; else if (i % 3 == 1) &#123; noP2.add(no); &#125; else &#123; noP3.add(no); &#125; &#125; &#125; // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌 // 4.1 对手中编号进行排序 Collections.sort(noP1); Collections.sort(noP2); Collections.sort(noP3); Collections.sort(dipaiNo); // 4.2 进行牌面的转换 // 创建三个玩家牌面集合 以及底牌牌面集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); // 4.3转换 for (Integer i : noP1) &#123; // 4.4 根据编号找到 牌面 pokerMap String card = pokerMap.get(i); // 添加到对应的 牌面集合中 player1.add(card); &#125; for (Integer i : noP2) &#123; String card = pokerMap.get(i); player2.add(card); &#125; for (Integer i : noP3) &#123; String card = pokerMap.get(i); player3.add(card); &#125; for (Integer i : dipaiNo) &#123; String card = pokerMap.get(i); dipai.add(card); &#125; //4.5 查看 System.out.println(\"令狐冲：\"+player1); System.out.println(\"石破天：\"+player2); System.out.println(\"鸠摩智：\"+player3); System.out.println(\"底牌：\"+dipai); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;/* 斗地主综合案例:有序版本 1.准备牌 2.洗牌 3.发牌 4.排序 5.看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1.准备牌 //创建一个Map集合,存储牌的索引和组装好的牌 HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;(); //创建一个List集合,存储牌的索引 ArrayList&lt;Integer&gt; pokerIndex = new ArrayList&lt;&gt;(); //定义两个集合,存储花色和牌的序号 List&lt;String&gt; colors = List.of(\"♠\", \"♥\", \"♣\", \"♦\"); List&lt;String&gt; numbers = List.of(\"2\", \"A\", \"K\", \"Q\", \"J\", \"10\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\"); //把大王和小王存储到集合中 //定义一个牌的索引 int index = 0; poker.put(index,\"大王\"); pokerIndex.add(index); index++; poker.put(index,\"小王\"); pokerIndex.add(index); index++; //循环嵌套遍历两个集合,组装52张牌,存储到集合中 for (String number : numbers) &#123; for (String color : colors) &#123; poker.put(index,color+number); pokerIndex.add(index); index++; &#125; &#125; //System.out.println(poker); //System.out.println(pokerIndex); /* 2.洗牌 使用Collections中的方法shuffle(List) */ Collections.shuffle(pokerIndex); //System.out.println(pokerIndex); /* 3.发牌 */ //定义4个集合,存储玩家牌的索引,和底牌的索引 ArrayList&lt;Integer&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; diPai = new ArrayList&lt;&gt;(); //遍历存储牌索引的List集合,获取每一个牌的索引 for (int i = 0; i &lt;pokerIndex.size() ; i++) &#123; Integer in = pokerIndex.get(i); //先判断底牌 if(i&gt;=51)&#123; //给底牌发牌 diPai.add(in); &#125;else if(i%3==0)&#123; //给玩家1发牌 player01.add(in); &#125;else if(i%3==1)&#123; //给玩家2发牌 player02.add(in); &#125;else if(i%3==2)&#123; //给玩家3发牌 player03.add(in); &#125; &#125; /* 4.排序 使用Collections中的方法sort(List) 默认是升序排序 */ Collections.sort(player01); Collections.sort(player02); Collections.sort(player03); Collections.sort(diPai); /* 5.看牌 调用看牌的方法 */ lookPoker(\"刘德华\",poker,player01); lookPoker(\"周润发\",poker,player02); lookPoker(\"周星驰\",poker,player03); lookPoker(\"底牌\",poker,diPai); &#125; /* 定义一个看牌的方法,提高代码的复用性 参数: String name:玩家名称 HashMap&lt;Integer,String&gt; poker:存储牌的poker集合 ArrayList&lt;Integer&gt; list:存储玩家和底牌的List集合 查表法: 遍历玩家或者底牌集合,获取牌的索引 使用牌的索引,去Map集合中,找到对应的牌 */ public static void lookPoker(String name,HashMap&lt;Integer,String&gt; poker,ArrayList&lt;Integer&gt; list)&#123; //输出玩家名称,不换行 System.out.print(name+\":\"); //遍历玩家或者底牌集合,获取牌的索引 for (Integer key : list) &#123; //使用牌的索引,去Map集合中,找到对应的牌 String value = poker.get(key); System.out.print(value+\" \"); &#125; System.out.println();//打印完每一个玩家的牌,换行 &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"集合","slug":"Collections","date":"2020-07-14T08:49:51.000Z","updated":"2020-07-16T01:48:32.094Z","comments":true,"path":"2020/07/14/Collections/","link":"","permalink":"http://zenner006.github.io/2020/07/14/Collections/","excerpt":"第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。","text":"第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add(\"小李广\"); coll.add(\"扫地僧\"); coll.add(\"石破天\"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\")); //boolean remove(E e) 删除在集合中的o元素 System.out.println(\"删除石破天：\"+coll.remove(\"石破天\")); System.out.println(\"操作之后集合中元素:\"+coll); // size() 集合中有几个元素 System.out.println(\"集合中有\"+coll.size()+\"个元素\"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println(\"集合中内容为：\"+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 数据结构3.1 数据结构有什么用？当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。 现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。 我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。 3.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下： 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 第四章 List集合我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（java.util.List集合、java.util.Set集合）。 4.1 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下： List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。 4.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧： 12345678910111213141516171819202122232425262728293031323334353637383940public class ListDemo &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(\"图图\"); list.add(\"小美\"); list.add(\"不高兴\");x System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,\"没头脑\"); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(\"删除索引位置为2的元素\"); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, \"三毛\"); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 第五章 List的子类5.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 通过查看源码就发现每次增删用ArrayList都会在系统底层复制一遍再增删。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 5.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素 相当于removeFirst public void push(E e):将元素推入此列表所表示的堆栈 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 12345678910111213141516171819202122public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); //添加元素 link.addFirst(\"abc1\"); link.addFirst(\"abc2\"); link.addFirst(\"abc3\"); System.out.println(link); // 获取元素 System.out.println(link.getFirst()); System.out.println(link.getLast()); // 删除元素 System.out.println(link.removeFirst()); System.out.println(link.removeLast()); while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素 &#125; System.out.println(link); &#125;&#125; 5.3 Vector 集合jdk1.1时期的；它是同步的，速度比ArrayList要慢。因为它更早，早于迭代器出现的时间，所以早期它迭代用的是把元素转成枚举类型再进行迭代，Elements方法； 第六章 Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 6.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 1234567891011121314151617181920212223public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(\"cba\")); set.add(\"abc\"); set.add(\"bac\"); set.add(\"cba\"); //遍历 for (String name : set) &#123; System.out.println(name); &#125; // while System.out.println(\"-------------------------\") Iterator&lt;Integer&gt; it = set.iterator(); while (it.hasNext())&#123; Interge n = it.next(); System.out.println(n) // 1,2,3 &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 123cbaabcbac tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。 6.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 12345678910111213package com.zenner.Demo;public class Person extends Object &#123; &#125;// 改写的Person类 public class Person extends Object &#123; // 重写hashcode @Override public int hashCode() &#123; return 1; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.zenner.Demo;public class Demo01 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); int h1 = p1.hashCode(); System.out.println(h1); //189568618 Person p2 = new Person(); int h2 = p2.hashCode(); System.out.println(h2); //793589513 /* toString方法的源码 return getclass().getName() + \"@\" + Integer.toHexString(hashcode()) */ System.out.println(p1); // com.zenner.Demo.Person@b4c966a (189568618 的十六进制) //com.zenner.Demo.Person@1 System.out.println(p2); // com.zenner.Demo.Person@2f4d3709 //com.zenner.Demo.Person@1 /* 字符串哈希值 */ String s1 = new String(\"abc\"); String s2 = new String(\"abc\"); System.out.println(s1.hashCode()); // 96354 System.out.println(s2.hashCode()); // 96354 &#125;&#125;/*189568618793589513com.zenner.Demo.Person@b4c966acom.zenner.Demo.Person@2f4d3709 */ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 6.3 HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 ：ALt+insert选hashcode and equals可自动生成类的比较这两个 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] 6.3 LinkedHashSet （有序，不允许重复的结构）我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 6.9 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。… 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 1234567891011121314151617181920212223242526272829303132public class ChangeArgs &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 4, 62, 431, 2 &#125;; int sum = getSum(arr); System.out.println(sum); // 6 7 2 12 2121 // 求 这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); &#125; /* * 完成数组 所有元素的求和 原始写法 public static int getSum(int[] arr)&#123; int sum = 0; for(int a : arr)&#123; sum += a; &#125; return sum; &#125; */ //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 第七章 集合7.1 常用功能 java.utils.集合是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819public class 集合Demo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 集合.addAll(list, 5, 222, 1，2); System.out.println(list); //排序方法 集合.sort(list); System.out.println(list); &#125;&#125;结果：[5, 222, 1, 2][1, 2, 5, 222] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 7.2 Comparator比较器我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 123456789101112public class 集合Demo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 集合.sort(list); System.out.println(list); &#125;&#125; 结果： 1[aba, cba, nba, sba] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567891011121314151617public class 集合Demo3 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"cba\"); list.add(\"aba\"); list.add(\"sba\"); list.add(\"nba\"); //排序方法 按照第一个单词的降序 集合.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0) - o1.charAt(0); &#125; &#125;); System.out.println(list); &#125;&#125; 结果如下： 1[sba, nba, cba, aba] 7.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过集合.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如集合.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 7.4 练习：使用Comparable比较自定义对象创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233343536public class Student&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(\"rose\",18)); list.add(new Student(\"jack\",16)); list.add(new Student(\"abc\",16)); list.add(new Student(\"ace\",17)); list.add(new Student(\"mark\",16)); /* 让学生 按照年龄排序 升序 */// 集合.sort(list);//要求 该list中元素类型 必须实现比较器Comparable接口 for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 发现，当我们调用集合.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 1234567public class Student implements Comparable&lt;Student&gt;&#123; .... @Override public int compareTo(Student o) &#123; return this.age-o.age;//升序 &#125;&#125; 再次测试，代码就OK 了效果如下： 12345Student&#123;name='jack', age=16&#125;Student&#123;name='abc', age=16&#125;Student&#123;name='mark', age=16&#125;Student&#123;name='ace', age=17&#125;Student&#123;name='rose', age=18&#125; 2.5 扩展：用Comparator增加一种临时的比较机制如果在使用的时候，想要独立的定义规则去使用 可以采用集合.sort(List list,Comparetor c)方式，自己定义规则： 123456集合.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o2.getAge()-o1.getAge();//以学生的年龄降序 &#125;&#125;); 效果： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125; 如果想要规则更多一些，可以参考下面代码： 12345678910111213集合.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄降序 int result = o2.getAge()-o1.getAge();//年龄降序 if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;); 效果如下： 12345Student&#123;name&#x3D;&#39;rose&#39;, age&#x3D;18&#125;Student&#123;name&#x3D;&#39;ace&#39;, age&#x3D;17&#125;Student&#123;name&#x3D;&#39;abc&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;jack&#39;, age&#x3D;16&#125;Student&#123;name&#x3D;&#39;mark&#39;, age&#x3D;16&#125; 第八章 集合工具类8.1 Stack栈操作Java里面使用Stack来描述栈的操作，这个类定义如下： 1public class Stack&lt;E&gt; extends Vector&lt;E&gt; 可以发现Stack是Vector的子类，但它使用的并不是Vector提供的方法； public E push(E item)：入栈 public E pop()： 出栈 12345678910111213141516package com.itheima.demo07.Utils;import java.util.Stack;public class Demo01Stack &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; all = new Stack&lt;String&gt;(); all.push(\"A\"); all.push(\"B\"); all.push(\"C\"); System.out.println(all.pop()); // C System.out.println(all.pop()); // B System.out.println(all.pop()); // A System.out.println(all.pop()); // 无数据。EmptyStackException &#125;&#125; 8.2 Queue队列 如果将队列应用在多线程的“生产者与消费者”的模型处理上，那么对于生产者过快的情况下，就没有必要等待消费者获取数据了。可以将所有的数据先保存在队列当中。 队列的实现可以用LinkedList子类来完成。 public boolean offer(E e)： 向队列之中追加数据，也可以直接使用add方法 public E poll()： 弹出队头并删除 1234567891011121314151617package com.itheima.demo07.Utils;import java.util.LinkedList;import java.util.Queue;public class Demo02Queue &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(\"X\"); queue.offer(\"A\"); queue.offer(\"Z\"); System.out.println(queue.poll()); // X System.out.println(queue.poll()); // A System.out.println(queue.poll()); // Z System.out.println(queue.poll()); // null &#125;&#125; 除了LinkedList子类之外，还有一个优先级队列的概念，可以使用 PriorityQueue 12345678910111213141516package com.itheima.demo07.Utils;import java.util.PriorityQueue;import java.util.Queue;public class Demo02Queue &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new PriorityQueue&lt;String&gt;(); queue.offer(\"X\"); queue.offer(\"A\"); queue.offer(\"Z\"); System.out.println(queue.poll()); // A System.out.println(queue.poll()); // X System.out.println(queue.poll()); // Z System.out.println(queue.poll()); // null &#125;&#125; 8.3 Properties属性操作1public class Properties extends Hashtable&lt;Object,​Object&gt; Properties只能操作的类型是String类型，在Properties之中如果想要实现属性的操作可以采用如下的方法来实现。 public String getProperty(String key) : 取得属性 public Object setProperty(String key, String value) : 设置属性 public String getProperty(String key,String defaultValue) : 取得属性，不存在返回默认值 public void store(OutputStream out, String comments) throws IOException ： 存储属性内容 public void load(InputStream inStream) throws IOException ： 通过输入流读取属性 12345678910111213package com.itheima.demo07.Utils;import java.util.Properties;public class Demo03Properties &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); prop.setProperty(\"zenner\",\"zenner006.github.io\"); prop.setProperty(\"巨饼\",\"9.9毛钱\"); System.out.println(prop.getProperty(\"zenner\")); // zenner006.github.io System.out.println(prop.getProperty(\"sina\",\"NoFound\")); // NoFound &#125;&#125; 这个类只能操作字符串，而Map则能操作的就很多。但是Properties可以通过输出输入流处理属性。 123456789101112131415161718package com.itheima.demo07.Utils;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Properties;public class Demo04PropertiesToFile &#123; public static void main(String[] args) throws IOException &#123; // Properties类与文件操作 Properties prop = new Properties(); prop.setProperty(\"zenner\",\"zenner006.github.io\"); prop.setProperty(\"巨饼\",\"9.9毛钱\"); prop.store(new FileOutputStream(new File(\"./info.properties\")), \"Something all is well\"); &#125;&#125; 1234#Something all is well#Wed Jul 15 11:29:16 CST 2020zenner=zenner006.github.io\\u5DE8\\u997C=9.9\\u6BDB\\u94B1 1234567891011121314package com.itheima.demo07.Utils;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;public class Demo05PropertiesLoadFile &#123; public static void main(String[] args) throws IOException &#123; Properties prop = new Properties(); prop.load(new FileInputStream(new File(\"./info.properties\"))); System.out.println(prop.getProperty(\"zenner\")); &#125;&#125; 8.4 Collections 工具类（注意不是Collection）Collections是java提供的一组集合数据的操作工具类，也就是说利用它可以实现各个集合的操作。 1234567891011121314151617181920212223242526package com.itheima.demo07.Utils;import java.sql.SQLOutput;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Demo06Collections &#123; public static void main(String[] args) &#123; // Collections处理list集合 List&lt;String&gt; all = new ArrayList&lt;String&gt;(); Collections.addAll(all,\"Hello\",\"world\",\"today\"); System.out.println(all); //[Hello, world, today] // 实现数据反转 Collections.reverse(all); System.out.println(all); // [today, world, Hello] // 二分查找 System.out.println(Collections.binarySearch(all, \"R\")); // -1 System.out.println(Collections.binarySearch(all, \"Hello\")); // -1 不排序返回-1 Collections.sort(all); System.out.println(all); // [Hello, today, world] System.out.println(Collections.binarySearch(all, \"Hello\")); // 0 排序后 &#125;&#125; Collection是集合接口，允许保存单值对象 Collections是集合操作的工具类。","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"集合","slug":"java/java高级编程/集合","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E9%9B%86%E5%90%88/"}],"tags":[]},{"title":"leetcode","slug":"leetcode","date":"2020-06-11T12:22:50.000Z","updated":"2020-10-07T09:20:41.501Z","comments":true,"path":"2020/06/11/leetcode/","link":"","permalink":"http://zenner006.github.io/2020/06/11/leetcode/","excerpt":"leetcode标签（空格分隔）： 2020 编程 [TOC]","text":"leetcode标签（空格分隔）： 2020 编程 [TOC] 2. 两数相加 (中等）给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: L = ListNode(-1) i = L if not l1:return l2 if not l2:return l1 n = 0 while l1 and l2: a = l1.val +l2.val + n m = a%10 n = a//10 i.next = ListNode(m) i = i.next l1 = l1.next l2 = l2.next B = l1 if not l2 else l2 while B: a = B.val + n m = a%10 n = a//10 i.next = ListNode(m) i = i.next B = B.next if n != 0: i.next = ListNode(n) return L.next 一个修正了的答案 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: L = ListNode(-1) i = L if not l1:return l2 if not l2:return l1 n = 0 while l1 or l2: x = l1.val if l1 else 0 y = l2.val if l2 else 0 a = x + y + n m = a%10 n = a//10 i.next = ListNode(m) i = i.next if l1:l1 = l1.next if l2:l2 = l2.next if n != 0: i.next = ListNode(n) return L.next 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 # 我的这个答案的结果很差，勉强能通过 class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s: return 0 dp = [1]*len(s) for i in range(len(s)): for j in range(i+1,len(s)): if s[j] not in s[i:j]: dp[i] += 1 else: break return max(dp) 看了一下答案，这个题目是可以学习滑动窗口的！ 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 1234567891011121314151617181920212223242526272829303132333435363738def longestPalindrome(self, s: str) -&gt; str: # 走一个滑动窗口，长度为2（两种相同的字符）或者3（第一个和第三个相同） # 需要记录最长回文子串的变量t # 最长自串长度用len(t)得到 if not s: return s e = len(s) r1,r2 = 1,2 t = s[0] for l in range(len(s)): print(\"l:\"+str(l)+\" r1:\"+str(r1)+\" r2:\"+str(r2)) if r2&lt;e and s[l] == s[r2]: i,j = l,r2 while i&gt;=0 and j&lt;len(s): if i-1&lt;0 or j+1==e or s[i-1] != s[j+1]: if len(t) &lt; j-i+1: t = s[i:j+1] print(i) print(j) break else: i -= 1 j += 1 if r1&lt;e and s[l] == s[r1]: i,j = l,r1 while i&gt;=0 and j&lt;len(s): if i-1&lt;0 or j+1==e or s[i-1] != s[j+1]: if len(t) &lt; j-i+1: t = s[i:j+1] print(i) print(j) break else: i -= 1 j += 1 r1+=1 r2+=1 return t 6. Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N def convert(self, s: str, numRows: int) -&gt; str: if not s or numRows&lt;2: return s size = len(s) Lines = [[] for _ in range(numRows)] p = 0 d = 1 for i in s: print(p) Lines[p].append(i) if p == numRows - 1: d = -1 if p == 0: d = 1 p += d T = &quot;&quot; for i in Lines: T += &quot;&quot;.join(i) return T 7. 整数翻转# 用字符串反转达成 # python3 class Solution: def reverse(self, x: int) -&gt; int: f = True if x &lt; 0 : f = False y = str(abs(x)) y = list(y) y = y[::-1] z = 0 for i in y: z = 10*z + int(i) if z &gt; pow(2,31)-1 or z &lt; -pow(2,31): return 0 else: if not f: z = -z return z 8. 字符串转换整数 (atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 def myAtoi(self, str: str) -&gt; int: p = True N = 0 str = str.strip() if not str: return 0 if str[0] == &quot;+&quot; or str[0] == &quot;-&quot; or ord(str[0]) &gt;= 48 and ord(str[0]) &lt;= 57: if str[0] == &quot;+&quot;: p = True str = str[1:] elif str[0] == &quot;-&quot;: p = False str = str[1:] if not str: return 0 i = 0 t = ord(str[0]) while t &gt;= 48 and t &lt;= 57: N = N * 10 + (t - 48) i += 1 if i &lt; len(str): t = ord(str[i]) else: break if not p: N = -N if N &lt; -2147483648: return -2147483648 if N &gt; 2147483647: return 2147483647 return N else: return 0 9. 回文数# 字符串解法 # python3 class Solution: def isPalindrome(self, x: int) -&gt; bool: y = str(x) y = list(y) l = len(y) for i in range(l): if y[i] != y[l-1-i]: return False return True 11. 盛最多水的容器给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 # 双指针法 class Solution: def maxArea(self, height: List[int]) -&gt; int: l,r = 0,len(height)-1 Max = 0 while l &lt; r: if (r-l)*min(height[l],height[r]) &gt; Max: Max = (r-l)*min(height[l],height[r]) if height[l] &lt; height[r]: l += 1 else: r -= 1 return Max 12. 整数转罗马数字def intToRoman(self, num: int) -&gt; str: Roman_char = {1000:&quot;M&quot;,900:&quot;CM&quot;, 500:&quot;D&quot;, 400:&quot;CD&quot;, 100:&quot;C&quot;, 90:&quot;XC&quot;, 50:&quot;L&quot;, 40:&quot;XL&quot;, 10:&quot;X&quot;, 9:&quot;IX&quot;, 5:&quot;V&quot;, 4:&quot;IV&quot;, 1:&quot;I&quot;} L = &quot;&quot; for i in Roman_char: L += Roman_char[i]*(num // i) num = num - (num // i)*i return L 13. 罗马数字转整数# 在编译器帮助下运行通过的 # python3 class Solution: def romanToInt(self, s: str) -&gt; int: roman = {&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000, &#39;IV&#39;:4,&#39;IX&#39;:9,&#39;XL&#39;:40,&#39;XC&#39;:90,&#39;CD&#39;:400,&#39;CM&#39;:900} right = False num = 0 if len(s) == 1: num += roman[s] else: for i in range(len(s)-1): if right: right = False continue if roman[s[i]] &lt; roman[s[i+1]]: right = True num += roman[s[i]+s[i+1]] else: num += roman[s[i]] if not right: num += roman[s[i+1]] return num 14. 最长公共前缀# python3 class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: s = &#39;&#39; l = len(strs) if l==0: return s mi = min([len(i) for i in strs]) for i in range(mi): a = strs[0][i] b = True for j in range(1,l): if a != strs[j][i]: b = False break if b: s = s + a else: break return s 1234567891011121314151617181920def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return \"\" res = \"\" length = len(strs[0]) for item in strs: if len(item) &lt; length: length = len(item) i = 0 while i &lt; length: flag = False cur_char = strs[0][i] for item in strs: if item[i] != cur_char: flag = True if flag: break res += cur_char i += 1 return res 12345678910111213141516171819def longestCommonPrefix(self, strs: List[str]) -&gt; str: N = len(strs) if N &gt; 2: mid = N//2 str1 = self.longestCommonPrefix(strs[0:mid]) str2 = self.longestCommonPrefix(strs[mid:]) return self.longestCommonPrefix([str1,str2]) elif N == 2: min_length = len(strs[0]) if len(strs[0]) &lt;= len(strs[1]) else len(strs[1]) res = \"\" for i in range(min_length): if strs[0][i] != strs[1][i]: return res res += strs[0][i] return res elif N == 1: return strs[0] elif N == 0: return \"\" 17. 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 def letterCombinations(self, digits: str) -&gt; List[str]: hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;], &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;], &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]} temp_list = [] last_list = [] for n in digits: if not last_list: last_list = hash_table[n] continue for key in hash_table[n]: for i in range(len(last_list)): temp_list.append(last_list[i]+key) last_list = temp_list temp_list = [] return last_list def letterCombinations(self, digits: str) -&gt; List[str]: # 回溯法 hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;], &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;], &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]} L = [] length = len(digits) print(length) if length &lt; 1: return L def helper(n,temp_s): if n == length: L.append(temp_s) else: c = digits[n] chars = hash_table[c] for item in chars: helper(n+1,temp_s + item) s = &quot;&quot; helper(0,s) return L 19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: L = ListNode(-1) L.next = head p = head i = 0 while p: i += 1 p = p.next print(i) p = L for _ in range(i-n): p = p.next print(p.val) p.next = p.next.next return L.next 20. 有效的括号# python3 class Solution: def isValid(self, s: str) -&gt; bool: bracket = {&#39;(&#39;:1,&#39;)&#39;:2,&#39;[&#39;:4,&#39;]&#39;:5,&#39;{&#39;:7,&#39;}&#39;:8} stack = [] for i in s: if stack: if bracket[stack[-1]]+1 == bracket[i]: stack.pop() else: stack.append(i) else: stack.append(i) if stack: return False else: return True 21. 合并两个有序链表将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: L = ListNode(-1) p = L while l1 and l2: l3 = None if l1.val &gt; l2.val: l3 = l2 l2 = l2.next else: l3 = l1 l1 = l1.next p.next = l3 p = p.next if 1: p.next = l1 else: p.next = l2 return L.next 23. 合并K个排序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return None L = ListNode(-1) x = L cur_min = None while len(lists) &gt; 1: n = len(lists) if lists[0] != None: cur_min = lists[0] else: lists.pop(0) continue # print(&quot;cur_min: &quot;+str(cur_min.val)) # 找到最小的值 t = 0 for i in range(n): if lists[i] == None: continue if lists[i].val &lt; cur_min.val: cur_min = lists[i] t = i if lists[t].next != None: lists[t] = lists[t].next else: lists.pop(t) cur_min.next = None x.next = cur_min x = x.next x.next = lists[0] return L.next 25. K 个一组翻转链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: if not head: return head res = ListNode(-1) res.next = head def revereKnode(k,L): # 不足k个，直接返回 t = L # 用t来表示结尾 for _ in range(k): if t.next == None: return L.next, None t= t.next # 足够k个进行翻转 d = L.next # d表示正序列上的末尾节点 u = L.next while u != t: u = d.next d.next = u.next u.next = L.next L.next = u return L.next,d R = res E = res while E: R = E R.next,E = revereKnode(k,R) return res.next ​ 26. 删除排序数组中的重复项# python3 class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if nums: a = nums[0] for i in nums[1:]: if i == a: nums.remove(i) else: a = i return len(nums) else: return 0 28.实现strStr()# python3 class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if needle: if needle not in haystack: return -1 else: return haystack.index(needle) else: return 0 # 这个题目水很深需要再多再看看KMP算法之流多翻一翻 31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 def nextPermutation(self, nums: List[int]) -&gt; None: n = len(nums) if n == 0: return None for i in range(-1,-n,-1): if nums[i-1] &lt; nums[i]: t = 0 j = -1 # 找到下一个值,把它与i-1位置的元素交换 while j &gt; i-1: if nums[j] &gt; nums[i-1]: nums[i-1],nums[j] = nums[j],nums[i-1] break j -= 1 # i-1 后面一定是逆序的 L = i R = -1 while L&lt;R: nums[L], nums[R] = nums[R],nums[L] L += 1 R -= 1 return None nums.sort() return None 34. 在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 def searchRange(self, nums: List[int], target: int) -&gt; List[int]: res = [] n = len(nums) p = False for i in range(n): if not p and nums[i] == target: res.append(i) p = True if p and (i+1 == n or nums[i+1] != target): res.append(i) p = False if not res: return [-1,-1] return res def searchRange(self, nums: List[int], target: int) -&gt; List[int]: res = [] n = len(nums) for i in range(n): if nums[i] == target: res.append(i) if not res: return [-1,-1] return [res[0],res[-1]] def searchRange(self, nums, target): for i in range(len(nums)): if nums[i] == target: left_idx = i break else: return [-1, -1] for j in range(len(nums)-1, -1, -1): if nums[j] == target: right_idx = j break return [left_idx, right_idx] 35. 搜索插入位置# python3 自己写的 class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: if target not in nums: for i in range(len(nums)): if target &lt;= nums[i]: nums.insert(i,target) return i nums.append(target) return len(nums)-1 else: return nums.index(target) 36. 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 def isValidSudoku(self, board: List[List[str]]) -&gt; bool: # 三重判定 # 判定行 for L in board: temp = [] for i in L: if i != &quot;.&quot;: temp.append(i) if len(temp) != len(set(temp)): return False print(&quot;行OK&quot;) # 判定列 for j in range(9): temp = [] for i in range(9): if board[i][j] != &quot;.&quot;: temp.append(board[i][j]) if len(temp) != len(set(temp)): return False print(&quot;列OK&quot;) # 判定方格 for x in range(0,9,3): for y in range(0,9,3): print((x,y)) temp = [] for i in range(3): for j in range(3): if board[x+i][y+j] != &quot;.&quot;: temp.append(board[x+i][y+j]) print(temp) if len(temp) != len(set(temp)): return False return True def isValidSudoku(self, board: List[List[str]]) -&gt; bool: # 只遍历一次的答案 Row = [{} for _ in range(9)] Col = [{} for _ in range(9)] Square = [{} for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] != &quot;.&quot;: if board[i][j] not in Row[i]: Row[i][board[i][j]] = 1 else: return False if board[i][j] not in Col[j]: Col[j][board[i][j]] = 1 else: return False local = (i//3)*3 + j //3 if board[i][j] not in Square[local]: Square[local][board[i][j]] = 1 else: return False return True 38. 报数# python3自己解决 class Solution: def countAndSay(self, n: int) -&gt; str: s = &quot;1&quot; for j in range(n-1): a = s[0] x = 1 re = &quot;&quot; for i in s[1:]: if i == a: x = x + 1 else: re = re + str(x) + str(a) a = i x = 1 s = re + str(x) + str(a) return s ​ l3 = [] while l1 and l2: if l1[0] &gt;= l2[0]: l3.append(l2.pop(0)) elif l1[0] &lt; l2[0]: l3.append(l1[0].pop(0)) return l3 39. 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: candidates.sort() def help(candidates,target,temp_list): print(temp_list) if target &gt;= candidates[0]: i = 0 while i &lt; len(candidates) and candidates[i] &lt;= target: if target == candidates[i]: print(&quot;yeap!!&quot;) temp = temp_list.copy() temp.append(target) print(temp) res.append(temp) temp = temp_list.copy() temp.append(candidates[i]) help(candidates[i:],target-candidates[i],temp) i += 1 res = [] temp = [] help(candidates,target,temp) return res 43. 字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 def multiply(self, num1: str, num2: str) -&gt; str: if num1 == &#39;0&#39; or num2 == &#39;0&#39;: return &quot;0&quot; n1 = len(num1) n2 = len(num2) digits = [0]*(n1+n2) for i in range(n1-1, -1, -1): for j in range(n2-1, -1, -1): prod = (ord(num1[i])-ord(&#39;0&#39;))*(ord(num2[j])-ord(&#39;0&#39;)) sum_ = 0 sum_ = prod + digits[i+j+1] digits[i+j] += sum_ //10 digits[i+j+1] = sum_ %10 # for i in range(n1 + n2 - 1, 0, -1): # carry = digits[i] // 10 # digits[i] = digits[i] % 10 # digits[i - 1] += carry return &#39;&#39;.join([str(i) for i in digits]).lstrip(&#39;0&#39;) 47. 全排列 II给定一个可包含重复数字的序列，返回所有不重复的全排列。 class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: res = [] if not nums: return res nums.sort() N = len(nums) def helper(start,temp,unused): if start == N: print(str(start)+ &quot; &quot;+str(temp)+&quot; &quot;+str(unused)) res.append(temp[:]) i = 0 while i &lt; len(unused): if i &gt; 0 and unused[i] == unused[i-1]: i += 1 continue temp.append(unused[i]) a = unused.pop(i) helper(start+1,temp,unused) temp.pop() unused.insert(i,a) i += 1 helper(0,[],nums) return res 48. 旋转图像给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; N = len(matrix) # 矩阵行列数 C = N //2 # 旋转层数 for t in range(C): print(t) for i in range(0,N-t*2-1): a = matrix[t][t+i] # 左上角 matrix[t][t+i] = matrix[N-t-1-i][t] # 左下角 matrix[N-t-1-i][t] = matrix[N-t-1][N-t-1-i] # 右下角 matrix[N-t-1][N-t-1-i] = matrix[t+i][N-t-1] # 右上角 matrix[t+i][N-t-1] = a # a = matrix[t+i,N-t-1] # 右上角 # matrix[t+i,N-t-1] = matrix[t][t+i] # 左上角 # b = matrix[N-t-1][N-t-1-i] # 右下角 # matrix[N-t-1][N-t-1-i] = a # a = matrix[N-t-1-i][t] # 左下角 # matrix[N-t-1-i][t] = b # matrix[t][t+i] = a 49. 字母异位词分组给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 from collections import defaultdict class Solution: def groupAnagrams(self, strs): ans = collections.defaultdict(list) for s in strs: ans[tuple(sorted(s))].append(s) return ans.values() class Solution: def groupAnagrams(self, strs): ans = {} for s in strs: if tuple(sorted(s)) in ans: ans[tuple(sorted(s))].append(s) else: ans[tuple(sorted(s))] = [s] return list(ans.values()) 53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）暴力法# 这道题不会做。 # 答案中有四种解法：暴力法，动态规划，贪心法，分治法； # 我都可以学！！！ # 2020年1月8日学会第一种暴力法！ # 这种暴力法超时了！！ class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: Max = nums[0] for i in range(len(nums)): Sum = 0 for j in range(i,len(nums)): Sum += nums[j] if Sum &gt; Max: Max = Sum return Max # 一个更为先进的暴力法，好吧，说好一起暴力呢，你怎么动起了脑子 class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: Sum = nums[0] Max = nums[0] for i in range(1,len(nums)): if Sum + nums[i] &gt; nums[i]: Sum = Sum + nums[i] else: Sum = nums[i] Max = max(Max,Sum) return Max # 20200109 动态规划（动态规划代码在上面第二段） 通常我们遍历子串或者子序列有三种遍历方式 以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。 根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。 以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。 而动态规划就是第三种方式，求出以某个节点结束节点的最大值。 分治法# 分治法 class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) #递归终止条件 if n == 1: return nums[0] else: #递归计算左半边最大子序和 max_left = self.maxSubArray(nums[0:len(nums) // 2]) #递归计算右半边最大子序和 max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)]) max_l = nums[len(nums)//2-1] tmp = 0 for i in range(len(nums)//2-1,-1,-1): tmp += nums[i] max_l = max(max_l, tmp) max_r = nums[len(nums)//2] tmp = 0 for i in range(len(nums)//2,len(nums)): tmp += nums[i] max_r = max(max_r, tmp) return max(max_left,max_right,max_l+max_r) 54. 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: res = [] if not matrix: return res m = len(matrix) n = len(matrix[0]) def next_item(i,j): # 这里可以用另一个矩阵来表示这个是否被换过了。 # 返回一个值，如果没返回则结束 # 如果上下左右都不能走则返回None结束 if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;): return None if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and not (j == n-1 or matrix[i][j+1]== &quot;*&quot;): return (i,j+1) if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (i == m-1 or matrix[i+1][j] == &quot;*&quot;): return (i+1,j) if (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (j == 0 or matrix[i][j-1]== &quot;*&quot;): return (i,j-1) if (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and not (i==0 or matrix[i-1][j] == &quot;*&quot;): return (i-1,j) t = (0,0) while t: i,j = t res.append(matrix[i][j]) matrix[i][j] = &quot;*&quot; t = next_item(i,j) return res 55. 跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 def canJump(self, nums: List[int]) -&gt; bool: # dp n = len(nums) dp = [False]*n for i in range(n-1,-1,-1): if i == n-1: dp[i] = True continue for j in range(i+1,min(i+nums[i]+1,n)): if dp[j] == True: dp[i] = True break print(dp) return dp[0] 61. 旋转链表给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if not head: return head temp = ListNode(-1) temp.next = head node_count = 0 point = temp while point.next: node_count+= 1 point = point.next if k&gt;node_count: k = k%node_count elif k == node_count: return head # 再走node_count - k 步 point = temp for _ in range(node_count-k): point = point.next t = point while t.next: t = t.next t.next = temp.next temp.next = point.next point.next = None return temp.next ​ 62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ def uniquePaths(self, m: int, n: int) -&gt; int: N = m + n -2 c = min(m,n)-1 res = 1 for i in range(1,c+1): res *= N res = res//i N = N-1 return res 63. 不同路径 II （动态规划，浅拷贝陷阱）一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: print(obstacleGrid) m = len(obstacleGrid) n = len(obstacleGrid[0]) print(m,n) dp = [[0]*n for _ in range(m)] # 不要用下面这样的浅拷贝 # dp = [[0]*n]*m # 这样赋值会把整个列赋值成一样值 # 放第一行，第一列： for i in range(m): if obstacleGrid[i][0] == 1: break dp[i][0] = 1 for j in range(n): if obstacleGrid[0][j] == 1: break dp[0][j] = 1 for i in range(1,m): for j in range(1,n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 continue dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 64. 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 def minPathSum(self, grid: List[List[int]]) -&gt; int: m = len(grid) n = len(grid[0]) dp = [[0]*n for _ in range(m)] for i in range(m): if i == 0: dp[0][0] = grid[0][0] continue dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1,n): dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1,m): for j in range(1,n): dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j] print(dp) return dp[-1][-1] ​ ​ 66. 加一这个题的第一印象就是把数组转成数字，加一后再转成数组； class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: Sum = 0 for i in digits: Sum = 10*Sum + i Sum =Sum + 1 D_list = [] while Sum: D_list.append(Sum%10) Sum = Sum//10 D_list.reverse() return D_list 这个结果速度还可以，但是内存消耗大 第二个想法就是在原数组上进行 class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: Up = False # 进位符 # 给最低位加一 if digits[-1] + 1 &gt; 9: digits[-1] = (digits[-1] + 1)%10 Up = True else: digits[-1] = digits[-1] + 1 # 给整个数字进位： for i in range(len(digits)-2,-1,-1): if Up: digits[i] = digits[i] + 1 if digits[i] &gt; 9: digits[i] = digits[i]%10 Up = True else: return digits # 多进位 if Up: digits.insert(0,1) Up = False return digits ​ 67. 二进制求和一个不用内置函数的解法 class Solution: def addBinary(self, a: str, b: str) -&gt; str: Up = False C = &quot;&quot; if len(a)&gt;len(b): b = (len(a)-len(b))*&quot;0&quot; + b else: a = (len(b)-len(a))*&quot;0&quot; + a for i in range(len(a)-1,-1,-1): z = int(a[i])+int(b[i]) if Up: z = z + 1 Up = False C = str(z%2) + C if z//2: Up = True if Up: C = &quot;1&quot; + C return C 题解里的一个答案：时间和空间都优于我写的 class Solution: def addBinary(self, a: str, b: str) -&gt; str: r, p = &#39;&#39;, 0 d = len(b) - len(a) a = &#39;0&#39; * d + a b = &#39;0&#39; * -d + b for i, j in zip(a[::-1], b[::-1]): s = int(i) + int(j) + p r = str(s % 2) + r p = s // 2 return &#39;1&#39; + r if p else r 用内置函数的解法 class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a,2)+int(b,2))[2:] 69. x的平方根我的答案： class Solution: def mySqrt(self, x: int) -&gt; int: start = 0 end = x while start + 1 != end: mid = (end-start)//2 + start if mid mid == x: return mid elif mid mid &gt; x: if (mid-1)(mid-1) &lt; x: return mid-1 end = mid elif mid mid &lt; x: if (mid+1)*(mid+1) &gt; x: return mid start = mid return end 71. 简化路径以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 def simplifyPath(self, path: str) -&gt; str: res = [] i = 0 while i&lt;len(path): if path[i] == &quot;/&quot;: i += 1 continue j = i while j &lt; len(path) and path[j] != &quot;/&quot;: j += 1 if j-i == 2 and path[i:j] == &quot;..&quot;: if res: res.pop() elif j-i == 1 and path[i:j] == &quot;.&quot;: pass else: res.append(path[i:j]) i = j res_S = &quot;/&quot; if res: res_S += &quot;/&quot;.join(res) return res_S 73. 矩阵置零给定一个 m x n 的矩阵，如果一个元素为0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 def setZeroes(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; res = [] m = len(matrix) n = len(matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] == 0: res.append((i,j)) for i,j in res: for t in range(n): matrix[i][t] = 0 for t in range(m): matrix[t][j] = 0 74. 搜索二维矩阵编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。 def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix or not matrix[0]: return False m = len(matrix) n = len(matrix[0]) for row in range(m): if target &gt;= matrix[row][0] and target &lt;= matrix[row][-1]: for col in range(n): if matrix[row][col] == target: return True return False return False 75. 颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 def sortColors(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; n = len(nums) l1 = 0 for i in range(n): if nums[i] == 0: nums.pop(i) nums.insert(0,0) l1 += 1 if nums[i] == 1: nums.pop(i) nums.insert(l1,1) 76. 最小覆盖子串给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 def minWindow(self, s: str, t: str) -&gt; str: t_table = defaultdict(int) for i in t: t_table[i] += 1 hash_table = defaultdict(list) left , right = 0,len(s) count = 0 flag = False for i in range(len(s)): if count &lt;len(t) and s[i] in t: if s[i] not in hash_table or len(hash_table[s[i]])&lt;t_table[s[i]]: count += 1 hash_table[s[i]].append(i) else: hash_table[s[i]].pop(0) hash_table[s[i]].append(i) if count == len(t): flag = True alp_left = min(hash_table, key = lambda k: hash_table[k][0]) alp_right = max(hash_table,key = lambda k: hash_table[k][-1]) if hash_table[alp_right][-1]-hash_table[alp_left][0] &lt; right-left: right, left = hash_table[alp_right][-1], hash_table[alp_left][0] if len(hash_table[alp_left]) &gt;1: hash_table[alp_left].pop(0) else: hash_table.pop(alp_left) count -= 1 if not flag: return &quot;&quot; return s[left:right+1] 77. 组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 def combine(self, n: int, k: int) -&gt; List[List[int]]: help_List = list(range(1,n+1)) def help(temp,help_List): l = len(temp) T = len(help_List) if l == k: res.append(temp) else: for i in range(T-k+1+l): help(temp + [help_List[i]],help_List[i+1:]) res = [] help([],help_List) return res # 第二种解法很厉害的！！ 94% def combine(self, n: int, k: int) -&gt; List[List[int]]: def help(temp): l = len(temp) T = n - temp[-1] if l != 0 else n if l == k: res.append(temp) else: for i in range(1,T-k+1+l+1): if temp: help(temp + [temp[-1]+i]) else: help([i]) res = [] help([]) return res 78. 子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] if not nums: return [[]] N = len(nums) def help(temp,remain): res.append(temp) for i in range(len(remain)): help(temp+[remain[i]],remain[i+1:]) help([],nums) return res 79. 单词搜索 (这道题是有点东西的)给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 def exist(self, board: List[List[str]], word: str) -&gt; bool: m = len(board) n = len(board[0]) # word = &quot;SEE&quot; def dfs(visited,word): l = len(visited) if l == len(word): return True x,y = visited[-1] dir_x = [-1,0,1,0] dir_y = [0,-1,0,1] for dx,dy in zip(dir_x,dir_y): if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and (x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[l] and dfs(visited+[(x+dx,y+dy)],word): # 这里的大判断分别判断了以下几件事： # 判断越界 # 判断是否被访问过 # 判断当下是否等于那个字母 # 判断它以后是否找得到 # 这些都满足了，把它返回True return True # 四个方向都不满足，就否定它 return False # print(&quot;嘿嘿我进来了 &quot;+str((i,j))) # visited = [(i,j)] # dir_x = [-1,0,1,0] # dir_y = [0,-1,0,1] # x,y = i,j # for alp in range(1,len(word)): # flag = False # for dx,dy in zip(dir_x,dir_y): # if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and(x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[alp]: # flag = True # x,y = x+dx,y+dy # print(x,y,word[alp]) # visited.append((x,y)) # if not flag: # return False # return True ​​ for i in range(m):​ for j in range(n):​ if board[i][j] == word[0] and dfs([(i,j)],word):​ return True​ return False 81. 搜索旋转排序数组 II假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 def search(self, nums: List[int], target: int) -&gt; bool: if len(nums) &lt;= 0: return False left = 0 right = len(nums) - 1 while left &lt; right: mid = (right - left) // 2 + left if nums[mid] == target: return True if nums[left] == nums[mid]: left += 1 continue if nums[left] &lt; nums[mid]: if nums[left] &lt;= target &lt;= nums[mid]: right = mid else: # 这里 +1，因为上面是 &lt;= 符号 left = mid + 1 else: # 注意：这里必须是 mid+1，因为根据我们的比较方式，mid属于左边的序列 if nums[mid+1] &lt;= target &lt;= nums[right]: left = mid + 1 else: right = mid return True if nums[left] == target else False 82. 删除排序链表中的重复元素 II给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现 的数字。 def deleteDuplicates(self, head: ListNode) -&gt; ListNode: Temp = ListNode(-1) Temp.next = head t = Temp while t: if t.next and t.next.next: if t.next.val == t.next.next.val: R = t.next.next while R.next: if R.next.val == R.val: R = R.next else: break t.next = R.next else: t = t.next else: t = t.next return Temp.next 83. 删除排序链表中的重复元素# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: cur = head if not cur: return head V = cur.val while cur.next: if cur.next.val != V: V = cur.next.val cur = cur.next else: cur.next = cur.next.next return head 84. 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。12345678910111213141516171819202122232425def largestRectangleArea(self, heights: List[int]) -&gt; int: hash_table = &#123;&#125; area = 0 for i in range(len(heights)): delete = [] for item in hash_table: if heights[i] &lt; item: if item * hash_table[item] &gt; area: area = item * hash_table[item] delete.append(item) else: hash_table[item] += 1 if heights[i] not in hash_table: m = 0 for item in delete: if hash_table[item] &gt; m: m = hash_table[item] hash_table[heights[i]] = m + 1 for item in delete: hash_table.pop(item) for item in hash_table: if item * hash_table[item] &gt; area: area = item * hash_table[item] return area 86. 分隔链表给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def partition(self, head: ListNode, x: int) -&gt; ListNode: temp = ListNode(-1) temp.next = head t = temp p1 = temp pass_flag = False while t and p1: R = None if t.next: if pass_flag and t.next.val &lt; x: R = t.next t.next = R.next R.next = None if t.next and t.next.val &gt;= x: pass_flag = True t = t.next if not pass_flag: t = t.next else: break while p1.next: if p1.next.val &lt; x: p1 = p1.next else: if R: R.next = p1.next p1.next = R p1 = p1.next break return temp.nextdef partition(self, head: ListNode, x: int) -&gt; ListNode: temp = ListNode(-1) temp.next = head t = temp p1 = temp pass_flag = False while p1.next: if p1.next.val &lt; x: p1 = p1.next else: break while t: R = None if t.next: if pass_flag and t.next.val &lt; x: R = t.next t.next = R.next R.next = None if t.next and t.next.val &gt;= x: pass_flag = True t = t.next if not pass_flag: t = t.next else: break if R: R.next = p1.next p1.next = R p1 = p1.next return temp.next 89. 格雷编码格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 1234567891011121314151617181920212223def grayCode(self, n: int) -&gt; List[int]: if n == 0: return [0] res = [0] temp = 0 for _ in range(1,1&lt;&lt;n): for i in range(n): # 判断第i位需要怎么变 flag = temp for _ in range(i): flag = flag // 2 flag = flag % 2 if flag: if temp - (1&lt;&lt;i) not in res: res.append(temp - (1&lt;&lt;i)) temp = temp - (1&lt;&lt;i) break else: if temp + (1&lt;&lt;i) not in res: res.append(temp + (1&lt;&lt;i)) temp = temp + (1&lt;&lt;i) break return res 下面这是一个完全理解了格雷码产生方式的写法： 12345678def grayCode(self, n: int) -&gt; List[int]: res,head = [0],1 for i in range(n): # n次 # 每一轮把列表里的值的二进制前面加一个1逆序添加进列表中 for j in range(len(res)-1,-1,-1): res.append(head+res[j]) head &lt;&lt;= 1 return res 90. 子集 II给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。 12345678910111213141516def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] N = len(nums) def help(step,temp): res.append(temp[:]) if step &lt;= N: i = step while i &lt; N: if i &gt; step and nums[i] != nums[i-1]: help(i+1,temp+[nums[i]]) elif i==step: help(i+1,temp+[nums[i]]) i += 1 help(0,[]) return res 92. 反转链表 II反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 1234567891011121314151617181920212223242526def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: # head = ListNode(3) # head.next = ListNode(5) # m = 3 # n = 4 Length = n-m+1 if Length &lt; 2: return head L = ListNode(-1) L.next = head p = L for _ in range(m-1): p = p.next end = p.next start = None for _ in range(Length): # 切除 temp = p.next p.next = temp.next # 头插入 temp.next = start start = temp # 再插入 end.next = p.next p.next = start return L.next 100. 相同的树# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if p and q: if p.val != q.val: return False return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) elif not p and not q: return True else: return False 101. 对称二叉树# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True if not root.left and not root.right: return True elif root.left and root.right: return self.isSameTree(root.left,root.right) else: return False def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if p and q: if p.val != q.val: return False return self.isSameTree(p.left,q.right) and self.isSameTree(p.right,q.left) elif not p and not q: return True else: return False 104. 二叉树的最大深度# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if root: MD = 1 return MD + max(self.maxDepth(root.left),self.maxDepth(root.right)) else: return 0 105. 从前序与中序遍历序列构造二叉树# Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not preorder: return None head = TreeNode(preorder[0]) ind_inorder = inorder.index(preorder[0]) head.left = self.buildTree(preorder[1:1+ind_inorder],inorder[0:ind_inorder]) head.right = self.buildTree(preorder[1+ind_inorder:], inorder[ind_inorder+1:]) return head 107. 二叉树的层次遍历def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] A = [] B = [] if root.left: B.append(root.left) if root.right: B.append(root.right) nextL = [root.val] while nextL: A.insert(0,nextL) nextL = [] nextNodes = [] while B: c = B.pop(0) nextL.append(c.val) if c.left: nextNodes.append(c.left) if c.right: nextNodes.append(c.right) B = nextNodes return A 108.将有序数组转换为二叉搜索树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 首先答案是不一致的，则需要将他做成符合一定规则的结果。emmmm最后的答案还是非常简单的。首先应该抓住他是一个生成平衡树的题目。其他的要求都是细节。有的细节需要技巧得出。有的细节自然而然就可以得出来结果。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: def helper(left, right): if left &gt; right: return None p = (left + right)//2 root = TreeNode(nums[p]) root.left = helper(left, p-1) root.right = helper(p+1, right) return root return helper(0,len(nums)-1) 110.平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 首先它是一个判断题。针对每个节点都有可能进行对比。 # 这是一个暴力解法，从上到下 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if not root: return True def helper(root): if not root: return 0 return 1+ max(helper(root.left),helper(root.right)) if abs(helper(root.left)-helper(root.right)) &gt; 1: return False else: return self.isBalanced(root.left) and self.isBalanced(root.right) 这里是从底到顶的解法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def helper(root): if not root: return 0 left = helper(root.left) if left == -1: return -1 right = helper(root.right) if right == -1: return -1 return max(left,right)+1 if abs(left-right) &lt; 2 else -1 return helper(root)!= -1 111.二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 mLeft = self.minDepth(root.left) mRight = self.minDepth(root.right) if mLeft &gt; 0 and mRight &gt; 0: return 1 + min(mLeft,mRight) elif mRight == 0: return 1+ mLeft elif mLeft == 0: return 1+ mRight 112.路径总和给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: def helper(root,temp): temp += root.val if not root.left and not root.right: # 叶子节点 return temp == sum elif root.left and not root.right: # 有左节点没有右节点 return helper(root.left, temp) elif not root.left and root.right: # 有右节点没有左节点 return helper(root.right, temp) else: return helper(root.left, temp) or helper(root.right, temp) if not root: return False return helper(root,0) 118.杨辉三角class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: L = [] for i in range(numRows): temp = (i+1)*[1] if i&gt;1: for j in range(i-1): temp[j+1] = L[i-1][j] +L[i-1][j+1] L.append(temp) return L # 优秀解法 class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] res = [[1]] while len(res) &lt; numRows: newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])] res.append(newRow) return res 119.杨辉三角IIclass Solution: def getRow(self, rowIndex: int) -&gt; List[int]: res = [1] while len(res) &lt;= rowIndex: res = [a+b for a, b in zip([0]+res, res+[0])] return re 121.买股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 暴力法： class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 m = 0 for i in range(1,len(prices)): a = min(prices[0:i]) if m &lt; prices[i]-a: m = prices[i]-a return m 改进：x5i class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 minprice = prices[0] maxprofit = 0 for i in range(1,len(prices)): if minprice &gt; prices[i]: minprice = prices[i] elif prices[i]-minprice &gt; maxprofit: maxprofit = prices[i]-minprice return maxprofit 125.验证回文串class Solution: def isPalindrome(self, s: str) -&gt; bool: if not s: return True # 1.字符串格式转换 s = s.lower() t = &quot;&quot; for i in s: if (i&gt;=&quot;0&quot; and i&lt;=&quot;9&quot;) or (i&gt;=&quot;a&quot; and i&lt;=&quot;z&quot;): t = t+i # 2.对字符串进行翻转 S = t[::-1] return S == t # 3.判断两字符串是否相等 136.只出现一次的数字哈希表是最快的！！！ class Solution: def singleNumber(self, nums: List[int]) -&gt; int: # 暴力一点， only = 0 l = len(nums) for i in range(0,l): only = nums[i] if only not in nums[0:i] and only not in nums[i+1:l]: return only class Solution(object): def singleNumber(self, nums): # 列表操作 tale = [] for i in nums: if i not in tale: tale.append(i) else: tale.remove(i) return tale[0] class Solution(object): def singleNumber(self, nums): # 哈希操作 hash_table = {} for i in nums: try: hash_table.pop(i) except: hash_table[i] = 1 return hash_table.popitem()[0] ​​ class Solution(object):​ def singleNumber(self, nums):​ # 位操作​ “””​ :type nums: List[int]​ :rtype: int​ “””​ a = 0​ for i in nums:​ a ^= i​ return a 141.环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def hasCycle(self, head: ListNode) -&gt; bool: # 列表法 hash_table = [] t = head while t: if t in hash_table: return True else: hash_table.append(t) t = t.next return False class Solution: def hasCycle(self, head: ListNode) -&gt; bool: # 哈希法 hash_table = {} t = head while t: try: hash_table.pop(t) return True except: hash_table[t] = 1 t = t.next return False class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if head == None or head.next == None: return False # 双指针法 fast = head.next slow = head while slow != fast: if fast ==None or fast.next == None: return False slow = slow.next fast = fast.next.next return True 151.翻转字符串里的单词class Solution: def reverseWords(self, s: str) -&gt; str: if not s: return s s = s.strip() L = [] P = False j = 0 for i in range(len(s)): if s[i]!=&quot; &quot;: if not P: j = i P = True else: if P: P = False L.append(s[j:i]) L.append(s[j:]) return &quot; &quot;.join(L[::-1]) 152. 乘积最大子数组给你一个整数数组 nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 def maxProduct(self, nums: List[int]) -&gt; int: hash_table = {} hash_table[-1] = 1 posi = [-1] nega = [] Max = nums[0] for i in range(len(nums)): t = nums[i] * hash_table[i-1] if t &gt; 0: if Max &lt; t/hash_table[posi[0]]: Max = t//hash_table[posi[0]] hash_table[i] = t elif t &lt; 0: if nega: if Max &lt; t/hash_table[nega[0]]: Max = t//hash_table[nega[0]] else: nega.append(i) hash_table[i] = t else: posi = [i] nega = [] hash_table[i] = 1 if Max &lt; 0: Max = 0 return Max 153. 寻找旋转排序数组中的最小值(二分查找)假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 def findMin(self, nums: List[int]) -&gt; int: # nums = [4,5,6,7,0,1,2] # 二分查找走一波 left = 0 right = len(nums)-1 while left &lt; right: mid = left + (right-left)//2 print(left,mid,right) if nums[mid] &lt; nums[mid-1]: return nums[mid] if nums[left] &lt;= nums[right]: return nums[left] if nums[mid] &gt;= nums[left]: left = mid+1 else: right = mid return nums[left] ​ 160.相交链表# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: # 第一个想法，简单法：弄两个列表然后得到答案 if not headA or not headB: return None listA = [] listB = [] A = headA B = headB while A: listA.append(A) A = A.next while B : listB.append(B) B = B.next if listA[-1] != listB[-1]: return None t = listA[-1] for i in range(1,min(len(listB),len(listA))+1): if listA[-i] != listB[-i]: return t else: t = listA[-i] return t 162. 寻找峰值峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 def findPeakElement(self, nums: List[int]) -&gt; int: left = 0 right = len(nums) -1 while left &lt; right: mid = left + (right - left)//2 if nums[mid] &gt; nums[mid+1]: right = mid else: left = mid + 1 return left 167.相交链表class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: m=0;n = 0 for i in range(len(numbers)): T = target-numbers[i] if T in numbers[i+1:]: m = i+1 n = numbers[m:].index(T)+m+1 break return [m,n] 168. Excel表列名称class Solution: def convertToTitle(self, n: int) -&gt; str: L = &quot;&quot; while n != 0: j = n % 26 if j == 0: j = 26 n -= 1 L = chr(ord(&quot;A&quot;) + j -1) + L n = n//26 return L 169. 多数元素class Solution: def majorityElement(self, nums: List[int]) -&gt; int: hashtable = {} for i in nums: if i in hashtable: hashtable[i] += 1 else: hashtable[i] = 1 M = 0 N = 0 for i in list(hashtable): if hashtable[i]&gt;M: N = i M = hashtable[i] return N 171. Excel表列序号class Solution: def titleToNumber(self, s: str) -&gt; int: N = 0 for i in s: w = ord(i)-ord(&quot;A&quot;)+1 N = N*26 +w return N 172. 阶乘后的零class Solution: def trailingZeroes(self, n: int) -&gt; int: count = 0 while n &gt;= 5: n = n//5 count += n return count 189. 旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 190. 颠倒二进制位颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 class Solution: def reverseBits(self, n: int) -&gt; int: a = bin(n)[2:] if len(a) &lt; 32: a = &quot;0&quot;*(32-len(a))+a return int(a[::-1],2) 191. 位1的个数编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 class Solution: def hammingWeight(self, n: int) -&gt; int: return bin(n)[2:].count(&quot;1&quot;) 198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 我开始想把奇数与偶数分开算，但发现了例外测试。就是第一个和第四个加起来是最大的。所以我采用了动态规划的方法。 class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) &lt;2: return nums[0] table = [0]*len(nums) table[0] = nums[0] table[1] = nums[1] for i in range(2,len(nums)): table[i] = nums[i] + max(table[0:i-1]) return max(table) 我要看看答案里有没有更好的结果。 200. 岛屿数量给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 R = len(grid) C = len(grid[0]) def modify_grid(i,j): x = [-1,1,0,0] y = [0,0,-1,1] if i &gt;= 0 and i &lt; R and j &gt;= 0 and j &lt; C: if grid[i][j] == &quot;1&quot;: grid[i][j] = &quot;0&quot; for p,q in zip(x,y): modify_grid(i+p,j+q) I_num = 0 for i in range(R): for j in range(C): # print(i) # print(j) if grid[i][j] == &quot;1&quot;: I_num += 1 modify_grid(i,j) return I_num 202. 快乐数编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 class Solution: def isHappy(self, n: int) -&gt; bool: while True: n = sum([int(i)**2 for i in str(n)]) if n == 4: return False if n == 1: return True 203. 移除链表元素删除链表中等于给定值 val 的所有节点。示例:输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: L = ListNode(-1) L.next = head head = L while L.next: if L.next.val == val: L.next = L.next.next else: L = L.next return head.next 204. 计数质数关于质数的计算还是很有讲究的。 class Solution: def countPrimes(self, n: int) -&gt; int: if n &lt; 3: return 0 results = [1]*n results[0],results[1] = 0, 1 for i in range(2,int(n**0.5)+1): if results[i] == 1: results[i*2:n:i] = [0]*len(results[i*2:n:i]) return sum(results)-1 205. 同构字符串给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = “egg”, t = “add”输出: true class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: hashtable1 = {} hashtable2 = {} x = 0 for i in s: if i not in hashtable1: hashtable1[i] = x x = x + 1 x = 0 for i in t: if i not in hashtable2: hashtable2[i] = x x = x + 1 for i,j in zip(s,t): if hashtable1[i] != hashtable2[j]: return False return True 206. 反转链表# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: pre = None cur = head while cur: n = cur.next cur.next = pre pre = cur cur = n return pre 210. 课程表 II现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 # 广度优先和深度优先方法的解法 def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: # 存储有向图 edges = collections.defaultdict(list) # 存储每个节点的入度 indeg = [0] * numCourses # 存储答案 result = list() for info in prerequisites: edges[info[1]].append(info[0]) indeg[info[0]] += 1 q = collections.deque([u for u in range(numCourses) if indeg[u] == 0]) while q: # 从队首取出一个节点 u = q.popleft() # 放入答案中 result.append(u) for v in edges[u]: indeg[v] -= 1 # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了 if indeg[v] == 0: q.append(v) if len(result) != numCourses: result = list() return result def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: # 存储有向图 edges = collections.defaultdict(list) # 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成 visited = [0] * numCourses # 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶 result = list() # 判断有向图中是否有环 invalid = False for info in prerequisites: edges[info[1]].append(info[0]) def dfs(u: int): nonlocal invalid # 将节点标记为「搜索中」 visited[u] = 1 # 搜索其相邻节点 # 只要发现有环，立刻停止搜索 for v in edges[u]: if visited[v] == 0: dfs(v) if invalid: return # 如果「搜索中」说明找到了环 elif visited[v] == 1: invalid = True return # 将节点标记为「已完成」 visited[u] = 2 # 将节点入栈 result.append(u) # 每次挑选一个「未搜索」的节点，开始进行深度优先搜索 for i in range(numCourses): if not invalid and not visited[i]: dfs(i) if invalid: return list() # 如果没有环，那么就有拓扑排序 # 注意下标 0 为栈底，因此需要将数组反序输出 return result[::-1] 217. 存在重复元素给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: hashtable = {} for i in nums: if i in hashtable: return True else: hashtable[i] = 1 return False 219. 存在重复元素 II给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: n = len(nums) table = n * [0] hashtable = {} for i in range(n): if nums[i] not in hashtable: hashtable[nums[i]] = i table[i] = 0 else: table[i] = i - hashtable[nums[i]] hashtable[nums[i]] = i print(table) for i in table: if i&gt;0 and i&lt;=k: return True return False 221. 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含1的最大正方形，并返回其面积。 def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if not matrix: return 0 if not matrix[0]: return 0 Row = len(matrix) Col = len(matrix[0]) Max = 0 for i in range(Row): for j in range(Col): if matrix[i][j] == &quot;1&quot;: print(i,j) temp = self.getArea(matrix,Row,Col,i,j) print(temp) if temp &gt; Max: Max = temp return Max # 判定以该节点为左上角所能得到的最大正方形面积 def getArea(self, matrix,Row, Col, i, j): x,y = i,j t = 1 R = t flag = True while x+t &lt; Row and y+t &lt; Col: t += 1 for p in range(t): if matrix[x+p][y+t-1] == &quot;0&quot;: flag = False break if not flag: break for q in range(t-1): if matrix[x+t-1][y+q]== &quot;0&quot;: flag = False break if not flag: break R = t return R*R 225. 用队列实现栈使用队列实现栈的下列操作： push(x) — 元素 x 入栈pop() — 移除栈顶元素top() — 获取栈顶元素empty() — 返回栈是否为空注意: 你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作） 226. 翻转二叉树翻转一棵二叉树。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return root a = self.invertTree(root.right) root.right = self.invertTree(root.left) root.left = a return root 231. 2的幂给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: i = 0 while i == 0 and n &gt;= 2: i = n%2 n = n//2 if i == 0 and n &gt; 0: return True else: return False 234. 回文链表（解答明天看一下）请判断一个链表是否为回文链表。 我的简单解法 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: L = [] t = head while t: L.append(t.val) t = t.next return True if L == L[::-1] else False 235. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: if not root: return None b = p if p.val &gt;= q.val else q s = p if p.val &lt; q.val else q if root.val &gt; b.val: return self.lowestCommonAncestor(root.left,p,q) elif root.val &gt;=s.val: return root else: return self.lowestCommonAncestor(root.right,p,q) 236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: # 两个节点在路径中的最后一个相同的节点 L1 = self.search(root,p) L2 = self.search(root,q) i,j = 0,0 while i&lt;len(L1) and i &lt;len(L2): if L1[i] == L2[i]: i += 1 else: break return L1[i-1] def search(self, root, p): # p在root中的路径 if not root: return [] if root == p: return [root] left = self.search(root.left,p) right = self.search(root.right,p) if not left and not right: return [] if not right: return [root] + left if not left: return [root] + right def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left: return right if not right: return left return root 238. 除自身以外数组的乘积给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 123456789101112131415161718class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: Sum = 1 hash_table = &#123;&#125; n = len(nums) for i in range(len(nums)): hash_table[i] = &#123;\"pre\":Sum,\"rear\":1&#125; Sum *= nums[i] Sum = 1 for i in range(len(nums)): hash_table[n-1-i][\"rear\"] = Sum Sum *= nums[n-1-i] res = [] for key,item in hash_table.items(): # print(key,item) res.append(hash_table[key][\"pre\"]*hash_table[key][\"rear\"]) return res 一个我写的更好的答案123456789101112131415class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: pre_Sum = 1 rear_Sum = 1 n = len(nums) help_table = [[0,0] for _ in range(n)] for i in range(n): help_table[i][0] = pre_Sum help_table[n-i-1][1] = rear_Sum pre_Sum *= nums[i] rear_Sum *= nums[n-i-1] res = [] for i in range(n): res.append(help_table[i][0]*help_table[i][1]) return res 123456789101112class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: n = len(nums) res = [1] * n pre_Sum = 1 rear_Sum = 1 for i in range(n): res[i] *= pre_Sum res[n-i-1] *= rear_Sum pre_Sum *= nums[i] rear_Sum *= nums[n-i-1] return res 1234567891011121314151617class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int pre_Value = 1; int rear_value = 1; int [] res = new int [nums.length] ; for (int i = 0; i &lt; nums.length; i++)&#123; res[i] = 1; &#125; for (int i = 0; i &lt; nums.length; i++)&#123; res[i] *= pre_Value; res[nums.length-i-1] *= rear_value; pre_Value *= nums[i]; rear_value *= nums[nums.length-i-1]; &#125; return res; &#125;&#125; 242. 有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: hash_table1 = {} hash_table2 = {} for i in s: if i in hash_table1: hash_table1[i] += 1 else: hash_table1[i] = 1 for j in t: if j in hash_table2: hash_table2[j] += 1 else: hash_table2[j] = 1 if len(hash_table2) != len(hash_table1): return False else: for i in hash_table1: if i not in hash_table2: return False elif hash_table2[i] != hash_table1[i]: return False return True 257. 二叉树的所有路径给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 258. 各位相加给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 class Solution: def addDigits(self, num: int) -&gt; int: x = 0 while num != 0: x += num % 10 num =num // 10 return self.addDigits(x) if x &gt;= 10 else x 263. 丑数编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 class Solution: def isUgly(self, num: int) -&gt; bool: if num == 0: return False if num == 1: return True while True: if num % 2 == 0: num = num /2 else: break while True: if num % 3 == 0: num = num /3 else: break while True: if num % 5 == 0: num = num /5 else: break return True if num == 1 else False 268. 缺失数字给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 class Solution: def missingNumber(self, nums: List[int]) -&gt; int: M = len(nums) + 1 for i in range(M+1): if i not in nums: return i return M+1 278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 # The isBadVersion API is already defined for you. # @param version, an integer # @return a bool # def isBadVersion(version): class Solution: def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int 二分排序 &quot;&quot;&quot; i = 1 j = n while i&lt;j: x = (i+j)//2 if isBadVersion(x): j = x else: i = x+1 return i 290. 单词规律给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 class Solution: def wordPattern(self, pattern: str, str: str) -&gt; bool: a = str.strip().split() b = list(pattern) hash_tabel = {} if len(a) != len(b): return False for i,j in zip(a,b): if j in hash_tabel: if hash_tabel[j] != i: return False else: hash_tabel[j] = i # 判断不同key值不同 S = [] for i in hash_tabel: if hash_tabel[i] not in S: S.append(hash_tabel[i]) else: return False return True 292. Nim 游戏你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 class Solution: def canWinNim(self, n: int) -&gt; bool: if n%4==0: return False else: return True 300.最长上升子序列动态规划给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 我第一时间想到的也是动态规划，可是没有抓住重点就没写出来。还好。这个代码也是一看就懂的。动态规划的基本要素，一个表来记录已有的最好记录。一步一步推到想要的那一步。表是用来记录最好的结果的。 class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = len(nums)*[1] for i in range(len(nums)): t = dp[i] for j in range(0,i): if nums[j] &lt; nums[i]: if dp[i] &lt; dp[j] + t: dp[i] = dp[j] + t return max(dp) 394. 字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 # 递归解法 def decodeString(self, s: str) -&gt; str: res = &quot;&quot; i = 0 while i &lt; len(s) : if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;): k = int(s[i]) i += 1 while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;): k = k*10 + int(s[i]) i += 1 j = i+1 stack = [&quot;[&quot;] while j&lt;len(s) and len(stack)&gt;0: if s[j] == &quot;[&quot;: stack.append(&quot;[&quot;) elif s[j] == &quot;]&quot;: stack.pop() j += 1 temp = self.decodeString(s[i+1:j-1]) res += k*temp i = j else: res += s[i] i += 1 return res # 栈解法 def decodeString(self, s: str) -&gt; str: res = &quot;&quot; i = 0 stack = [] while i &lt; len(s) : if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;): k = int(s[i]) i += 1 while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;): k = k*10 + int(s[i]) i += 1 stack.append(k) elif s[i] == &quot;]&quot;: temp = &quot;&quot; t = stack.pop() while t != &quot;[&quot;: temp = t + temp t = stack.pop() k = stack.pop() stack.append(k*temp) i += 1 else: stack.append(s[i]) i += 1 return &quot;&quot;.join(stack) 466. 统计重复个数由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcabcabc”。 如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。 现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。 请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。 def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -&gt; int: if n1 == 0: return 0 s1cnt, index, s2cnt = 0, 0, 0 # recall 是我们用来找循环节的变量，它是一个哈希映射 # 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符 # 如果我们之前遍历了 s1cnt&#39; 个 s1 时，匹配到的是第 s2cnt&#39; 个 s2 中同样的第 index 个字符，那么就有循环节了 # 我们用 (s1cnt&#39;, s2cnt&#39;, index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果 # 那么哈希映射中的键就是 index，值就是 (s1cnt&#39;, s2cnt&#39;) 这个二元组 # 循环节就是； # - 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2 # - 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2 # 那么还会剩下 (n1 - s1cnt&#39;) % (s1cnt - s1cnt&#39;) 个 s1, 我们对这些与 s2 进行暴力匹配 # 注意 s2 要从第 index 个字符开始匹配 recall = dict() while True: # 我们多遍历一个 s1，看看能不能找到循环节 s1cnt += 1 for ch in s1: if ch == s2[index]: index += 1 if index == len(s2): s2cnt, index = s2cnt + 1, 0 # 还没有找到循环节，所有的 s1 就用完了 if s1cnt == n1: return s2cnt // n2 # 出现了之前的 index，表示找到了循环节 if index in recall: s1cnt_prime, s2cnt_prime = recall[index] # 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2 pre_loop = (s1cnt_prime, s2cnt_prime) # 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2 in_loop = (s1cnt - s1cnt_prime, s2cnt - s2cnt_prime) break else: recall[index] = (s1cnt, s2cnt) # ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop ans = pre_loop[1] + (n1 - pre_loop[0]) // in_loop[0] * in_loop[1] # S1 的末尾还剩下一些 s1，我们暴力进行匹配 rest = (n1 - pre_loop[0]) % in_loop[0] for i in range(rest): for ch in s1: if ch == s2[index]: index += 1 if index == len(s2): ans, index = ans + 1, 0 # S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2 return ans // n2 560. 和为K的子数组 (##)给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: # 数组还可能有小于0的情况 res = 0 s = 0 n = len(nums) hash_table = {} hash_table[s] = 1 for i in range(n): pre += nums[i] if pre-k in hash_table: res += hash_table[s-k] if pre in hash_table: hash_table[pre] += 1 else: hash_table[pre] = 1 return res 695.岛屿的最大面积用深度优先遍历： class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: m = len(grid) if m == 0: return 0 n = len(grid[0]) ans = 0 def dfs(i,j): if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n: return 0 if grid[i][j] == 0: return 0 grid[i][j] = 0 top = dfs(i+1, j) bottom = dfs(i-1,j) left = dfs(i,j-1) right = dfs(i,j+1) return 1 + sum([top,bottom,left,right]) for i in range(m): for j in range(n): ans = max(ans,dfs(i,j)) return ans 739. 每日温度请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 12345678910111213141516171819def dailyTemperatures(self, T: List[int]) -&gt; List[int]: N = len(T) res = [0]*N M = T[-1] for i in range(len(T)-2,-1,-1): if T[i] &gt; M: M = T[i] else: r = i+1 flag = True while T[i]&gt;=T[r]: if res[r] != 0: r = res[r] + r else: flag = False break if flag: res[i] = r-i return res 837. 新21点 (回溯法超时了，经提示还是用动态规划）12345678910111213def new21Game(self, N: int, K: int, W: int) -&gt; float: # 回溯法超时了 def help(score): if score &gt;= K and score &lt;= N: return 1 elif score &gt;= K and score &gt; N: return 0 elif score &lt; K: res = 0 for i in range(1,W+1): res += (1/W)*help(score+i) return res return help(0) 动态规划12345678910def new21Game(self, N: int, K: int, W: int) -&gt; float: dp = [0]*(K+W) if K+W-1 &lt;= N: return 1 for i in range(K,N+1): dp[i] = 1 for i in range(K-1,-1,-1): for j in range(i+1,i+1+W): dp[i] += dp[j]/W return dp[0]12345678910111213class Solution &#123; public double new21Game(int N, int K, int W) &#123; double[] dp = new double[N+1]; for (int i = K; i&lt;N+1;i++) dp[i] = 1.0; for (int i = K-1;i&gt;-1;i--)&#123; for (int j = i+1; j&lt;N+1 &amp;&amp; j&lt;i+1+W;j++)&#123; dp[i] += dp[j]/W; &#125; &#125; return dp[0]; &#125;&#125;123456789101112class Solution: # 最终通过的答案！！把相加的步骤优化一下 def new21Game(self, N: int, K: int, W: int) -&gt; float: dp=[None]*(K+W) s=0 for i in range(K,K+W): # 填蓝色的格子 dp[i] = 1 if i&lt;=N else 0 s+=dp[i] for i in range(K-1,-1,-1): # 填橘黄色格子 dp[i]=s/W s=s-dp[i+W]+dp[i] return dp[0] 876. 链表的中间结点给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def middleNode(self, head: ListNode) -&gt; ListNode: L = head N = 0 while L: N += 1 L = L.next L = head for _ in range(N//2): L = L.next return L 887. 鸡蛋掉落你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: memo = {} def dp(k, n): if (k, n) not in memo: if n == 0: ans = 0 elif k == 1: ans = n else: lo, hi = 1, n # keep a gap of 2 X values to manually check later while lo + 1 &lt; hi: x = (lo + hi) // 2 t1 = dp(k-1, x-1) t2 = dp(k, n-x) if t1 &lt; t2: lo = x elif t1 &gt; t2: hi = x else: lo = hi = x ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x)) for x in (lo, hi)) memo[k, n] = ans return memo[k, n] return dp(K, N) 914. 卡牌分组给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= 2 时返回 true。 class Solution: def hasGroupsSizeX(self, deck: List[int]) -&gt; bool: hashtable = {} for i in deck: if i in hashtable: hashtable[i] += 1 else: hashtable[i] = 1 a = set(hashtable.values()) if len(a) == 1: return True if list(a)[0]&gt;1 else False else: b = min(a) for j in range(b,1,-1): print(j) p = False for i in a: if i%j != 0: p = True break if p: continue return True return False 974. 和可被 K 整除的子数组给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 def subarraysDivByK(self, A: List[int], K: int) -&gt; int: hash_table = defaultdict(list) hash_table[0] = [-1] count = 0 S = 0 for i in range(len(A)): S += A[i] count += len(hash_table[S%K]) hash_table[S%K].append(i) return count 990. 等式方程的可满足性 (并查集)给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 12345678910111213141516171819202122232425262728293031323334353637383940def equationsPossible(self, equations: List[str]) -&gt; bool: table = [] for item in equations: if item[1:3] == \"==\": S1,S2 = None,None k1,k2 = -1,-1 for i in range(len(table)): if item[0] in table[i]: S1 = table[i] k1 = i if item[3] in table[i]: S2 = table[i] k2 = i if not S1 and not S2: table.append([item[0],item[3]]) elif not S1 and S2: S2.append(item[0]) elif S1 and not S2: S1.append(item[3]) else: if S1 != S2: S1.extend(S2) table.pop(k2) for item in equations: if item[1:3] == \"!=\": S1,S2 = None,None for L in table: if item[0] in L: S1 = L if item[3] in L: S2 = L if not S1: table.append([item[0]]) S1 = table[-1] if not S2: table.append([item[3]]) S2 = table[-1] if S1 == S2: return False return True 123456789101112131415161718192021from collections import defaultdictclass Solution: def equationsPossible(self, equations: List[str]) -&gt; bool: parent = defaultdict(str) def find(x): if parent[x] ==\"\": parent[x] = x while x != parent[parent[x]]: parent[x] = parent[parent[x]] x = parent[x] return x def union(x,y): parent[find(x)] = find(y) for item in equations: if item[1] == \"=\": union(item[0],item[3]) for item in equations: if item[1] == \"!\": if find(item[0]) == find(item[3]): return False return True 999. 车的可用捕获量在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。 返回车能够在一次移动中捕获到的卒的数量。 class Solution: def numRookCaptures(self, board: List[List[str]]) -&gt; int: [(x,y)] = [(i,j) for i in range(8) for j in range(8) if board[i][j]==&quot;R&quot;] N = 0 dx = [-1, 0, 1, 0] dy = [0, -1, 0, 1] for i,j in zip(dx,dy): d = 1 while True: if x + i*d &lt;0 or x + i*d &gt;=8 or y + j*d &lt; 0 or y + j*d &gt;= 8: break if board[x + i*d][y + j*d] == &quot;B&quot;: break elif board[x + i*d][y + j*d] == &quot;p&quot;: N += 1 break d += 1 return N 1014. 最佳观光组合给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 1234567891011# 超时答案def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: res = 0 for i in range(len(A)-1): cost = 1 for j in range(i+1,len(A)): print(i,j,cost,A[i]+A[j],A[i]+A[j]-cost) if A[i]+A[j]-cost &gt; res: res = A[i]+A[j]-cost cost += 1 return res 123456789def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: dp = 0 res = 0 for i in range(1,len(A)): dp = dp + (A[i]-A[i-1]) -1 dp = A[i]+A[i-1] -1 if A[i]+A[i-1] -1 &gt; dp else dp if dp &gt; res: res = dp return res 1028. 从先序遍历还原二叉树我们从二叉树的根节点 root 开始进行深度优先搜索。 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。 如果节点只有一个子节点，那么保证该子节点为左子节点。 给出遍历输出 S，还原树并返回其根节点 root。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def recoverFromPreorder(self, S: str) -&gt; TreeNode: # S = \"1-2--3---4-5--6---7\" # print(self.My_split(S)) val, S1, S2 = self.My_split(S) root = TreeNode(val) if S1: root.left = self.recoverFromPreorder(S1) if S2: root.right = self.recoverFromPreorder(S2) return root def My_split(self, S): res = [] step = 0 i = 0 while i &lt; len(S): if S[i] ==\"-\": step += 1 if S[i] != \"-\": break i += 1 j = i step += 1 # print(\"step:\" + str(step) while j &lt; len(S): if S[j] == \"-\": break if S[j] != \"-\": j += 1 val = S[i:j] window_head = j window_rear = window_head+step while window_rear &lt; len(S): if S[window_rear] != \"-\": # print(\"window_head: \"+ str(window_head)+\" window_rear: \"+str(window_rear)) flag = True for j in range(window_head,window_rear): if S[j] != \"-\": flag = False continue if flag: # print(\"flag: \" + str(S[window_head])) if (S[window_head-1] != \"-\"): res.append(window_head) window_head = window_rear window_rear = window_head+step else: window_head += 1 window_rear += 1 # print(\"res: \" + str(res)) if len(res) == 0: return val, None, None if len(res) == 1: return val, S[res[0]:],None if len(res) == 2: return val, S[res[0]:res[1]],S[res[1]:] 1095. 山脉数组中查找目标值（这是一个 交互式问题 ） 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length &gt;= 3 其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）MountainArray.length() - 会返回该数组的长度 # &quot;&quot;&quot; # This is MountainArray&#39;s API interface. # You should not implement it, or speculate about its implementation # &quot;&quot;&quot; #class MountainArray: # def get(self, index: int) -&gt; int: # def length(self) -&gt; int: class Solution: def findInMountainArray(self, target: int, mountain_arr: &#39;MountainArray&#39;) -&gt; int: length = mountain_arr.length() left = 0 right = length -1 return self.helper(target,mountain_arr,left,right) ​​ def helper(self, target,mountain_arr, left, right):​ if left &gt;= right:​ if mountain_arr.get(left) == target:​ # 这里可以做一个实验，删掉这个判断和有这个有什么区别​ return left​ return -1​ mid = left + (right - left)//2​ x = mountain_arr.get(index = mid)​ print(“left: “ + str(left) + “ mid: “ + str(mid) + “ right: “ + str(right))​ print(“x: “ +str(x))​ if x &gt; target:​ # 先找前面，如果有就return，没有就再找后面​ # 也可以判断坡​ t = self.helper(target,mountain_arr, left, mid)​ return t if t != -1 else self.helper(target,mountain_arr, mid+1, right)​ else:​ # 中间值小于目标值先判断在前坡还是后坡​ if mid == 0 or x &gt; mountain_arr.get(mid-1):​ # 如果在前坡，就舍弃0~mid,查找mid+1到后面​ # 在前坡与目标值相等，直接返回​ if x == target:​ return mid​ return self.helper(target,mountain_arr, mid+1, right)​ else:​ # 如果在后坡，就舍弃mid:,查找前面​ t = self.helper(target,mountain_arr, left, mid)​ if t != -1:​ return t​ else:​ if x == target:​ return mid​ return self.helper(target,mountain_arr, mid+1, right) 面试题 17.16. 按摩师一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 class Solution: def massage(self, nums: List[int]) -&gt; int: if not nums: return 0 curMax = 0 preMax = 0 for x in nums: temp = curMax curMax = max(preMax+x, curMax) preMax = temp return curMax 面试题40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 1234567# 我的方法就比较暴力，在原来的数组中把最大的几个给删了，剩下k个最小的留下class Solution: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: if k &gt;= len(arr):return arr for _ in range(k): arr.remove(min(arr)) return arr 面试题46. 把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 123456789101112131415161718192021222324252627# 回溯法def translateNum(self, num: int) -&gt; int: S= str(num) N = len(S) def help(step): if step &gt; N-1: return 1 else: res = 0 res += help(step+1) if step &lt; N-1 and int(S[step:step+2])&lt;26 and int(S[step:step+2]) &gt; 9 : res += help(step+2) return res return help(0)# 动态规划def translateNum(self, num: int) -&gt; int: S= str(num) N = len(S) dp = [0]*(N+1) dp[0] = 1 dp[1] = 1 for i in range(2,N+1): dp[i] += dp[i-1] if int(S[i-2:i])&lt;26 and int(S[i-2:i]) &gt; 9: dp[i] += dp[i-2] print(dp) return dp[-1] 面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 ​​ class Solution:​ def reversePairs(self, nums: List[int]) -&gt; int:​ L = len(nums)​ if L &lt; 2:​ return 0​ def reversePairs(nums, left, right):​ if left == right:​ return 0​ mid = left + (right - left)//2​ leftpairs = reversePairs(nums, left, mid)​ rightpairs = reversePairs(nums, mid+1, right)​ crosspairs = self.crosspairs(nums, left, mid, right)​ return leftpairs + rightpairs + crosspairs​ return reversePairs(nums, 0, L-1)​​ def crosspairs(self, nums, left, mid, right):​ temp = nums[left:right+1]​ m = mid - left​ r = right - left​ i,j = 0, m+1​ count = 0​ for k in range(left, right+1):​ if i == m+1:​ nums[k] = temp[j]​ j += 1​ elif j == r + 1:​ nums[k] = temp[i]​ i += 1​ elif temp[i] &lt;= temp[j]:​ nums[k] = temp[i]​ i += 1​ else:​ nums[k] = temp[j]​ j += 1​ count += m - i + 1​ return count 面试题62. 圆圈中最后剩下的数字 [TOC]","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://zenner006.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"编程题","slug":"编程题","permalink":"http://zenner006.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"java高级编程上","slug":"java高级编程","date":"2020-05-11T12:22:50.000Z","updated":"2020-07-14T02:14:17.583Z","comments":true,"path":"2020/05/11/java高级编程/","link":"","permalink":"http://zenner006.github.io/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","excerpt":"[TOC] eclipse启动后会选择工作目录 如果把一些视图关闭了可以从 windows+show View: t 里打开 “project Explorer”,”outline”,”console”,”problems”; 建立项目：命名为Myproject 项目创建完成后会产生两个目录： src : 保存所有的原代码目录 bin : 保存所有的生成的 *.class 目录； 这个视图会和原来不一样，可以在右上角切换； 字体大小通过Ctrl + ++放大字体，通过 windows+preference也可以调整 范例：编写程序 输入main,然后ALt+”/“可补充完成 系统输出：sysout，ALT+/ 代码生成功能可以生成一些类方法： 范例生成类方法： 光标放在这里： 状态栏【source】 里面可选 生成 setter，getter；有参构造，无参构造； 快捷键： Alt+/:代码编写提示 Ctr + 1：代码纠正； CTRL + SHIFT + O :开发包的自动导入 CTRL + / ：注释代码 CTRL + SHIFT + / ：注释多行 CTRL + SHIFT + F ：格式化代码 CTRL + SHIFT + L : 快捷键列表； 文档注释：/**+回车 项目导入导出： 导出：【file】+【export】; 导入：【项目】右键+【properties】+【java build path】+【library】+【classpath】+【Add External JARs】 带参数的项目运行","text":"[TOC] eclipse启动后会选择工作目录 如果把一些视图关闭了可以从 windows+show View: t 里打开 “project Explorer”,”outline”,”console”,”problems”; 建立项目：命名为Myproject 项目创建完成后会产生两个目录： src : 保存所有的原代码目录 bin : 保存所有的生成的 *.class 目录； 这个视图会和原来不一样，可以在右上角切换； 字体大小通过Ctrl + ++放大字体，通过 windows+preference也可以调整 范例：编写程序 输入main,然后ALt+”/“可补充完成 系统输出：sysout，ALT+/ 代码生成功能可以生成一些类方法： 范例生成类方法： 光标放在这里： 状态栏【source】 里面可选 生成 setter，getter；有参构造，无参构造； 快捷键： Alt+/:代码编写提示 Ctr + 1：代码纠正； CTRL + SHIFT + O :开发包的自动导入 CTRL + / ：注释代码 CTRL + SHIFT + / ：注释多行 CTRL + SHIFT + F ：格式化代码 CTRL + SHIFT + L : 快捷键列表； 文档注释：/**+回车 项目导入导出： 导出：【file】+【export】; 导入：【项目】右键+【properties】+【java build path】+【library】+【classpath】+【Add External JARs】 带参数的项目运行 3. debug操作 范例 类方法代码 123456789package cn.jubingyi.util;public class MyMath &#123; public static int add(int x, int y) &#123; int temp = 0; temp = x + y; return temp; &#125;&#125; 测试代码 12345678package cn.jubingyi.Demo;import cn.jubingyi.util.MyMath;public class TestMath &#123; public static void main(String[] args) &#123; int result = MyMath.add(10, 20); //将此处设置为断点：在行头双击，出现蓝点； System.out.println(\"加法结果 \"+ result); &#125;&#125; 随后就可以以debug模式进行操作， 调试的几种形式： 单步跳入【F5】：进入到代码之中观察，进入到内部； 单步跳过【F6】：不进入到代码中观察，只观察代码表面 单步返回【F7】：后面的代码不再调试，返回到进入处 恢复执行【F8】：程序直接正常执行完毕 4. Junit测试工具junit是一种用例测试工具； 测试用例 123456789package cn.jubingyi.util;public class MyMath &#123; public static int add(int x, int y) &#123; int temp = 0; temp = x + y; return temp; &#125;&#125; 选中要测试的例，继续选择新建； java-junit junit属于第三方程序包，需要额外的配置； 导入包后再import还报错了，删除项目自带的那个module什么文件； Junit测试有两个返回结果： GREEN BAR：测试通过 RED BAR：测试失败； java新特性1.可变参数设计一个方法，用于计算任意个数的整数的相加结果； 最开始用数组实现 现在可以用的方法定义形式是这样的： 12// 方法模板public [static] [final] 返回值 方法名称(参数类型 ... 参数名称)&#123;&#125; 参数上的 …就明确描述了数组得的结构； 12345678910111213141516171819public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(add(1,23,124)); // 多个参数是可以的 System.out.println(add(new int[] &#123;1,2,4&#125;)); // 用数组也是可以的 &#125; /** * 实现任意个整数的相加 * @param data 要进行相加的整数 * @return 返回多个整数相加结果 */ public static int add(int... data) &#123; // 描述的是一个数组 int sum = 0; for (int x = 0; x &lt; data.length; x++) &#123; sum += data[x]; &#125; return sum; &#125;&#125; 注意：传递多个参数，可变参数写在最后 2. foreach 循环（增加for）原始数组： 123for (int x = 0; x &lt; data.length; x++) &#123; sum += data[x];&#125; 新特性： 1234// 模板for(数据类型 临时变量：数组)&#123; //循环次数为数组长度，每一次循环都会取出一个数组元素给临时变量&#125; 增强型的for循环： 123456public static void main(String[] args) &#123; int data[] = new int[] &#123;1,2,3,4,5&#125;; for (int i:data) &#123; System.out.println(i); &#125;&#125; 避免角标问题，避免越界问题； 3.静态导入定义一个类 1234567891011public class MyMath &#123; public static int add(int x, int y) &#123; int temp = 0; temp = x + y; return temp; &#125; public static int sub(int x, int y) &#123; return x - y; &#125;&#125; 最开始肯定是先导入MyMath类，然后再用MyMath类来使用类中的static方法 范例： 12345678910package cn.jubingyi.Demo;import cn.jubingyi.util.MyMath;public class TestMath &#123; public static void main(String[] args) &#123; System.out.println(MyMath.add(10,20)); System.out.println(MaMath.sub(20,10)); &#125;&#125; 静态导入的方法： 12345678import cn.jubingyi.util.MyMath.*;public class TestMath &#123; public static void main(String[] args) &#123; System.out.println(add(10,20)); System.out.println(sub(20,10)); &#125;&#125; 泛型可以解决程序的参数转换问题 1. 泛型问题引出假设定义一个描述坐标的类Point; 类中有两个属性x，y; 参数可能有如下的选择： x = 10 、y = 20 x = 10.1, y = 20.2 x = 东经70° y = 北纬20° 首先要解决的就是Point类属性x，y类型问题，那么此时需要保存的有int，double，String类型；再Java里只有一种类型Object可以保存所有的类型； int 自动装箱 Integer，在自动转型到Object double 自动装箱 Double，Double自动向上到Object String 向上转型Object； 范例：定义Point类 12345678910111213141516class Point&#123; private Object x; private Object y; public Object getX() &#123; return x; &#125; public void setX(Object x) &#123; this.x = x; &#125; public Object getY() &#123; return y; &#125; public void setY(Object y) &#123; this.y = y; &#125;&#125; 范例：设置整形数据 12345678public static void main(String[] args) &#123; Point p = new Point(); p.setX(10); p.setY(20); int x = (Integer) p.getX(); int y = (Integer) p.getY(); System.out.println(\"x = \" + x + \"、 y=\" + y);&#125; 范例设置字符串： 12345678public static void main(String[] args) &#123; Point p = new Point(); p.setX(\"东经70°\"); p.setY(\"北纬20°\"); String x = (String) p.getX(); String y = (String) p.getY(); System.out.println(\"x = \" + x + \"、 y=\" + y);&#125; 但设置就可以随意设置，但接收时总要确定的类型来接收； 2. 泛型基本定义 泛型就是类在定义时候不会设置类中的属性或方法中的参数的具体类型，在类使用的时候才进行定义 如果想要进行这种泛型的操作，就必须进行一个类型标记的声明 范例：Point类 123456789101112131415161718192021222324252627282930// 在Point类定义的时候完全不知道属性的类型，完全由使用者来决定class Point &lt;T&gt;&#123; // T表示参数，是一个占位标记 private T x; private T y; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125; public T getY() &#123; return y; &#125; public void setY(T y) &#123; this.y = y; &#125; &#125;public class TestDeme &#123; public static void main(String[] args) &#123; Point&lt;String&gt; p = new Point&lt;String&gt;(); p.setX(\"东经70°\"); p.setY(\"北纬20°\"); String x = p.getX(); // 避免了向下转型 String y = p.getY(); System.out.println(\"x = \" + x + \"、 y=\" + y); &#125;&#125; 3. 通配符（重点）增加了泛型解决了不同类型的定义问题，但又有了统一参数的问题 范例 12345678910111213141516171819202122class Message &lt;T&gt;&#123; private T note; public T getNote() &#123; return note; &#125; public void setNote(T note) &#123; this.note = note; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message&lt;String&gt; message = new Message &lt;String&gt;(); message.setNote(\"巨饼很帅气\"); fun(message); &#125; public static void fun(Message&lt;String&gt; temp) &#123; System.out.println(temp.getNote()); &#125;&#125; 现在的问题是在于使用时类型使用的不是String那么其他的就不能使用fun函数了；也就是说还得写其他的重载方法；但写了所谓的重载方法也是错的：因为方法在程序看来都是Message&lt;T&gt;类型的，而不是你想要的，Message&lt;String&gt;，Message&lt;Integer&gt;之类的； 我们想要的就是可以接受所有的类型，又不想让用户随意修改我们使用的类型； 这里使用“？”来处理 ：能接收一切，但不能修改 12345678910111213public class TestDeme &#123; public static void main(String[] args) &#123; Message&lt;Integer&gt; message = new Message &lt;Integer&gt;(); message.setNote(99); fun(message); &#125; // 此时使用的通配符“？”描述的是他可以接受任意类型，但由于不确定类型，而无法修改 public static void fun(Message&lt;?&gt; temp) &#123; temp.setNote(\"句柄很帅\"); // 这时就报错了，这是不能修改的； temp.setNote(87); // 这种自身传进来的修改也不可以； System.out.println(temp.getNote()); &#125;&#125; 而在“？”的基础上产生了两个子通配符 ？ extends 类 ： 设置泛型上限： 例如 ？ extends Number，只能设置Number 或其子类，Integer，Double之类的 ? super 类： 设置泛型下限： 例如 ？ super String ,表示只能够设置String或其父类：Object； 范例：泛型上限 1234567891011121314151617181920212223package cn.jubingyi.Demo;class Message &lt;T extends Number&gt;&#123; // 设置泛型上限 ，表示只接收Number及其子类 private T note; public T getNote() &#123; return note; &#125; public void setNote(T note) &#123; this.note = note; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message&lt;Integer&gt; message = new Message &lt;Integer&gt;(); message.setNote(99); fun(message); &#125; public static void fun(Message&lt;? extends Number&gt; temp) &#123; // 只接收Number及其子类 System.out.println(temp.getNote()); &#125;&#125; 泛型：泛型下限 1234567891011121314151617181920212223package cn.jubingyi.Demo;class Message &lt;T&gt;&#123; private T note; public T getNote() &#123; return note; &#125; public void setNote(T note) &#123; this.note = note; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message&lt;String&gt; message = new Message &lt;String&gt;(); message.setNote(\"Hello world\"); fun(message); &#125; public static void fun(Message&lt;? super String&gt; temp) &#123; // 只在这里使用 System.out.println(temp.getNote()); &#125;&#125; 4. 泛型接口 范例：泛型接口 第一种类实现接口也泛型 1234567891011121314interface IMessage&lt;T&gt;&#123; // 在接口上定义了泛型 public void print(T t);&#125;class MessageImpl&lt;T&gt; implements IMessage&lt;T&gt;&#123; public void print(T t) &#123; System.out.println(t); &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage&lt;String&gt; msg = new MessageImpl&lt;String&gt;(); msg.print(\"Hello world!!\"); &#125;&#125; 第二种：在子类实现接口的时候明确给出具体类型； 12345678910111213141516interface IMessage&lt;T&gt;&#123; // 在接口上定义了泛型 public void print(T t);&#125;class MessageImpl implements IMessage&lt;String&gt;&#123; // 明确了类型是String @Override public void print(String t) &#123; // TODO Auto-generated method stub System.out.println(t); &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage&lt;String&gt; msg = new MessageImpl(); msg.print(\"Hello world!!\"); &#125;&#125; 5. 泛型方法在类或接口里的方法就是泛型方法，但这些方法不一定非要在类或接口里 范例：定义泛型方法 123456789101112public class TestDeme &#123; public static void main(String[] args) &#123; Integer [] data = fun(1,2,3,4,5); for (int temp:data) &#123; System.out.println(temp); &#125; &#125; // &lt;T&gt;描述的是泛型标记的声明 public static &lt;T&gt; T[] fun(T ... args) &#123; return args; &#125; &#125; 枚举枚举功能比较玩出现，所以一定程度上来说，可以不会； 1. 多例与枚举多例设计模式：构造方法私有化，而后类内部需要提供有若干个实例化对象，后面通过static方法返回 范例：定义一个描述颜色基色的多例设计类 12345678910111213141516171819202122232425262728293031class Color &#123; private static final Color RED = new Color(\"RED\"); private static final Color GREEN = new Color(\"GREEN\"); private static final Color BLUE = new Color(\"BLUE\"); private String title; private Color(String title) &#123; this.title = title; &#125; public static Color getInstance(int ch) &#123; switch (ch) &#123; case 0: return RED; case 1: return GREEN; case 2: return BLUE; default: return null; &#125; &#125; public String toString() &#123; return this.title; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(Color.getInstance(2)); &#125;&#125; 限制本类实例化个数 所谓枚举就是一种高级的多例设计模式 范例 12345678enum Color&#123; RED,GREEN,BLUE&#125;public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(Color.RED); &#125;&#125; 2. Enum类enum是对一种类型的包装：使用enum定义的枚举类本质上就相当于一个class定义的类继承了java.lang.Enum父类； 在Enum类里面有以下的方法： 构造方法： 1protected Enum(String name, int ordinal) 当定义枚举类中对象的时候会自动设置序号和名字； 取得枚举名字： 1public final String name() 取得枚举序号 1public final int ordinal() 范例： 123456789enum Color&#123; RED,GREEN,BLUE&#125;public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(Color.RED.name()+\" : \"+Color.RED.ordinal()); &#125;&#125;//RED : 0 在枚举操作里还有一个方法可以取得所有的枚举数据：values()返回的是一个枚举的对象数组 范例：取得所有的枚举数据 123456789101112131415enum Color &#123; RED, GREEN, BLUE&#125;public class TestDeme &#123; public static void main(String[] args) &#123; for (Color temp : Color.values()) &#123; System.out.println(temp.name() + \" : \" + temp.ordinal()); &#125; &#125;&#125;/*RED : 0GREEN : 1BLUE : 2*/ 面试题：请解释enum和Enum的区别 enum是一个关键字，用enum定义的枚举类本质上就相当于一个类继承了Enum这个抽象类； 3. 枚举中定义其他结构多例设计是在一个类中产生的，所以在这个类中就可以定义更多的属性和方法。 而枚举依靠以上额概念只能够说产生了若干个对象，但并不能扩充方法定义更多的结构。 所以设计枚举：定义属性，方法，或者实现接口 范例：在枚举中定义更多的结构 12345678910111213141516171819202122enum Color &#123; RED(\"红色\"), GREEN(\"绿色\"), BLUE(\"蓝色\"); //定义有其他内容，枚举对象定义在第一行； private String title; private Color(String title) &#123; this.title = title; &#125; public String toString() &#123; return this.title; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; for (Color temp : Color.values()) &#123; System.out.println(temp); &#125; &#125;&#125;/*红色绿色蓝色*/ 枚举还可以实现接口 范例： 12345678910111213141516171819202122232425262728interface IColor&#123; public String getColor();&#125;enum Color implements IColor&#123; // 实现了接口！！！ RED(\"红色\"), GREEN(\"绿色\"), BLUE(\"蓝色\"); //定义有其他内容，枚举对象定义在第一行； private String title; private Color(String title) &#123; // 构造方法不能用public this.title = title; &#125; public String toString() &#123; return this.title; &#125; @Override public String getColor() &#123; // TODO Auto-generated method stub return this.title; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IColor ic = Color.RED; System.out.println(ic.getColor()); &#125;&#125;/*红色*/ 4. 枚举应用实现一个表示性别的对象 范例： 1234567891011121314151617181920212223242526272829303132class People&#123; private String name; private int age; private Sex sex; public People(String name, int age, Sex sex) &#123; super(); this.name = name; this.age = age; this.sex = sex; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\"; &#125; &#125;enum Sex&#123; MALE(\"男\"),FEMALE(\"女\"); private String title; private Sex(String title) &#123; this.title = title; &#125; public String toString() &#123; return this.title; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; People per = new People(\"张三\",20,Sex.MALE); System.out.println(per); &#125;&#125; 枚举还支持switch判断 范例： 12345678910111213141516171819202122enum Sex&#123; MALE(\"男\"),FEMALE(\"女\"); private String title; private Sex(String title) &#123; this.title = title; &#125; public String toString() &#123; return this.title; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; switch (Sex.MALE) &#123; case MALE: System.out.println(\"是男人\"); break; case FEMALE: System.out.println(\"是女人\"); break; &#125; &#125;&#125; Annotation代码开发逻辑 项目开发：把所有地址信息写在程序里 ​ 如果地址换了，则需要修改程序， 使用一个配置文件，程序运行时要通过文件读取相关的配置操作 如果此时要更改一些配置，只需要更改配置文件即可（可以不修改源代码） 当使用配置文件后， 代码维护方便了，但开发还不是很方便；配置文件很难去修改，并且会造成一个项目的配置文件非常多； JDK提供了一种做法把配置写进代码里，但用注解来控制；这样可以减少配置文件； 主要关注三个JDK内置的注解：@override,@Deprecated,@SuppressWarnnings 1. 准确覆写 @override覆写：子类定义了与父类方法名称相同、参数类型及个数、返回值类型相同的方法的时候叫做覆写；被覆写方法不能拥有比父类更为严格的访问控制权限 范例：观察问题 123456789101112写了一个类里的toString写错成：tostring；导致没有报错；class Person&#123; // 写了一个类里的toString写错成：tostring；导致没有报错； public String tostring() &#123; return \"是个人\"; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(new Person()); &#125;&#125; 现在为了保证覆写方法严格，可以使用一个注解（@override）来检测是否覆写成功 123456class Person&#123; @Override public String tostring() &#123; return \"是个人\"; &#125;&#125; 报错：The method tostring() of type Person must override or implement a supertype method 2. 过期声明 @Deprecated如果一个程序类废止了，不能直接删除，加一个过期注解； 范例：观察过期操作 123456789101112131415class Person&#123; @Deprecated // 表明该方法过期了，但用了也没事； public Person()&#123;&#125; public Person(String name) &#123; &#125; public void fun() &#123; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Person person = new Person(); //明确表示出过期 &#125;&#125; 仅仅警告不建议在使用； 3. 压制警告 @SuppressWarnnings调用某些操作会出现警告信息。警告不代表有错误；但用压制警告可以不再提示警告 这里可以给主方法main加l也可以给person加； 123456public class TestDeme &#123; public static void main(String[] args) &#123; @SuppressWarnings(&#123; \"rawtypes\", \"unused\" &#125;) // 压制警告 Person person = new Person(); //明确表示出过期 &#125;&#125; 接口定义加强分析实际问题： 接口使用问题 造成此种情况就在于接口只是个方法的声明，而没有具体方法实现； 使用default来定义普通方法，通过对象调用 使用static来定义静态方法，通过接口名来使用 范例：定义普通方法 12345678910111213141516171819202122interface IMessage&#123; public default void fun() &#123; // 追加了普通方法体 System.out.println(\"Hello world!!\"); &#125; public void print();&#125;class Message implements IMessage&#123; @Override public void print() &#123; // TODO Auto-generated method stub System.out.println(\"你开门一直可以的\"); &#125; &#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage msg = new Message(); msg.print(); msg.fun(); &#125;&#125; 范例：追加静态方法 123456789101112131415161718192021222324252627interface IMessage&#123; public default void fun() &#123; // 追加了普通方法体 System.out.println(\"Hello world!!\"); &#125; // 可以由类名称直接调用 public static IMessage getInstance() &#123; return new Message(); &#125; public void print();&#125;class Message implements IMessage&#123; @Override public void print() &#123; // TODO Auto-generated method stub System.out.println(\"你开门一直可以的\"); &#125; &#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage msg = new Message(); msg.print(); msg.fun(); &#125;&#125; 更像抽象类了。但可以多继承；这是一种挽救设计 函数式编程1. lambda表达式12345678910111213interface IMessage&#123; public void print();&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage msg = new IMessage() &#123; public void print() &#123; System.out.println(\"Hello world!!\"); &#125; &#125;; msg.print(); &#125;&#125; 面对对象方法太完整了；使用时需要写的太多了。而使用lambda表达式就可以写出一个简单的救急函数； 函数式编程模型,同样的效果： 123456789interface IMessage&#123; public void print();&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMessage msg = ()-&gt;System.out.println(\"hello world!\"); msg.print(); &#125;&#125; 面对对象的要求在于结构必须非常完整 但是要想使用函数式编程，接口方法只能有一个； 所以可以加一个注解：@FunctionalInterface，加上这个注解的接口的方法就不能是两个及两个以上； 123456 @FunctionalInterfaceinterface IMessage&#123; //报错 public void print(); public void fun();&#125;// Invalid '@FunctionalInterface' annotation; IMessage is not a functional interface ()-&gt;括号里写参数 12345IMessage msg1 = ()-&gt;System.out.println(\"hello world!\"); // 单行语句IMessage msg2 = ()-&gt;&#123; // 多行语句 System.out.println(\"hello world!\"); System.out.println(\"hello world!\");&#125; 如果是返回，可以不写return直接写结果即可； 12345678910@FunctionalInterfaceinterface IMath&#123; public int add(int x,int y);&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IMath msg = (x,y)-&gt;x+y; System.out.println(msg.add(10, 20)); &#125;&#125; 2.方法引用数组、类有引用； 方法引用也就是别名； 引用静态方法：类名称 :: static方法名称 引用某个对象方法：实例化对象 :: 普通方法 引用某个特定类的方法：类名称 :: 普通方法 范例：引用静态方法： 在String类中有一个valueof() 1234567891011@FunctionalInterfaceinterface IUtil&lt;P,R&gt;&#123; public R transfor(P p);&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IUtil&lt;Integer,String&gt; iu = String::valueOf; // 进行方法引用 String str = iu.transfor(1000); System.out.println(str.length()); &#125;&#125; 给函数起了个别名 范例：引用某一个对象中的方法 使用大写转换 1234567891011@FunctionalInterfaceinterface IUtil&lt;R&gt;&#123; public R transfor();&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IUtil&lt;String&gt; iu = \"hello\"::toUpperCase; // 进行方法引用 System.out.println(iu.transfor()); &#125;&#125;/*HELLO*/ 范例：引用类中的普通方法 String类有一个compareTo 12345678910111213@FunctionalInterfaceinterface IUtil&lt;R,P&gt;&#123; public R transfor(P p1,P p2);&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IUtil&lt;Integer,String&gt; iu = String::compareTo; // 进行方法引用 System.out.println(iu.transfor(\"H\",\"h\")); &#125;&#125;/*-32*/ 范例:引用构造方法 123456789101112131415161718192021222324252627class Person&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; &#125;@FunctionalInterfaceinterface IUtil&lt;R,FP,SP&gt;&#123; public R transfor(FP p1,SP p2);&#125;public class TestDeme &#123; public static void main(String[] args) &#123; IUtil&lt;Person,String,Integer&gt; iu = Person::new; // 进行方法引用 System.out.println(iu.transfor(\"张三\",20)); &#125;&#125;/*Person [name=张三, age=20]*/ 3. 内建函数式接口lambda的核心在于函数式接口；函数式接口的核心在于只有一个方法；在函数式编程里面只需要有四类接口（java.util.function） 功能型的函数式接口： 1public interface Function&lt;T,R&gt; &#123;public R apply(T t);&#125; 供给型函数式接口 1public interface Supplier&lt;T&gt; &#123;public T get();&#125; 消费型函数式接口 1public interface Consumer&lt;T&gt; &#123;public void accept(T t);&#125; 断言型函数式接口 1public interface Predicate&lt;T&gt; &#123;public boolean test(T t);&#125; 范例：功能型的函数式接口 String.valueOf 12345678import java.util.function.Function;public class TestDeme &#123; public static void main(String[] args) &#123; Function&lt;Integer,String&gt; fun = String::valueOf; System.out.println(fun.apply(1000)); &#125;&#125; 输入一个数据对数据处理后再进行输出； 如果知道输入的是 Integer 可以用 IntFunction&lt;R&gt;泛型仅表示一个返回值； 范例：扩展的Function接口 12345678import java.util.function.IntFunction;public class TestDeme &#123; public static void main(String[] args) &#123; IntFunction&lt;String&gt; fun = String::valueOf; System.out.println(fun.apply(1000)); &#125;&#125; 范例：使用供给型函数式接口 “hello”.toUpperCase() 12345678import java.util.function.Supplier;public class TestDeme &#123; public static void main(String[] args) &#123; Supplier&lt;String&gt; sup = \"Hello\"::toUpperCase; System.out.println(sup.get()); &#125;&#125; 范例：消费型函数式接口 System.out.println 12345678import java.util.function.Consumer;public class TestDeme &#123; public static void main(String[] args) &#123; Consumer&lt;String&gt; fun = System.out::println; System.out.println(fun.accept(\"Hello world\")); &#125;&#125; 范例：断言型函数式接口 isempty() 12345678import java.util.function.Predicate;public class TestDeme &#123; public static void main(String[] args) &#123; Predicate&lt;String&gt; pre = \"hello\"::startsWith; System.out.println(pre.test(\"he\")); &#125;&#125; 多线程编程java的多线程编程是最大的特色 1. 进程与线程 线程启动所花费的时间一定是短的；进程一定要比线程慢； 思考：那里体现了多线程的应用 所谓的高并发指的就是访问的线程量暴高；高并发最直白的问题是：服务器的内存不够用了，无法处理过多的线程（用户） 线程实在进程基础上的一个划分。没有进程就没有线程；进程消失了，线程也就消失了； 2. 继承Thread类实现多线程实现多线程的前提是：在一个执行主类里； 有两种途径实现多线程主类： 继承Thread类 【推荐】实现Runnable、Callable接口 java.lang.Thread是核心类； 若想定义一个线程的主类，直接的方法就是继承Thread类，而后覆写其中的run()方法（相当于线程中的主方法）。 范例：定义线程主体类 123456789101112131415class MyThread extends Thread&#123; //线程主体类 private String title; public MyThread(String title) &#123; super(); this.title = title; &#125; @Override public void run() &#123; // 所有的线程从此处开始执行； // TODO Auto-generated method stub super.run(); for (int x=0;x&lt;10;x++) &#123; System.out.println(this.title+\", x = \"+x); &#125; &#125;&#125; 一般认为有了主题类就产生对象，执行run方法；但这里不能直接调用run方法； 范例：观察直接调用run方法 123456789101112131415161718public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(\"线程A\"); MyThread mt2 = new MyThread(\"线程B\"); MyThread mt3 = new MyThread(\"线程C\"); mt1.run(); mt2.run(); mt3.run(); &#125;&#125;/*线程A, x = 0线程A, x = 1线程B, x = 0线程B, x = 1线程C, x = 0线程C, x = 1*/ 仅做了一个顺序打印，和多线程没有关系；多线程也是交替执行，不是各自执行各自的； 正确启动多线程的方式是Thread类中的start方法 启动多线程：public void start() 范例：正确启动多线程 123456789101112131415161718192021public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(\"线程A\"); MyThread mt2 = new MyThread(\"线程B\"); MyThread mt3 = new MyThread(\"线程C\"); mt1.start(); mt2.start(); mt3.start(); &#125;&#125;/*线程B, x = 0线程B, x = 1线程C, x = 0线程C, x = 1线程C, x = 2线程A, x = 0线程B, x = 2线程A, x = 1线程A, x = 2*/ 此时执行代码发现所有的线程对象变为了交替执行； 为什么要这样做而不是直接执行start？ ​ 这里它查看了源代码： 每一个线程只能启动一次 3. 使用Runable接口实现多线程Thread类的核心功能是进行线程启动，但是如果一个类直接继承Thread类所造成的问题就是单继承局限； 另一种实现模式：Runnable接口 1234@FunctionalInterfacepublic interface Runnable&#123; public void run();&#125; 同时也存在一个run方法和Thread一样得 范例：利用Runnable定义线程主体类 1234567891011121314151617class MyThread implements Runnable&#123; private String title; public MyThread(String title) &#123; super(); this.title = title; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x&lt;10;x++) &#123; System.out.println(this.title + \", x=\"+x); &#125; &#125; &#125; 但是此时没有了start类，解决方法是Thread类里有一个构造方法： 1public Thread(Runnable target) 可以接收Runnable的接口对象，也就是可以通过Thread去启动它； 范例：启动多线程 123456789101112131415161718192021222324public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(\"线程A\"); MyThread mt2 = new MyThread(\"线程B\"); MyThread mt3 = new MyThread(\"线程C\"); new Thread(mt1).start(); new Thread(mt2).start(); new Thread(mt3).start(); &#125;&#125;/*线程A, x=0线程C, x=0线程B, x=0线程C, x=1线程C, x=2线程B, x=1线程A, x=1线程B, x=2线程C, x=3线程B, x=3线程A, x=2线程A, x=3*/ 这时就启动了多线程，多线程的启动永远都是THread类里的start方法； 也可以启动多个： 12345678910111213141516171819public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(\"线程A\"); MyThread mt2 = new MyThread(\"线程B\"); MyThread mt3 = new MyThread(\"线程C\"); new Thread(mt1).start(); new Thread(mt1).start(); &#125;&#125;/*线程A, x=0线程A, x=0线程A, x=1线程A, x=2线程A, x=1线程A, x=3线程A, x=2线程A, x=3*/ 此时的Runnable接口对象也可以采用匿名内部类或lambda表达式来定义 范例：通过匿名内部类定义操作 1234567891011public class TestDeme &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"Hello world!!\"); &#125; &#125;).start(); &#125;&#125; 范例：使用lambda 12345public class TestDeme &#123; public static void main(String[] args) &#123; new Thread(()-&gt;System.out.println(\"Hello world\")).start(); &#125;&#125; 4. Thread和Runnable的区别使用形式上来说Runable可以实现多继承； 但这两个都有一定的联系； 首先观察Thread类的继承定义形式 1public class Thread extends Object implements Runnable 翻开源代码看到Thread实现了Runnable中的run()方法，他写的是：如果targe不为空就运行这个target 这个target在Thread类的构造时赋值进来的。Thread初始化时把它作为属性保存了起来； 所以在多线程的处理上使用的就是代理设计模式； 实际上开发过程中Runnable还有一个特点：使用Runnable实现的多线程的程序类可以更好地描述出数据的共享的概念；（并不是说Thread不能） 目标只是希望产生若干个线程进行同一数据的处理操作 范例：使用Thread实现数据操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyThread extends Thread&#123; private int ticket = 10; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 10; x++) &#123; if (this.ticket&gt;0) &#123; System.out.println(\"卖票，票剩 = \"+ this.ticket--); &#125; &#125; &#125; &#125;public class TestDeme &#123; public static void main(String[] args) &#123; new MyThread().start(); new MyThread().start(); new MyThread().start(); &#125;&#125;/*卖票，票剩 = 10卖票，票剩 = 9卖票，票剩 = 8卖票，票剩 = 7卖票，票剩 = 6卖票，票剩 = 5卖票，票剩 = 4卖票，票剩 = 3卖票，票剩 = 2卖票，票剩 = 1卖票，票剩 = 10卖票，票剩 = 10卖票，票剩 = 9卖票，票剩 = 9卖票，票剩 = 8卖票，票剩 = 8卖票，票剩 = 7卖票，票剩 = 7卖票，票剩 = 6卖票，票剩 = 5卖票，票剩 = 6卖票，票剩 = 4卖票，票剩 = 5卖票，票剩 = 3卖票，票剩 = 2卖票，票剩 = 1卖票，票剩 = 4卖票，票剩 = 3卖票，票剩 = 2卖票，票剩 = 1 */ 各自卖各自的10张票 范例：用Thraed实现数据共享 1234567891011121314151617181920public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); &#125;&#125;/*卖票，票剩 = 10卖票，票剩 = 9卖票，票剩 = 7卖票，票剩 = 8卖票，票剩 = 5卖票，票剩 = 6卖票，票剩 = 3卖票，票剩 = 4卖票，票剩 = 1卖票，票剩 = 2 */ 它把同一堆内存空间（MyThread对象）传给了一个新的Thread对象让其各自start；但是这样有点多此一举，因为MyThread也有继承自Thread里的start方法；它用了别人的 此时的MyThread对象各自有各自的空间就像图中上面的这个； 范例：实现Runnable实现数据共享 123456789101112131415161718192021222324252627282930313233class MyThread implements Runnable&#123; private int ticket = 10; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 10; x++) &#123; if (this.ticket&gt;0) &#123; System.out.println(\"卖票，票剩 = \"+ this.ticket--); &#125; &#125; &#125; &#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); &#125;&#125;/*卖票，票剩 = 10卖票，票剩 = 8卖票，票剩 = 7卖票，票剩 = 6卖票，票剩 = 5卖票，票剩 = 4卖票，票剩 = 3卖票，票剩 = 2卖票，票剩 = 1卖票，票剩 = 9 */ 此时Runnable是没有start()方法的它传给Thread类是合适的 5. 线程运行状态 调用了start不是立即执行，而是就绪，等待资源分配给了线程后才进入运行资源； 6. 通过Callable实现多线程JDK1.5加入了一个新的开发包：java.util.concurrent,主要进行高性能开发使用的，提供高并发操作才会用到的类。在这个包里面定义有一个新接口Callable 123public interface Callable&lt;V&gt;&#123; public V call() throws Exception&#125; Runnable虽也是线程主方法，但是它么有返回值；很多时候需要返回值时就可以用Callable 范例：使用Callable定义线程主体类 123456789101112import java.util.concurrent.Callable;class MyThread implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 10; x++) &#123; System.out.println(\"卖票，x = \"+ x); &#125; return \"票卖完了\"; &#125;&#125; Thread貌似与Callable没啥关系但通过分析得出以下的关系图 范例：启动Callable多线程 1234567891011121314151617181920public class TestDeme &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new MyThread()); new Thread(task).start(); System.out.println(task.get()); &#125;&#125;/*卖票，x = 0卖票，x = 1卖票，x = 2卖票，x = 3卖票，x = 4卖票，x = 5卖票，x = 6卖票，x = 7卖票，x = 8卖票，x = 9票卖完了 */ 多线程常用操作方法多线程的主要操作方法都在Thread里面。重点掌握核心几个方法就可以了； 1. 线程的命名及取得Thread类里提供了如下的名称操作方法； No. 方法 类型 描述 1 public Thread(Runnable target, String name) 构造 创建线程对象时设置好名字 2 public final void setName(String name) 普通 设置线程名字 3 public final String getName() 普通 取得线程名字 如果想要取得线程的对象，在Thread类有一个方法： 取得当前线程对象：public static Thread currentThread()； 范例：观察线程名称的取得 12345678910111213141516171819202122232425262728293031class MyThread implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 4; x++) &#123; System.out.println(Thread.currentThread().getName()+\",x = \"+x); &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt,\"有名线程\").start(); &#125;&#125;/*Thread-0,x = 0Thread-0,x = 1有名线程,x = 0Thread-1,x = 0有名线程,x = 1Thread-0,x = 2有名线程,x = 2Thread-1,x = 1Thread-1,x = 2Thread-1,x = 3有名线程,x = 3Thread-0,x = 3 */ 没有设置线程名字会自动分配一个； 范例：观察线程执行结果 123456789101112131415161718class MyThread implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()); &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.run(); // 通过对象调用run方法 main new Thread(mt).start(); //没有名字通过线程调用 Thread-0 &#125;&#125;/*mainThread-0 */ 主方法就是一个线程；其他线程就是由主线程创建的 2. 线程休眠用来模拟延迟操作； 指的是让线程暂缓执行，等到了一定的时间再运行； 方法： 1public static void sleep(long millis) throws InterruptedException 休眠实现使用毫秒为单位 范例：休眠操作 123456789101112131415class MyThread implements Runnable &#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 20; x++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\",x = \"+x); &#125; &#125;&#125; 进入代码的顺序有差异，但他们的执行基本是并发执行 3. 线程中断线程被打断一定是由其他线程完成的；Thread类里提供的中断执行处理方法： 判断线程是否被中断：public boolean isInterrupted() 中断线程执行：public void interrupt(); 范例：观察线程中断处理 12345678910111213141516171819202122232425public class TestDeme &#123; public static void main(String[] args) &#123; Thread thread = new Thread(()-&gt;&#123; System.out.println(\"我想睡觉\"); try &#123; Thread.sleep(10000); System.out.println(\"睡够了！！\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block System.out.println(\"谁把我弄醒了\"); &#125; &#125;); thread.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (!thread.isInterrupted()) &#123; System.out.println(\"打扰你睡眠\"); thread.interrupt(); &#125; &#125;&#125; 所有执行的线程都是可以被中断的； 4. 线程强制执行线程强制执行是指当满足某些条件之后，某一线程对象将可以一直独占资源，一直到程序执行结束； 范例：没有强制执行的程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestDeme &#123; public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; for (int x = 0; x &lt; 20; x++) &#123; System.out.println(Thread.currentThread().getName() + \",x = \" + x); &#125; &#125;, \"正常的线程\"); thread.start(); for (int x = 0; x &lt; 20; x++) &#123; System.out.println(\"[霸道的Main线程] Number = \" + x); &#125; &#125;&#125;/*[霸道的Main线程] Number = 0正常的线程,x = 0[霸道的Main线程] Number = 1正常的线程,x = 1[霸道的Main线程] Number = 2正常的线程,x = 2[霸道的Main线程] Number = 3[霸道的Main线程] Number = 4正常的线程,x = 3[霸道的Main线程] Number = 5正常的线程,x = 4[霸道的Main线程] Number = 6[霸道的Main线程] Number = 7[霸道的Main线程] Number = 8[霸道的Main线程] Number = 9[霸道的Main线程] Number = 10[霸道的Main线程] Number = 11[霸道的Main线程] Number = 12正常的线程,x = 5[霸道的Main线程] Number = 13正常的线程,x = 6[霸道的Main线程] Number = 14正常的线程,x = 7[霸道的Main线程] Number = 15[霸道的Main线程] Number = 16[霸道的Main线程] Number = 17[霸道的Main线程] Number = 18[霸道的Main线程] Number = 19正常的线程,x = 8正常的线程,x = 9正常的线程,x = 10正常的线程,x = 11 */ 强制执行的方法： 1public final void join() throws InterruptedException 范例：强制执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TestDeme &#123; public static void main(String[] args) &#123; Thread MainThread = Thread.currentThread(); // 获得主线程 Thread thread = new Thread(() -&gt; &#123; for (int x = 0; x &lt; 20; x++) &#123; if (x&gt;3) &#123; try &#123; MainThread.join(); // 霸道线程独占！ &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + \",x = \" + x); &#125; &#125;, \"正常的线程\"); thread.start(); for (int x = 0; x &lt; 20; x++) &#123; System.out.println(\"[霸道的Main线程] Number = \" + x); &#125; &#125;&#125;/*[霸道的Main线程] Number = 0[霸道的Main线程] Number = 1正常的线程,x = 0[霸道的Main线程] Number = 2正常的线程,x = 1[霸道的Main线程] Number = 3正常的线程,x = 2[霸道的Main线程] Number = 4正常的线程,x = 3[霸道的Main线程] Number = 5[霸道的Main线程] Number = 6[霸道的Main线程] Number = 7[霸道的Main线程] Number = 8[霸道的Main线程] Number = 9[霸道的Main线程] Number = 10[霸道的Main线程] Number = 11[霸道的Main线程] Number = 12[霸道的Main线程] Number = 13[霸道的Main线程] Number = 14[霸道的Main线程] Number = 15[霸道的Main线程] Number = 16[霸道的Main线程] Number = 17[霸道的Main线程] Number = 18[霸道的Main线程] Number = 19正常的线程,x = 4正常的线程,x = 5正常的线程,x = 6正常的线程,x = 7正常的线程,x = 8正常的线程,x = 9正常的线程,x = 10正常的线程,x = 11正常的线程,x = 12正常的线程,x = 13正常的线程,x = 14正常的线程,x = 15正常的线程,x = 16正常的线程,x = 17正常的线程,x = 18正常的线程,x = 19 */ 5.线程礼让先将资源让出去，让别的线程先完成；用Thread中的方法： 礼让：public static void yield() 123456789101112131415161718public class TestDeme &#123; public static void main(String[] args) &#123; Thread MainThread = Thread.currentThread(); // 获得主线程 Thread thread = new Thread(() -&gt; &#123; for (int x = 0; x &lt; 20; x++) &#123; if (x%3==0) &#123; Thread.yield(); System.out.println(\"#####子线程礼让执行\"); &#125; System.out.println(Thread.currentThread().getName() + \",x = \" + x); &#125; &#125;, \"正常的线程\"); thread.start(); for (int x = 0; x &lt; 20; x++) &#123; System.out.println(\"[霸道的Main线程] Number = \" + x); &#125; &#125;&#125; 每一次礼让只会礼让当前一次的资源；可能就是一次程序轮转的机会； 6. 线程优先级优先级越高越有可能先执行 Thread类里有以下优先级操作： 设置优先级：public final void setPriority(int newPriority) 取得优先级：public final int getPriority() 对于优先级设置的内容可以通过Thread类的几个常量来决定； 最高优先级：public static final int MAX_PRIORITY 中等优先级：public static final int NORM_PRIORITY 最低优先级：public static final int MIN_PRIORITY 范例：设置优先级 123456789101112131415161718192021222324252627282930class MyThread implements Runnable &#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 20; x++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \",x = \" + x); &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); Thread t1 = new Thread(mt,\"线程A\"); Thread t2 = new Thread(mt,\"线程B\"); Thread t3 = new Thread(mt,\"线程C\"); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t3.setPriority(Thread.NORM_PRIORITY); t1.start(); t2.start(); t3.start(); &#125; &#125; 主方法是一个线程，那么主线程的优先级可以这么得到： 123456public class TestDeme &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getPriority()); &#125; &#125;// 5 中等优先级 线程的同步与死锁1.同步问题的引出编写一个卖票操作 1234567891011121314151617181920212223class MyThread implements Runnable &#123; private int ticket = 10; //总票数 @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; if (this.ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName()+\",剩余票数\"+this.ticket--); &#125; else &#123; System.out.println(\"**票卖光了**\"); break; &#125; &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt,\"票贩子A\").start(); new Thread(mt,\"票贩子B\").start(); new Thread(mt,\"票贩子C\").start(); &#125; &#125; 三个票贩子卖十张票；看似没有问题，但这是有问题的，加入延迟操作来查看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyThread implements Runnable &#123; private int ticket = 10; //总票数 @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; if (this.ticket&gt;0) &#123; try &#123; Thread.sleep(100); // 模拟网络延迟 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\",剩余票数\"+this.ticket--); &#125; else &#123; System.out.println(\"**票卖光了**\"); break; &#125; &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt,\"票贩子A\").start(); new Thread(mt,\"票贩子B\").start(); new Thread(mt,\"票贩子C\").start(); &#125; &#125;/*票贩子C,剩余票数10票贩子B,剩余票数9票贩子A,剩余票数8票贩子C,剩余票数7票贩子B,剩余票数6票贩子A,剩余票数5票贩子C,剩余票数4票贩子B,剩余票数3票贩子A,剩余票数2票贩子C,剩余票数1**票卖光了**票贩子B,剩余票数0**票卖光了**票贩子A,剩余票数-1**票卖光了** */ 2. 线程同步处理同步问题的解决关键是锁：当一个线程执行操作的时候，其他线程外边等着； 要实现这把锁的功能，就要用synchronized关键字来实现，利用此关键字可以定义同步方法或者同步代码块；在同步代码块里只允许一个线程执行； 利用同步代码块来执行 123synchronized(同步对象)&#123; 同步代码操作； &#125; ​ 一般进行同步对象，处理的时候采用当前对象this进行同步； 范例：利用同步代码块解决数据同步访问问题 1234567891011121314151617181920212223242526272829303132class MyThread implements Runnable &#123; private int ticket = 10; //总票数 @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; synchronized(this) &#123; // 每一次只允许一个线程进行访问 if (this.ticket&gt;0) &#123; try &#123; Thread.sleep(50); // 模拟网络延迟 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\",剩余票数\"+this.ticket--); &#125; else &#123; System.out.println(\"**票卖光了**\"); break; &#125; &#125; &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt,\"票贩子A\").start(); new Thread(mt,\"票贩子B\").start(); new Thread(mt,\"票贩子C\").start(); &#125; &#125; 加入同步解决了上述的问题，但是一个线程运行的时间太长了；同步实际上造成了性能的降低； 利用同步方法解决：只需要在方法定义上使用synchronized; 范例：同步方法 123456789101112131415161718192021222324252627282930313233class MyThread implements Runnable &#123; private int ticket = 10; //总票数 public synchronized boolean sale() &#123; if (this.ticket&gt;0) &#123; try &#123; Thread.sleep(50); // 模拟网络延迟 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\",剩余票数\"+this.ticket--); return true; &#125; else &#123; System.out.println(\"**票卖光了**\"); return false; &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub while (this.sale()) &#123; &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt,\"票贩子A\").start(); new Thread(mt,\"票贩子B\").start(); new Thread(mt,\"票贩子C\").start(); &#125; &#125; 同步会造成性能的下降 3. 线程死锁死锁是在进行多线程同步处理之中有可能产生的一种问题，所谓的死锁指的是若干个线程彼此等待对方释放资源的过程； 范例：死锁展示 1234567891011121314151617181920212223242526272829303132333435class Wang&#123; public synchronized void say(Li l) &#123; System.out.println(\"【王】要想过路先交钱！！\"); l.get(); &#125; public synchronized void get() &#123; System.out.println(\"【王】拿到钱了！！你过吧\"); &#125;&#125;class Li&#123; public synchronized void say(Wang w) &#123; System.out.println(\"【李】先过路再交钱！！\"); w.get(); &#125; public synchronized void get() &#123; System.out.println(\"【李】过来了，还是先跑吧\"); &#125;&#125;public class DeadLock implements Runnable &#123; private Wang w = new Wang(); private Li l = new Li(); public DeadLock() &#123; new Thread(this).start(); l.say(w); &#125; @Override public void run() &#123; // TODO Auto-generated method stub w.say(l); &#125; public static void main(String[] args) &#123; new DeadLock(); &#125;&#125; 综合实战：”生产者-消费者“模型流程如下： 生产者负责信息内容的生产 每当生产者生产完一项完整的信息之后消费者要从这里取走信息； 如果生产者没有生产则消费者要等待他生产完成； 如果消费者没有及时对信息进行消费，则生产者应该等待消费完成之后再继续生产； 1. 生产者消费者基本程序模型将生产者与消费者定义为两个独立的线程类对象，对于生产的数据可以使用如下的组成 数据一： 数据二： 两个线程独立，那么两个线程之间需要有一个存放数据的地方 范例：实现基本结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Producter implements Runnable&#123; private Message msg ; public Producter(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; if (x%2==0) &#123; this.msg.setTitle(\"小王\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.msg.setContent(\"宇宙大帅哥\"); &#125; else &#123; this.msg.setTitle(\"小李\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.msg.setContent(\"猥琐第一人\"); &#125; &#125; &#125; &#125;class Consumer implements Runnable&#123; private Message msg ; public Consumer(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(this.msg.getTitle()+\" - \"+this.msg.getContent()); &#125; &#125; &#125;class Message&#123; private String title; private String content; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producter(msg)).start(); new Thread(new Consumer(msg)).start(); &#125; &#125;/*小王 - null小王 - null小王 - null小王 - null小王 - null小王 - null小王 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小李 - 宇宙大帅哥小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小王 - 猥琐第一人小李 - 宇宙大帅哥小李 - 宇宙大帅哥 */ 通过程序执行法系拿了两个问题： 问题一：数据不同步； 问题二：应该生产一个取走一个，但发现有了重复生产，重复取出的问题 2. 解决消费者-生产者同步问题最简单的解决同步使用synchronized关键字； 把数据的set与get的同步交给Message类来处理； 范例：解决同步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Producter implements Runnable&#123; private Message msg ; public Producter(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; if (x%2==0) &#123; this.msg.set(\"小王\",\"宇宙大帅哥\",x); &#125; else &#123; this.msg.set(\"小李\",\"猥琐第一人\",x); &#125; &#125; &#125; &#125;class Consumer implements Runnable&#123; private Message msg ; public Consumer(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; System.out.println(\"第\" + x + \"次取值： \"+ this.msg.get()); &#125; &#125; &#125;class Message&#123; private String title; private String content; private int id; // 生产批号 public synchronized void set(String title,String content,int id) &#123; this.title = title; this.id = id; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.content = content; &#125; public synchronized String get() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return this.title+\" - \"+this.content+\" -id- \"+this.id; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producter(msg)).start(); new Thread(new Consumer(msg)).start(); &#125; &#125;/*第0次取值： 小王 - 宇宙大帅哥 -id- 0第1次取值： 小李 - 猥琐第一人 -id- 1第2次取值： 小王 - 宇宙大帅哥 -id- 2第3次取值： 小王 - 宇宙大帅哥 -id- 14第4次取值： 小王 - 宇宙大帅哥 -id- 28第5次取值： 小李 - 猥琐第一人 -id- 33第6次取值： 小李 - 猥琐第一人 -id- 37第7次取值： 小王 - 宇宙大帅哥 -id- 40第8次取值： 小王 - 宇宙大帅哥 -id- 42第9次取值： 小李 - 猥琐第一人 -id- 45第10次取值： 小李 - 猥琐第一人 -id- 47第11次取值： 小李 - 猥琐第一人 -id- 49第12次取值： 小李 - 猥琐第一人 -id- 53第13次取值： 小王 - 宇宙大帅哥 -id- 56第14次取值： 小李 - 猥琐第一人 -id- 57第15次取值： 小李 - 猥琐第一人 -id- 59第16次取值： 小王 - 宇宙大帅哥 -id- 62第17次取值： 小王 - 宇宙大帅哥 -id- 64第18次取值： 小李 - 猥琐第一人 -id- 65第19次取值： 小王 - 宇宙大帅哥 -id- 66第20次取值： 小王 - 宇宙大帅哥 -id- 68第21次取值： 小李 - 猥琐第一人 -id- 69第22次取值： 小王 - 宇宙大帅哥 -id- 70第23次取值： 小李 - 猥琐第一人 -id- 71第24次取值： 小王 - 宇宙大帅哥 -id- 78第25次取值： 小王 - 宇宙大帅哥 -id- 84第26次取值： 小李 - 猥琐第一人 -id- 85第27次取值： 小李 - 猥琐第一人 -id- 87第28次取值： 小王 - 宇宙大帅哥 -id- 88第29次取值： 小李 - 猥琐第一人 -id- 89第30次取值： 小李 - 猥琐第一人 -id- 91第31次取值： 小王 - 宇宙大帅哥 -id- 92第32次取值： 小李 - 猥琐第一人 -id- 99第33次取值： 小李 - 猥琐第一人 -id- 99第34次取值： 小李 - 猥琐第一人 -id- 99第35次取值： 小李 - 猥琐第一人 -id- 99第36次取值： 小李 - 猥琐第一人 -id- 99 */ 可以看出他们的信息同步了，但是生产者-消费者之间的协作还不够；存在消费者重复操作的问题； 3. 利用Object类解决重复操作：线程等待与唤醒机制等待与唤醒利用Object类中的三个方法： 等待机制： 死等： 1public final void wait() throws InterruptedException 设置等待时间 1public final void wait(long timeout) throws InterruptedException 设置等待时间： 1public final void wait(long timeout, int nanos) throws InterruptedException 唤醒机制 唤醒第一个等待进程 1public final void notify() // 有若干个等待线程，唤醒其中的的第一个等待的； 唤醒全部等待线程 1public final void notify() // 唤醒所有的等待进程 范例：修改Message类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195class Producter implements Runnable&#123; private Message msg ; public Producter(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; if (x%2==0) &#123; this.msg.set(\"小王\",\"宇宙大帅哥\",x); &#125; else &#123; this.msg.set(\"小李\",\"猥琐第一人\",x); &#125; &#125; &#125; &#125;class Consumer implements Runnable&#123; private Message msg ; public Consumer(Message msg) &#123; super(); this.msg = msg; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0;x&lt;100;x++) &#123; System.out.println(\"第\" + x + \"次取值： \"+ this.msg.get()); &#125; &#125; &#125;class Message&#123; private String title; private String content; private int id; // 生产批号 private boolean flag = true; // flag = True 允许生产，不许消费 // flag = False 允许消费不许生产 public synchronized void set(String title,String content,int id) &#123; if(!this.flag) &#123; try &#123; super.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; this.title = title; this.id = id; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.content = content; this.flag = false; super.notify(); &#125; public synchronized String get() &#123; if (this.flag) &#123; try &#123; super.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; return this.title+\" - \"+this.content+\" -id- \"+this.id; &#125; finally &#123; this.flag = true; super.notify(); &#125; &#125;&#125;public class TestDeme &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producter(msg)).start(); new Thread(new Consumer(msg)).start(); &#125; &#125;/*第0次取值： 小王 - 宇宙大帅哥 -id- 0第1次取值： 小李 - 猥琐第一人 -id- 1第2次取值： 小王 - 宇宙大帅哥 -id- 2第3次取值： 小李 - 猥琐第一人 -id- 3第4次取值： 小王 - 宇宙大帅哥 -id- 4第5次取值： 小李 - 猥琐第一人 -id- 5第6次取值： 小王 - 宇宙大帅哥 -id- 6第7次取值： 小李 - 猥琐第一人 -id- 7第8次取值： 小王 - 宇宙大帅哥 -id- 8第9次取值： 小李 - 猥琐第一人 -id- 9第10次取值： 小王 - 宇宙大帅哥 -id- 10第11次取值： 小李 - 猥琐第一人 -id- 11第12次取值： 小王 - 宇宙大帅哥 -id- 12第13次取值： 小李 - 猥琐第一人 -id- 13第14次取值： 小王 - 宇宙大帅哥 -id- 14第15次取值： 小李 - 猥琐第一人 -id- 15第16次取值： 小王 - 宇宙大帅哥 -id- 16第17次取值： 小李 - 猥琐第一人 -id- 17第18次取值： 小王 - 宇宙大帅哥 -id- 18第19次取值： 小李 - 猥琐第一人 -id- 19第20次取值： 小王 - 宇宙大帅哥 -id- 20第21次取值： 小李 - 猥琐第一人 -id- 21第22次取值： 小王 - 宇宙大帅哥 -id- 22第23次取值： 小李 - 猥琐第一人 -id- 23第24次取值： 小王 - 宇宙大帅哥 -id- 24第25次取值： 小李 - 猥琐第一人 -id- 25第26次取值： 小王 - 宇宙大帅哥 -id- 26第27次取值： 小李 - 猥琐第一人 -id- 27第28次取值： 小王 - 宇宙大帅哥 -id- 28第29次取值： 小李 - 猥琐第一人 -id- 29第30次取值： 小王 - 宇宙大帅哥 -id- 30第31次取值： 小李 - 猥琐第一人 -id- 31第32次取值： 小王 - 宇宙大帅哥 -id- 32第33次取值： 小李 - 猥琐第一人 -id- 33第34次取值： 小王 - 宇宙大帅哥 -id- 34第35次取值： 小李 - 猥琐第一人 -id- 35第36次取值： 小王 - 宇宙大帅哥 -id- 36第37次取值： 小李 - 猥琐第一人 -id- 37第38次取值： 小王 - 宇宙大帅哥 -id- 38第39次取值： 小李 - 猥琐第一人 -id- 39第40次取值： 小王 - 宇宙大帅哥 -id- 40第41次取值： 小李 - 猥琐第一人 -id- 41第42次取值： 小王 - 宇宙大帅哥 -id- 42第43次取值： 小李 - 猥琐第一人 -id- 43第44次取值： 小王 - 宇宙大帅哥 -id- 44第45次取值： 小李 - 猥琐第一人 -id- 45第46次取值： 小王 - 宇宙大帅哥 -id- 46第47次取值： 小李 - 猥琐第一人 -id- 47第48次取值： 小王 - 宇宙大帅哥 -id- 48第49次取值： 小李 - 猥琐第一人 -id- 49第50次取值： 小王 - 宇宙大帅哥 -id- 50第51次取值： 小李 - 猥琐第一人 -id- 51第52次取值： 小王 - 宇宙大帅哥 -id- 52第53次取值： 小李 - 猥琐第一人 -id- 53第54次取值： 小王 - 宇宙大帅哥 -id- 54第55次取值： 小李 - 猥琐第一人 -id- 55第56次取值： 小王 - 宇宙大帅哥 -id- 56第57次取值： 小李 - 猥琐第一人 -id- 57第58次取值： 小王 - 宇宙大帅哥 -id- 58第59次取值： 小李 - 猥琐第一人 -id- 59第60次取值： 小王 - 宇宙大帅哥 -id- 60第61次取值： 小李 - 猥琐第一人 -id- 61第62次取值： 小王 - 宇宙大帅哥 -id- 62第63次取值： 小李 - 猥琐第一人 -id- 63第64次取值： 小王 - 宇宙大帅哥 -id- 64第65次取值： 小李 - 猥琐第一人 -id- 65第66次取值： 小王 - 宇宙大帅哥 -id- 66第67次取值： 小李 - 猥琐第一人 -id- 67第68次取值： 小王 - 宇宙大帅哥 -id- 68第69次取值： 小李 - 猥琐第一人 -id- 69第70次取值： 小王 - 宇宙大帅哥 -id- 70第71次取值： 小李 - 猥琐第一人 -id- 71第72次取值： 小王 - 宇宙大帅哥 -id- 72第73次取值： 小李 - 猥琐第一人 -id- 73第74次取值： 小王 - 宇宙大帅哥 -id- 74第75次取值： 小李 - 猥琐第一人 -id- 75第76次取值： 小王 - 宇宙大帅哥 -id- 76第77次取值： 小李 - 猥琐第一人 -id- 77第78次取值： 小王 - 宇宙大帅哥 -id- 78第79次取值： 小李 - 猥琐第一人 -id- 79第80次取值： 小王 - 宇宙大帅哥 -id- 80第81次取值： 小李 - 猥琐第一人 -id- 81第82次取值： 小王 - 宇宙大帅哥 -id- 82第83次取值： 小李 - 猥琐第一人 -id- 83第84次取值： 小王 - 宇宙大帅哥 -id- 84第85次取值： 小李 - 猥琐第一人 -id- 85第86次取值： 小王 - 宇宙大帅哥 -id- 86第87次取值： 小李 - 猥琐第一人 -id- 87第88次取值： 小王 - 宇宙大帅哥 -id- 88第89次取值： 小李 - 猥琐第一人 -id- 89第90次取值： 小王 - 宇宙大帅哥 -id- 90第91次取值： 小李 - 猥琐第一人 -id- 91第92次取值： 小王 - 宇宙大帅哥 -id- 92第93次取值： 小李 - 猥琐第一人 -id- 93第94次取值： 小王 - 宇宙大帅哥 -id- 94第95次取值： 小李 - 猥琐第一人 -id- 95第96次取值： 小王 - 宇宙大帅哥 -id- 96第97次取值： 小李 - 猥琐第一人 -id- 97第98次取值： 小王 - 宇宙大帅哥 -id- 98第99次取值： 小李 - 猥琐第一人 -id- 99 */ 注意初始的flag应设置为true让它能够生产 多线程深入话题1. 优雅的停止线程原本提供了stop方法，destory方法，suspend方法，resume方法（回复挂起线程执行）；需要一种柔和的方式在进行线程停止； 范例：实现柔和的停止 123456789101112131415161718192021222324public class ThreadDemo &#123; public static boolean flag = true; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; long num = 0; while(flag) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" 正在运行\"+ num++); &#125; &#125;,\"执行线程\").start(); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; flag = false; &#125;&#125; 其他线程控制这个flag，也不是说立马就能停止，而是根据flag的内容来判断的； 2. 后台守护线程所以多线程里可以进行守护线程 在Thread类里提供的守护线程的操作方法： 设置为守护线程： 1public final void setDaemon(boolean on) 判断是否为守护线程 1public final boolean isDaemon() 范例：使用守护线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ThreadDemo &#123; public static boolean flag = true; public static void main(String[] args) &#123; Thread userThread = new Thread(() -&gt; &#123; for (int x = 0;x&lt;10;x++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" 正在运行\"+ x); &#125; &#125;,\"用户线程\"); // 完成核心业务 Thread daemonThread = new Thread(() -&gt; &#123; for (int x = 0;x&lt;Integer.MAX_VALUE;x++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\" 正在运行\"+ x); &#125; &#125;,\"守护线程\"); daemonThread.setDaemon(true); userThread.start(); daemonThread.start(); &#125;&#125;/*守护线程 正在运行0用户线程 正在运行0守护线程 正在运行1用户线程 正在运行1守护线程 正在运行2用户线程 正在运行2守护线程 正在运行3用户线程 正在运行3用户线程 正在运行4守护线程 正在运行4用户线程 正在运行5守护线程 正在运行5守护线程 正在运行6用户线程 正在运行6守护线程 正在运行7用户线程 正在运行7用户线程 正在运行8守护线程 正在运行8用户线程 正在运行9守护线程 正在运行9 * */ 用户线程完毕了，守护线程也就消失了。java程序中最大的守护线程就是GC线程； 3. volatile关键字volatile关键字是在属性定义上使用的，表示此属性为直接数据操作，而不进行副本的拷贝处理；但是他不是同步操作； 在进行变量处理的时候会进行如下几个步骤： 获取变量原有的数据内容副本 利用副本为变量及逆行数学计算 将计算后的变量保存到原始空间中 如果属性加了 volatile关键字，表示就是不使用副本，而是直接在原变量上操作’； 面试题：volatile关键字与sychronized的区别： volatile在属性，sychronized在代码块与方法上使用； volatile无法描述同步处理，只是一种直接内存的处理 线程池所谓的线程池就是多个线程封装在一起进行操作 1. 线程池简介用来处理问题的线程池不同情况下： 要解决的活很大有多少人来多少人 活很大，但要求只招聘10个人 活虽然很大，但只允许一个人做 JDK 1.5后追加了一并发访问的程序包：java.util.concurrent，对于线程池操作的核心类和接口就定义在此包之中，这里面有两个核心的接口： 普通的执行线程池定义 1java.util.concurrent.ExecutorService 调度线程池： 1java.util.concurrent.ScheduledExecutorService 要进行线程池的创建，一般可以使用java.util.concurrent.Executors 类完成，有以下几个方法： 创建无大小限制的线程池： 1public static ExecutorService newCachedThreadPool() 创建固定大小的线性池： 1public static ExecutorService newFixedThreadPool(int nThreads,ThreadFactorythreadFactory) 单线程池： 1public static ScheduledExecutorService newSingleThreadScheduledExecutor() 创建定时调度池 1public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 2. 线程池的实现 无限大小的线程池 1234567891011121314151617import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建了线程池模型，但里面没有线程 ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();//核心 for (int x = 0;x&lt;10;x++) &#123; Thread.sleep(200); int index = x; newCachedThreadPool.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \",x = \"+ index); &#125;); &#125; newCachedThreadPool.shutdown(); // 关闭线程池 &#125;&#125; 创建单线程线程池 12345678910111213public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建了线程池模型，但里面没有线程 ExecutorService newCachedThreadPool = Executors.newSingleThreadScheduledExecutor(); //核心 for (int x = 0;x&lt;10;x++) &#123; int index = x; newCachedThreadPool.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \",x = \"+ index); &#125;); &#125; newCachedThreadPool.shutdown(); // 关闭线程池 &#125;&#125; 创建固定大小的线程池 12345678910111213141516import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建了线程池模型，但里面没有线程 ExecutorService newCachedThreadPool = Executors.newFixedThreadPool(3); //核心 for (int x = 0;x&lt;10;x++) &#123; int index = x; newCachedThreadPool.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \",x = \"+ index); &#125;); &#125; newCachedThreadPool.shutdown(); // 关闭线程池 &#125;&#125; 定时调度池 12345678910111213141516171819202122import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 三个大小的定时调度池 ScheduledExecutorService newCachedThreadPool = Executors.newScheduledThreadPool(1); for (int x = 0;x&lt;10;x++) &#123; int index = x; newCachedThreadPool.scheduleAtFixedRate(new Runnable()&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName() + \",x = \"+ index); &#125; &#125;, 3, 2, TimeUnit.SECONDS); // 使用的是秒的单位，表示3秒后执行，而后每2秒执行一次 &#125; newCachedThreadPool.shutdown(); // 关闭线程池 &#125;&#125; 多线程综合案例1. 数字加减设计4个线程对象，两个线程执行减操作，两个线程执行加操作； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class ThreadDemo &#123; public static void main(String[] args)&#123; Resource res = new Resource(); AddThread at = new AddThread(res); SubThread st = new SubThread(res); new Thread(at,\"加法线程 - A\").start(); new Thread(at,\"加法线程 - B\").start(); new Thread(st,\"减法线程 - X\").start(); new Thread(st,\"减法线程 - Y\").start(); &#125;&#125;class AddThread implements Runnable&#123; private Resource resource; public AddThread(Resource resource) &#123; super(); this.resource = resource; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 50; x++) &#123; try &#123; this.resource.add(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;class SubThread implements Runnable&#123; private Resource resource; public SubThread(Resource resource) &#123; super(); this.resource = resource; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 50; x++) &#123; try &#123; this.resource.sub(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;class Resource&#123; private int num = 0; private boolean flag = true; // flag : true 可加 不可减 // flag : false 可减不可加 public synchronized void add() throws InterruptedException &#123; if (this.flag == false) &#123; super.wait(); &#125; Thread.sleep(100); this.num++; System.out.println(\"【加法操作- \"+Thread.currentThread().getName()+\"】 num = \"+this.num ); this.flag = false; super.notifyAll(); &#125; public synchronized void sub() throws InterruptedException &#123; if (this.flag == true) &#123; super.wait(); &#125; Thread.sleep(200); this.num--; System.out.println(\"【减法操作- \"+Thread.currentThread().getName()+\"】 num = \"+this.num ); this.flag = true; super.notifyAll(); &#125;&#125; 2. 生产电脑要求生产出来一台电脑就搬走一台电脑； 如果没有新的电脑生产出来，搬运工要等电脑生产出来； 如果没有搬走则要等电脑搬走后再生产，并统计处生产的电脑数量； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ThreadDemo &#123; public static void main(String[] args)&#123; Resource res = new Resource(); new Thread(new Producer(res)).start(); new Thread(new Remover(res)).start(); &#125;&#125;class Remover implements Runnable&#123; private Resource res; public Remover(Resource res) &#123; super(); this.res = res; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x&lt;50;x++) &#123; try &#123; res.get(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;class Producer implements Runnable&#123; private Resource res; public Producer(Resource res) &#123; super(); this.res = res; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for (int x = 0; x &lt; 50; x++) &#123; try &#123; res.make(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;class Resource&#123; private Computer computer; public synchronized void make() throws InterruptedException &#123; if (this.computer != null) &#123; super.wait(); &#125; Thread.sleep(200); this.computer = new Computer(\"联想牌\",1.1); System.out.println(\"【生产电脑】： \"+this.computer); super.notifyAll(); &#125; public synchronized void get() throws InterruptedException &#123; if (this.computer == null) &#123; super.wait(); &#125; System.out.println(\"【取走电脑】： \"+this.computer); this.computer = null; super.notifyAll(); &#125;&#125;class Computer&#123; private static int count = 0; // 生产个数 private String name; private double price; public Computer(String name, double price) &#123; super(); this.name = name; this.price = price; this.count ++; &#125; @Override public String toString() &#123; return \"第\"+count+\"台电脑\"+\"Coumputer [name=\" + name + \", price=\" + price + \"]\"; &#125;&#125; 3. 竞争抢答有三个抢答者。同时发出抢答指令，抢答成功者给出成功提示，未抢答成功的给出失败提示； 这是看到有返回，则用Callable是比较合适的； 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.jubingyi.Demo;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException&#123; MyThread mt = new MyThread(); FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mt); FutureTask&lt;String&gt; taskB = new FutureTask&lt;String&gt;(mt); FutureTask&lt;String&gt; taskC = new FutureTask&lt;String&gt;(mt); new Thread(taskA,\"竞赛者 - A\").start(); new Thread(taskB,\"竞赛者 - B\").start(); new Thread(taskC,\"竞赛者 - C\").start(); System.out.println(taskA.get()); System.out.println(taskB.get()); System.out.println(taskC.get()); &#125;&#125;class MyThread implements Callable&lt;String&gt;&#123; private boolean flag = false; @Override public String call() throws Exception &#123; // TODO Auto-generated method stub synchronized(this) &#123; if (this.flag == false) &#123; this.flag = true; return Thread.currentThread().getName() + \" 抢答成功！!\"; &#125; else &#123; return Thread.currentThread().getName() + \" 抢答失败！!\"; &#125; &#125; &#125;&#125;/*竞赛者 - A 抢答失败！!竞赛者 - B 抢答成功！!竞赛者 - C 抢答失败！!*/ 只返回一个信息的结果： 123456789101112131415161718192021222324252627282930313233343536package cn.jubingyi.Demo;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException&#123; MyThread mt = new MyThread(); FutureTask&lt;String&gt; taskA = new FutureTask&lt;String&gt;(mt); new Thread(taskA,\"竞赛者 - A\").start(); new Thread(taskA,\"竞赛者 - B\").start(); new Thread(taskA,\"竞赛者 - C\").start(); System.out.println(taskA.get()); &#125;&#125;class MyThread implements Callable&lt;String&gt;&#123; private boolean flag = false; @Override public String call() throws Exception &#123; // TODO Auto-generated method stub synchronized(this) &#123; if (this.flag == false) &#123; this.flag = true; return Thread.currentThread().getName() + \" 抢答成功！!\"; &#125; else &#123; return Thread.currentThread().getName() + \" 抢答失败！!\"; &#125; &#125; &#125;&#125;/*竞赛者 - B 抢答成功！!*/ java基础类库1. StringBuffer类String类是所有项目开发中，一定会使用到的一个功能类，这个类有如下的特点： 每个字符串常量都属于String类的匿名对象，并且不可更改； String有两个常量池：静态常量池，运行时常量池； String实例化建议直接使用赋值的形式完成，这样可以把对象保存在常量池中，方便下次重用； 字符串目前所能看到的最大的弊端就是字符串不允许修改； 为了解决此问题，专门提供了一个StringBuffer类可以使用String字符串内容的处理； 范例：观察String与StringBuffer类 String类引用传递 StringBuffer类应用传递 123456789101112131415package cn.jubingyi.Demo;// String类引用传递public class JavaApiDemo &#123; public static void main(String[] args) &#123; String str = \"Hello \"; change(str); System.out.println(str); &#125; public static void change(String temp) &#123; // 内容没有发生改变 temp += \"world!\"; &#125;&#125;/*Hello */ StringBuffer没有String类的两种对象实例化方式，StringBuffer得像普通类对象一样先对象实例化，再调用方法执行处理 构造方法： 12public StringBuffer()public StringBuffer(String str) 数据追加： 123StringBuffer append(float f)StringBuffer append(int n)// 有各种类型参数的此方法 12345678910111213package cn.jubingyi.Demo;public class JavaApiDemo &#123; public static void main(String[] args) &#123; StringBuffer sb = new StringBuffer(); sb.append(\"Hello \"); change(sb); System.out.println(sb); &#125; public static void change(StringBuffer temp) &#123; temp.append(\"world!\"); &#125;&#125; 实际上，大部分情况下，很少会出现字符串内容的改变，改变指的并不是针对静态常量池的改变 范例：分析已有问题 1234567public class JavaApiDemo &#123; public static void main(String[] args) &#123; String strA = \"Hello world\"; String strB = \"Hello \" + \"world\"; System.out.println(strA == strB); &#125;&#125; 这时候strB对象的内容并不算是改变；对于strB再程序编译后会变成如下形式 String strB = “Hello “ + “world”; StringBuffer buf = new StringBuffer();buf.append(“Hello “).append(“world”); String 方法的”+“在编译之后都变为了StringBuffer里的append方法；StringBuffer和String类之间可以相互转换； String类变为StringBuffer类：StringBuffer类的构造方法或者使用append 所有的类通过toString方法将其变为String类型； 其他方法： 插入数据： 1234567891011public StringBuffer insert(int offset, 数据类型 b) public class JavaApiDemo &#123; public static void main(String[] args) &#123; StringBuffer buf = new StringBuffer(); buf.append(\"miao\").insert(0,\"Hello\").insert(5, \" \"); System.out.println(buf); &#125;&#125; 删除指定范围 12345678910111213public StringBuffer delete(int start,int end) public class JavaApiDemo &#123; public static void main(String[] args) &#123; StringBuffer buf = new StringBuffer(); buf.append(\"Hello world\").delete(1,3); System.out.println(buf); &#125;&#125;/*Hlo world */ 字符串反转 1234567891011121314public StringBuffer reverse() public class JavaApiDemo &#123; public static void main(String[] args) &#123; StringBuffer buf = new StringBuffer(); buf.append(\"Hello world\"); System.out.println(buf.reverse()); &#125;&#125;/*dlrow olleH */ 与StringBuffer类有一个类似的功能类：StringBuilder：提供的方法与StringBuffer有相同的方法； StringBuffer属于线程安全的，全部使用了synchronnized关键字；StringBuffer没有这个； 2. CharSequence接口这个接口描述字符串接口的接口，实现了这个接口的有三个常用子类：String,StringBuffer,StringBuilder String StringBuffer StringBuilder public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence public final class StringBuffer extends Object implements Serializable, CharSequence public final class StringBuilder extends Object implements Serializable, CharSequence 现在只要有字符串就可以为CharSequence接口实例化 12345public class JavaApiDemo &#123; public static void main(String[] args) &#123; CharSequence str = \"Hello world\"; // 子类实例向父接口转型 &#125;&#125; CharSequence中定义的操作方法如下： 获取指定索引字符： 1public char charAt(int index); 获取字符串长度： 1public int length() 截取部分字符串 1public CharSequence subSequence(int start, int end); 范例：字符串截取 123456public class JavaApiDemo &#123; public static void main(String[] args) &#123; CharSequence str = \"Hello world\"; // 子类实例向父接口转型 System.out.println(str.subSequence(0, 5)); &#125;&#125; CharSequence描述的就是一个字符串 3. AutoCloseable接口用于资源开发的处理，以实现资源的自动关闭； 更好的说明资源问题，通过一个消息的发送处理来完成； 范例：手工实现资源处理:反正就是调用close函数关闭资源； 这个接口只提供了一个方法： 关闭方法 1public void close() throws Exception 要想使用自动关闭除了AutoCloseable之外，还需要结合异常处理语句才可以； 范例：实现自动关闭: 1234567891011121314151617181920212223242526272829303132333435public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; try (NetMessage nm = new NetMessage(\"Hello world\"))&#123; nm.send(); &#125; catch (Exception e) &#123;&#125; &#125;&#125;interface IMessage&#123; public void send();&#125;class NetMessage implements IMessage, AutoCloseable&#123; private String msg ; public NetMessage(String msg) &#123; super(); this.msg = msg; &#125; public boolean open() &#123; System.out.println(\"【open】获取消息发送连接资源\"); return true; &#125; @Override public void close() throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"【close】关闭消息发送通道\"); &#125; @Override public void send() &#123; // TODO Auto-generated method stub if (this.open()) &#123; System.out.println(\"【*** 发送消息 ***】 \"+this.msg); &#125; &#125;&#125; 以后接触到资源关闭时经常会遇到AutoCloseable 4. Runtime类描述运行时的状态；Runtime是唯一一个与JVM运行状态有关的类，并且默认提供一个该类的实例化对象； 由于JVM运行时只有一个Runtime类对象，所以这个类的构造方法私有化了。也就是单例设计模式； Runtime类负责描述系统信息，由JVM维护，所以就只有一个； 如果想获取这个对象可以使用Runtime类中的getRuntime方法获得； 获取实例化对象 1public static Runtime getRuntime() 范例：获取Runtime对象 1234567public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Runtime run = Runtime.getRuntime(); // 获取内核数availableProcessors() System.out.println(\"可用的进程数量：\"+run.availableProcessors()); &#125;&#125; 获取最大内存空间：默认为本机系统内存的四分之一 1public long maxMemory() 获取内存空间：默认为本机系统内存的64分之一 1public long totalMemory() 获取空闲内存空间： 1public long freeMemory() 手工进行垃圾回收处理： 1public void gc() 范例：观察内存状态 123456789public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Runtime run = Runtime.getRuntime(); System.out.println(\"可用的进程数量：\"+run.availableProcessors()); System.out.println(\"最大内存空间\"+run.maxMemory()); System.out.println(\"空闲内存空间\"+run.freeMemory()); System.out.println(\"获取内存空间\"+run.totalMemory()); &#125;&#125; 5. system类其他方法： 数组拷贝 1public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 获取当前日期时间数值 1public static long currentTimeMillis() // 计算程序耗时 垃圾回收 123public static void gc()&#123; // 和Runtime.getRuntime().gc()是一样的； Runtime.getRuntime().gc()&#125; 6. cleaner类对象清理操作，主要功能是进行finalize()方法的替代； C++类中的函数：构造函数，析构函数（对象手工回收）；java中由垃圾回收机制不太用这类析构函数； Java给提供了用户收尾操作，Object类中的finalized()；JDK 9 之后不建议使用了； 12@Deprecatedprotected void finalize() throws Throwable 这个类最大特征是抛出Throwable异常类型； 这个异常类型分为两个子类型：Error，Exception，平常都是Exception; 范例：观察传统回收 12345678910111213141516171819202122232425class Member&#123; public Member()&#123; System.out.println(\"【构造】你诞生了！！\"); &#125; public void finalize() throws Exception &#123; System.out.println(\"【回收】凡人终有一死\"); throw new Exception(\"哎，我还想活500年\"); &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Member m = new Member(); m = null; System.gc(); System.out.println(\"太阳照常升起\"); &#125;&#125;/*【构造】你诞生了！！太阳照常升起【回收】凡人终有一死 */ JDK 1.9开始finalize已经不建议使用了；建议使用 java.lang.ref.Cleaner类进行回收处理；（Cleaner也支持AutoCloseable接口处理） 123456789101112131415161718192021222324252627282930313233343536373839import java.lang.ref.Cleaner;class Member implements Runnable&#123; public Member()&#123; System.out.println(\"【构造】你诞生了！！\"); &#125; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"【回收】凡人终有一死\"); &#125;&#125;class MemberCleaning implements AutoCloseable&#123; private static final Cleaner cleaner = Cleaner.create(); private Member member; private Cleaner.Cleanable cleanable; public MemberCleaning()&#123; this.member = new Member(); this.cleanable = this.cleaner.register(this, this.member); //注册使用的对象 &#125; @Override public void close() throws Exception &#123; // TODO Auto-generated method stub this.cleanable.clean(); // 启动多线程 &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; try (MemberCleaning mc = new MemberCleaning())&#123; &#125;catch (Exception e) &#123; &#125; &#125;&#125; 7. 对象克隆要使用Object类里的clone()方法 1protected Object clone() throws CloneNotSupportedException 所有的类都会继承这个方法，但不是所有类都可以被克隆；要实现克隆就要实现一个接口Cloneable，这个接口没有任何方法提供；它只描述一种能力 123**Throws:**`CloneNotSupportedException` - if the object's class does not support the `Cloneable` interface. Subclasses that override the `clone` method can also throw this exception to indicate that an instance cannot be cloned 范例：实现clone 1234567891011121314151617181920212223242526272829303132333435363738class Member implements Cloneable&#123; private String name; private int age; public Member(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【\"+super.toString()+\"】 Member [name=\" + name + \", age=\" + age + \"]\"; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) throws Exception &#123; Member mem = new Member(\"小王\",23); Member mem_clone = (Member)mem.clone(); System.out.println(mem); System.out.println(mem_clone); &#125;&#125;/*【cn.jubingyi.Demo.Member@54bedef2】 Member [name=小王, age=23]【cn.jubingyi.Demo.Member@5caf905d】 Member [name=小王, age=23] */ 不覆写clone方法的话就会报错：The method clone() from the type Object is not visible 不实现Cloneable接口就会抛出CloneNotSupportedException异常： 调用clone后返回的是一个Object类方法，还需要向下转 数学操作类1. Math数学计算类这个类构造方法被私有化了，但不是单例； 其中很多方法都是static，可以直接通过类名称调用 12345678910public class JavaApiDemo &#123; public static void main(String[] args)&#123; System.out.println(Math.abs(-10)); System.out.println(Math.max(10.4, 19)); System.out.println(Math.log(0.75)); // -0.2876820724517809 System.out.println(Math.log(0.5)); // -0.6931471805599453 System.out.println(Math.log(0.25)); // -1.3862943611198906 System.out.println(Math.round(15.51)); // 四舍五入，返回最接近的long &#125;&#125; 范例：实现自定义的四舍五入 123456789101112131415161718public class JavaApiDemo &#123; public static void main(String[] args)&#123; System.out.println(MathUtil.round(19.562, -2)); &#125;&#125;class MathUtil&#123; private MathUtil() &#123;&#125; /** * 实现四舍五入操作 * @param num：要进行的数字 * @param scale：四舍五入保留的位数 * @return 四舍五入处理后的结果 */ public static double round(double num,int scale ) &#123; return Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale); &#125;&#125; 2. Random随机数生成类java.util.Random类，这个类主要靠内部提供的方法来完成： 产生一个不大于边界的随机非负整数： 1public int nextInt(int bound) 12345678910import java.util.Random;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Random a = new Random(); for (int x = 0; x &lt; 20; x++) &#123; System.out.print(a.nextInt(5)+\" \"); &#125; &#125;&#125; 有一款彩票叫做36选7，利用Random实现随机生成彩票号： 范例：随机生成彩票号： 123456789101112131415161718192021222324252627282930313233343536import java.util.Random;public class JavaApiDemo &#123; public static void main(String[] args)&#123; int data [] = new int[7]; Random rand = new Random(); int foot = 0; while (foot&lt;7) &#123; int num = rand.nextInt(37); if (isUsable(num, data)) &#123; data[foot++] = num; &#125; &#125; java.util.Arrays.sort(data); for (int t:data) &#123; System.out.print(t+\" \"); &#125; &#125; /** * 判断传入的数组是否为0以及是否在数组中中存在 * @param num 要判断的数字 * @param temp 已经存在的数据 * @return 判断是否可用 */ public static boolean isUsable(int num, int temp[]) &#123; if (num == 0) &#123; return false; &#125; for (int x:temp) &#123; if (x == num) &#123; return false; &#125; &#125; return true; &#125;&#125; 3. 大数字处理类海量数字计算（基础计算）；在java.math包里提供了BigInteger,BigDecimal；他们继承自Number类； 观察两个大数字操作类的构造方法 BigInteger类构造 1public BigInteger(String val) BigDecimal类构造： 1public BigDecimal(String val) 范例：使用BIgInteger实现四则运算 1234567891011121314import java.math.BigInteger;import java.util.Random;public class JavaApiDemo &#123; public static void main(String[] args)&#123; BigInteger bigA = new BigInteger(\"234234234234234234243242678678678676786883432\"); BigInteger bigB = new BigInteger(\"23423423\"); System.out.println(\"加法操作\"+bigA.add(bigB)); System.out.println(\"减法操作\"+bigA.subtract(bigB)); System.out.println(\"除法操作\"+bigA.divide(bigB)); System.out.println(\"乘法操作\"+bigA.multiply(bigB)); &#125;&#125; 虽然可以但还是要考虑性能问题 范例：观察性能问题 1 这种计算是非常缓慢的，任何电脑都是有极限的； 求余： 1public BigInteger[] divideAndRemainder​(BigInteger val) 范例：求余除法： 12345678910import java.math.BigInteger;public class JavaApiDemo &#123; public static void main(String[] args)&#123; BigInteger bigA = new BigInteger(\"234234234234234234243242678678678676786883432\"); BigInteger bigB = new BigInteger(\"23423423\"); BigInteger result [] = bigA.divideAndRemainder(bigB); System.out.println(\"商： \"+result[0]+\"、余数\"+result[1]); &#125;&#125; BigDicimal都是非常类似的，都有基础的数学支持； 范例：使用BigDecimal计算 1234567891011121314import java.math.BigDecimal;public class JavaApiDemo &#123; public static void main(String[] args)&#123; BigDecimal bigA = new BigDecimal(\"234234234234234234243242678678678676786883432\"); BigDecimal bigB = new BigDecimal(\"23423423\"); System.out.println(\"加法操作\"+bigA.add(bigB)); System.out.println(\"减法操作\"+bigA.subtract(bigB)); System.out.println(\"除法操作\"+bigA.divide(bigB,6,BigDecimal.ROUND_HALF_UP)); System.out.println(\"乘法操作\"+bigA.multiply(bigB)); BigDecimal result [] = bigA.divideAndRemainder(bigB); System.out.println(\"除法计算：商： \"+ result[0] + \"、 余数：\" + result[1]); &#125;&#125; 其中除法操作：第二个参数表示精度，第三个表示进位模式；但是已经被废弃了； 日期操作类因为java的设计来自于数据表中的结构，数据表中的字符，数字都学了；现在就差日期了； java提供了一个java.util.Data类，直接实例化就可以获取当前的日期时间； 范例：观察java.util.Data类 12345678import java.util.Date;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Date date = new Date(); System.out.println(date); &#125;&#125; 观察：Data构造： 123public Date() &#123; this(System.currentTimeMillis());&#125; 123public Date(long date) &#123; fastTime = date; &#125; 结论：Data类只不过是对long数据的一种包装；所以Data类中一定有所谓的日期与long之间的转换的方法： 将long转为日期： 123public Date(long date) &#123; fastTime = date; &#125; 将日期转为Long： 1public long getTime() 范例：观察Data与long之间的转换： 123456789101112import java.util.Date;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Date date = new Date(); long current = date.getTime(); current += 864000000; Date date2 = new Date(current); System.out.println(date); System.out.println(date2); &#125;&#125; 2. 日期的格式化处理Data类输出的日期结构不习惯，进行格式化日期使用：java.text.SimpleDateFormat类； 这个类是DateFormat类的子类，在这个类中提供有如下的方法： 【DateFormat继承】将日期格式化： 1public final String format(Date date) 【DateFormat继承】将字符串转为日期： 1public Date parse(String source) throws ParseException 【SimpleDateFormat】构造方法 1public SimpleDateFormat(String pattern) 日期格式描述：年（yyyy）、月（MM）、日（dd）、时（H,h）、分（m）、秒（ss）、毫秒（SSS）； Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, ..., 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 &lt;/table&gt;&gt; Date and Time Pattern Result \"yyyy.MM.dd G 'at' HH:mm:ss z\" 2001.07.04 AD at 12:08:56 PDT \"EEE, MMM d, ''yy\" Wed, Jul 4, '01 \"h:mm a\" 12:08 PM \"hh 'o''clock' a, zzzz\" 12 o'clock PM, Pacific Daylight Time \"K:mm a, z\" 0:08 PM, PDT \"yyyyy.MMMMM.dd GGG hh:mm aaa\" 02001.July.04 AD 12:08 PM \"EEE, d MMM yyyy HH:mm:ss Z\" Wed, 4 Jul 2001 12:08:56 -0700 \"yyMMddHHmmssZ\" 010704120856-0700 \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" 2001-07-04T12:08:56.235-0700 \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\" 2001-07-04T12:08:56.235-07:00 \"YYYY-'W'ww-u\" 2001-W27-3 范例: 格式化日期显示1234567891011121314import java.text.SimpleDateFormat;import java.util.Date;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); String str = sdf.format(date); System.out.println(str); &#125;&#125;/*2020-06-23 17:15:08.686 */ ​ 范例: 接下来实现字符串转为date;123456789101112131415import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String birthday = \"1995-09-24 00:40:00.000\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); Date date = sdf.parse(birthday); System.out.println(date); &#125;&#125;/*Sun Sep 24 00:40:00 CST 1995 */ 范例:数字格式化1 到目前可以发现字符串可以向所有类型转换：基本类型，日期类型； 正则表达式1. 认识正则表达式基本数用户输入的信息用String表示，为了转换的正确性需要进行一些复杂的验证处理； 给一个字符串判断是否由数字所组成，如果为数字所组成，就把它变为数字进行乘法计算 范例：字符串转数字123456789101112public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"123\"; if (str.matches(\"\\\\d+\")) &#123; int num = Integer.parseInt(str); System.out.println(num * 2); &#125; &#125;&#125;/*246 */ 有开发包java.util.regex,也有String类里的直接支持 正则方便进行验证处理，方便机型复杂字符串的修改处理； 2. 常用正则标记在java.util.regex有一个pattern类，这个程序类定义所有支持的正则标记； 【数量：单个】字符匹配 任意字符：表示有任意字符组成 范例 123public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"a\"; String regex = &quot;a&quot;; System.out.println(str.matches(regex)); } } 1 \\ \\: 匹配 ” \\ “ \\n :匹配换行 \\t : 匹配制表符 【数量：单个】字符集（可以从其中选一个字符） [ abc ] : 表示其中任意一个 [ ^abc ] : 不是a、b、c [ a-zA-Z ] : 表示所有字母步在意大小写 [ 0-9 ] : 数字 【数量：单个】简化字符集 ”.” : 任意的一个字符 ”\\d“ : 表示一个数字等价于[ 0-9 ] ”\\D“ : 不是一个数字等价于[ ^0-9 ] “\\s” : 匹配任意的一位空格，可能是空格、换行、制表符； “\\S” : 匹配任意的一位非（空格，可能是空格、换行、制表符）； ”\\w“ : 匹配字母与数字下划线 ”\\W“ ： 求反 边界匹配 ^ : 匹配边界开始 $ :匹配边界结束 数量表达：默认情况下只有添加上了数量单位才可以匹配多位字符 表达式？： 该表达式可以出现0次或1次 表达式* ： 该正则可以出现0次、1次或多次； 表达式+ ： 该正则可以出现1次或多次 表达式{n} ：表达式长度为n次 表达式{n,} ：表达式长度为n次及以上 表达式{n,m} ：表达式长度为n~m次 逻辑表达式 表达式X表达式Y ： X表达式后紧跟Y表达式； 表达式X|表达式Y ： X表达式 或 Y表达式； (表达式) ： 为表达式设置一个整体描述，可以为整体描述设置数量单位； 3. String类对正则的支持String类里提供有如下方法： No 方法名称 类型 描述 1 public boolean matches(String regex) 普通 与指定字符串进行正则判断 2 public String replaceAll(String regex, String replacement) 普通 替换全部 3 public String replacefirst(String regex, String replacement) 普通 替换首个 4 public String[] split(String regex,int limit) 普通 正则拆分 5 public String[] split(String regex) 普通 正则拆分 接下来范例说 范例：实现字符串替换（删除掉非字母和数组）12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"jfds91$%38&amp;4fh&amp;*931h&amp;**((NKN$%^nununouuiu*(*(non^&amp;*nfwqonf\"; String regex = \"\\\\W+\"; System.out.println(str.replaceAll(regex, \"\")); &#125;&#125;/*jfds91384fh931hNKNnununouuiunonnfwqonf */ 范例：实现字符串的拆分 ：一个含有字母和数字的字符串，把字母取出来12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"a1b22c333d4444e5555f666666\"; String regex = \"\\\\d+\"; System.out.println(str.replaceAll(regex, \"\")); &#125;&#125;/*abcdef */ 范例：判断一个数据是不是小数如果是小数则把它转换为double类型12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"100.\"; String regex = \"\\\\d+(\\\\.\\\\d+)?\"; System.out.println(str.matches(regex)); if (str.matches(regex)) &#123; System.out.println(Double.parseDouble(str)); &#125; &#125;&#125; 范例：判断一个字符串是否由日期所组成，如果是由日子所组成，则将其转成Date类型12345678910public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"2007-02-13\"; String regex = \"\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;\"; System.out.println(str.matches(regex)); if (str.matches(regex)) &#123; System.out.println(new SimpleDateFormat(\"yyyy-MM-dd\").parseObject(str)); &#125; &#125;&#125; 范例：判定给定的电话号码是否正确 电话号码：52518590 电话号码：01052518590 电话号码：(010)-52518590 1234567public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"(010)-51283346\"; String regex = \"((\\\\d&#123;3,4&#125;)|(\\\\(\\\\d&#123;3,4&#125;\\\\)-))?\\\\d&#123;7,8&#125;\"; System.out.println(str.matches(regex)); &#125;&#125; 范例：实现一个email地址格式的验证 email的用户名可以由字母、数字、下划线_、中划线- 所组成（不能用下划线开头） Email的域名由字母、数字、下划线_、中划线-； 后缀必须是：.cn .com .net .com.cn .gov 1234567public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"juyi006@163.com\"; String regex = \"[a-zA-Z0-9]\\\\w*@\\\\w+\\\\.(cn|com|com.cn|gov)\"; System.out.println(str.matches(regex)); &#125;&#125; 3. java.util.regex包支持这个包有两个类：Pattern（正则表达式编译），Matcher（匹配） pattern类提供有正则表达式的编译处理： 1public static Pattern compile(String regex,int flags) 同时也有字符串拆分支持： 1public String[] split(CharSequence input,int limit) 范例：Pattern的使用1234567891011public class JavaApiDemo &#123; public static void main(String[] args) throws ParseException&#123; String str = \"juyi006@1jif_.com\"; String regex = \"[^a-zA-Z]+\"; Pattern pat = Pattern.compile(regex); String[] split = pat.split(str); for (String temp:split) &#123; System.out.println(temp); &#125; &#125;&#125; Matcher类：实现了正则匹配的处理类，这个类的实例化对象依靠Pattern类完成； Pattern类提供的方法： 1public Matcher matcher(CharSequence input) 当获取了Matcher类的对象之后就可以利用该类中的方法进行如下操作： 正则匹配： 1public boolean matches() 字符串替换 1public String replaceAll(String replacement) 范例：字符串匹配1234567891011import java.util.regex.Matcher;import java.util.regex.Pattern;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String str = \"juyi006@1jif_.com\"; String regex = \"[^a-zA-Z]+\"; Pattern pat = Pattern.compile(regex); Matcher mat = pat.matcher(str); System.out.println(mat.matches()); &#125;&#125; 之前的拆分，匹配，替换都根本用不到这个开发包；但有一些正则是String不具备的：Matcher类里有一个分组的功能，这个功能时Matcher不具备的； 范例：用于分组把1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;public class JavaApiDemo &#123; public static void main(String[] args)&#123; // 要求取出 #&#123;&#125;中的内容 String str = \"INSERT INTO dept(deptno,dname,loc) VALUES (#&#123;deptno&#125;，#&#123;dname&#125;，#&#123;loc&#125;)\"; String regex = \"#\\\\&#123;\\\\w+\\\\&#125;\"; Pattern pat = Pattern.compile(regex); Matcher mat = pat.matcher(str); while(mat.find()) &#123; System.out.println(mat.group(0).replaceAll(\"#|\\\\&#123;|\\\\&#125;\", \"\")); &#125; &#125;&#125; 这个开发包不是很复杂的正则处理也很难用到； 国际化程序实现同一个代码可以更具不同的国家实现不同的语言描述，但是程序处理的核心业务是相同的 1.国际化程序实现原理语言环境不同； 通过分析，可以发现，想实现这个国际化程序开发，就要解决以下两点： 如何可以保存文字的文件信息； 如何可以根据不同的区域语言的编码读取指定的资源信息； 2. locale类首先需要解决的就是不同国家用户的区域和语言编码问题，而在java.util.Locale类中就提供类似的功能；而后可以利用Locale类中的两个构造方法： 12public Locale​(String language)public Locale​(String language,String country) 此时需要知道国家和语言的代码：中文代码：zh_CN; 美国英语：en_US; 获取这些信息的方式：网上搜吧 范例：实例化Locale类对象1234567891011import java.util.Locale;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = new Locale(\"zh\", \"CN\"); //中文环境 System.out.println(locale); &#125;&#125;/*zh_CN */ 如果现在像自动获得当前的环境，就可以利用Locale类本身默认方法进行实例化： 1public static Locale getDefault​() 范例：当地的环境；1234567891011import java.util.Locale;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = Locale.getDefault(); System.out.println(locale); &#125;&#125;/*zh_CN */ 在开发中并不关心国家和语言的编码，把著名的这些设置为了常量： 范例：读取常量1234567891011121314import java.util.Locale;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = Locale.CHINA; Locale loc = Locale.CHINESE; System.out.println(locale); System.out.println(loc); &#125;&#125;/*zh_CNzh */ 3. ResourceBundle读取资源文件现在已经准备好了资源文件，那么随后就需要进行资源文件；读取资源文件依靠：java.util.ResourceBundle类完成；此类定义如下： 1public abstract class ResourceBundle extends Object ·ResourceBundle是一个抽象类，如果说要想进行此类的实例化可以直接·利用该类中提供的一个static方法来完成； 获取ResourceBundle类对象： 1public static final ResourceBundle getBundle​(String baseName) baseName：描述资源文件的名称，但是没有后缀 根据key读取读取资源内容： 1public final String getString​(String key) 范例：使用ResourceBundle类读取内容 在cn.jubingyi.message下 1info=\\u5F88\\u9AD8\\u5174\\u89C1\\u5230\\u4F60 12345678910import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\"); String val = resource.getString(\"info\"); System.out.println(val); &#125;&#125; 在进行数据读取时，key一定要存在，如果不存在会出现异常； 4. 实现国际化程序开发 在CLASSPATH下建立：cn.jubingyi.message.Message_zh_CN.properties 1info=\\u5F88\\u9AD8\\u5174\\u89C1\\u5230\\u4F60 在CLASSPATH下建立：cn.jubingyi.message.Message_en_US.properties 1info=Welcome ! 通过程序进行指定区域的资源信息加载 123456789101112import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\"); String val = resource.getString(\"info\"); System.out.println(val); &#125;&#125;/*欢迎你的到来*/ 这时没有指定locale对象，但是Message_zh_CN.properties起作用了; getBundle这个方法默认获取当前本地Locale的资源； 如果有需要也可以修改当前的locale环境，则可以使用ResourceBundle.getBundle的重载： 获取ResourceBundle 1public static final ResourceBundle getBundle​(String baseName,Locale locale) 1234567891011121314import java.util.Locale;import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = new Locale(\"en\",\"US\"); ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\",locale); String val = resource.getString(\"info\"); System.out.println(val); &#125;&#125;/*Welcome !*/ 如果资源包中没有德国但是设置了德国，则会读取本地的那一项： 12345678910111213import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = Locale.GERMAN; ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\",locale); String val = resource.getString(\"info\"); System.out.println(val); &#125;&#125;/*欢迎您的访问 */ 如果本地都没有（把zh-CN文件去掉了），则显示Message.properties 12345678910111213import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = Locale.GERMAN; ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\",locale); String val = resource.getString(\"info\"); System.out.println(val); &#125;&#125;/*TaDaYiMaSi! */ 读取顺序：读取指定区域的资源文件 &gt; 默认本地资源 &gt; 公共的资源（没有区域设置的） 5. 格式化文本显示某一位用户登录成功：显示“xxx，欢迎您”；这样的信息保存在资源文件里就需要用占位符来描述；对于读取出来的数据进行消息格式化 范例：修改资源文件 【中文资源】cn.jubingyi.message.Message_zh_CN.properties info=欢迎{0}的访问，日期{1} 【英文资源】cn.jubingyi.message.Message_en_US.properties info=Welcome{0}, data:{1} ! 如果有需要可增加{n}之类的内容； 如果要进行资源读取会将占位符的信息一起读取，所以此时就需要利用MessageFormat类进行格式化处理 在MessageFormat里提供了一个格式化文本的方法： 1public static String format​(String pattern,Object... arguments) 范例：格式化国际化程序 1234567891011121314151617import java.text.MessageFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;import java.util.ResourceBundle;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Locale locale = Locale.US; ResourceBundle resource = ResourceBundle.getBundle(\"cn.jubingyi.message.Message\",locale); String val = resource.getString(\"info\"); System.out.println(MessageFormat.format(val, \"zenner\",new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()))); &#125;&#125;/*Welcome zenner, data: 2020-06-24 ! */ 日后见到资源文件里的{0}，{1}的结构表示，要实现相应的格式化文本 开发支持类库UUID生成无重复字符串的程序类，根据时间戳实现一个自动的无重复的字符串定义； 1234567import java.util.UUID;public class JavaApiDemo &#123; public static void main(String[] args)&#123; System.out.println(UUID.randomUUID()); &#125;&#125; 1. UUID类A UUID represents a 128-bit value. There exist different variants of these global identifiers. 获取UUID对象： 1public static UUID randomUUID​() 根据字符串获取UUID内容 1public static UUID fromString​(String name) 在对一些文件进行自动命名处理的情况下，UUID非常好用； 2. Optional类Optional类主要功能进行null的相关处理；在以前进行程序开发的时候，如果为了防止程序之中出现空指向异常往往可以追加有null的验证； 一般情况下都是在引用接收方被动进行判断，所以为了解决这种被动处理操作，在java中提供的Optional类；这个类提供的操作方法： 返回空的数据： 1public static &lt;T&gt; Optional&lt;T&gt; empty​() 获取数据： 1public T get​() 保存数据，但是不允许出现null： 1public static &lt;T&gt; Optional&lt;T&gt; of​(T value) 如果保存数据的时候存在有null，则会抛出NullPointerException异常 保存数据，允许为空 1public static &lt;T&gt; Optional&lt;T&gt; ofNullable​(T value) 空的时候，返回其他数据： 1public T orElse​(T other) 范例：修改程序，按照正规结构完成1234567891011121314151617181920212223242526272829import java.util.Optional;public class JavaApiDemo &#123; public static void main(String[] args)&#123; IMessage temp = MessageUtil.getMessage().get(); MessageUtil.useMessage(temp); &#125;&#125;class MessageUtil&#123; private MessageUtil() &#123;&#125; public static Optional&lt;IMessage&gt; getMessage() &#123; return Optional.of(new MessageImpl()); &#125; public static void useMessage(IMessage msg) &#123; if (msg != null) &#123; System.out.println(msg.getContent()); &#125; &#125;&#125;interface IMessage&#123; public String getContent();&#125;class MessageImpl implements IMessage&#123; @Override public String getContent() &#123; // TODO Auto-generated method stub return \"www.get.cn\"; &#125;&#125; 如果说现在数据保存的内容是null，则就会在保存处出现异常； 范例：修改 getMessage() 给他返回一个null12345678910111213141516class MessageUtil&#123; private MessageUtil() &#123;&#125; public static Optional&lt;IMessage&gt; getMessage() &#123; return Optional.of(null); // 修改处 &#125; public static void useMessage(IMessage msg) &#123; if (msg != null) &#123; System.out.println(msg.getContent()); &#125; &#125;&#125;Exception in thread \"main\" java.lang.NullPointerException at java.base/java.util.Objects.requireNonNull(Objects.java:222) at java.base/java.util.Optional.of(Optional.java:111) at cn.jubingyi.Demo.MessageUtil.getMessage(JavaApiDemo.java:14) // 报错了 at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:7) 由于Optional类中允许保存有null的内容，所以在数据获取的时候也可以进行null的处理；但是如果为空，使用get获取对象时就会报错； 范例：处理空123456789101112131415161718192021222324252627282930public class JavaApiDemo &#123; public static void main(String[] args)&#123; IMessage temp = MessageUtil.getMessage().get(); // get时就会报错 MessageUtil.useMessage(temp); &#125;&#125;class MessageUtil&#123; private MessageUtil() &#123;&#125; public static Optional&lt;IMessage&gt; getMessage() &#123; return Optional.ofNullable(null); // 修改为可以接受null的方法 &#125; public static void useMessage(IMessage msg) &#123; if (msg != null) &#123; System.out.println(msg.getContent()); &#125; &#125;&#125;interface IMessage&#123; public String getContent();&#125;class MessageImpl implements IMessage&#123; @Override public String getContent() &#123; // TODO Auto-generated method stub return \"www.get.cn\"; &#125;&#125;Exception in thread \"main\" java.util.NoSuchElementException: No value present at java.base/java.util.Optional.get(Optional.java:141) at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:7) 再把get换掉换成orelse，在为null时返回null或设定值； 范例：123456789101112131415161718192021222324252627282930313233343536373839import java.util.Optional;public class JavaApiDemo &#123; public static void main(String[] args)&#123; IMessage temp = MessageUtil.getMessage().orElse(new Message_send_Impl()); MessageUtil.useMessage(temp); &#125;&#125;class MessageUtil&#123; MessageUtil() &#123;&#125; public static Optional&lt;IMessage&gt; getMessage() &#123; return Optional.ofNullable(null); &#125; public static void useMessage(IMessage msg) &#123; if (msg != null) &#123; System.out.println(msg.getContent()); &#125; &#125;&#125;interface IMessage&#123; public String getContent();&#125;class MessageImpl implements IMessage&#123; @Override public String getContent() &#123; // TODO Auto-generated method stub return \"www.get.cn\"; &#125;&#125;class Message_send_Impl implements IMessage&#123; @Override public String getContent() &#123; // TODO Auto-generated method stub return \"www.send.cn\"; &#125;&#125;/*www.send.cn */ 在所有的引用数据类型的操作处理之中null是一个重要的问题 3. ThreadLocal类解决了核心资源与多线程并发访问的处理情况 范例：定义一个消息发送结构：1234567891011121314151617181920212223242526272829303132333435public class JavaApiDemo &#123; public static void main(String[] args)&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"www.zenner.com\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;&#125;class Channel&#123; //消息发送通道 private static Message msg; private Channel() &#123;&#125; public static Message getMsg() &#123; return msg; &#125; public static void setMsg(Message msg) &#123; Channel.msg = msg; &#125; public static void send() &#123; System.out.println(\"【消息发送】\"+msg.getInfo()); &#125;&#125;class Message&#123; private String info; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; &#125; 当前的程序实际上采用的是一种单线程的模式处理的；那么在多线程的状态下能否实现完全一致的效果呢？ 范例：多线程影响12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class JavaApiDemo &#123; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 1-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者A\").start(); new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 2-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者B\").start(); new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 3-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者C\").start(); &#125;&#125;class Channel&#123; //消息发送通道 private static Message msg; private Channel() &#123;&#125; public static Message getMsg() &#123; return msg; &#125; public static void setMsg(Message msg) &#123; Channel.msg = msg; &#125; public static void send() &#123; System.out.println(\"【\"+Thread.currentThread().getName()+\"、消息发送】\"+msg.getInfo()); &#125;&#125;class Message&#123; private String info; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; &#125;/*【消息发送者A、消息发送】The 2-th Thread's MESSAGE【消息发送者B、消息发送】The 2-th Thread's MESSAGE【消息发送者C、消息发送】The 3-th Thread's MESSAGE */ 这个时候消息的处理产生了影响，出现了数据覆盖 在保持Channel（所有发送的通道）核心结构不改变的情况下，需要考虑到每个线程的独立操作问题；在这种情况下，对于Channel类而言除了要保留有发送的消息之外，还应该对存放有每一个线程的标记（当前线程），那么我们就可以通过ThreadLocal类存放数据；在ThreadLocal里提供有如下的方法： 构造方法：创建有新的ThreadLocal类对象 1public ThreadLocal​() 设置数据 1public void set​(T value) 取出数据 1public T get​() 删除数据 1public void remove​() 范例：使用ThreadLocal解决核心资源与多线程的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class JavaApiDemo &#123; public static void main(String[] args)&#123; new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 1-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者A\").start(); new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 2-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者B\").start(); new Thread(()-&gt;&#123; Message msg = new Message(); // 实例化消息对象 msg.setInfo(\"The 3-th Thread's MESSAGE\"); // 设置要发送的内容 Channel.setMsg(msg); // 通道中设置要发送的消息 Channel.send(); // 发送消息 &#125;,\"消息发送者C\").start(); &#125;&#125;class Channel&#123; //消息发送通道 private static final ThreadLocal&lt;Message&gt; ThreadLocalMsg = new ThreadLocal&lt;Message&gt;(); private Channel() &#123;&#125; public static void setMsg(Message msg) &#123; Channel.ThreadLocalMsg.set(msg); &#125; public static void send() &#123; System.out.println(\"【\"+Thread.currentThread().getName()+\"、消息发送】\"+ThreadLocalMsg.get().getInfo()); &#125;&#125;class Message&#123; private String info; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; &#125;/*【消息发送者C、消息发送】The 3-th Thread's MESSAGE【消息发送者A、消息发送】The 1-th Thread's MESSAGE【消息发送者B、消息发送】The 2-th Thread's MESSAGE */ 每一个线程通过ThreaLocal只允许保存一个数据 4.定时调度定时器的主要操作就是进行定时任务的处理，像闹钟一样；在java中有定时任务的支持，但是这种任务的处理只是实现了一种间隔触发的操作；如果要想实现定时的处理操作需要有一个定时操作的主体类，以及一个定时任务的控制； 可使用两个类实现:： Timer，TimeTask; java.util.TimerTask 类：实现定时任务处理 java.util.Timer 类：进行任务的启动，启动的方法： 任务启动 1public void schedule​(TimerTask task,long delay) // 延迟单位是毫秒 间隔触发： 1public void scheduleAtFixedRate​(TimerTask task, long delay, long period) 范例：实现定时任务处理1234567891011121314151617181920212223242526import java.util.Date;import java.util.Timer;import java.util.TimerTask;import javax.xml.crypto.Data;class MyTask extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+\"、当前时间为: \"+new Date(System.currentTimeMillis())); &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; System.out.println(new Date()); Timer timer = new Timer(); timer.schedule(new MyTask(), 3000); // 修改点位 &#125;&#125;/*Sun Jun 28 23:17:23 CST 2020Timer-0、当前时间为: Sun Jun 28 23:17:26 CST 2020 */ 范例：间隔启动任务1234567891011121314151617181920212223242526import java.util.Date;import java.util.Timer;import java.util.TimerTask;import javax.xml.crypto.Data;class MyTask extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+\"、当前时间为: \"+new Date(System.currentTimeMillis())); &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; System.out.println(new Date()); Timer timer = new Timer(); timer.scheduleAtFixedRate(new MyTask(), 3000, period); &#125;&#125;/*Sun Jun 28 23:17:23 CST 2020Timer-0、当前时间为: Sun Jun 28 23:17:26 CST 2020 */ 5. Base64 加密与解密正常来说加密永远伴随着解密；加密与解密都伴随着一定的规则；提供的加密加密操作类：Base64，这个类里面有两个类： Base64 Encoder：进行加密处理 加密处理 1public byte[] encode​(byte[] src) Base64 Decoder ：进行解密处理 解密处理 1public byte[] decode​(byte[] src) 范例：实现加密与解密操作123456789101112131415import java.util.Base64;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String msg = \"www.zenner.com\"; // 要发送的信息内容 String encMsg = new String(Base64.getEncoder().encode(msg.getBytes())); System.out.println(encMsg); String oldMsg = new String(Base64.getDecoder().decode(encMsg)); System.out.println(oldMsg); &#125;&#125;/*d3d3Lnplbm5lci5jb20=www.zenner.com */ 目前这个只是对一个字符串进行加密加密；是一个公版算法，用这个加密不安全，那么最好的做法是使用盐值操作· 范例：盐值操作12345678910111213141516import java.util.Base64;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String salt = \"zennerJBY\"; String msg = \"www.zenner.com\"+\"&#123;\"+salt+\"&#125;\"; // 要发送的信息内容 String encMsg = new String(Base64.getEncoder().encode(msg.getBytes())); System.out.println(encMsg); String oldMsg = new String(Base64.getDecoder().decode(encMsg)); System.out.println(oldMsg); &#125;&#125;/*d3d3Lnplbm5lci5jb217emVubmVySkJZfQ==www.zenner.com&#123;zennerJBY&#125; */ 即便有盐值但加密的效果也不是很好；可以用多次加密； 范例：多层加密 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Base64;class StringUtil&#123; private static final String SALT = \"zennerJBY\"; // 公共盐值 private static final int REPEAT = 3; /** * 加密处理 * @param str * @param repeat * @return */ public static String encode(String str) &#123; String temp = str +\"&#123;\"+SALT+\"&#125;\"; // 盐值对外不公布 byte data[] = temp.getBytes(); for (int x = 0;x &lt; REPEAT;x++) &#123; data = Base64.getEncoder().encode(data); &#125; return new String(data); &#125; /** * 解密处理 * @return */ public static String decode(String str) &#123; byte data [] = str.getBytes(); for (int x = 0;x &lt; REPEAT; x++) &#123; data = Base64.getDecoder().decode(data); &#125; return new String(data).replaceAll(\"\\\\&#123;\\\\w+\\\\&#125;\", \"\"); &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String str = StringUtil.encode(\"www.zenner.com\"); System.out.println(str); System.out.println(StringUtil.decode(str)); &#125;&#125;/*WkROa00weHVjR3hpYlRWc1kyazFhbUl5TVRkbGJWWjFZbTFXZVZOclNscG1VVDA5www.zenner.com */ 比较器所谓的比较器就是进行大小关系的确定判断，分析比较器存在的意义是什么； 1. 比较器问题的引出若要进行数组操作，肯定是用java.util.Arrays 的操作完成，这个类一定是提供有绝大部分的数组操作；这个类还提供了对象数组的排序支持； 1public static void sort​(Object[] a) 范例：实现对象数组得排序1234567891011import java.util.Arrays;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Integer data [] = new Integer [] &#123;10,9,6,3,20&#125;; Arrays.sort(data); // 进行对象数组的排序 System.out.println(Arrays.toString(data)); &#125;&#125;/*[3, 6, 9, 10, 20]*/ 同样，如果数现在给定的是一个String型的对象数组，那么也是可以进行排序处理的； 范例：String 对象数组排序1234567891011import java.util.Arrays;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String data [] = new String [] &#123;\"X\",\"B\",\"A\",\"E\",\"G\"&#125;; Arrays.sort(data); // 进行对象数组的排序 System.out.println(Arrays.toString(data)); &#125;&#125;/*[A, B, E, G, X] */ 接下来看看自定义的类如何进行比较 范例：采用自定义类型进行排序123456789101112131415161718192021222324252627282930313233import java.util.Arrays;class Person&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125; &#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Person per [] = new Person [] &#123; new Person(\"小强-A\",89), new Person(\"小强-B\",50), new Person(\"小强-C\",100), &#125;; Arrays.sort(per); System.out.println(Arrays.toString(per)); &#125;&#125;/*Exception in thread \"main\" java.lang.ClassCastException: class cn.jubingyi.Demo.Person cannot be cast to class java.lang.Comparable (cn.jubingyi.Demo.Person is in unnamed module of loader 'app'; java.lang.Comparable is in module java.base of loader 'bootstrap') at java.base/java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320) at java.base/java.util.ComparableTimSort.sort(ComparableTimSort.java:188) at java.base/java.util.Arrays.sort(Arrays.java:1040) at cn.jubingyi.Demo.JavaApiDemo.main(JavaApiDemo.java:25) */ 任意一个类默认情况下是无法使用系统内部的类实现数组排序或比较需求的，是因为我们没有明确指出自定义类该如何比较（没有比较规则），所以提供有比较器的接口：Comparable接口 2. Comparable比较器要实现对象的比较肯定需要有比较器来制定规则，而比较的规则则需要comparable来实现；对于Comparable需要清楚其定义的结构； 12345678public interface Comparable&lt;T&gt;&#123; /** * 实现对象的比较处理操作 * @param o 要比较的对象 * @return 当数据比传入的对象小返回负数，如果大于返回正数，等于返回0 */ public int compareTo​(T o);&#125; 范例：实现自定义对象数组排序12345678910111213141516171819202122232425262728293031323334353637import java.util.Arrays;class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125; @Override public int compareTo(Person o) &#123; // TODO Auto-generated method stub return this.age - o.age; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Person per [] = new Person [] &#123; new Person(\"小强-A\",89), new Person(\"小强-B\",50), new Person(\"小强-C\",100), &#125;; Arrays.sort(per); System.out.println(Arrays.toString(per)); &#125;&#125;/*[【Person】 [name=小强-B, age=50], 【Person】 [name=小强-A, age=89], 【Person】 [name=小强-C, age=100]] */ 排序里面只需要有一个comparaTo()方法进行排序规则的定义，而后整个java系统里面就可以为其实现排序处理了； 3. Comparator比较器Comparator是一种挽救的比较器支持，其主要目的是解决一些没有使用Comparable排序的类的对象数组； 范例：已开发完成的程序项目，并且先期设计没有考虑到所谓的比较器功能；1234567891011121314import java.util.Arrays;class Person&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125;&#125; 就是上一版没有加入Comparable的 Person 类；后来需要进行对Person类进行排序处理，但是又不能修改Person类。此时就需要一种挽救的方法来实现比较，在Arrays类里排序有另外一种实现 基于Comparator的排序处理（这是一个接口） 1public static &lt;T&gt; void sort​(T[] a, Comparator&lt;? super T&gt; c) 在排序类里引入一个要排序类的辅助类用来实现比较器； 在java.util.Comparator里最初只定义有一个排序的compare方法（int compare(T o1,T o2)）后来添加了很多static方法 范例：定义排序规则类1234567class PersonComparator implements Comparator&lt;Person&gt;&#123; @Override public int compare(Person p1, Person p2) &#123; // TODO Auto-generated method stub return p1.getAge() - p2.getAge(); &#125;&#125; 在测试类进行测序处理时就可以利用排序规则实现操作。 范例：排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Arrays;import java.util.Comparator;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Person per [] = new Person [] &#123; new Person(\"小强-A\",89), new Person(\"小强-B\",50), new Person(\"小强-C\",100), &#125;; Arrays.sort(per,new PersonComparator()); // 使用了自定义的比较类 System.out.println(Arrays.toString(per)); &#125;&#125;class Person&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125;&#125;class PersonComparator implements Comparator&lt;Person&gt;&#123; @Override public int compare(Person p1, Person p2) &#123; // TODO Auto-generated method stub return p1.getAge() - p2.getAge(); &#125;&#125;/*[【Person】 [name=小强-B, age=50], 【Person】 [name=小强-A, age=89], 【Person】 [name=小强-C, age=100]] */ 面试题：请解释 Comparable 和 Comparator的区别？ java.lang.Comparable 是在类定义的时候实现的父接口，主要用于定于排序规则，里面只有一个compareTo() 方法 java.util.Comparator 是挽救的比较器操作，需要设置单独的比较器规则类实现排序，里面有compare方法 二叉树1. 二叉树结构简介数据的存储形式，在二叉树的实现之中其基本的实现原理如下：取第一个数据为保存的根节点，小于等于根节点的数据放在节点的左子树，大于的数组放在右子树； 要进行信息检索，就需要进行每个节点的判断。他的时间复杂度是O(logn) 再有三种遍历方式：前序遍历，中序遍历，后序遍历 2. 二叉树基础实现实现二叉树的处理中最为关键的问题在于数据的保存，而数据由于牵扯到对象比较的问题，这就需要到了比较器的支持，而且比较器首选Comparable，所以本次将保存Person类 范例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.Arrays;public class JavaApiDemo &#123; public static void main(String[] args)&#123; BinaryTree&lt;Person&gt; bt = new BinaryTree&lt;Person&gt;(); bt.add(new Person(\"小强-80\",80)); bt.add(new Person(\"小强-30\",30)); bt.add(new Person(\"小强-50\",50)); bt.add(new Person(\"小强-60\",60)); bt.add(new Person(\"小强-90\",90)); System.out.println(Arrays.toString(bt.toArray())); &#125;&#125;class BinaryTree &lt;T extends Comparable&lt;T&gt;&gt;&#123; private class Node&#123; private Comparable &lt;T&gt; data; private Node parent; private Node left; private Node right; public Node(Comparable&lt;T&gt; data) &#123; this.data = data; &#125; /** * 实现节点数据的适当位置的存储 * @param newNode 创建的新节点 */ public void addNode(Node newNode) &#123; if (newNode.data.compareTo((T)this.data) &lt;= 0) &#123; if (this.left == null) &#123; this.left = newNode; this.parent = this; &#125;else &#123; this.left.addNode(newNode); &#125; &#125;else &#123; if (this.right == null) &#123; this.right = newNode; newNode.parent = this; &#125;else &#123; this.right.addNode(newNode); &#125; &#125; &#125; /** * 实现所有数据的获取处理，按照中序遍历的形式来完成 */ public void toArrayNode() &#123; if (this.left != null) &#123; this.left.toArrayNode(); &#125; BinaryTree.this.returnData[BinaryTree.this.foot++] = this.data; if (this.right != null) &#123; this.right.toArrayNode(); &#125; &#125; &#125; // ------------------- 以下为二叉树的功能实现 --------- private Node root; private int count; private Object [] returnData; private int foot = 0; // 角标控制 public void add(Comparable&lt;T&gt; data) &#123; if (data == null) &#123; throw new NullPointerException(\"保存的数据不允许为空\"); &#125; // 所有的数据本身不具有节点关系的匹配，一定要将其包装在Node类中； Node newNode = new Node(data); if (this.root == null) &#123; this.root = newNode; &#125;else &#123; //保存到合适的位置 this.root.addNode(newNode); &#125; this.count ++; &#125; /** * 以对象数组的形式返回全部数据，如果没有数据返回null * @return */ public Object[] toArray() &#123; if (this.count == 0) &#123; return null; &#125; this.returnData = new Object [this.count]; this.foot = 0; this.root.toArrayNode(); // 直接由Node类来负责 return this.returnData; &#125;&#125;class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125; @Override public int compareTo(Person o) &#123; // TODO Auto-generated method stub return this.age - o.age; &#125;&#125;/*[【Person】 [name=小强-30, age=30], 【Person】 [name=小强-50, age=50], 【Person】 [name=小强-60, age=60], 【Person】 [name=小强-80, age=80], 【Person】 [name=小强-90, age=90]] */ 在进行数据添加的时候只是实现了节点关系的保存，而这种关系保存后的结果就是所有的数据都是有序排列； 3. 数据删除二叉树的节点删除非常复杂，要考虑的情况是非常多的。 情况一：如果待删除的节点没有子节点，那么直接删除； 情况二：如果待删除节点只有一个子节点，那么直接删除，并用其子节点去顶替它 只有左子树 只有右子树 情况三：如果待删除的节点有两个子节点，首选找出它的后继节点，然后处理“后继节点” 和“被删节点的父节点”的关系 范例：在Node类中追加由新的处理功能12345678910111213141516171819202122/** * 获取要删除的节点 * @param data 比较的对象 * @return 要删除的节点对象 */public BinaryTree&lt;T&gt;.Node getRemoveNode(Comparable&lt;T&gt; data) &#123; if (data.compareTo((T)this.data) == 0) &#123; return this; &#125;else if (data.compareTo((T)this.data) &lt; 0) &#123; if (this.left != null) &#123; return this.left.getRemoveNode(data); &#125;else &#123; return null; &#125; &#125;else &#123; if (this.right != null) &#123; return this.right.getRemoveNode(data); &#125;else &#123; return null; &#125; &#125;&#125; 范例：在BinaryTree 里面进行节点的处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 执行数据删除处理 * @param data 要删除的数据 */public void remove(Comparable&lt;T&gt; data) &#123; if (this.root == null) &#123; return ; &#125;else &#123; if (this.root.data.compareTo((T)data)==0) &#123; // 要删除的是根节点 Node moveNode = root.right; while (moveNode.left != null) &#123; moveNode = moveNode.left; &#125; if (moveNode.parent.left.data.compareTo((T)moveNode.data)==0) &#123; moveNode.parent.left = null; &#125;else &#123; moveNode.parent.right = null; &#125; moveNode.parent = root.parent; System.out.println(moveNode.toString()); moveNode.right = root.right; moveNode.left = root.left; this.root = moveNode; &#125;else &#123; Node removeNode = this.root.getRemoveNode(data); if (removeNode != null) &#123; // 找到要删除的对象信息 System.out.println(removeNode.toString()); // 情况一：没有任何的子节点 if (removeNode.left == null &amp;&amp; removeNode.right == null) &#123; removeNode.parent.left = null; removeNode.parent.right = null; removeNode.parent = null; &#125;else if (removeNode.left != null &amp;&amp; removeNode.right == null) &#123; if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = removeNode.left; &#125;else &#123; removeNode.parent.right = removeNode.left; &#125; removeNode.left.parent = removeNode.parent; &#125;else if (removeNode.left == null &amp;&amp; removeNode.right != null)&#123; if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = removeNode.right; &#125;else &#123; removeNode.parent.right = removeNode.right; &#125; removeNode.right.parent = removeNode.parent; &#125;else &#123; Node moveNode = removeNode.right; while (moveNode.left != null) &#123; moveNode = moveNode.left; &#125; if (moveNode.parent.left.data.compareTo((T)moveNode.data)==0) &#123; moveNode.parent.left = null; &#125;else &#123; moveNode.parent.right = null; &#125; moveNode.parent = removeNode.parent; System.out.println(moveNode.toString()); if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = moveNode; &#125;else &#123; removeNode.parent.right = moveNode; &#125; moveNode.right = removeNode.right; moveNode.left = removeNode.left; &#125; &#125;else &#123; return ; &#125; &#125; this.count --; &#125;&#125; 范例：全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251import java.util.Arrays;public class JavaApiDemo &#123; public static void main(String[] args)&#123; BinaryTree&lt;Person&gt; bt = new BinaryTree&lt;Person&gt;(); bt.add(new Person(\"小强-80\",80)); bt.add(new Person(\"小强-50\",50)); bt.add(new Person(\"小强-60\",60)); bt.add(new Person(\"小强-30\",30)); bt.add(new Person(\"小强-90\",90)); bt.add(new Person(\"小强-10\",10)); bt.add(new Person(\"小强-55\",55)); bt.add(new Person(\"小强-70\",70)); bt.add(new Person(\"小强-85\",85)); bt.add(new Person(\"小强-95\",95)); bt.remove(new Person(\"小强-61\",61)); System.out.println(Arrays.toString(bt.toArray())); &#125;&#125;class BinaryTree &lt;T extends Comparable&lt;T&gt;&gt;&#123; private class Node&#123; private Comparable &lt;T&gt; data; private Node parent; private Node left; private Node right; public Node(Comparable&lt;T&gt; data) &#123; this.data = data; &#125; @Override public String toString() &#123; return \"Node [data=\" + data + \"]\"; &#125; /** * 实现节点数据的适当位置的存储 * @param newNode 创建的新节点 */ public void addNode(Node newNode) &#123; if (newNode.data.compareTo((T)this.data) &lt;= 0) &#123; if (this.left == null) &#123; this.left = newNode; newNode.parent = this; &#125;else &#123; this.left.addNode(newNode); &#125; &#125;else &#123; if (this.right == null) &#123; this.right = newNode; newNode.parent = this; &#125;else &#123; this.right.addNode(newNode); &#125; &#125; &#125; /** * 实现所有数据的获取处理，按照中序遍历的形式来完成 */ public void toArrayNode() &#123; if (this.left != null) &#123; this.left.toArrayNode(); &#125; BinaryTree.this.returnData[BinaryTree.this.foot++] = this.data; if (this.right != null) &#123; this.right.toArrayNode(); &#125; &#125; /** * 判断节点是否存在给定的数据 * @param data 给定的数据 * @return 存在返回true，不存在返回false */ public boolean containsNode(Comparable&lt;T&gt; data) &#123; if (data.compareTo((T)this.data) == 0) &#123; return true; &#125;else if (data.compareTo((T)this.data) &lt; 0) &#123; if (this.left != null) &#123; return this.left.containsNode(data); &#125;else &#123; return false; &#125; &#125;else &#123; if (this.right != null) &#123; return this.right.containsNode(data); &#125;else &#123; return false; &#125; &#125; &#125; /** * 获取要删除的节点 * @param data 比较的对象 * @return 要删除的节点对象 */ public BinaryTree&lt;T&gt;.Node getRemoveNode(Comparable&lt;T&gt; data) &#123; if (data.compareTo((T)this.data) == 0) &#123; return this; &#125;else if (data.compareTo((T)this.data) &lt; 0) &#123; if (this.left != null) &#123; return this.left.getRemoveNode(data); &#125;else &#123; return null; &#125; &#125;else &#123; if (this.right != null) &#123; return this.right.getRemoveNode(data); &#125;else &#123; return null; &#125; &#125; &#125; &#125; // ------------------- 以下为二叉树的功能实现 --------- private Node root; private int count; private Object [] returnData; private int foot = 0; // 角标控制 public boolean Contains(Comparable&lt;T&gt; data) &#123; if (this.count == 0) &#123; return false; &#125;else &#123; return this.root.containsNode(data); &#125; &#125; public void add(Comparable&lt;T&gt; data) &#123; if (data == null) &#123; throw new NullPointerException(\"保存的数据不允许为空\"); &#125; // 所有的数据本身不具有节点关系的匹配，一定要将其包装在Node类中； Node newNode = new Node(data); if (this.root == null) &#123; this.root = newNode; newNode.parent = null; &#125;else &#123; //保存到合适的位置 this.root.addNode(newNode); &#125; this.count ++; &#125; /** * 以对象数组的形式返回全部数据，如果没有数据返回null * @return */ public Object[] toArray() &#123; if (this.count == 0) &#123; return null; &#125; this.returnData = new Object [this.count]; this.foot = 0; this.root.toArrayNode(); // 直接由Node类来负责 return this.returnData; &#125; /** * 执行数据删除处理 * @param data 要删除的数据 */ public void remove(Comparable&lt;T&gt; data) &#123; if (this.root == null) &#123; return ; &#125;else &#123; if (this.root.data.compareTo((T)data)==0) &#123; // 要删除的是根节点 Node moveNode = root.right; while (moveNode.left != null) &#123; moveNode = moveNode.left; &#125; if (moveNode.parent.left.data.compareTo((T)moveNode.data)==0) &#123; moveNode.parent.left = null; &#125;else &#123; moveNode.parent.right = null; &#125; moveNode.parent = root.parent; System.out.println(moveNode.toString()); moveNode.right = root.right; moveNode.left = root.left; this.root = moveNode; &#125;else &#123; Node removeNode = this.root.getRemoveNode(data); if (removeNode != null) &#123; // 找到要删除的对象信息 System.out.println(removeNode.toString()); // 情况一：没有任何的子节点 if (removeNode.left == null &amp;&amp; removeNode.right == null) &#123; removeNode.parent.left = null; removeNode.parent.right = null; removeNode.parent = null; &#125;else if (removeNode.left != null &amp;&amp; removeNode.right == null) &#123; if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = removeNode.left; &#125;else &#123; removeNode.parent.right = removeNode.left; &#125; removeNode.left.parent = removeNode.parent; &#125;else if (removeNode.left == null &amp;&amp; removeNode.right != null)&#123; if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = removeNode.right; &#125;else &#123; removeNode.parent.right = removeNode.right; &#125; removeNode.right.parent = removeNode.parent; &#125;else &#123; Node moveNode = removeNode.right; while (moveNode.left != null) &#123; moveNode = moveNode.left; &#125; if (moveNode.parent.left.data.compareTo((T)moveNode.data)==0) &#123; moveNode.parent.left = null; &#125;else &#123; moveNode.parent.right = null; &#125; moveNode.parent = removeNode.parent; System.out.println(moveNode.toString()); if (removeNode.parent.left.data.compareTo((T)removeNode.data)==0) &#123; removeNode.parent.left = moveNode; &#125;else &#123; removeNode.parent.right = moveNode; &#125; moveNode.right = removeNode.right; moveNode.left = removeNode.left; &#125; &#125;else &#123; return ; &#125; &#125; this.count --; &#125; &#125;&#125;class Person implements Comparable&lt;Person&gt;&#123; private String name; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【Person】 [name=\" + name + \", age=\" + age + \"]\\n\"; &#125; @Override public int compareTo(Person o) &#123; // TODO Auto-generated method stub return this.age - o.age; &#125;&#125; 4. 红黑树原理简介二叉树的主要特点：数据查询的时候可以提供更好的查询性能，这种原始的二叉树结构是有明显缺陷的。当改变二叉树结构的时候可能会产生树的不平衡 成为了一个链表结构；要想达到最良好效果的二叉树，那么他应该是一个平衡二叉树，同时所有的节点层次深度应该不超过1； 这个时候二叉树的检索操作效率一定是最高的，并且树可以忍受着这些频繁的增加或者删除操作；所以针对二叉树有着进一步的设计要求： ​ 红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则是红黑树保证了一种平衡，插入，删除，查找的最坏时间复杂度都为O(logn); ​ 红黑树本质上在节点上追加了一个表示颜色的操作信息而已； 123456789101112enum Color&#123; RED,BLACK;&#125;class BinaryTree&lt;T&gt;&#123; private class Node&#123; private T data; private Node parent; private Node left; private Node right; private Color colo; // 多增加的一个属性 &#125;&#125; 红黑树的不一定要用枚举，用true或者false来实现也可以；不一定非要用枚举类； 一个标准的红黑树的结构如下所示 主要是利用这个红色节点和黑色节点实现均衡的控制；简单理解红黑树的结构就是为了实现左旋，右旋操作，已保证树的平衡； 但是对于平衡，还需要考虑数据增加的平衡以及数据删除的平衡，增加和删除都是需要对这颗树进行平衡修复的； 数据插入的平衡修复 在进行红黑树处理的时候为了方便操作都会将新的节点使用红色来描述。于是当设置根节点的时候就会违反规则2：根节点为黑色；那么这时候只需要将节点的颜色涂黑即可； 在红黑树进行修复处理中，他需要根据 当前节点 以及 当前节点的父节点 和 叔叔节点 的颜色来推断树是否需要修复处理； 数据删除的平衡修复 在红黑树之中修复的目的是为了保证树结构中的黑色节点的数量平衡，黑色节点的数量平衡了，那么才可能得到“O(logn)”的执行性能，但是修复的过程一方面是红黑的处理，另一方面就是子节点保存的层次。 类库使用案例分析1.StringBuffer使用​ 定义一个StringBuffer类对象，然后通过append()方法向对象中添加26个小写字母，要求每次只添加一次，共添加26次，然后按照逆序的方式输出，并且可以删除前5个字符； ​ 本操作只要是训练StringBuffer类中的处理方法，因为StringBuffer的主要特点是内容允许修改 12345678910111213public class JavaApiDemo &#123; public static void main(String[] args)&#123; StringBuffer buf = new StringBuffer(); for(int x = 'a';x &lt;= 'z';x++) &#123; buf.append((char)x); &#125; buf.reverse().delete(0, 5); System.out.println(buf); &#125;&#125;/*utsrqponmlkjihgfedcba */ 2. 随机数组利用Random类产生5个1~30之间（包括1和30）的随机数组 12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.Random;class NumberFactory&#123; private static Random random = new Random(); /** * 通过随机数来生成一个数组的内容，该内容不包括有0 * @param len：要开辟的数组大小 * @return 返回的数组 */ public static int [] creat(int len) &#123; int data [] = new int[len]; int foot = 0; while (foot &lt; data.length) &#123; int num = random.nextInt(31); if (num != 0) &#123; data[foot++] = num; &#125; &#125; return data; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; int result [] = NumberFactory.creat(30); System.out.println(Arrays.toString(result)); &#125;&#125; 3. Email验证输入一个Email地址，然后使用正则表达式验证该Email地址是否正确 在这里设置一个单独的验证处理类： 12345678910111213141516171819202122232425public class JavaApiDemo &#123; public static void main(String[] args)&#123; if (args.length != 1) &#123; System.out.println(\"程序执行错误，没有输入初始化参数，正确格式为： java JavaApiDemo Email地址\"); System.exit(1); &#125; String email = args[0]; if (Validator.isEmail(email)) &#123; System.out.println(email+\" 是一个email地址\"); &#125;else &#123; System.out.println(email+\" 不符合格式！\"); &#125; &#125;&#125;class Validator&#123; public Validator() &#123;&#125; public static boolean isEmail(String email) &#123; if (email == null || \"\".equals(email))&#123; return false; &#125; String regex = \"\\\\w+@\\\\w+\\\\.\\\\w+\"; return email.matches(regex); &#125;&#125; 4. 扔硬币用0~1之间的随机数来模拟扔硬币试验，统计扔1000次后出现正、反面的次数并输出 12345678910111213141516171819202122232425262728293031323334import java.util.Random;class Coin&#123; private int front ; // 保存正面的次数 private int back; // 保存北面的次数 private Random random = new Random(); /** * 扔硬币的处理 * @param num 执行次数 */ public void throwCol(int num) &#123; for (int x = 0; x &lt; num; x++) &#123; int temp = random.nextInt(2); if (temp == 0) &#123; this.front ++; &#125;else &#123; this.back ++; &#125; &#125; &#125; public int getFront() &#123; return front; &#125; public int getBack() &#123; return back; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; Coin coin = new Coin(); coin.throwCol(1000000); System.out.println(\"正面次数： \"+coin.getFront() + \"、背面出现次数： \"+coin.getBack()); &#125;&#125; 5. IP验证编写正则表达式，判断给定的是否是一个合法IP地址：第一位内容是无，1，或者2，后面的内容可以0-5，第三位0-9 12345678910111213141516171819202122232425class Validator&#123; public static boolean validateIP(String IP)&#123; if (IP == null||\"\".equals(IP)) &#123; return false; &#125; String regex = \"([12]?[0-9]?[0-9].)&#123;3&#125;[12]?[0-9]?[0-9]\"; if (IP.matches(regex)) &#123; String result [] = IP.split(\"\\\\.\"); for (int x = 0; x&lt; result.length; x++) &#123; int temp = Integer.parseInt(result[x]); if (temp &gt; 255) &#123; return false; &#125; &#125; return true; &#125; return false; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String str = \"252.168.122.2\"; System.out.println(Validator.validateIP(str)); &#125;&#125; 6. HTML拆分给定下面的HTML代码： 1&lt;font face=\"Arial,Serif\" size=\"+2\" color=\"red\"&gt; 要求对内容进行拆分，拆分之后的结果是： 123face Arial,Serifsize +2color red 对于此时最简单的方法就是进行分组处理 1234567891011121314151617181920import java.util.regex.Matcher;import java.util.regex.Pattern;public class JavaApiDemo &#123; public static void main(String[] args)&#123; String str = \"&lt;font face=\\\"Arial,Serif\\\" size=\\\"+2\\\" color=\\\"red\\\"&gt;\"; String regex = \"\\\\w+=\\\"[a-zA-Z0-9,\\\\+]+\\\"\"; Matcher matcher = Pattern.compile(regex).matcher(str); while (matcher.find()) &#123; String temp = matcher.group(0); String[] result = temp.split(\"=\"); System.out.println(result[0] + \"\\t\" + result[1].replaceAll(\"\\\"\",\"\")); &#125; &#125;&#125;/*face Arial,Serifsize +2color red */ 7. 国家代码编写代码，实现国际化应用，从命令行输入国家的代码，例如：1代表中国，2代表美国，然后根据输入代码的不同调用不同的资源文件显示信息； ​ 这个程序肯定要通过Locale类的对象来指定区域，然后利用ResourceBundle类来加载资源文件，而对于数据的输入可以继续使用初始化的参数形式来完成； 定义中文资源文件 1info=感谢老铁刷的火箭！ 定义英文资源文件 1info=Thanks for Mr.Tie's Rocket! 定义程序类进行加载控制 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Locale;import java.util.ResourceBundle;class MessageUtil &#123; public static final int CHINA = 1; public static final int USA = 2; public static final String KEY = \"info\"; public static final String BASENAME = \"cn.jubingyi.message.Message\"; public String getMessage(int num) &#123; Locale loc = this.getLocale(num); if (loc == null) &#123; return \"Nothing\"; &#125;else &#123; return ResourceBundle.getBundle(BASENAME, loc).getString(KEY); &#125; &#125; private Locale getLocale(int num) &#123; switch (num) &#123; case CHINA: return new Locale(\"zh\", \"CN\"); case USA: return new Locale(\"en\", \"US\"); default: return null; &#125; &#125;&#125;public class JavaApiDemo &#123; public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println(\"程序执行错误，没有设置地区编码\"); System.exit(1); &#125; int choose = Integer.parseInt(args[0]); System.out.println(new MessageUtil().getMessage(choose)); &#125;&#125;/*1 感谢老铁刷的火箭！2 Thanks for Mr.Tie's Rocket! */ 8. 学生信息比较按照“姓名：年龄：成绩|姓名：年龄：成绩”的格式定义字符串“张三：22：89|王五：20：70”，要求将每组值分别保存在student对象之中，并对这些对象进行排序，排序的原则为：按照成绩由高到低排列，如果成绩相同则按年龄由低向高排序。 是一个直接的做法按照比较器来完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Arrays;public class JavaApiDemo &#123; public static void main(String[] args) &#123; String input = \"张三:21:89|李四:22:89|王五:20:70\"; String result [] = input.split(\"\\\\|\"); Student students [] = new Student [result.length]; for (int x = 0; x &lt; result.length; x ++) &#123; String [] temp = result[x].split(\":\"); students[x] = new Student(temp[0],Integer.parseInt(temp[1]),Double.parseDouble(temp[2])); &#125; Arrays.sort(students); System.out.println(Arrays.toString(students)); &#125;&#125;class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private double score; public Student(String name, int age, double score) &#123; super(); this.name = name; this.age = age; this.score = score; &#125; @Override public String toString() &#123; return \"Student [name=\" + name + \", age=\" + age + \", score=\" + score + \"]\\n\"; &#125; @Override public int compareTo(Student o) &#123; if (this.score &lt; o.score) &#123; return 1; &#125;else if (this.score &lt; o.score) &#123; return -1; &#125;else &#123; return this.age - o.age; &#125; &#125; &#125;/*[Student [name=张三, age=21, score=89.0], Student [name=李四, age=22, score=89.0], Student [name=王五, age=20, score=70.0]] */","categories":[{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-13T14:02:22.000Z","updated":"2021-06-28T08:22:11.957Z","comments":true,"path":"2019/03/13/hello-world/","link":"","permalink":"http://zenner006.github.io/2019/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"tips","slug":"tips","permalink":"http://zenner006.github.io/categories/tips/"},{"name":"java","slug":"java","permalink":"http://zenner006.github.io/categories/java/"},{"name":"java web","slug":"java/java-web","permalink":"http://zenner006.github.io/categories/java/java-web/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/categories/algorithm/"},{"name":"左神算法","slug":"algorithm/左神算法","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"},{"name":"初级","slug":"algorithm/左神算法/初级","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"},{"name":"哈希","slug":"algorithm/左神算法/初级/哈希","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E5%93%88%E5%B8%8C/"},{"name":"树","slug":"algorithm/左神算法/初级/树","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%A0%91/"},{"name":"链表","slug":"algorithm/左神算法/初级/链表","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E9%93%BE%E8%A1%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据库系统概念","slug":"数据库/数据库系统概念","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"},{"name":"数据库原理及应用","slug":"数据库/数据库原理及应用","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"},{"name":"数据库基础知识","slug":"数据库/数据库原理及应用/数据库基础知识","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"排序","slug":"algorithm/左神算法/初级/排序","permalink":"http://zenner006.github.io/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"},{"name":"python","slug":"python","permalink":"http://zenner006.github.io/categories/python/"},{"name":"redis","slug":"数据库/redis","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"},{"name":"web","slug":"web","permalink":"http://zenner006.github.io/categories/web/"},{"name":"环境配置","slug":"web/环境配置","permalink":"http://zenner006.github.io/categories/web/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"剑指offer","slug":"algorithm/剑指offer","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/"},{"name":"简单","slug":"algorithm/剑指offer/简单","permalink":"http://zenner006.github.io/categories/algorithm/%E5%89%91%E6%8C%87offer/%E7%AE%80%E5%8D%95/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/"},{"name":"简单","slug":"algorithm/leetcode/简单","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E7%AE%80%E5%8D%95/"},{"name":"xml","slug":"xml","permalink":"http://zenner006.github.io/categories/xml/"},{"name":"容易","slug":"algorithm/leetcode/容易","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E5%AE%B9%E6%98%93/"},{"name":"Bootstrap","slug":"web/Bootstrap","permalink":"http://zenner006.github.io/categories/web/Bootstrap/"},{"name":"困难","slug":"algorithm/leetcode/困难","permalink":"http://zenner006.github.io/categories/algorithm/leetcode/%E5%9B%B0%E9%9A%BE/"},{"name":"java高级编程","slug":"java/java高级编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"},{"name":"注解与反射","slug":"java/java高级编程/注解与反射","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"},{"name":"jvm","slug":"java/jvm","permalink":"http://zenner006.github.io/categories/java/jvm/"},{"name":"javascript","slug":"web/javascript","permalink":"http://zenner006.github.io/categories/web/javascript/"},{"name":"CSS","slug":"web/CSS","permalink":"http://zenner006.github.io/categories/web/CSS/"},{"name":"HTML","slug":"web/HTML","permalink":"http://zenner006.github.io/categories/web/HTML/"},{"name":"JDBC","slug":"java/java高级编程/JDBC","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/JDBC/"},{"name":"matlab","slug":"matlab","permalink":"http://zenner006.github.io/categories/matlab/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://zenner006.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"网络编程","slug":"java/java高级编程/网络编程","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Stream","slug":"java/java高级编程/Stream","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/Stream/"},{"name":"io","slug":"java/java高级编程/io","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/io/"},{"name":"集合","slug":"java/java高级编程/集合","permalink":"http://zenner006.github.io/categories/java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://zenner006.github.io/tags/IDEA/"},{"name":"maven","slug":"maven","permalink":"http://zenner006.github.io/tags/maven/"},{"name":"tips","slug":"tips","permalink":"http://zenner006.github.io/tags/tips/"},{"name":"algorithm","slug":"algorithm","permalink":"http://zenner006.github.io/tags/algorithm/"},{"name":"哈希函数","slug":"哈希函数","permalink":"http://zenner006.github.io/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"},{"name":"哈希表","slug":"哈希表","permalink":"http://zenner006.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://zenner006.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"一致性哈希","slug":"一致性哈希","permalink":"http://zenner006.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"},{"name":"并查集","slug":"并查集","permalink":"http://zenner006.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"树","slug":"树","permalink":"http://zenner006.github.io/tags/%E6%A0%91/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"http://zenner006.github.io/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"完全二叉树","slug":"完全二叉树","permalink":"http://zenner006.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"http://zenner006.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://zenner006.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://zenner006.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"数据库","slug":"数据库","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"排序","slug":"排序","permalink":"http://zenner006.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://zenner006.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://zenner006.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://zenner006.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://zenner006.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"http://zenner006.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://zenner006.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"对数器","slug":"对数器","permalink":"http://zenner006.github.io/tags/%E5%AF%B9%E6%95%B0%E5%99%A8/"},{"name":"python","slug":"python","permalink":"http://zenner006.github.io/tags/python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://zenner006.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"闭包","slug":"闭包","permalink":"http://zenner006.github.io/tags/%E9%97%AD%E5%8C%85/"},{"name":"java","slug":"java","permalink":"http://zenner006.github.io/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://zenner006.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"全局解释器锁","slug":"全局解释器锁","permalink":"http://zenner006.github.io/tags/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"name":"同步锁","slug":"同步锁","permalink":"http://zenner006.github.io/tags/%E5%90%8C%E6%AD%A5%E9%94%81/"},{"name":"递归锁","slug":"递归锁","permalink":"http://zenner006.github.io/tags/%E9%80%92%E5%BD%92%E9%94%81/"},{"name":"死锁","slug":"死锁","permalink":"http://zenner006.github.io/tags/%E6%AD%BB%E9%94%81/"},{"name":"信号量","slug":"信号量","permalink":"http://zenner006.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"web","slug":"web","permalink":"http://zenner006.github.io/tags/web/"},{"name":"JQuery","slug":"JQuery","permalink":"http://zenner006.github.io/tags/JQuery/"},{"name":"cookie","slug":"cookie","permalink":"http://zenner006.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://zenner006.github.io/tags/session/"},{"name":"JSP","slug":"JSP","permalink":"http://zenner006.github.io/tags/JSP/"},{"name":"http","slug":"http","permalink":"http://zenner006.github.io/tags/http/"},{"name":"request","slug":"request","permalink":"http://zenner006.github.io/tags/request/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://zenner006.github.io/tags/Tomcat/"},{"name":"数组","slug":"数组","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符","slug":"字符","permalink":"http://zenner006.github.io/tags/%E5%AD%97%E7%AC%A6/"},{"name":"java web","slug":"java-web","permalink":"http://zenner006.github.io/tags/java-web/"},{"name":"SerVlet","slug":"SerVlet","permalink":"http://zenner006.github.io/tags/SerVlet/"},{"name":"每日一题","slug":"每日一题","permalink":"http://zenner006.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://zenner006.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"双指针","slug":"双指针","permalink":"http://zenner006.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分查找","slug":"二分查找","permalink":"http://zenner006.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"二维数组","slug":"二维数组","permalink":"http://zenner006.github.io/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://zenner006.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"暴力法","slug":"暴力法","permalink":"http://zenner006.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://zenner006.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"HTML","slug":"HTML","permalink":"http://zenner006.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://zenner006.github.io/tags/CSS/"},{"name":"JDBC","slug":"JDBC","permalink":"http://zenner006.github.io/tags/JDBC/"},{"name":"essay","slug":"essay","permalink":"http://zenner006.github.io/tags/essay/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zenner006.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://zenner006.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"编程题","slug":"编程题","permalink":"http://zenner006.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]}