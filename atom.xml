<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zenner&#39;s Blog</title>
  
  <subtitle>巨饼的技术博</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-28T07:57:05.539Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven基础</title>
    <link href="http://yoursite.com/2021/03/13/Maven-basic-md/"/>
    <id>http://yoursite.com/2021/03/13/Maven-basic-md/</id>
    <published>2021-03-13T14:02:22.000Z</published>
    <updated>2021-06-28T07:57:05.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-Maven介绍"><a href="#第一章-Maven介绍" class="headerlink" title="第一章 Maven介绍"></a>第一章 Maven介绍</h2><h3 id="1-1-什么是Maven"><a href="#1-1-什么是Maven" class="headerlink" title="1.1 什么是Maven"></a>1.1 什么是Maven</h3><p>Maven 是一个项目管理工具，它包含了一个<strong>项目对象模型</strong> (POM：Project Object Model)，一组<strong>标准集合</strong>，一个<strong>项目生命周期</strong>(Project Lifecycle)，一个<strong>依赖管理系统</strong>(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</p><h3 id="1-2-Maven两个经典作用"><a href="#1-2-Maven两个经典作用" class="headerlink" title="1.2 Maven两个经典作用"></a>1.2 Maven两个经典作用</h3><h4 id="1-2-1-Maven-的依赖管理"><a href="#1-2-1-Maven-的依赖管理" class="headerlink" title="1.2.1 Maven 的依赖管理"></a>1.2.1 Maven 的依赖管理</h4><p>要将项目运行起来，就得要把项目所依赖得jar包添加到工程，项目工程大小就很大，得几兆。</p><p>如果使用Maven则会发现总体上工程的大小会少很多。</p><p>因为Maven把所用到得jar包管理到了一个仓库中。它让任何想要用jar包的工程都去从仓库中引用。那么每个工程就不用自己携带jar包了。在每个项目中放置jar包在jar包仓库中的坐标即可。</p><p>这个就叫做Maven的<strong>依赖管理</strong>。</p><p>Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。</p><p><img src="/.com//image-20210313221728818.png" alt="image-20210313221728818"></p><a id="more"></a><p>maven 工程中不直接将 jar 包导入到工程中，而是<strong>通过在 pom.xml 文件中添加所需 jar 包的坐标</strong>。</p><blockquote><p>问题一：通过读取 pom.xml 文件中的坐标，再到仓库中找到 jar 包，会不会很慢？从而导致这种方式 不可行！</p><p>​             通过 pom.xml 文件配置要引入的 jar 包的坐标，再读取坐标并到仓库中加载 jar 包，这样我们就可以直接使用 jar 包了，为了解决这个过程中速度慢的问题，maven 中也有索引的概念，通 过建立索引，可以大大提高加载 jar 包的速度，使得我们认为 jar 包基本跟放在本地的工程文件中再 读取出来的速度是一样的。</p></blockquote><h4 id="1-2-2-项目的一键构建"><a href="#1-2-2-项目的一键构建" class="headerlink" title="1.2.2 项目的一键构建"></a>1.2.2 项目的一键构建</h4><p>项目往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。</p><p><strong>构建</strong>指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理的过程。</p><p><strong>一键构建</strong>指的是整个构建过程，使用 maven一个命令（<strong>mvn tomcat:run</strong>）可以轻松完成整个工作。</p><h2 id="第二章-Maven的使用"><a href="#第二章-Maven的使用" class="headerlink" title="第二章 Maven的使用"></a>第二章 Maven的使用</h2><h3 id="2-1-Maven的安装"><a href="#2-1-Maven的安装" class="headerlink" title="2.1 Maven的安装"></a>2.1 Maven的安装</h3><h4 id="2-1-1-下载与安装"><a href="#2-1-1-下载与安装" class="headerlink" title="2.1.1 下载与安装"></a>2.1.1 下载与安装</h4><p>下载后解压即可，放在一个没有中文没有空格的路径下。</p><p><img src="/.com//image-20210314193027480.png" alt="image-20210314193027480"></p><h4 id="2-1-2-配置系统变量"><a href="#2-1-2-配置系统变量" class="headerlink" title="2.1.2 配置系统变量"></a>2.1.2 配置系统变量</h4><p>配置 <strong>MAVEN_HOME</strong> ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录）</p><p>然后在系统变量中加入 <strong>%MAVEN_HOME%/bin</strong></p><h4 id="2-1-3-Maven-版本测试"><a href="#2-1-3-Maven-版本测试" class="headerlink" title="2.1.3 Maven 版本测试"></a>2.1.3 Maven 版本测试</h4><p><code>mvn -v</code> 检查maven是否安装成功。</p><h3 id="2-2-Maven仓库"><a href="#2-2-Maven仓库" class="headerlink" title="2.2 Maven仓库"></a>2.2 Maven仓库</h3><h4 id="2-2-1-Maven-仓库的分类"><a href="#2-2-1-Maven-仓库的分类" class="headerlink" title="2.2.1 Maven 仓库的分类"></a>2.2.1 Maven 仓库的分类</h4><p><strong>“远程仓库”</strong>，<strong>“本地仓库”</strong>，“<strong>中央仓库</strong>”的关系</p><ul><li><strong>本地仓库</strong>：用来存储从远程仓库或中央仓库下载的插件和 jar 包，<ul><li>默认本地仓库位置在 <code>${user.dir}/.m2/repository</code>，<code>${user.dir}</code>表示 windows 用户目录。</li></ul></li><li><strong>远程仓库</strong>：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。</li><li><strong>中央仓库</strong>：在 maven 软件中内置一个远程仓库地址 <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a> ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件。</li></ul><p><img src="/.com//maven仓库的种类和关系.png" alt="maven仓库的种类和关系"></p><h4 id="2-2-2-Maven-本地仓库的配置"><a href="#2-2-2-Maven-本地仓库的配置" class="headerlink" title="2.2.2 Maven 本地仓库的配置"></a>2.2.2 Maven 本地仓库的配置</h4><p>在 <code>MAVE_HOME/conf/settings.xml</code> 文件中配置本地仓库位置（maven 的安装目录下)</p><p>打开 settings.xml文件，配置其中<code>localRepository</code>标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\software\Programing_software\maven_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-全局-setting-与用户-setting"><a href="#2-2-3-全局-setting-与用户-setting" class="headerlink" title="2.2.3 全局 setting 与用户 setting"></a>2.2.3 全局 setting 与用户 setting</h4><p>maven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。 </p><p>在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project 项目，它作为 maven 的全局配置。 </p><p>如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：<code>${user.dir} /.m2/settings.xml</code> 目录中,<code>${user.dir}</code> 指 windows 中的用户目录。 </p><p>maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。</p><p><img src="/.com//image-20210314195549254.png" alt="image-20210314195549254"></p><h3 id="2-3-Maven-工程的认识"><a href="#2-3-Maven-工程的认识" class="headerlink" title="2.3 Maven 工程的认识"></a>2.3 Maven 工程的认识</h3><h4 id="2-3-1-Maven-工程的目录结构"><a href="#2-3-1-Maven-工程的目录结构" class="headerlink" title="2.3.1 Maven 工程的目录结构"></a>2.3.1 Maven 工程的目录结构</h4><p>这个目录结构不是上面那个Maven软件的目录结构。而是用Maven管理的工程的目录结构</p><p>一个项目管理起来所需要的几个组成部分都有四种：</p><p>（1）核心代码部分</p><p>（2）配置文件部分</p><p>（3）测试代码部分</p><p>（4）测试配置部分</p><p>传统项目目录结构：</p><p>src目录下存放着四种代码。打包的时候可能会发生交叉混乱。</p><p>Maven建立了一个项目的标准目录结构</p><p><img src="/.com//image-20210314195150747.png" alt="image-20210314195150747"></p><h2 id="第3章-Maven-常用命令"><a href="#第3章-Maven-常用命令" class="headerlink" title="第3章 Maven 常用命令"></a>第3章 Maven 常用命令</h2><h3 id="3-1-Maven-常用命令"><a href="#3-1-Maven-常用命令" class="headerlink" title="3.1 Maven 常用命令"></a>3.1 Maven 常用命令</h3><p>在Maven工程下，打开命令提示符，可以输入Maven 常用命令对Maven工程进行操作。</p><h4 id="3-1-1-mvn-clean"><a href="#3-1-1-mvn-clean" class="headerlink" title="3.1.1 mvn clean"></a>3.1.1 mvn clean</h4><p>可以把target文件夹删除掉。也就是删除之前编译的信息。</p><h4 id="3-1-2-mvn-compile"><a href="#3-1-2-mvn-compile" class="headerlink" title="3.1.2 mvn compile"></a>3.1.2 mvn compile</h4><p>仅把<code>src/main</code>目录下的代码进行编译。</p><h4 id="3-1-3-mvn-test"><a href="#3-1-3-mvn-test" class="headerlink" title="3.1.3 mvn test"></a>3.1.3 mvn test</h4><p>对<code>src/test</code>下的代码进行测试。而且还把<code>src/main</code>目录下的代码也进行编译</p><h4 id="3-1-4-mvn-package"><a href="#3-1-4-mvn-package" class="headerlink" title="3.1.4 mvn package"></a>3.1.4 mvn package</h4><p>对整个项目进行打包。还生成了war文件。</p><p>查看pom.xml文件就会发现，配置文件中配置了打包成war包。</p><h4 id="3-1-5-mvn-install"><a href="#3-1-5-mvn-install" class="headerlink" title="3.1.5 mvn install"></a>3.1.5 mvn install</h4><p>相当于<code>mvn package</code>后，再把war包安装到了本地仓库。</p><h3 id="3-2-Maven-指令的生命周期"><a href="#3-2-Maven-指令的生命周期" class="headerlink" title="3.2 Maven 指令的生命周期"></a>3.2 Maven 指令的生命周期</h3><p>Maven工程的过程</p><p><strong>清理生命周期（Clean Lifecycle）</strong> 在进行真正的构建之前进行一些清理工作。</p><p><strong>默认生命周期（Default Lifecycle）</strong> 构建的核心部分，编译，测试，打包，部署等等。</p><p><strong>站点生命周期（Site Lifecycle）</strong> 生成项目报告，站点，发布站点。</p><p><img src="/.com//image-20210315110019302.png" alt="image-20210315110019302"></p><h3 id="3-3-Maven概念模型"><a href="#3-3-Maven概念模型" class="headerlink" title="3.3 Maven概念模型"></a>3.3 Maven概念模型</h3><p>Maven 包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段 (phase)中插件(plugin)目标(goal)的逻辑。</p><p><img src="/.com//image-20210315110905565.png" alt="image-20210315110905565"></p><h3 id="3-4-idea开发maven项目"><a href="#3-4-idea开发maven项目" class="headerlink" title="3.4 idea开发maven项目"></a>3.4 idea开发maven项目</h3><h4 id="3-4-1-在idea中配置maven"><a href="#3-4-1-在idea中配置maven" class="headerlink" title="3.4.1 在idea中配置maven"></a>3.4.1 在idea中配置maven</h4><p>要在idea中使用maven就要配置它。</p><p>setttings里搜maven。然后填写maven主目录，设置文件路径，还有本地仓库路径。</p><p>running里面配置：<code>-DarchetypeCatalog=internal</code> 使得它首先从本地仓库中找包。</p><p>再对maven下的setting进行配置阿里云的镜像：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-2-使用maven骨架创建java工程"><a href="#3-4-2-使用maven骨架创建java工程" class="headerlink" title="3.4.2 使用maven骨架创建java工程"></a>3.4.2 使用maven骨架创建java工程</h4><p>新建maven项目就好。选择quickstart骨架。然后结束后，它不会把整个的目录创建好，需要手动补齐。</p><p>添加 resources文件。</p><h4 id="3-4-3-使用maven无骨架创建java工程"><a href="#3-4-3-使用maven无骨架创建java工程" class="headerlink" title="3.4.3 使用maven无骨架创建java工程"></a>3.4.3 使用maven无骨架创建java工程</h4><p>新建maven项目就好。然后结束后，他有着默认的maven目录结构。</p><h4 id="3-4-4-使用maven骨架创建web工程"><a href="#3-4-4-使用maven骨架创建web工程" class="headerlink" title="3.4.4 使用maven骨架创建web工程"></a>3.4.4 使用maven骨架创建web工程</h4><p>用到了webapp骨架。创建好以后，只有<code>src/main/webapp</code>目录。其他的需要自主创建。</p><h3 id="3-5-创建一个servlet"><a href="#3-5-创建一个servlet" class="headerlink" title="3.5 创建一个servlet"></a>3.5 创建一个servlet</h3><h4 id="3-5-1-指定某目录为web资源包"><a href="#3-5-1-指定某目录为web资源包" class="headerlink" title="3.5.1 指定某目录为web资源包"></a>3.5.1 指定某目录为web资源包</h4><p>可以在<code>webapp</code>下加入网页资源文件。要想在其他文件夹下加入网页资源文件可以把该文件设为该工程的”project structure”，“module”，然后“web”。</p><h4 id="3-5-2-导入项目依赖的jar包"><a href="#3-5-2-导入项目依赖的jar包" class="headerlink" title="3.5.2 导入项目依赖的jar包"></a>3.5.2 导入项目依赖的jar包</h4><p>给<code>pom.xml</code>加入依赖jar包。可以直接在中央仓库中找xml的写法。</p><p>这里写了一个<code>servlet</code>。需要两个jar包。<code>servlet</code> 和 <code>jsp</code></p><p>然后用 <code>mvn tomcat:run</code> 来运行。</p><p>发现报错</p><h4 id="3-5-3-解决jar包冲突"><a href="#3-5-3-解决jar包冲突" class="headerlink" title="3.5.3 解决jar包冲突"></a>3.5.3 解决jar包冲突</h4><p>因为tomcat是maven带的。它里面也带了<code>servlet</code> 和 <code>jsp</code>。运行时把代码拿进去发现这两个对象不一样。所以会出现冲突。</p><p>为解决这个问题需要给<code>pom.xml</code>里的依赖包加入一个范围。这个范围决定了该<code>jar</code>包仅在写的时候不让他报错就好。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样下来就可以使得代码用tomcat里的包了。</p><h4 id="3-5-4-maven工程运行环境修改"><a href="#3-5-4-maven工程运行环境修改" class="headerlink" title="3.5.4 maven工程运行环境修改"></a>3.5.4 maven工程运行环境修改</h4><p>还可以用tomcat7，还设置了端口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般这种可以设置动态模板的方式来定义。</p><p>setting ——Live templates——加号选择创建动态模板的组。然后在该组里创建模板。写入模板代码，然后定义模板使用范围XML。就可以在XML中写入tomcat7，自动导入tomcat7插件模板。</p><h4 id="3-5-5-maven的java工程从mysql中取数据"><a href="#3-5-5-maven的java工程从mysql中取数据" class="headerlink" title="3.5.5 maven的java工程从mysql中取数据"></a>3.5.5 maven的java工程从mysql中取数据</h4><ol><li>先在mySQL里建立一个数据库，建立表Items，有id，name两个列</li><li>创建一个java工程</li><li>创建一个Items类，有两个私有变量。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章-Maven介绍&quot;&gt;&lt;a href=&quot;#第一章-Maven介绍&quot; class=&quot;headerlink&quot; title=&quot;第一章 Maven介绍&quot;&gt;&lt;/a&gt;第一章 Maven介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是Maven&quot;&gt;&lt;a href=&quot;#1-1-什么是Maven&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是Maven&quot;&gt;&lt;/a&gt;1.1 什么是Maven&lt;/h3&gt;&lt;p&gt;Maven 是一个项目管理工具，它包含了一个&lt;strong&gt;项目对象模型&lt;/strong&gt; (POM：Project Object Model)，一组&lt;strong&gt;标准集合&lt;/strong&gt;，一个&lt;strong&gt;项目生命周期&lt;/strong&gt;(Project Lifecycle)，一个&lt;strong&gt;依赖管理系统&lt;/strong&gt;(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;1-2-Maven两个经典作用&quot;&gt;&lt;a href=&quot;#1-2-Maven两个经典作用&quot; class=&quot;headerlink&quot; title=&quot;1.2 Maven两个经典作用&quot;&gt;&lt;/a&gt;1.2 Maven两个经典作用&lt;/h3&gt;&lt;h4 id=&quot;1-2-1-Maven-的依赖管理&quot;&gt;&lt;a href=&quot;#1-2-1-Maven-的依赖管理&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 Maven 的依赖管理&quot;&gt;&lt;/a&gt;1.2.1 Maven 的依赖管理&lt;/h4&gt;&lt;p&gt;要将项目运行起来，就得要把项目所依赖得jar包添加到工程，项目工程大小就很大，得几兆。&lt;/p&gt;
&lt;p&gt;如果使用Maven则会发现总体上工程的大小会少很多。&lt;/p&gt;
&lt;p&gt;因为Maven把所用到得jar包管理到了一个仓库中。它让任何想要用jar包的工程都去从仓库中引用。那么每个工程就不用自己携带jar包了。在每个项目中放置jar包在jar包仓库中的坐标即可。&lt;/p&gt;
&lt;p&gt;这个就叫做Maven的&lt;strong&gt;依赖管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/.com//image-20210313221728818.png&quot; alt=&quot;image-20210313221728818&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    <category term="java web" scheme="http://yoursite.com/categories/java/java-web/"/>
    
    
    <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-05</title>
    <link href="http://yoursite.com/2020/12/11/zuoshen-basic-class-5/"/>
    <id>http://yoursite.com/2020/12/11/zuoshen-basic-class-5/</id>
    <published>2020-12-11T09:52:44.000Z</published>
    <updated>2020-12-11T10:08:24.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一-认识哈希函数和哈希表"><a href="#题目一-认识哈希函数和哈希表" class="headerlink" title="题目一 认识哈希函数和哈希表"></a>题目一 认识哈希函数和哈希表</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><strong>一、性质</strong></p><ol><li>哈希函数的输入域是无限大的；</li><li>哈希函数的输出域是有穷尽的；</li><li>输入如果一样，输出一定一样；</li><li><strong>哈希碰撞：</strong>输入不一样，也可能得到输出一样的值；（因为输入域无穷大，输出域有限大，所以必然会产生冲突；)</li><li>哈希函数的离散性：也就是输出域每个值被输出的概率都差不多一样大；</li></ol><p><strong>二、特征</strong></p><ol><li>输出的值和输入没有关系；保证它结果是均匀出现的；</li></ol><p><strong>三、找到一千个独立的哈希函数</strong></p><p>独立的意思在于一个哈希函数不会随着一个的变化而变化；</p><a id="more"></a><p><strong>具体做法</strong>：</p><p>一个哈希函数可以生成16位的十六进制的输出集；他们每个位的码都是相互不关联的；</p><p>那么可以把它前八位作为一个哈希函数$h_1$，后八位做一个哈希函数$h_2$</p><p>紧接着，$h_3 = h_1+1*h_2$ ；这里第三个哈希函数与他们两个是没有关系的；</p><p>以此类推： $h_i=h_1+(i-2)*h_2$ 做出很多很多的哈希函数，并且它们相互之间是相互独立的；</p><p><strong>四、 粗略介绍哈希函数的内部构造</strong></p><p>比如说一个字符串，不管多长，要把它得到一个16位的哈希函数；</p><p>就分割16位16位的异或，再错位异或之类的；</p><p>实现方法有很多；</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表可以： <code>put(key1, value1)</code>，<code>get(key1)</code>，<code>remote(key1)</code></p><p><strong>一、哈希表的存放</strong></p><p>比方有一个数组大小是 <code>N</code>，进来一个<code>(key, value)</code> ; </p><p>通过计算 <code>key</code>的哈希值，膜上数组的大小 <code>N</code> ;  可以在数组中找到一个存放这个<code>(key, value)</code> 的位置；以节点的形式把它存放在数组中；</p><p>再有值进来冲突了某个位置，就在节点后形成链表的形式；</p><p><strong>二、哈希表的扩容</strong></p><p>某一个位置的链很长了，那么就把它扩容；扩容讲究也很宽泛。可以<strong>成倍扩容</strong>；那么存放N个元素可能就要扩容 $log_2N$次</p><p><strong>离线扩容</strong>：指的是在用的哈希表已经很元素很多了，那么想办法先让访问都在目前的哈希表上访问；然后再后台再扩容的空间里把元素放进来。等做好后就把访问引到这个上面来；它扩容过程不占用线上访问时间；</p><h2 id="哈希函数的一个使用场景"><a href="#哈希函数的一个使用场景" class="headerlink" title="哈希函数的一个使用场景"></a>哈希函数的一个使用场景</h2><p>【面试题】：给你一个大文件，100T，寸的都是数字；把其中所有数字得到一个新文件，保证每个数不重复；</p><p>给1000个机器；为了充分使用这1000个机器，可以用哈希函数来给1000个机器来分流。每从大文件中读书来一个数，就算出它的哈希函数。然后再膜上1000，决定它该由哪个机器处理。这样做有个好处就是相同的数会被分配到同一个机器上去；这样重复的值就可以被找到；</p><p>大数据的题目：就用哈希函数，相同输入导致相同输出。不同输入均匀分布；</p><h1 id="题目二-设计RandomPool结构"><a href="#题目二-设计RandomPool结构" class="headerlink" title="题目二 设计RandomPool结构"></a>题目二 设计RandomPool结构</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一种结构，在该结构中有如下三个功能： </p><ul><li><strong>insert(key)</strong>：将某个key加入到该结构，做到不重复加入。 </li><li><strong>delete(key)</strong>：将原本在结构中的某个key移除。 </li><li><strong>getRandom()</strong>： 等概率随机返回结构中的任何一个key。</li></ul><p>【要求】<code>Insert</code>、<code>delete</code>和<code>getRandom</code>方法的时间复杂度都是 <code>O(1)</code></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>前两个方法是可以考虑用一个哈希表来自然实现的；但是第三个单纯用一个哈希表是得不到的；</p><p>所以这里除了原本的哈希表还需要另外的结构来辅助完成这个功能；</p><ol><li><p>在不考虑delete的情况，仅仅往哈希表里的加入元素：</p><p>我们要知道加入了几个了</p><p>第一个哈希表加入第一个元素<code>(key,value)</code>，另一个哈希表加入（value，key），value表示第几次插入到这个哈希表中；</p><p>我们在第一个哈希表中可以根据key找到它是第几个插入的；在第二个可以通过第几个插入的找到key值；</p><p>str0 —— 0    0 —— str0</p><p>str1 —— 1    1 —— str1</p><p>str2 —— 2    2 —— str2</p><p>strN —— N    N —— strN</p><p>以此类推，加入<code>N</code>个后，可以在 <code>0 ~ N-1</code>之间随机选择一个数在第二个哈希表找到key，再在第二个哈希表中找到相对应的值；这种情况下，可以根据加入元素多少实现等概率返回。</p></li><li><p>删除情况：</p><p>比方要删除 <code>0 ~ N-1</code> 中的某一个数。可以在第一个哈希表中找到它是第几个加入的。相对应的加入的元素数目也减少了；但是在随机的时候就可能随机到 <code>i</code>。另外由于总数变为 <code>N-1</code>了，随机范围是 <code>0 ~ N-2</code>了，所以之前最后一个加入的次序为 <code>N-1</code> 的元素就随机不到了。所以可以用最后一个加入的这个元素补被删除的那个位置。</p><p>另外这里的进入哈希表的次序只不过是一个辅助信息。它在接口中，不对外呈现；所以更改它没有多大影响；</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; KeyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; IndexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.IndexKeyMap = <span class="keyword">new</span> HashMap&lt;Integer, K&gt;();</span><br><span class="line">        <span class="keyword">this</span>.KeyIndexMap = <span class="keyword">new</span> HashMap&lt;K, Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.KeyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.put(key, size);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.put(size ++ , key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Already exits!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.KeyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteIndex = <span class="keyword">this</span>.KeyIndexMap.get(key);</span><br><span class="line">            <span class="keyword">int</span> lastIndex = --<span class="keyword">this</span>.size;</span><br><span class="line">            K lastKey = <span class="keyword">this</span>.IndexKeyMap.get(lastIndex);</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="keyword">this</span>.KeyIndexMap.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"SomeThing Wrong!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) (Math.random() * <span class="keyword">this</span>.size); <span class="comment">// 0 ~ size - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.IndexKeyMap.get(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在序列中出现了洞，用最后一个去填是常规操作</strong></p><h1 id="题目三-认识布隆过滤器"><a href="#题目三-认识布隆过滤器" class="headerlink" title="题目三 认识布隆过滤器"></a>题目三 认识布隆过滤器</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设有一个需求：100亿个<strong>url</strong>黑名单；每个url是64字节；使用场景是，给一个 url 如果这个 url 属于黑名单，那就返回 true， 否则返回 false；</p><p>这种场景用哈希表的话就需要把所有的东西加入到内存当中来；这样子所需的内存资源就很多很多。所以就可以用布隆过滤器；</p><p>布隆过滤器有一个缺点：它有一定的失误率（宁可错杀3000不可放过一个；在黑名单的不会弄错，他会返回 True；但是不在黑名单的有一定的概率会搞错。）</p><ol><li><p>布隆过滤器需要先准备一个长比特数组，它的长度为 $m$ ；使用这个长比特数组的目的就在于我们准备用其中某几个 <code>bit</code> 的位置来组合说明某个url是否存在；</p><ul><li>长比特数组的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个整数的位数是 32个bit，那么申请的整数数组是 32000 bits</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">30000</span>;  <span class="comment">// 把第 30000 个位置描黑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intIndex = index / <span class="number">32</span>;    <span class="comment">// 它在整数数组里的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitIndex = index % <span class="number">32</span>;  <span class="comment">// 在所在的整数里的哪一个 bit 位；</span></span><br><span class="line"></span><br><span class="line">    arr[intIndex] = (arr[intIndex] | (<span class="number">1</span> &lt;&lt; bitIndex));  <span class="comment">// 把arr[intIndex] 这个整数的 第bitIndex位描黑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对每个 url 我们把它经过 $k$ 个独立的哈希函数，算出 $k$ 个哈希值，再膜上比特数组的长度 $m$ 得到比特数组的 $k$ 个位置 ；分别在数组上把这 $k$ 个位置给描黑（写上1）；</p></li></ol><ol><li><p>查询：来了一个 url ，用它经过我们之前的 $k$ 个哈希函数，同样的方法求出来 $k$ 个位置；看比特数组中这 $k$ 个位置是否被描黑了；如果都被描黑了，则我们可以认为这个 url 在黑名单里（有可能有失误，碰巧那几个都被涂黑了。）。如果有一个不是黑的，则它绝对不在黑名单了；</p><ul><li><p>所以选择哈希函数的 $k$ 的大小，和比特数组长度 $m$ 来控制失误率；</p><ul><li>$m$ 越大，失误率降低；$m$ 越小，失误率升高；下面是 $m$ 的所需公式 ：$n$ 表示样本量；$p$ 是预期失误率；</li></ul><script type="math/tex; mode=display">m = -\frac{n*\ln p}{(\ln 2)^2}</script><ul><li>确定哈希函数个数 $k$ 的个数：这个数是小数需要向上取整<script type="math/tex; mode=display">k=\ln 2 * \frac{m}{n}</script></li></ul></li></ul></li></ol><ul><li>当哈希函数个数 $k$ 和样本数 $m$ 确定时（都向上取整了），预期失误率是：<pre><code>$$p=(1-e^{-\frac{n*k}{m}})^k$$</code></pre></li></ul><h1 id="题目四-认识一致性哈希"><a href="#题目四-认识一致性哈希" class="headerlink" title="题目四 认识一致性哈希"></a>题目四 认识一致性哈希</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p><strong>经典服务器抗压结构</strong>：后端集群有 $N$ 台机器；前端获取请求后根据请求的 $key$ 来得到一个哈希值。 然后在得到这个哈希值除以 $N$ 的余数；根据这个余数把这个请求分配到相对应位置的机器上。这样会使得几台机器得到的请求压力差不多相同。（<strong>负载均衡</strong>）</p><p>但是当需要在这个结构中加机器或者减机器的时候这个结构就需要大范围的改动。因为每一个key的哈希值会根据新的机器数和之前得到的位置是不同的。（<strong>数据归属变化了</strong>）</p><p>这种情况下就可以使用一致性哈希。<strong>它可以把数据迁移代价变得很低，又负载均衡</strong>；</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="/.com//image-20201210152321153.png" alt="image-20201210152321153"></p><p><strong>实际服务器集群的结构：</strong></p><p><img src="/.com//image-20201210153820881.png" alt="image-20201210153820881"></p><p><strong>此时需要加入新的机器</strong></p><p><img src="/.com//image-20201210160021986.png" alt="image-20201210160021986"></p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li>在机器数量比较小的时候，他们在哈希值组成的环中的分布不是均分的；使得某个机器可能负载过多；</li><li>即使人为的让他分布均匀，但是再加入新机器时；还是会破环原来的均衡；</li></ul><p>这里我们可以用<strong>虚拟节点技术</strong>来解决这个问题；</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>每个物理机器不再使用自己的ip信息来分配哈希域的区间</p><p><img src="/.com//image-20201210170417902.png" alt="image-20201210170417902"></p><h1 id="题目五-岛问题"><a href="#题目五-岛问题" class="headerlink" title="题目五 岛问题"></a>题目五 岛问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？</p><p>举例： </p><p>0 0 1 0 1 0 </p><p>1 1 1 0 1 0 </p><p>1 0 0 1 0 0 </p><p>0 0 0 0 0 0</p><p>这个矩阵中有三个岛。</p><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><p>单任务的想法：</p><ul><li>遇到岛就深度遍历把遍历过的都给标记起来。之后遇到标记过的，直接跳过，直到遇到未标记的岛，就给岛的数量加一；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = m.length;</span><br><span class="line">    <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                res ++;</span><br><span class="line">                infect(m, i, j, N, M);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = <span class="number">2</span>;</span><br><span class="line">    infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">    infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">    infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">    infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多任务的思想（并行计算）：</p><ul><li>把矩阵分块处理分别数出其中各自有多少岛屿</li><li>然后对矩阵块的边缘进行考虑<ul><li>普遍情况下要对矩阵间的边缘也就是 灰色部分进行考察；两个矩阵边缘相连，在不同情况下是不同的，在下图中两个边缘区域相连，他们总岛屿数 - 1；<img src="/.com//image-20201211162620873.png" alt="image-20201211162620873"></li></ul></li><li>考虑矩阵块边界相连时，把各个矩阵块里找到的岛屿当作并查集；</li><li>搜索边界，如果分属于两个矩阵块里的岛屿（并查集）在边界是相连的但是没有被合并过，那么总岛屿数减一，把他们相连；</li></ul><h1 id="题目六-并查集"><a href="#题目六-并查集" class="headerlink" title="题目六 并查集"></a>题目六 并查集</h1><p>概念好理解，但是比较难的是在什么场合去应用他。</p><h2 id="可应用的地方"><a href="#可应用的地方" class="headerlink" title="可应用的地方"></a>可应用的地方</h2><ul><li>检查两个元素是否属于一个集合： <ul><li><code>isSameSet(A, B)</code> ：</li></ul></li><li>两个元素各自所在的集合合并在一起：<ul><li><code>set union(element A, element B)</code>  </li></ul></li></ul><h2 id="并查集的结构"><a href="#并查集的结构" class="headerlink" title="并查集的结构"></a>并查集的结构</h2><p><strong>并查集的初始化</strong></p><p>初始化时需要把所有的元素都给出；并每个元素都可以被看成是独立的集合；它有一个自旋指向；</p><p>并查集代表一个集合的节点会把指针指向自己；可以通过指针指向自己的节点识别出集合的头。</p><p><img src="/.com//image-20201211095208875.png" alt="image-20201211095208875"></p><p><strong>并查集合并</strong></p><p>两个集合合并时任意的让其中一个集合的代表节点解除自旋指向，指向另一个并查集中的节点：</p><p><strong>一般会让节点数更小的，指向节点多一些的并查集。</strong></p><p><img src="/.com//image-20201211095510716.png" alt="image-20201211095510716"></p><p><strong>检查元素是否在一个集合</strong>：就是找到两个节点一直找到他们所在集合的代表节点，看他们是否是一个节点；</p><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h2><p><strong>查询后再优化，仅优化查询路径上的节点</strong></p><p>查询 $4$ 节点会路过三个节点，直到找到 $1$ 节点</p><p><img src="/.com//image-20201211100851717.png" alt="image-20201211100851717"></p><p>然后再把这个结构进行优化成这个样子：</p><p><img src="/.com//image-20201211101606972.png" alt="image-20201211101606972"></p><p>至于那些指向 $4$ 或者 $3$ 和 $2$ 的都保持原地不动。仅仅把查询 $4$ 到代表节点的路径扁平化，让它们指向 $1$ 节点；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// whatever you like</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">        fatherMap.clear();</span><br><span class="line">        sizeMap.clear();</span><br><span class="line">        <span class="keyword">for</span> (Node node: nodes) &#123;</span><br><span class="line">            fatherMap.put(node, node);</span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node father = fatherMap.get(node);</span><br><span class="line">        <span class="keyword">if</span> (father != node) &#123;</span><br><span class="line">            father = findHead(father);</span><br><span class="line">        &#125;</span><br><span class="line">        fatherMap.put(node, father);</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node aHead = findHead(a);</span><br><span class="line">        Node bHead = findHead(b);</span><br><span class="line">        <span class="keyword">if</span> (aHead != bHead) &#123;</span><br><span class="line">            <span class="keyword">int</span> aSetSize = sizeMap.get(aHead);</span><br><span class="line">            <span class="keyword">int</span> bSetSIze = sizeMap.get(bHead);</span><br><span class="line">            <span class="keyword">if</span> (aSetSize &lt;= bSetSIze) &#123;</span><br><span class="line">                fatherMap.put(aHead, bHead);</span><br><span class="line">                sizeMap.put(bHead, aSetSize + bSetSIze);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fatherMap.put(bHead, aHead);</span><br><span class="line">                sizeMap.put(aHead, aSetSize + bSetSIze);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>所有的操作包括：查询过程 + 合并过程 ——&gt; $O(N)$ 及以上，那么平均每次操作都是常数级别，可以说是：$O(1)$</p><h2 id="应用：岛问题"><a href="#应用：岛问题" class="headerlink" title="应用：岛问题"></a>应用：<a href="#题目五 岛问题">岛问题</a></h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目一-认识哈希函数和哈希表&quot;&gt;&lt;a href=&quot;#题目一-认识哈希函数和哈希表&quot; class=&quot;headerlink&quot; title=&quot;题目一 认识哈希函数和哈希表&quot;&gt;&lt;/a&gt;题目一 认识哈希函数和哈希表&lt;/h1&gt;&lt;h2 id=&quot;哈希函数&quot;&gt;&lt;a href=&quot;#哈希函数&quot; class=&quot;headerlink&quot; title=&quot;哈希函数&quot;&gt;&lt;/a&gt;哈希函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一、性质&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希函数的输入域是无限大的；&lt;/li&gt;
&lt;li&gt;哈希函数的输出域是有穷尽的；&lt;/li&gt;
&lt;li&gt;输入如果一样，输出一定一样；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希碰撞：&lt;/strong&gt;输入不一样，也可能得到输出一样的值；（因为输入域无穷大，输出域有限大，所以必然会产生冲突；)&lt;/li&gt;
&lt;li&gt;哈希函数的离散性：也就是输出域每个值被输出的概率都差不多一样大；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;二、特征&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输出的值和输入没有关系；保证它结果是均匀出现的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;三、找到一千个独立的哈希函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;独立的意思在于一个哈希函数不会随着一个的变化而变化；&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="哈希" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E5%93%88%E5%B8%8C/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="哈希函数" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    
    <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="布隆过滤器" scheme="http://yoursite.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    <category term="一致性哈希" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
    <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-04</title>
    <link href="http://yoursite.com/2020/12/03/zuoshen-basic-class-4/"/>
    <id>http://yoursite.com/2020/12/03/zuoshen-basic-class-4/</id>
    <published>2020-12-03T08:16:55.000Z</published>
    <updated>2020-12-11T09:57:39.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一-实现二叉树的先序、中序、后序遍历"><a href="#题目一-实现二叉树的先序、中序、后序遍历" class="headerlink" title="题目一 实现二叉树的先序、中序、后序遍历"></a>题目一 实现二叉树的先序、中序、后序遍历</h1><p><strong>包括递归方式和非递归方式</strong></p><h2 id="递归方式遍历"><a href="#递归方式遍历" class="headerlink" title="递归方式遍历"></a>递归方式遍历</h2><p><img src="/.com//image-20201120112203883.png" alt="image-20201120112203883"></p><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol><li>自行准备一个栈，判断头节点非空时，将头节点压入栈中</li><li>以下部分循环：直到栈为空；<ol><li>弹出节点，输出</li><li>判断是否有右孩子，有的话压入栈中</li><li>判断是否有左孩子，有的话压入栈中</li></ol></li><li>打印换行，结束</li></ol><a id="more"></a><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol><li>准备一个栈，</li><li>循环：当栈为空且当前指针为空时停止<ol><li>当前节点不为空：<ul><li>当前节点压入栈中，当前节点找到左孩子；</li></ul></li><li>当前节点为空<ul><li>从栈中弹出给当前节点，打印；然后当前节点找到右孩子；</li></ul></li></ol></li></ol><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先序遍历是: <code>中右左</code>；</p><p>后序遍历是：<code>中左右</code>的逆序；可以用到先序遍历的技巧+栈序打印；</p><p>也就是再先序遍历打印的位置把它保存起来；逆序打印；所以用到栈结构保存，再弹出打印就很方便；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    Node tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        tmp = stack.pop();</span><br><span class="line">        System.out.print(tmp.value + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    Stack&lt;Node&gt; stack_p = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        tmp = stack.pop();</span><br><span class="line">        stack_p.push(tmp);</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack_p.isEmpty()) &#123;</span><br><span class="line">        System.out.print(stack_p.pop().value + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        Node c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                1. 左节点为空或者它的孩子节点刚被输出过</span></span><br><span class="line"><span class="comment">                    反过来想，这个节点的左孩子不为空，并且左孩子没有被刚输出（没有右孩子），右孩子也没有被刚输出（左孩子可能被输出过了）</span></span><br><span class="line"><span class="comment">                    这种情况下就需要把左孩子压栈</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; head != c.left &amp;&amp; head != c.right) &#123; </span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                2. 右节点为空或者它的右节点刚被输出过；</span></span><br><span class="line"><span class="comment">                    右孩子不为空，并且栈顶结点的右孩子没有被输出过，满足这个条件即可压入栈</span></span><br><span class="line"><span class="comment">                    因为左孩子被上一个判断了，它可能为空，也可能被输出过了。</span></span><br><span class="line"><span class="comment">                    在这一步判断要不要把右孩子加入到栈中不重要；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; head != c.right) &#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               3. 当前栈顶节点的左右孩子要么为空要么被输出了，那么就把它输出了；</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="comment">// 当前栈顶节点，在以上两个条件同时不满足的情况下输出：</span></span><br><span class="line">                System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">                head = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目二-如何直观的打印一颗二叉树"><a href="#题目二-如何直观的打印一颗二叉树" class="headerlink" title="题目二 如何直观的打印一颗二叉树"></a>题目二 如何直观的打印一颗二叉树</h1><p>左神说：从上到下的树很难画出来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for test -- print tree</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">    printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">    String val = to + head.value + to;</span><br><span class="line">    <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">    <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">    val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height * len) + val);</span><br><span class="line">    printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String space = <span class="string">" "</span>;</span><br><span class="line">    StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        buf.append(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目三-在二叉树中找到一个节点的后继节点"><a href="#题目三-在二叉树中找到一个节点的后继节点" class="headerlink" title="题目三 在二叉树中找到一个节点的后继节点"></a>题目三 在二叉树中找到一个节点的后继节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在有一种新的二叉树节点类型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right; </span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。</p><p>假设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向 自己的父节点，头节点的parent指向null。</p><p>只给一个在 二叉树中的某个节点 node，请实现返回node的后继节点的函数。</p><p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>针对一个给定节点，要求出它的后继结点；</p><p>首先第一步就是判断它是什么节点：它是其父节点的左孩子，他是其父节点的右孩子，它是根节点；</p><ul><li>它是父节点的左孩子<ul><li>如果它的右子树存在：则返回右子树中序遍历的第一个节点；</li><li>如果不存在右子树：则返回其父节点</li></ul></li><li>它是父节点的右孩子<ul><li>它是父节点的右孩子，那么它的左孩子都已经被中序遍历过了。即只能再看其右孩子；</li><li>如果它没有右孩子，那就需要考虑其父节点在树中的位置</li></ul></li><li>它是根节点<ul><li>找到其右子树中序遍历的第一个节点；</li></ul></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>当前节点有右子树，那么返回其右子树上最左的节点</p><p>节点右子树不存在：那么当前节点即可被认为是某一节点的左子树中序遍历的最后一个节点；找到这个节点即可；</p><ul><li>找到节点的父节点判断节点是其父节点的左孩子或者右孩子：<ul><li>左孩子：停止，返回这个父节点</li><li>右孩子：继续往上找；</li><li>空或者自循环：到树的根节点了，则不存在下一个；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node parent = node.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目四-介绍二叉树的序列化和反序列化"><a href="#题目四-介绍二叉树的序列化和反序列化" class="headerlink" title="题目四 介绍二叉树的序列化和反序列化"></a>题目四 介绍二叉树的序列化和反序列化</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>​    <strong>先序遍历</strong>：节点和节点之间用一个符号（比如 _）分隔。并且遇到空时用另一个符号（比如 #）来表示。</p><p><img src="/.com//image-20201125155615990.png" alt="image-20201125155615990"></p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><pre><code> **按照先序遍历序列化的就按照先序遍历反序列化**</code></pre><p>​    依次取出头节点，再取就是头节点的左节点或者空左孩子；依次完成树的重建；</p><h2 id="序列化实现"><a href="#序列化实现" class="headerlink" title="序列化实现"></a>序列化实现</h2><p><strong>先序遍历</strong></p><p>通过递归的方式：</p><p>如果当前节点为空则直接返回 “ #! ” ;</p><p>如果不为空，字符串加入头节点的值和分割符 “ ! ” ；</p><p>再把字符串后加上当前节点左节点的返回和右节点的返回；</p><p>整个函数返回字符串；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层序遍历</strong></p><p>如果当前节点为空则直接返回 “ #! ” ;</p><p>申请一个队列来保存队列的顺序；</p><p>给字符串 res 加上根节点的值以及分割符；</p><p>再把根节点加入到队列当中；</p><p>持续循环——&gt;直到队列为空：</p><ul><li>从队列中取出一个节点；</li><li>判断这个节点的左节点是否为空 ？ 字符串加上这个节点的左节点的值以及分割符，队列加入 这个节点的左节点  :  给字符串加上空节点的符号表示</li><li>同样的流程判断右节点是否为空；</li></ul><p>返回字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += head.left.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.left) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res += head.right.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反序列化实现"><a href="#反序列化实现" class="headerlink" title="反序列化实现"></a>反序列化实现</h2><p><strong>前序遍历反序列化</strong></p><p>把序列化字符串用分割符分割开成为一个字符串数组；</p><p>申请一个保存字符串的队列；</p><p>按照前序遍历的方式序列化的，就按照前序遍历的方式反序列化</p><p>调用一个从队列反序列化的函数：</p><ul><li>从队列中取出第一个节点的字符串。判断它是否是空节点的表示，是的话，返回null；</li><li>如果不是，创建节点对象，保存这个值；然后再递归调用自身得到接下来的左子树的表示和右子树的表示；</li><li>最终返回头节点；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span> </span>&#123;</span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length ; i++) &#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层次遍历反序列化</strong></p><p>把序列化字符串用分割符分割开成为一个字符串数组；</p><p>把字符川数组的第一个字符串转成根节点；</p><p>申请一个保存节点的队列；</p><p>如果头节点不为空，则把根节点加入进去；</p><p>while 循环 ——&gt; 如果队列不为空</p><ul><li>从队列中取出一个节点</li><li>把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的左节点；</li><li>如果左节点不为空则把左节点加入队列</li><li>把字符串数字接下来的值转成节点（也可能为空），赋给取出节点的右节点；</li><li>如果右节点不为空则把左节点加入队列</li></ul><p>返回根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span> </span>&#123;</span><br><span class="line">    String[] values = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Node head = generateNodeByString(values[index++]);</span><br><span class="line">    Queue&lt;Node&gt; quene = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        quene.offer(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!quene.isEmpty()) &#123;</span><br><span class="line">        node = quene.poll();</span><br><span class="line">        node.left = generateNodeByString(values[index ++]);</span><br><span class="line">        node.right = generateNodeByString(values[index ++]);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quene.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quene.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNodeByString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目五-折纸问题"><a href="#题目五-折纸问题" class="headerlink" title="题目五 折纸问题"></a>题目五 折纸问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>【题目】 请把一段纸条竖着放在桌子上，然后从纸条的下边向 上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕 突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折 痕、下折痕和上折痕。 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次， 请从上到下打印所有折痕的方向。 例如：N=1时，打印： down N=2时，打印： down down up</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把纸折一次，它的中间是凹的；它的上部分再折也是凹的；它的下部分再折是凸的；以此类推，就可以得到这个问题的答案；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    printProcess(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    System.out.println(down ? <span class="string">"down "</span> : <span class="string">"up "</span>);</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目六-判断一棵树是否是平衡二叉树（AVL）"><a href="#题目六-判断一棵树是否是平衡二叉树（AVL）" class="headerlink" title="题目六 判断一棵树是否是平衡二叉树（AVL）"></a>题目六 判断一棵树是否是平衡二叉树（AVL）</h1><p><strong>平衡二叉树</strong> ：一颗树的任意节点左子树与右子树的高度差不超过1；</p><p> 树算法：递归很好用；因为针对一个节点的递归会返回一个节点三次：他自己，左子树回来，右子树回来；</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>判断一个节点 x 是否平衡：</p><ol><li>左树是否平衡；</li><li>右数是否平衡；</li><li>左树的高度是什么？</li><li>右数的高度是什么？</li><li>左树与右数高度差是否平衡；</li></ol><p>就是需要求左子树与右子树的高度，还要时刻判断当下的树是否平衡：</p><p>方法传入了两个值，一个是level表示判断节点的层级，res用了数组。使其能改变自身使值返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    getHeight(head, <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node head, <span class="keyword">int</span> level, <span class="keyword">boolean</span>[] res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lH = getHeight(head.left, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span> (!res[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rH = getHeight(head.right, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span> (!res[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(lH - rH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lH, rH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一个套路化的过程，具体的思想就是把需要求得到信息封装成一个类，然后把这个类打包在每个节点间传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isB;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnData</span><span class="params">(<span class="keyword">boolean</span> isB, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isB = isB;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isB</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData leftData = process(head.left);</span><br><span class="line">    <span class="keyword">if</span> (!leftData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData rightData = process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (!rightData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftData.h-rightData.h) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, Math.max(leftData.h, rightData.h));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目七-判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树"><a href="#题目七-判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树" class="headerlink" title="题目七 判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树"></a>题目七 判断一棵树是否是搜索二叉树、判断一棵树是完全二叉树</h1><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><p><strong>搜索二叉树</strong>：这棵树上任何一个节点为头的子树，这个节点的左子树都比这个节点的数小，右子树都比他大；（中序遍历是依次升序的，充分必要条件）</p><p>所以看一个树是否是搜索二叉树，可以直接判断它的中序遍历是否是依次升序的；</p><p>所以对于非递归版的中序遍历打印那句，就判断要打印的当前节点是否大于本应该打印的上一个节点，不大于就是不是搜索二叉树，大于就直接更新，找下一个中序节点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isBST(Node head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; null;</span><br><span class="line">    Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();</span><br><span class="line">    while (!stack.isEmpty() || head !&#x3D; null) &#123;</span><br><span class="line">        if (head !&#x3D; null) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head &#x3D; head.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; stack.pop();</span><br><span class="line">            if (node!&#x3D; null &amp;&amp; node.value &gt; head.value) &#123;</span><br><span class="line">                System.out.println(node.value+&quot; &quot;+ head.value);;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; head;</span><br><span class="line">            head &#x3D; head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><strong>完全二叉树</strong>：算法过程需要按层遍历；</p><ul><li><p>如果一个节点有右孩子，没有左孩子；一定不是完全二叉树；</p></li><li><p>如果一个节点只有一个左孩子，或者没有孩子，那么它后面遇到的节点都必须是叶节点；否则不是完全二叉树；</p></li></ul><p>（由于情况一违反的话直接就没了，所以判断是否是情况二的情况，右边叶子一定是空；）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我写的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    Node node;</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leaf) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leaf) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左神简化版</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目八-已知一棵完全二叉树，求其节点的个数"><a href="#题目八-已知一棵完全二叉树，求其节点的个数" class="headerlink" title="题目八 已知一棵完全二叉树，求其节点的个数"></a>题目八 已知一棵完全二叉树，求其节点的个数</h1><p>要求：时间复杂度低于O(N)，N为这棵树的节点个数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>先遍历完全二叉树根节点到它的最左节点；这样可以判断出完全二叉树的高度；然后再判断右子树的最左节点是否存在；</p><p>如果存在则说明他的根节点的左子树是满二叉树：左子树可以通过高度求出来；右子树可以通过递归求得；</p><p>如果不存在说明右节点也是满二叉树；则可以由递归求得左子树； </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(Node node, <span class="keyword">int</span> level, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mostLeftLevel(node.right, level + <span class="number">1</span>) == h)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level)) + bs(node.right, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level - <span class="number">1</span>)) + bs(node.left, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftLevel</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目一-实现二叉树的先序、中序、后序遍历&quot;&gt;&lt;a href=&quot;#题目一-实现二叉树的先序、中序、后序遍历&quot; class=&quot;headerlink&quot; title=&quot;题目一 实现二叉树的先序、中序、后序遍历&quot;&gt;&lt;/a&gt;题目一 实现二叉树的先序、中序、后序遍历&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;包括递归方式和非递归方式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;递归方式遍历&quot;&gt;&lt;a href=&quot;#递归方式遍历&quot; class=&quot;headerlink&quot; title=&quot;递归方式遍历&quot;&gt;&lt;/a&gt;递归方式遍历&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/.com//image-20201120112203883.png&quot; alt=&quot;image-20201120112203883&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;非递归遍历&quot;&gt;&lt;a href=&quot;#非递归遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归遍历&quot;&gt;&lt;/a&gt;非递归遍历&lt;/h2&gt;&lt;h3 id=&quot;先序遍历&quot;&gt;&lt;a href=&quot;#先序遍历&quot; class=&quot;headerlink&quot; title=&quot;先序遍历&quot;&gt;&lt;/a&gt;先序遍历&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;自行准备一个栈，判断头节点非空时，将头节点压入栈中&lt;/li&gt;
&lt;li&gt;以下部分循环：直到栈为空；&lt;ol&gt;
&lt;li&gt;弹出节点，输出&lt;/li&gt;
&lt;li&gt;判断是否有右孩子，有的话压入栈中&lt;/li&gt;
&lt;li&gt;判断是否有左孩子，有的话压入栈中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;打印换行，结束&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="树" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%A0%91/"/>
    
    
    <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="平衡二叉树" scheme="http://yoursite.com/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="完全二叉树" scheme="http://yoursite.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-03</title>
    <link href="http://yoursite.com/2020/12/01/zuoshen-basic-class-3/"/>
    <id>http://yoursite.com/2020/12/01/zuoshen-basic-class-3/</id>
    <published>2020-12-01T08:20:03.000Z</published>
    <updated>2020-12-11T10:00:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一：用数组结构实现大小固定的队列和栈"><a href="#题目一：用数组结构实现大小固定的队列和栈" class="headerlink" title="题目一：用数组结构实现大小固定的队列和栈"></a>题目一：用数组结构实现大小固定的队列和栈</h1><p>栈与队列的数据结构都是很熟悉的了；</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>具体在这里他们的实现：栈的实现涉及：压栈，出栈，返回栈顶元素，返回栈元素个数等等；在栈满时压栈会报错；在栈空时出栈会报错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer [] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The Stack is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[size++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[--size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="队"><a href="#队" class="headerlink" title="队"></a>队</h2><p>另外的是队列的实现；一般普通的方法是维护队头和队尾两个变量。左神在这里引入了第三个变量：size，也就是队列中元素的个数；</p><p>如果size是数组的大小的话，那么就不能从队尾入队了，如果小于数组的大小，则可以入队；</p><p>如果size是0的话，就不能从队头出队；如果大于0，就可以从队头入队；</p><p>这样对于入队与出队的操作就只需要看size就可以；队头和队尾两个变量就没有关系了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer [] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> Integer first;</span><br><span class="line">    <span class="keyword">private</span> Integer last;   <span class="comment">// 指向队尾的后一格（可能空，也可能不空）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        first = last = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[first];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[last] = obj;</span><br><span class="line">        last = last == arr.length - <span class="number">1</span> ? <span class="number">0</span> : last + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">int</span> tmp = first;</span><br><span class="line">        first = first == arr.length - <span class="number">1</span> ? <span class="number">0</span> : first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【思考】如果没有size该如何实现</p><p>如果没有size则在队为空时，队头 <code>start</code> 和队尾 <code>end</code> 都指向一个位置；</p><p>入队时要判断是否还有空间，则就是 <code>end</code> 的下一个位置如果不是<code>start</code> 就说明可以入队；这里 <code>end</code> 的下一个位置分为两种情况，<code>end</code>到达数组尾部，他的下一个位置是0，<code>end</code>未到达数组尾部，他的下一个位置是 <code>end + 1</code>；</p><p>出队时要判断是否队为空，则就是 <code>start</code> 和 <code>end</code>相等；</p><h1 id="题目二：实现栈，并且实现返回栈中最小元素的操作"><a href="#题目二：实现栈，并且实现返回栈中最小元素的操作" class="headerlink" title="题目二：实现栈，并且实现返回栈中最小元素的操作"></a>题目二：实现栈，并且实现返回栈中最小元素的操作</h1><p><img src="/.com//image-20201024110123120.png" alt="image-20201024110123120"></p><p>【实现】：这个栈有两个数组，一个数组是 <code>data</code> 数组，另一个数组是 <code>min</code>最小值数组；</p><p>在往<code>data</code>和<code>min</code>是两个同步运作的数组；</p><p><code>data</code>入栈，<code>min</code>也入栈：<code>data</code>入栈一个数字 <code>x</code>，则把这个数字与<code>min</code>的栈顶比较，把较小值入<code>min</code>栈；当然如果<code>min</code>为空，则直接入栈就好了；</p><p><code>data</code>出栈，<code>min</code>也出栈：这个没得说，他们的个数是一样的；</p><h2 id="实现一：最小栈与数据栈同步"><a href="#实现一：最小栈与数据栈同步" class="headerlink" title="实现一：最小栈与数据栈同步"></a>实现一：最小栈与数据栈同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newMin = <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your Stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现二：最小栈与数据栈不一定同步"><a href="#实现二：最小栈与数据栈不一定同步" class="headerlink" title="实现二：最小栈与数据栈不一定同步"></a>实现二：最小栈与数据栈不一定同步</h2><p>之前两个栈是同步的过程；而当进来的数大于当前最小值时的过程可以通过判断不用往最小栈里添加。弹出栈时，当当前栈中最小值被弹出了，最小栈才做改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt;= <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.getmin())&#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目三：用队列实现栈，用栈实现队列"><a href="#题目三：用队列实现栈，用栈实现队列" class="headerlink" title="题目三：用队列实现栈，用栈实现队列"></a>题目三：用队列实现栈，用栈实现队列</h1><p><img src="/.com//image-20201024112244638.png" alt="image-20201024112244638"></p><h2 id="用队列实现栈结构"><a href="#用队列实现栈结构" class="headerlink" title="用队列实现栈结构"></a>用队列实现栈结构</h2><p>需要两个队列；</p><p>一个数据队列 <code>data</code>，一个辅助队列 <code>help</code> ；</p><p>入队就把数据放进 <code>data</code>；</p><p>弹出时需要弹出进入 <code>data</code> 的最后一个元素；所以需要把队列前面的元素出队放入 <code>help</code> 当中；得到和栈一样的结果；</p><p>但此时的 <code>help</code> 成了 <code>data</code> 的作用，所以把他们的引用交换一下就可以；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueuesStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueuesStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        queue.add(pushInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; tmp = help;</span><br><span class="line">        help = queue;</span><br><span class="line">        queue = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>需要两个栈；</p><p><code>push</code> 栈 和 <code>pop</code> 栈</p><p>往 <code>push</code> 栈里加入数据；若想得到该队列的出队。则需要从 <code>push</code> 栈中把所有数据倒到 <code>pop</code> 栈中；从<code>pop</code> 栈栈顶返回；</p><p>倒数据有两个规则：</p><p>1）<code>push</code> 栈往 <code>pop</code> 栈里倒数据要一次性倒完；不要有剩余；</p><p>2）如果 <code>pop</code> 栈不为空，那么<code>push</code> 栈一定不要倒；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackpush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackpop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacksQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackpush = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stackpop = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        stackpush.push(pushInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackpush.empty() &amp;&amp; stackpop.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackpop.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.empty()) &#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackpop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackpush.empty() &amp;&amp; stackpop.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackpop.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackpush.empty()) &#123;</span><br><span class="line">                stackpop.push(stackpush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackpop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目四-猫狗队列"><a href="#题目四-猫狗队列" class="headerlink" title="题目四 猫狗队列"></a>题目四 猫狗队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>宠物、狗和猫的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一种狗猫队列的结构，要求如下：</p><ol><li>用户可以调用add方法将cat类或dog类的 实例放入队列中；</li><li>用户可以调用pollAll方法，将队列中所有的实例按照进队列 的先后顺序依次弹出；</li><li>用户可以调用pollDog方法，将队列中dog类的实例按照 进队列的先后顺序依次弹出；</li><li>用户可以调用pollCat方法，将队列中cat类的实 例按照进队列的先后顺序依次弹出；</li><li>用户可以调用isEmpty方法，检查队列中是 否还有dog或cat的实例；</li><li>用户可以调用isDogEmpty方法，检查队列中是否有dog 类的实例；</li><li>用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>两个队列分别保存狗和猫；需要最早进的狗与猫这两个操作可以得以解决；</p><p>在这两个队列里保存的是包装后的狗和猫，另外包装的信息是他们进入队列的时间戳；这样对比两个队列的头部来返回最早进入队列的宠物；</p><p><strong>对Pet的包装</strong></p><p>有添加进入队列的时间戳；获取宠物的方法，获取时间戳的方法，获取宠物类型的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PetEnterQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQueue</span><span class="params">(Pet pet, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEnterPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pet.getPetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>猫狗队列的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DogCatQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQ;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogCatQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dogQ = <span class="keyword">new</span> LinkedList&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="keyword">this</span>.catQ = <span class="keyword">new</span> LinkedList&lt;PetEnterQueue&gt;();</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pet pet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"dog"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dogQ.add(<span class="keyword">new</span> PetEnterQueue(pet, count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pet.getPetType().equals(<span class="string">"cat"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.catQ.add(<span class="keyword">new</span> PetEnterQueue(pet, count++));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, not dog or cat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty() &amp;&amp; !<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dogQ.peek().getCount() &lt; <span class="keyword">this</span>.catQ.peek().getCount()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.poll().getPet();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.catQ.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">pollDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.dogQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Dog) dogQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">pollCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.catQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Cat) catQ.poll().getPet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"err, the queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.isEmpty() &amp;&amp; <span class="keyword">this</span>.catQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dogQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatQueueEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catQ.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目五-转圈打印矩阵"><a href="#题目五-转圈打印矩阵" class="headerlink" title="题目五 转圈打印矩阵"></a>题目五 转圈打印矩阵</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个整形矩阵matrix，请按照转圈的方式打印它；</p><blockquote><p>1     2     3     4 </p><p>5     6     7     8 </p><p>9    10    11    12</p></blockquote><p>转圈打印的结果为： <code>1，2，3，4，8，12，11，10，9，5，6，7</code></p><p><strong>要求</strong>：额外空间复杂度为 <code>O(1)</code></p><p><img src="/.com//image-20201106091549670.png" alt="image-20201106091549670"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_PrintMatrixSpiralOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123;</span><br><span class="line">            printEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (tR == dR)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tC; i &lt;= dC ; i++) &#123;</span><br><span class="line">                System.out.println(m[tR][i] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tR; i &lt;= dR ; i++) &#123;</span><br><span class="line">                System.out.println(m[i][tC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> curC = tC;</span><br><span class="line">            <span class="keyword">int</span> curR = tR;</span><br><span class="line">            <span class="keyword">while</span> (curC != dC)&#123;</span><br><span class="line">                System.out.println(m[curR][curC++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != dR)&#123;</span><br><span class="line">                System.out.println(m[curR++][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">                System.out.println(m[curR][curC--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != tR)&#123;</span><br><span class="line">                System.out.println(m[curR--][curC] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,<span class="number">12</span> &#125;, &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>,<span class="number">16</span>&#125; &#125;;</span><br><span class="line">        spiralOrderPrint(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目六-旋转正方形矩阵"><a href="#题目六-旋转正方形矩阵" class="headerlink" title="题目六 旋转正方形矩阵"></a>题目六 旋转正方形矩阵</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 </p><p>【要求】 额外空间复杂度为O(1)。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_RotateMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tR &lt; dR)&#123;</span><br><span class="line">            rotateEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = dC - tC;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != times; i++) &#123;</span><br><span class="line">            tmp = m[tR][tC + i];</span><br><span class="line">            m[tR][tC + i] = m[dR - i][tC];</span><br><span class="line">            m[dR - i][tC] = m[dR][dC - i];</span><br><span class="line">            m[dR][dC - i] = m[tR + i][dC];</span><br><span class="line">            m[tR + i][dC] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;,</span><br><span class="line">                &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        rotate(matrix);</span><br><span class="line">        System.out.println(<span class="string">"========="</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目七-反转单向和双向链表"><a href="#题目七-反转单向和双向链表" class="headerlink" title="题目七 反转单向和双向链表"></a>题目七 反转单向和双向链表</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>【题目】分别实现反转单向链表和反转双向链表的函数；</p><p>【要求】如果链表长度为<strong>N</strong>，时间复杂度要求为 $O(N)$ , 额外空间复杂度要求为 $O(1)$ ;</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点类；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// tmp指向头节点</span></span><br><span class="line">            tmp = head;</span><br><span class="line">            <span class="comment">// tmp拿着头节点，head向后走</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            tmp.next = pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向链表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转双向链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseList</span><span class="params">(DoubleNode head)</span></span>&#123;</span><br><span class="line">        DoubleNode p = head;</span><br><span class="line">        DoubleNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.last = p.next;</span><br><span class="line">            p.next = tmp;</span><br><span class="line">            tmp = p;</span><br><span class="line">            p = p.last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Linked List: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印双向链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDoubleLinkedList</span><span class="params">(DoubleNode head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Double Linked List "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.next.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        printLinkedList(head1);</span><br><span class="line">        head1 = reverseList(head1);</span><br><span class="line">        printLinkedList(head1);</span><br><span class="line"></span><br><span class="line">        DoubleNode head2 = <span class="keyword">new</span> DoubleNode(<span class="number">1</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> DoubleNode(<span class="number">2</span>);</span><br><span class="line">        head2.next.last = head2;</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> DoubleNode(<span class="number">3</span>);</span><br><span class="line">        head2.next.next.last = head2.next;</span><br><span class="line">        head2.next.next.next = <span class="keyword">new</span> DoubleNode(<span class="number">4</span>);</span><br><span class="line">        head2.next.next.next.last = head2.next.next;</span><br><span class="line">        printDoubleLinkedList(head2);</span><br><span class="line">        printDoubleLinkedList(reverseList(head2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目八-“之”字形打印矩阵"><a href="#题目八-“之”字形打印矩阵" class="headerlink" title="题目八 “之”字形打印矩阵"></a>题目八 “之”字形打印矩阵</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p><img src="/.com//image-20201110092314568.png" alt="image-20201110092314568"></p><p><img src="/.com//image-20201110092351277.png" alt="image-20201110092351277"></p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><p>在矩阵中设计两个初始位置相同的点；</p><p>A和B分别有着不同的运动轨迹；A每次往右移动直到到矩阵的边缘再往下移动；B每次往下移动直到矩阵的边缘再往右移动</p><p><img src="/.com//image-20201110092711246.png" alt="image-20201110092711246"></p><p>经历过一次移动之后，A和B分别到达的位置，可以看出A和B总是处在一条线的两端：</p><p><img src="/.com//image-20201110092941055.png" alt="image-20201110092941055"></p><p>此时B到达矩阵的边缘，开始往右走了；此时A和B仍处于一个对角线上；</p><p><img src="/.com//image-20201110093044928.png" alt="image-20201110093044928"></p><p>依次类推，按顺序打印A和B所在的线，不过按照 “之” 字型打印，就需要看好是从A到B还是从B到A；需要一个布尔类型的变量来设定这件事情；</p><p><img src="/.com//image-20201110093542635.png" alt="image-20201110093542635"></p><p>接下来就是实现一个打印函数，这个函数需要被告知矩阵的A点和B点，然后还需要告知打印的方向；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrixZigZag</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aR = <span class="number">0</span>, bR = <span class="number">0</span>, aC = <span class="number">0</span>, bC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (aR != endR) &#123;</span><br><span class="line">            printLevel(matrix, aR, aC, bR, bC, fromUp);</span><br><span class="line">            aR = aC == endC ? aR + <span class="number">1</span> : aR;</span><br><span class="line">            aC = aC == endC ? aC : aC + <span class="number">1</span>;</span><br><span class="line">            bC = bR == endR ? bC + <span class="number">1</span> : bC;  <span class="comment">// 这里需要注意这几个语句的顺序；被判断的值一定是最后才修改的；</span></span><br><span class="line">            bR = bR == endR ? bR : bR + <span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLevel</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC, <span class="keyword">boolean</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f)&#123;</span><br><span class="line">            <span class="keyword">while</span> (tR != dR + <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(m[tR++][tC--] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(dR != tR - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(m[dR--][dC++] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125; &#125;;</span><br><span class="line">        printMatrixZigZag(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目九-在行和列都排好序的矩阵中找数"><a href="#题目九-在行和列都排好序的矩阵中找数" class="headerlink" title="题目九 在行和列都排好序的矩阵中找数"></a>题目九 在行和列都排好序的矩阵中找数</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>在行列都排好序的矩阵中找数；</p><p>给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。</p><p><img src="/.com//image-20201110104951864.png" alt="image-20201110104951864"></p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>从左上角或右下角开始找，每次都能排除一行或一列的数据；</p><p>【思路】从数据状况考虑出发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_09_FindNumInSortedMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; value) &#123;</span><br><span class="line">                col --;</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                row ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;,<span class="comment">// 0</span></span><br><span class="line">                &#123; <span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span> &#125;,<span class="comment">// 1</span></span><br><span class="line">                &#123; <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span> &#125;,<span class="comment">// 2</span></span><br><span class="line">                &#123; <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span> &#125;,<span class="comment">// 3</span></span><br><span class="line">                &#123; <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span> &#125;,<span class="comment">// 4</span></span><br><span class="line">                &#123; <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">122</span> &#125;,<span class="comment">// 5</span></span><br><span class="line">                &#123; <span class="number">166</span>, <span class="number">176</span>, <span class="number">186</span>, <span class="number">187</span>, <span class="number">190</span>, <span class="number">195</span>, <span class="number">200</span> &#125;,<span class="comment">// 6</span></span><br><span class="line">                &#123; <span class="number">233</span>, <span class="number">243</span>, <span class="number">321</span>, <span class="number">341</span>, <span class="number">356</span>, <span class="number">370</span>, <span class="number">380</span> &#125; <span class="comment">// 7</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">233</span>;</span><br><span class="line">        System.out.println(isContains(matrix, K));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目十-打印两个有序链表的公共部分"><a href="#题目十-打印两个有序链表的公共部分" class="headerlink" title="题目十 打印两个有序链表的公共部分"></a>题目十 打印两个有序链表的公共部分</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给定两个有序链表的头指针<strong>head1</strong>和<strong>head2</strong>，打印两个链表的公共部分</p><h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zuoshen.basic_class.class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_10_PrintCommonPart</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要一个节点类；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Common Part:  "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head1.value &lt; head2.value) &#123;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(head1.value + <span class="string">" "</span>);</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Linked List: "</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node1.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        node1.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node1.next.next.next = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        node2.next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        node2.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node2.next.next.next = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        node2.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        printLinkedList(node1);</span><br><span class="line">        printLinkedList(node2);</span><br><span class="line">        printCommonPart(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目十一-判断一个链表是否为回文结构"><a href="#题目十一-判断一个链表是否为回文结构" class="headerlink" title="题目十一 判断一个链表是否为回文结构"></a>题目十一 判断一个链表是否为回文结构</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p><img src="/.com//image-20201110110900046.png" alt="image-20201110110900046"></p><h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><p><strong>思路一</strong>：一个长度与链表一样长的栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// need n extra space 一个长度与链表一样长的栈；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; nodes = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.pop().value != head.value)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong>：快慢指针 + 栈 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// need n/2 extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next != <span class="keyword">null</span> ? fast.next.next : fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; nodes = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nodes.push(slow);</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.pop().value != head.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路</strong>三：快慢指针，快指针走两步，慢指针走一步；（其实这个方法也是找到链表中心点的方法）</p><ul><li>快指针每次走两步直到末尾，此时慢指针指向中心<ul><li>当链表节点个数为偶数时，慢指针刚好指向第 $\frac{N}{2}$ 的位置</li><li>当链表节点个数为奇数时，快指针会移动 $\frac{N+1}{2}$ 次，慢指针也会移动 $\frac{N+1}{2}$ 次（比被2整数结果后面的一个，例如：N=5，那么移动三次指向第4个节点；N=9，移动5次指向第6个节点）；</li></ul></li><li>然后把慢指针之后的链表逆序；</li><li>与头节点开始与慢指针比较是否是回文结构；</li><li>然后恢复原链表结构；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// need O(1) extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> ( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node tmp = <span class="keyword">null</span>;</span><br><span class="line">    fast = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        tmp.next = fast;</span><br><span class="line">        fast = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别从head 和 fast出发查看是否一样</span></span><br><span class="line">    slow = head;    <span class="comment">//  保存头节点</span></span><br><span class="line">    tmp = fast; <span class="comment">// 保存最后一个节点</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.value != slow.value)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复原链表</span></span><br><span class="line">    fast = tmp.next;    <span class="comment">// 保存最后一个节点最后一个值</span></span><br><span class="line">    tmp.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = fast;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow.next = tmp;</span><br><span class="line">        tmp = slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目十二-将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#题目十二-将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="题目十二 将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>题目十二 将单向链表按某值划分成左边小、中间相等、右边大的形式</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p><strong>【题目】</strong> 给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。 除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9-&gt;0-&gt;4-&gt;5- &gt;1，pivot=3。调整后链表可以是1-&gt;0-&gt;4-&gt;9-&gt;5，也可以是0-&gt;1-&gt;9-&gt;5-&gt;4。总 之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部 分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做要求。</p><p><strong>【进阶】</strong>在原问题的要求之上再增加如下两个要求。 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的 顺序与原链表中节点的先后次序一致。 例如：链表9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。 调整后的链表是0-&gt;1-&gt;9-&gt;4-&gt;5。 在满足原问题要求的同时，左部分节点从左到 右为0、1。在原链表中也 是先出现0，后出现1；中间部分在本例中为空，不再 讨论；右部分节点 从左到右为9、4、5。在原链表中也是先出现9，然后出现4， 最后出现5。 如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。</p><h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><p><strong>思路一</strong>：把链表套进一个数组当中；数组的元素就是链表的节点；然后用荷兰国旗问题进行解决；这样子的解决方案是不能达到稳定性要求的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i ++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodearr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodearr.length ; i++) &#123;</span><br><span class="line">        nodearr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodearr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nodearr.length; i++) &#123;</span><br><span class="line">        nodearr[i-<span class="number">1</span>].next = nodearr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodearr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodearr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, index++, ++small);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot)&#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr,index, --big);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node tmp = nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二</strong>：</p><ul><li><p>用分别准备三个链表变量分别保存小于，等于和大于的组；</p><p>每个链表需要两个变量保存头和尾</p></li><li><p>然后把三个链表串起来就可以实现；</p><p>需要判断每个链表是否存在，涉及一个较为复杂的编程过程；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node bH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node bT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node cur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = cur;</span><br><span class="line">                sT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = cur;</span><br><span class="line">                sT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = cur;</span><br><span class="line">                eT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = cur;</span><br><span class="line">                eT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bH = cur;</span><br><span class="line">                bT = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bT.next = cur;</span><br><span class="line">                bT = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// small and equal reconnect</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目十三-复制含有随机指针的链表"><a href="#题目十三-复制含有随机指针的链表" class="headerlink" title="题目十三 复制含有随机指针的链表"></a>题目十三 复制含有随机指针的链表</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>【题目】 一种特殊的链表节点类描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">public</span> Node next; </span><br><span class="line">    <span class="keyword">public</span> Node rand; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = data; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类中的value是节点值，<strong>next</strong>指针和正常单链表中<strong>next</strong>指针的意义 一 样，都指向下一个节点，<strong>rand</strong>指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向<strong>null</strong>。给定一个由 Node节点类型组成的无环单链表的头节点<strong>head</strong>，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。</p><p>进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 $O(N)$ 内完成原问题要实现的函数。</p><h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><p>【我的考虑】：直接复制相对应的节点把他们的节点的值和<strong>next</strong> 指针复制好。接着问题出现了 <strong>rand</strong> 是无法复制的。要找到第一个节点的 <strong>rand</strong> 指针需要和原始链表一样去同步遍历才能找到。这样无疑会有很大的时间复杂度；</p><p>【解法一】把原始链表与新链表通过哈希表的方式来建立联系</p><p>哈希表中的 <strong>key</strong> 是原始链表中的节点，相对应的 <strong>value</strong> 是它复制后的节点。要找到新链表节点的 <strong>next</strong> 和 <strong>rand</strong>，可以通过哈希表查找原始链表节点相对应节点来完成赋值；</p><p>【解法二】原地把原始链表与新链表关联起来：</p><p>用 $i’$ 来表示 $i$ 节点的复制节点 ，那么把它关联起来的方式是 ：</p><script type="math/tex; mode=display">1  -> 1'  ->  2  -> 2'  ->  3  ->  3' -> null</script><p>把原来的链表组织成这样的形式；每次从链表中去取出两个节点 $1  -&gt; 1’$ ；先复制 <strong>rand</strong> 指针，$1$ 的 <strong>rand</strong> 指针可以直接找到。 而复制的新的 $1’$ 的 <strong>rand</strong> 指针可以从 $1$ 的 <strong>rand</strong> 指针找到对应节点的下一个就是 $1’$ 的 <strong>rand</strong> 指针的对应节点；</p><p>最后再把 <strong>next</strong> 指针复原组织好。即可完成；</p><h1 id="题目十四-两个单链表相交的一系列问题"><a href="#题目十四-两个单链表相交的一系列问题" class="headerlink" title="题目十四 两个单链表相交的一系列问题"></a>题目十四 两个单链表相交的一系列问题</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>【题目】 在本题中，单链表可能有环，也可能无环。</p><p>给定两个 单链表的头节点 head1和head2，这两个链表可能相交，也可能 不相交。</p><p>请实现一个函数， 如果两个链表相交，请返回相交的 第一个节点；</p><p>如果不相交，返回null 即可。 </p><p>要求：如果链表1 的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外 空间复杂度请达到O(1)。</p><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><p>【我的考虑】</p><ol><li><p>先分类考虑</p><p>有环相交，有环不相交，无环相交，无环不相交</p><p>然后发现任何一个都很复杂；</p></li></ol><p><strong>问题一 如何判断链表有没有环</strong> </p><p>​    【方法一】哈希表</p><p>​    通过一个哈希表，遍历链表节点；每遍历一个节点如果它不在集合中就把它放集合当中；如果第一个发现在集合中的节点，那就说明这是链表的环的入口；如果判断到节点为空，则说明不存在环；</p><p>​    <strong>实现</strong> : 判断一个链表是否有环，如果有，则返回环的第一个节点；没有则返回空；</p><p>​    【方法二】快慢指针</p><ul><li><p>快指针走两步，慢指针走一步；</p></li><li><p>直到相遇；</p></li><li><p>如果相遇，快指针回到开头，由一次走两步变为一次走一步，【结论】<strong>快指针与慢指针一定会在入环节点处相遇</strong>；</p></li></ul><p><strong>问题二 如何判断一个无环单链表第一个相交的节点 </strong> </p><p>   由问题一我们可以知道是否有环，则可以考虑两个链表调用了判断是否有环函数后都返回为空，这个情况下他们是否有相交的节点</p><p>​    【方法一】哈希表</p><p>​    同样是用一个哈希表；遍历第一个链表节点，都放入哈希表当中去。</p><p>​    然后依次遍历第二个链表，在哈希表中查。如果都没有，说明它们不相交；如果第二个链表的节点在哈希表中出现了，则说明这个节点是相交节点；</p><p>​    【方法二】</p><p>​    遍历第一个链表，得到他的长度与最后一个节点的指针；同样的遍历第二个链表，得到他的长度和最后一个节点的指针；</p><ul><li>显而易见：判断 两个链表的最后一个节点是否是一个节点即可判断他们是否相交；</li><li>如果它们相交，根据链表长度去遍历；<ul><li>让长的链表先走，走到与短的一样长时它们一起走。</li><li>然后判断两个链表当下节点是否一样，直到它们指向节点一样也就是找到了相交的第一个节点；</li></ul></li></ul><p><strong>问题三 如何判断一个有环单链表与无环单链表第一个相交的节点</strong> </p><p>​    不可能相交；</p><p><strong>问题四 如何判断两个有环单链表第一个相交的节点 </strong></p><p>三种情况：</p><p><img src="/.com//image-20201119153209312.png" alt="image-20201119153209312"></p><ul><li>如果判断是有环并且得到的入环节点位置相同，他就是结构2：<ul><li>此时也就等同于无环链表相交，此时相交位置与入环节点没有关系；</li></ul></li><li>如果入环节点不相同，他可能是结构1也可能是结构2：<ul><li>此时从链表一的入环节点出发，遍历链表；<ul><li>如果碰到链表二的入环节点：则说明是第三种结构<ul><li>此时返回链表一的入环节点和链表二的入环节点都是对的；</li></ul></li><li>如果链表一的入环节点遍历回去了，还没碰到说明是结构一；<ul><li>不存在相交节点；</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head.next;</span><br><span class="line">    Node n2 = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = head;</span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n ++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n --;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// cur1 指向较长的链表</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// cur2 指向另一个</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n --;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur1 和 cur2 同时出发</span></span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n --;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// cur1 指向较长的链表</span></span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// cur2 指向另一个</span></span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n --;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cur1 和 cur2 同时出发</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目一：用数组结构实现大小固定的队列和栈&quot;&gt;&lt;a href=&quot;#题目一：用数组结构实现大小固定的队列和栈&quot; class=&quot;headerlink&quot; title=&quot;题目一：用数组结构实现大小固定的队列和栈&quot;&gt;&lt;/a&gt;题目一：用数组结构实现大小固定的队列和栈&lt;/h1&gt;&lt;p&gt;栈与队列的数据结构都是很熟悉的了；&lt;/p&gt;
&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;具体在这里他们的实现：栈的实现涉及：压栈，出栈，返回栈顶元素，返回栈元素个数等等；在栈满时压栈会报错；在栈空时出栈会报错；&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayStack&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Integer [] arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Integer size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayStack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; initSize)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (initSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;The init size is less than 0&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer[initSize];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;title&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (size == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr[size - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (size == arr.length)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayIndexOutOfBoundsException(&lt;span class=&quot;string&quot;&gt;&quot;The Stack is full&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[size++] = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;title&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (size == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayIndexOutOfBoundsException(&lt;span class=&quot;string&quot;&gt;&quot;The stack is empty&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr[--size];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="链表" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>第一章 引言</title>
    <link href="http://yoursite.com/2020/11/09/databaseSystemConcepts-1/"/>
    <id>http://yoursite.com/2020/11/09/databaseSystemConcepts-1/</id>
    <published>2020-11-09T03:17:44.000Z</published>
    <updated>2020-11-25T09:43:33.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-2-数据库系统的目标"><a href="#1-2-数据库系统的目标" class="headerlink" title="1.2 数据库系统的目标"></a>1.2 数据库系统的目标</h1><p>文件处理系统中存储组织信息的主要弊端包括：</p><ul><li>数据的冗余和不一致</li><li>数据访问困难</li><li>数据孤立</li><li>完整性问题</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li></ul><h1 id="1-3-数据视图"><a href="#1-3-数据视图" class="headerlink" title="1.3 数据视图"></a>1.3 数据视图</h1><p>​    数据库系统的一个主要目的是给用户提供数据的抽象视图，就是说，系统隐藏关于数据存储和维护的某些细节；</p><h2 id="1-3-1-数据抽象"><a href="#1-3-1-数据抽象" class="headerlink" title="1.3.1 数据抽象"></a>1.3.1 数据抽象</h2><p><img src="/.com//image-20201109160321098.png" alt="image-20201109160321098"></p><p>系统要能高效地检索数据。而这促使设计者再数据库中使用复杂的数据结构来表示数据；</p><p>许多用户不懂计算机，需要系统开发人员通过如下几个层次对用户屏蔽复杂性：</p><a id="more"></a><ul><li><p>物理层：最低层次的抽象，描述数据实际上是怎样存储的。</p><p>​    详细描述复杂的底层数据结构；</p></li><li><p>逻辑层：比物理层稍高一层。描述数据库存储什么数据，及数据间存在什么关系。</p><ul><li>虽然逻辑层的简单结的实现可能涉及复杂的物理层结构。但逻辑层用户不必知道这样的复杂性；这叫做<strong>物理独立性</strong></li><li>数据库管理员使用抽象的逻辑层。</li></ul></li><li><p>视图层：最高层，只描述数据库的某个部分；</p><ul><li>大型数据库信息的多样性使得其仍存在一定程度的复杂性；</li><li>数据库系统的很多用户并不关心所有的信息，只需要访问数据库的一部分；</li><li>视图层的定义正是为了使用户和系统交互更简单。</li><li>系统可以为同一数据库提供多个视图；</li></ul></li></ul><h2 id="1-3-2-实例和模式"><a href="#1-3-2-实例和模式" class="headerlink" title="1.3.2 实例和模式"></a>1.3.2 实例和模式</h2><p>存储在数据库中的信息的集合称作数据库的一个 <strong>实例</strong> 。而数据库的总体设计称作数据库<strong>模式</strong>（schema）；</p><p>不同的抽象层次，数据库系统可以分为几种不同的模式：<strong>物理模式</strong>在物理层描述数据库的设计、而<strong>逻辑模式</strong>则在逻辑层描述数据库的设计。数据库在视图层可以有几种模式，成为 <strong>子模式</strong>；</p><p><strong>物理数据独立性</strong>：物理层可以在应用程序（视图层）丝毫不受影响的情况下被轻易地改变；应用程序不依赖于物理模式；</p><h2 id="1-3-3-数据模型"><a href="#1-3-3-数据模型" class="headerlink" title="1.3.3 数据模型"></a>1.3.3 数据模型</h2><p>数据库结构的基础是<strong>数据模型</strong>；</p><p>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。</p><p>数据模型可被划分为四类：</p><ul><li><strong>关系模型</strong>（relational model）：关系模型用<strong>表的集合</strong>来表示数据和数据间的联系；</li><li><strong>实体-联系模型</strong>（entity-relationship model）：实体-联系（E-R）数据模型基于对现实世界的这样一种认识：现实世界由一组称为实体的基本对象以及这些对象间的联系构成；</li><li><strong>基于对象的数据模型</strong>（object-based data model）：面对对象的数据模型可以看成是E-R模型增加了封装、方法（函数）和对象标识等概念后的扩展；</li><li><strong>半结构化数据模型</strong>：半结构化数据模型允许那些相同类型的数据项含有不同的属性集的数据定义。<strong>可扩展标记语言</strong>被广泛地用来表示半结构化数据；</li></ul><h1 id="1-4-数据库语言"><a href="#1-4-数据库语言" class="headerlink" title="1.4 数据库语言"></a>1.4 数据库语言</h1><p><strong>数据库定义语言</strong>，<strong>数据库操纵语言</strong>；（不限于关系型数据库）</p><h2 id="1-4-1-数据操纵语言"><a href="#1-4-1-数据操纵语言" class="headerlink" title="1.4.1 数据操纵语言"></a>1.4.1 数据操纵语言</h2><p>要实现：增删改查</p><p>有两类基本的数据操纵语言：</p><ul><li><strong>过程化DML</strong>：要求用户指定需要什么数据以及如何获得这些数据；</li><li><strong>声明式DML</strong>：只要求用户指定需要什么数据，不知名如何获得这些数据；</li></ul><h2 id="1-4-2-数据定义语言"><a href="#1-4-2-数据定义语言" class="headerlink" title="1.4.2 数据定义语言"></a>1.4.2 数据定义语言</h2><p><strong>数据存储和定义语言</strong>规定了数据库系统所使用地存储结构和访问方式；这些语句定义了数据库模式的实现细节，而这些细节对用户来说通常不可见；</p><p>存储在数据库的数据值必须满足某些<strong>一致性约束</strong>。约束可以是关于数据库的任意谓词；测试任意谓词的代价比较高。因此数据库系统要以最小代价测试的完整性约束；</p><ul><li><strong>域约束</strong>（domain constraint）：每个属性都必须对应于一个所有可能的取值构成的域；声明一种属性属于某种具体的域就相当于约束它可以取的值。域约束是完整性约束的最基本形式；</li><li><strong>参照完整性</strong>（referential integrity）：一个关系中给定属性集上的取值也在另一关系的某一属性集的取值中出现；当参照完整性约束被违反时，通常的处理是拒绝执行导致完整性被破坏的操作；</li><li><strong>断言</strong>（assertion）：一个断言就是数据库需要时刻满足的某一条件；<ul><li>可以定义涉及多个表或聚集操作的比较复杂的完整性约束。断言创建以后，任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。</li></ul></li><li><strong>授权</strong>（authorization）：对不同的用户在数据库中的不同数据值上允许不同的访问类型。<ul><li>这些区别以 <strong>授权</strong> 来表达：<ul><li><strong>读授权</strong>：允许读不允许修改；</li><li><strong>插入授权</strong>：允许插入新数据，不允许修改已有数据；</li><li><strong>更新授权</strong>：</li><li><strong>删除授权</strong>：</li></ul></li></ul></li></ul><p>DDL的输出放在数据字典中，数据字典包含了<strong>元数据</strong>；元数据是关于数据的数据；可以把数据字典看成之恩那个有数据库系统本身来访问和修改的特殊表；</p><h1 id="1-5-关系数据库"><a href="#1-5-关系数据库" class="headerlink" title="1.5 关系数据库"></a>1.5 关系数据库</h1><h2 id="1-5-1-表"><a href="#1-5-1-表" class="headerlink" title="1.5.1 表"></a>1.5.1 表</h2><p>关系模型是基于记录的模型的一个实例。基于记录的模型是因为数据库的结构是几种固定格式的记录。每个表包含一种特定类型的记录。每个记录类型定义固定数目的字段或属性。表的列对应记录类型的属性；</p><p>在关系模型中可能创建一些有问题的模式，比如出现不必要的冗余信息；</p><h2 id="1-5-2-数据操纵语言"><a href="#1-5-2-数据操纵语言" class="headerlink" title="1.5.2 数据操纵语言"></a>1.5.2 数据操纵语言</h2><p>SQL语言是非过程的；</p><h2 id="1-5-3-数据定义语言"><a href="#1-5-3-数据定义语言" class="headerlink" title="1.5.3 数据定义语言"></a>1.5.3 数据定义语言</h2><p>SQL提供了丰富的DDL，通过它可以定义表、完整性约束、断言等；</p><h2 id="1-5-4-来自应用程序的数据库访问"><a href="#1-5-4-来自应用程序的数据库访问" class="headerlink" title="1.5.4 来自应用程序的数据库访问"></a>1.5.4 来自应用程序的数据库访问</h2><ul><li>通过提供应用程序接口，它可以用来将 DML 和 DDL 的语句发送给数据库，再取回结果。（ODBC、JDBC等）</li><li>通过扩展宿主语言的语法，在宿主语言中嵌入DML调用。通常用一个特殊字符作为DML调用的开始，并且通过预处理器，称为<strong>DML预编译器</strong>，来将DML语句转变成宿主语言中的过程调用；</li></ul><h1 id="1-6-数据库设计"><a href="#1-6-数据库设计" class="headerlink" title="1.6 数据库设计"></a>1.6 数据库设计</h1><p>数据库设计的主要内容是数据库模式的设计；</p><h2 id="1-6-1-设计过程"><a href="#1-6-1-设计过程" class="headerlink" title="1.6.1 设计过程"></a>1.6.1 设计过程</h2><ol><li><p>数据库设计初始阶段是全面刻画预期的数据库用户的数据需求；这阶段的成果是制定出用户需求的规格文档；</p></li><li><p>下一步，设计者选择一个数据模型，并运用该选定的数据模型的概念把那些需求转换成一个数据库的概念模式。在 <strong>概念设计</strong> 阶段开发出来的模式提供了企业的详细概述。</p><ul><li>确保所有数据需求都满足并且相互之间没有冲突；也可去掉一些冗余特性；</li></ul></li><li><p>从关系模型的角度来看，概念设计阶段设计决定数据库中应该包括哪些属性（商业决策），以及如何将这些属性组织到多个表中（计算机科学问题）。</p><ul><li>解决问题的主要方法：<ul><li>使用<strong>实体-联系模型</strong></li><li>引入一套算法(称为规范化)，这套算法将所有属性集作为输入，生成一组关系表；</li></ul></li></ul></li><li><p>一个开发完全的概念模式还将指出企业的功能需求。在 <strong>功能需求说明</strong> 中，用户描述数据之上的各种操作。</p></li><li>最后两个阶段<ul><li><strong>逻辑设计阶段</strong> ：设计者将高层的概念模式映射到要使用的数据库系统的实现数据模式上；</li><li><strong>物理设计阶段</strong> ：这阶段指定数据库的物理特性，特性包括文件组织的形式以及内部的存储结构；</li></ul></li></ol><h2 id="1-6-2-大学机构的数据库设计"><a href="#1-6-2-大学机构的数据库设计" class="headerlink" title="1.6.2 大学机构的数据库设计"></a>1.6.2 大学机构的数据库设计</h2><h2 id="1-6-3-实体-联系模型"><a href="#1-6-3-实体-联系模型" class="headerlink" title="1.6.3 实体-联系模型"></a>1.6.3 实体-联系模型</h2><p>实体-联系（E-R）数据模型使用一组称作实体的基本对象，以及这些对象间的联系。</p><blockquote><p><strong>实体</strong>是现实世界中可区别于其他对象的一件”事情“或一个”物体“。</p><p>数据库中实体通过属性集合来描述</p><p><strong>联系</strong> 是几个实体之间的关联。</p><p>同一类型的所有实体称为<strong>实体集</strong>。</p><p>同一类型的所有联系称为联系集。</p></blockquote><p>数据库的总体逻辑结构可以用实体-联系图来表示：</p><ul><li>实体集用矩形框表示，实体名在头部，属性名在下面；</li><li>联系集用联系一对相关的实体集的菱形表示，联系名放在菱形内部。</li></ul><p><img src="/.com//image-20201116112941078.png" alt="image-20201116112941078"></p><p>除了实体和联系外，E-R模型还描述了数据库必须描述的对其内容的某些约束。</p><h2 id="1-6-4-规范化"><a href="#1-6-4-规范化" class="headerlink" title="1.6.4 规范化"></a>1.6.4 规范化</h2><p><strong>规范化</strong>的目标是生成一个关系模式集合，使存储信息时没有不必要的冗余，同时又能很轻易地检索数据；</p><p>规范化是设计一种符合适当的范式的模式；最常用的方法是使用<strong>函数依赖</strong></p><p>不好的设计可能会包括如下特性：</p><ul><li><strong>信息重复</strong> ：重复信息的修改也是个问题</li><li><strong>缺乏表达某些信息的能力</strong> </li></ul><h1 id="1-7-数据存储和查询"><a href="#1-7-数据存储和查询" class="headerlink" title="1.7 数据存储和查询"></a>1.7 数据存储和查询</h1><p>数据库系统功能部件大致可分为 <strong>存储管理器</strong> 和 <strong>存储处理</strong>部件 ； </p><p><strong>存储管理</strong>：要在大量存储空间组织数据，使其满足和主存之间数据的移动最小化；</p><p><strong>查询处理</strong>：帮助数据库系统简化和方便数据的访问。使得用户获得高性能，同时在视图的层次上工作。不必了解系统实现物理层次细节的负担。</p><p>将在逻辑层编写的更新和查询转变成物理层的高效操作序列，这是数据库系统的任务；</p><h2 id="1-7-1-存储管理器"><a href="#1-7-1-存储管理器" class="headerlink" title="1.7.1 存储管理器"></a>1.7.1 存储管理器</h2><p><strong>存储管理器</strong> 是 数据库系统中负责在【数据库中存储的底层数据】与【应用程序】以及【向系统提交的查询】之间提供接口的部件；它负责与文件管理器进行交互；</p><p>​    存储管理器将各种 <code>DML</code> 语句翻译为底层文件系统命令。而原始数据通过操作系统提供的文件系统存储在硬盘上。</p><p>因此存储管理器负责数据库中数据的存储、检索和更新；</p><p>存储管理部件包括：</p><ul><li><strong>权限及完整性管理器</strong>(authorization and integrity manager)：检测是否满足完整性约束，并检查试图访问数据的用户的权限；</li><li><strong>事务管理器</strong>( transaction manager )：保证数据库及事故障时也保持在一致的状态，保证并发事务的执行不发生冲突；</li><li><strong>文件管理器</strong>( file manager )：它管理磁盘存储空间的分配，管理用于表示磁盘上存储信息的数据结构；</li><li><strong>缓存处理器</strong>( buffer manager )：负责将数据从磁盘上取到内存中，决定哪些数据应被缓存。</li></ul><p>存储管理器实现了几种数据结构，作为系统物理实现的一部分：</p><ul><li><strong>数据文件</strong> 存储数据库自身</li><li><strong>数据字典</strong> ：存储关于数据库结构的元数据，尤其是数据库模式；</li><li><strong>索引</strong>：提供对数据项的快速访问。</li></ul><h2 id="1-7-2-查询处理器"><a href="#1-7-2-查询处理器" class="headerlink" title="1.7.2 查询处理器"></a>1.7.2 查询处理器</h2><p>查询处理器组件包括：</p><ul><li><strong>DDL解释器（DDL interpreter）</strong>：他解释DDL语句并将这些定义记录在数据字典中。</li><li><strong>DML编译器（DML compiler）</strong>：将查询语言中的DML语句翻译为一个执行方案，包括一系列查询执行引擎能理解的低级指令。<ul><li>一个查询通常可翻译为多种等价的具有相同结果的执行方案的一种。DML编译器还进行<strong>查询优化</strong>，也就是从几种选择中选出代价最小的一种。</li></ul></li><li><strong>查询执行引擎（query evaluation engine）</strong>：执行由DML编译器产生的低级指令；</li></ul><h1 id="1-8-事务管理"><a href="#1-8-事务管理" class="headerlink" title="1.8 事务管理"></a>1.8 事务管理</h1><p>对数据库的几个操作合起来形成一个逻辑单元；</p><ul><li><strong>原子性（atomicity）</strong>：要求这些操作要么全部完成要么不发生的；</li><li><strong>一致性（consistency）</strong>：要求结果这种正确性；例如转账后两账户余额之和不变；</li><li><strong>持久性（durability）</strong>：要求即使发生系统故障，事务完成后的结果依然保持不变；</li></ul><p><strong>事务</strong> 是数据库应用中完成单一逻辑功能的操作集合；</p><blockquote><p>每个事务是既具有原子性又具有一致性的单元；因此要求事务不违反任何的数据库一致性约束；</p><ul><li>如果事务启动时数据库是一致的，那么事务完成结束时也应该时一致的。</li><li>而事务执行过程中，必要时允许暂时的不一致；（转账总有转出与转入总得有个顺序）</li><li>虽然暂时的不一致时必需的，但故障发生时，很可能导致问题产生；</li></ul></blockquote><p><strong>事务管理器</strong> 包括 <strong>并发控制管理器</strong> 和 <strong>恢复管理器</strong>；</p><p>原子性和持久性的保证是 <strong>恢复管理器</strong> 的职责；使得系统故障时保证数据的原子性和持久性；</p><p><strong>并发控制管理器</strong> 控制并发事务间的相互影响， 保证数据库一致性；</p><h1 id="1-9-数据库体系结构"><a href="#1-9-数据库体系结构" class="headerlink" title="1.9 数据库体系结构"></a>1.9 数据库体系结构</h1><p><img src="/.com//image-20201118102051536.png" alt="image-20201118102051536"></p><p>数据库系统可以是集中式的、客户/服务器式的（一台服务器为多个客户机执行任务）；也可以针对<strong>并行计算机体系结构</strong>设计数据库系统；<strong>分布式数据库</strong>包含地理上分离的多台计算机；</p><p>在一个 <strong>两层体系结构</strong> 中，应用程序驻留在客户机上，通过查询语言表达式来调用服务器上的数据库系统功能；</p><p>在一个 <strong>三层体系结构</strong> 中，客户机只作为一个前端并且不包含任何直接的数据库调用。客户端通常通过一个表单界面与应用服务器进行通信。应用服务器与数据库系统通信以访问数据。</p><p><img src="/.com//image-20201118103122320.png" alt="image-20201118103122320"></p><h1 id="1-10-数据挖掘与信息检索"><a href="#1-10-数据挖掘与信息检索" class="headerlink" title="1.10 数据挖掘与信息检索"></a>1.10 数据挖掘与信息检索</h1><p><strong>数据挖掘（data mining）</strong>指半自动地分析大型数据库并从中找出有用的模式的过程；从数据库中找到的发现的某些类型地只是可以用一套 <strong>规则</strong> 表示。</p><h1 id="1-11-特种数据库"><a href="#1-11-特种数据库" class="headerlink" title="1.11 特种数据库"></a>1.11 特种数据库</h1><p>数据库系统的一些应用领域收到关系数据库的限制。<strong>基于对象的数据模型</strong>和<strong>半结构化数据模型</strong>；</p><h1 id="1-12-数据库用户和管理员"><a href="#1-12-数据库用户和管理员" class="headerlink" title="1.12 数据库用户和管理员"></a>1.12 数据库用户和管理员</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-2-数据库系统的目标&quot;&gt;&lt;a href=&quot;#1-2-数据库系统的目标&quot; class=&quot;headerlink&quot; title=&quot;1.2 数据库系统的目标&quot;&gt;&lt;/a&gt;1.2 数据库系统的目标&lt;/h1&gt;&lt;p&gt;文件处理系统中存储组织信息的主要弊端包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的冗余和不一致&lt;/li&gt;
&lt;li&gt;数据访问困难&lt;/li&gt;
&lt;li&gt;数据孤立&lt;/li&gt;
&lt;li&gt;完整性问题&lt;/li&gt;
&lt;li&gt;原子性问题&lt;/li&gt;
&lt;li&gt;并发访问异常&lt;/li&gt;
&lt;li&gt;安全性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-3-数据视图&quot;&gt;&lt;a href=&quot;#1-3-数据视图&quot; class=&quot;headerlink&quot; title=&quot;1.3 数据视图&quot;&gt;&lt;/a&gt;1.3 数据视图&lt;/h1&gt;&lt;p&gt;​    数据库系统的一个主要目的是给用户提供数据的抽象视图，就是说，系统隐藏关于数据存储和维护的某些细节；&lt;/p&gt;
&lt;h2 id=&quot;1-3-1-数据抽象&quot;&gt;&lt;a href=&quot;#1-3-1-数据抽象&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 数据抽象&quot;&gt;&lt;/a&gt;1.3.1 数据抽象&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/.com//image-20201109160321098.png&quot; alt=&quot;image-20201109160321098&quot;&gt;&lt;/p&gt;
&lt;p&gt;系统要能高效地检索数据。而这促使设计者再数据库中使用复杂的数据结构来表示数据；&lt;/p&gt;
&lt;p&gt;许多用户不懂计算机，需要系统开发人员通过如下几个层次对用户屏蔽复杂性：&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库系统概念" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>第二章 关系模型介绍</title>
    <link href="http://yoursite.com/2020/11/09/database-system-conception-2/"/>
    <id>http://yoursite.com/2020/11/09/database-system-conception-2/</id>
    <published>2020-11-09T03:17:44.000Z</published>
    <updated>2020-11-25T09:42:03.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-关系数据库的结构"><a href="#2-1-关系数据库的结构" class="headerlink" title="2.1 关系数据库的结构"></a>2.1 关系数据库的结构</h1><ul><li><p>关系数据库由<strong>表</strong>（table）的集合构成，每个表有唯一的名字；</p></li><li><p>关系模型的术语中，<strong>关系</strong>用来指代<strong>表</strong>，而<strong>元组</strong>用来指代<strong>行</strong>。属性指代的是表中的<strong>列</strong>；</p></li><li><p>用<strong>关系实例</strong>来表示一个关系的特性实例，也就是所包含的一组特定的行；</p></li><li><p>对于关系的每个属性，都存在一个允许取值的集合，成为这个属性的<strong>域</strong>；如果域中元素被看作不可再分的单元，则域是<strong>原子的</strong>；（就是一个属性不能再被多个属性表示）</p></li><li><p><strong>空</strong> （null）指是一个特殊的值，表示值未知或不存在；空值会给数据库访问和更新带来很多困难。</p></li></ul><h1 id="2-2-关系数据库模式"><a href="#2-2-关系数据库模式" class="headerlink" title="2.2 关系数据库模式"></a>2.2 关系数据库模式</h1><p>​    需区分 <strong>数据库模式</strong> 和 <strong>数据库实例</strong>；前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照；</p><p>​    <strong>关系</strong>对应于程序设计语言中变量的概念；</p><p>​    <strong>关系模式</strong> 的概念对应于程序设计语言中类型定义的概念；关系模式由属性序列及各属性对应域组成；</p><p>​    当关系被更新时，关系实例的内容也随时间发生了变化。相反，关系的模式是不常变化的；</p><a id="more"></a><h1 id="2-3-码"><a href="#2-3-码" class="headerlink" title="2.3 码"></a>2.3 码</h1><p>我们必须有一种能区分给定关系中的不同元组的方法。一个关系中没有两个元组在所有属性上的取值都相同；</p><blockquote><p><font color="red"><strong>超码</strong></font> 是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组；</p><p>形式化地描述，设 $R$ 表示关系 $r$ 模式中的属性集合。如果我们说 $R$ 的一个子集 $K$ 是 $r$ 的一个超码，则限制了关系 $r$ 中任意两个不同元组不会在 $K$ 的所有属性上取值完全相等，即如果 $t_1$ 和 $t_2$ 在 $r$ 中且 $t_1\neq t_2$ , 则  $t_1.K \neq t_2.K$ </p><p>超码可能包含无关紧要的属性。则如果 $K$ 是一个超码，那么 $K$ 的任意超集也是超码；</p><p><strong>任意真子集都不能成为超码的最小超码被称为<font color="red">候选码</font>( candidate key)</strong></p><p>几个不同的属性集都可以做候选码的情况是<span color="red">存在的</span>；</p><p><font color="red"><strong>主码</strong></font>这个术语代表被数据库设计者选中的、主要用来在一个关系中区分不同元组的候选码；</p><ul><li>主码的选择必须慎重：有的候选码不适合做主码</li><li>主码应选择那些值从不或极少变化的属性；（地址、电话号码等就不应该作为主码）</li><li>习惯上把主码放在其他属性前面</li></ul></blockquote><p>关系中的任意两个不同的元组都不允许同时在码属性上具有相同的值。码的指定代表了被建模的事物在现实世界中的约束；</p><p>一个关系模式（如 $r_1$）可能在它的属性中包括另一个关系模式（如 $r_2$）的主码。这个属性在 $r_1$ 上称作参照 $r_2$ 的<font color="red"><strong>外码</strong></font> ;</p><p>关系 $r_1$ 称为外码依赖的<strong>参照关系</strong>，关系 $r_2$ 叫做外码的<strong>被参照关系</strong> ；</p><p><strong>参照完整性</strong>要求在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值；</p><p>也就是在参照关系中出现的一些属性，我们也希望他们出现在被参照关系中，但是这些属性可能不能够成被参照关系的主键，而此时还需要达成这样的约束就叫做<strong>参照完整性</strong>；</p><h1 id="2-4-模式图"><a href="#2-4-模式图" class="headerlink" title="2.4 模式图"></a>2.4 模式图</h1><p>一个含有主码和外码依赖的数据库模式可以用<strong>模式图</strong>（schema diagram）来表示。</p><p>每一个关系用一个矩形来表示，关系的名字显示在矩形上方，矩形内列出各属性。</p><p>主码属性用下划线标注。</p><p>外码依赖用从参照关系的外码属性到被参照关系的主码属性之间的箭头来表示。</p><p><img src="/.com//image-20201124155008889.png" alt="image-20201124155008889"></p><p>除外码约束外，模式图没有显示出参照完整性约束；（后面学的实体-联系图的图形化表示有助于我们表示几种约束）</p><h1 id="2-5-关系查询语言"><a href="#2-5-关系查询语言" class="headerlink" title="2.5 关系查询语言"></a>2.5 关系查询语言</h1><p><strong>查询语言</strong>是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化的和非过程化的。</p><p>在 <strong>过程化语言</strong> 中，用户指导系统对数据库执行一系列操作以计算出所需结果；</p><p>在 <strong>非过程化语言</strong> 中，用户只需描述所需信息，而不用给出获取该信息的具体过程；</p><p>实际使用的查询语言两种方式都有。</p><p>有一些”纯“查询语言：<strong>关系代数</strong>是过程化的，而 <strong>元组关系演算</strong> 和 <strong>域关系演算</strong> 是非过程化的。</p><p><strong>关系代数</strong> 包括一个运算的集合，这些运算以一个或两个关系为输入，产生一个新的关系作为结果。</p><p><strong>关系演算</strong> 使用谓词逻辑来定义所需的结果，但不需给出获取结果的特定代数过程。</p><h1 id="2-6-关系运算"><a href="#2-6-关系运算" class="headerlink" title="2.6 关系运算"></a>2.6 关系运算</h1><p>所有的过程化关系查询语言都提供了一组运算；这些运算要么施加于单个关系上，要么施加于一对关系上，并且<strong>运算结果总是单个关系</strong>。</p><ul><li>最常用的关系运算是 从单个关系（如 instructor）种选出满足一些特定谓词（如 salary &gt; 85000美元）的特殊元组；其结果是一个新关系，它是原始关系（instructor）的一个子集；</li><li>另一个常用的运算是 从一个关系中选出特定的属性（列）。其结果是一个只包含那些被选择属性的新关系；</li><li>连接运算：把分别来自两个关系的元组对合并成单个元组；<ul><li>自然连接：对于两个关系中的分别两个元组，如果他们在某一属性上取值相同，那么它们就是匹配的；</li></ul></li><li>笛卡尔积：结果是包含来自两个关系元组的所有对，无论它们的属性值是否匹配；</li><li>集合运算：包括 并、交、集合差；</li></ul><p>查询结果中可能包含重复值。有的查询语言严格遵守集合的数学定义，取出了重复，有的没有；</p><blockquote><p><strong>关系代数</strong> ： 关系代数定义了在关系上的一组运算，通常以一个或两个关系为输入，返回一个关系作为返回；</p></blockquote><p><img src="/.com//image-20201125171819866.png" alt="image-20201125171819866"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2-1-关系数据库的结构&quot;&gt;&lt;a href=&quot;#2-1-关系数据库的结构&quot; class=&quot;headerlink&quot; title=&quot;2.1 关系数据库的结构&quot;&gt;&lt;/a&gt;2.1 关系数据库的结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关系数据库由&lt;strong&gt;表&lt;/strong&gt;（table）的集合构成，每个表有唯一的名字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关系模型的术语中，&lt;strong&gt;关系&lt;/strong&gt;用来指代&lt;strong&gt;表&lt;/strong&gt;，而&lt;strong&gt;元组&lt;/strong&gt;用来指代&lt;strong&gt;行&lt;/strong&gt;。属性指代的是表中的&lt;strong&gt;列&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用&lt;strong&gt;关系实例&lt;/strong&gt;来表示一个关系的特性实例，也就是所包含的一组特定的行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于关系的每个属性，都存在一个允许取值的集合，成为这个属性的&lt;strong&gt;域&lt;/strong&gt;；如果域中元素被看作不可再分的单元，则域是&lt;strong&gt;原子的&lt;/strong&gt;；（就是一个属性不能再被多个属性表示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;空&lt;/strong&gt; （null）指是一个特殊的值，表示值未知或不存在；空值会给数据库访问和更新带来很多困难。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-2-关系数据库模式&quot;&gt;&lt;a href=&quot;#2-2-关系数据库模式&quot; class=&quot;headerlink&quot; title=&quot;2.2 关系数据库模式&quot;&gt;&lt;/a&gt;2.2 关系数据库模式&lt;/h1&gt;&lt;p&gt;​    需区分 &lt;strong&gt;数据库模式&lt;/strong&gt; 和 &lt;strong&gt;数据库实例&lt;/strong&gt;；前者是数据库的逻辑设计，后者是给定时刻数据库中数据的一个快照；&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;关系&lt;/strong&gt;对应于程序设计语言中变量的概念；&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;关系模式&lt;/strong&gt; 的概念对应于程序设计语言中类型定义的概念；关系模式由属性序列及各属性对应域组成；&lt;/p&gt;
&lt;p&gt;​    当关系被更新时，关系实例的内容也随时间发生了变化。相反，关系的模式是不常变化的；&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库系统概念" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>第三章 数据库编程</title>
    <link href="http://yoursite.com/2020/11/09/database-principle-and-application-chapter-03/"/>
    <id>http://yoursite.com/2020/11/09/database-principle-and-application-chapter-03/</id>
    <published>2020-11-09T03:17:43.000Z</published>
    <updated>2020-11-09T03:19:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>标准SQL是非过程化的查询语言，具有操作统一，面向集合、功能丰富、使用简单等多项优点；</p><p>但它的缺点在于——缺少流程控制能力，难以实现应用业务中的逻辑控制；所以引入了SQL编程；</p><h1 id="3-1-MySQL编程基础"><a href="#3-1-MySQL编程基础" class="headerlink" title="3.1 MySQL编程基础"></a>3.1 MySQL编程基础</h1><p>需要将频繁使用的业务逻辑封装成存储程序；</p><p>MySQL提供了用于编写结构化程序的数据类型、常量、变量、运算符和表达式等；</p><h2 id="3-1-1-常量与变量"><a href="#3-1-1-常量与变量" class="headerlink" title="3.1.1 常量与变量"></a>3.1.1 常量与变量</h2><p>程序本身不能改变的数据成为常量；程序运行中可以改变其值的数据成为变量；</p><h3 id="1-常量"><a href="#1-常量" class="headerlink" title="1. 常量"></a>1. 常量</h3><p>常量的格式取决于其数据类型，常用的常量包括字符串常量、数值常量、日期和时间常量、布尔值常量和<code>NULL</code>值；</p><p>1）字符串常量</p><p>​    用单引号与双引号括起来的字符序列。推荐使用单引号；</p><p>2）数值常量<a id="more"></a></p><p>​    可以分为整数常量和小数常量；</p><p>3）日期和时间常量</p><p>​    使用特定格式的字符日期值表示，单引号括起来。例如：’2018/0717’、’2018-07-17 10:30:20’</p><p>4）布尔值常量</p><p>​    只有 <code>true</code> 和 <code>false</code> 两个值，SQL命令的运行结果用1代表 <code>true</code> ，用0代表 <code>false</code> </p><p>5）<code>NULL</code> 值</p><p>​    适用于各种字段类型，表示“不确定的值”。<code>NULL</code>值参与的运算，结果仍为 <code>NULL</code> 值；</p><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>变量有名字和数据类型两个属性。MySQL中存在两种变量，一种是系统定义和维护的全局变量，通常名称前加 <code>@@</code> 符号；另一种是用户定义的用来存放中间结果的局部变量，通常在名称前加 <code>@</code> 符号；</p><p>1）局部变量</p><p>​    局部变量作用范围限制在程序内部</p><p>​    （1）局部变量的定义与赋值：使用 <code>SET</code> 语句定义局部变量，并为其赋值；语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @局部变量名 = 表达式<span class="number">1</span>[, @局部变量名 = 表达式<span class="number">2</span>，··· ];</span><br></pre></td></tr></table></figure><p>​        <strong>注意</strong>：可同时定义多个变量；</p><p>​    （2）局部变量的显示：使用 <code>SELECT</code> 语句显示局部变量。语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @局部变量名 [ ,@局部变量名,··· ];</span><br></pre></td></tr></table></figure><p>【例】查询emp中雇员SMITH的sal值赋给变量salary，并显示其值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @salary = (<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename = <span class="string">'SMITH'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @salary;</span><br></pre></td></tr></table></figure><p>【例】查询emp中雇员SMITH的job和hiredate值赋给变量<code>job_v</code>，<code>hiredate_v</code>并显示两个变量的值；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job,hiredate <span class="keyword">INTO</span> @job_v, @hiredate_v</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename = <span class="string">'SMITH'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @job_v, @hiredate_v;</span><br></pre></td></tr></table></figure><p>2）全局变量</p><p>全局变量是MySQL系统提供并赋值的变量。用户不能定义全局变量，只能使用。</p><p>常用系统全局变量及说明如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">全局变量名称</th><th style="text-align:center">说    明</th></tr></thead><tbody><tr><td style="text-align:center"><code>@@back_log</code></td><td style="text-align:center">返回MySQL主要连接请求的数量</td></tr><tr><td style="text-align:center"><code>@@basedir</code></td><td style="text-align:center">返回MySQL安装基准目录</td></tr><tr><td style="text-align:center"><code>@@license</code></td><td style="text-align:center">返回服务器的许可类型</td></tr><tr><td style="text-align:center"><code>@@port</code></td><td style="text-align:center">返回服务器侦听TCP/IP连接所用的端口</td></tr><tr><td style="text-align:center"><code>@@storage_engine</code></td><td style="text-align:center">返回存储引擎</td></tr><tr><td style="text-align:center"><code>@@version</code></td><td style="text-align:center">返回服务器版本号</td></tr></tbody></table></div><h2 id="3-1-2-常用系统函数"><a href="#3-1-2-常用系统函数" class="headerlink" title="3.1.2 常用系统函数"></a>3.1.2 常用系统函数</h2><p>函数是一组编译好的SQL语句，定义了一组操作，返回数值、数值集合，或执行一些操作；</p><p>MySQL 的系统函数包括：字符串函数、数学函数、日期和时间函数、系统信息函数等；</p><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1. 字符串函数"></a>1. 字符串函数</h3><p>1）计算字符串字符数和字符串长度的函数</p><ul><li><code>CHAR_LENGTH(str)</code> ：返回字符串 <code>str</code> 所包含的字符个数；</li><li><code>LENGTH(str)</code> ：返回字符串的字节长度。一个汉字是3个字节，一个数字或字母是1个字节；</li></ul><p>【例】计算字符串字符数和字符串长度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`CHAR_LENGTH('CHINA'), LENGTH('CHINA');</span></span><br><span class="line"><span class="string">%  5   5  %</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SELECT `</span><span class="keyword">CHAR_LENGTH</span>(<span class="string">'中国'</span>), <span class="keyword">LENGTH</span>(<span class="string">'中国'</span>);</span><br><span class="line">%  2   6  %</span><br></pre></td></tr></table></figure><p>2）合并字符串函数</p><ul><li><code>CONCAT(s1,s2,···)</code> ：返回连接参数产生的字符串，若任一参数为NULL，则返回NULL；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'MySQL版本： '</span>, @@<span class="keyword">version</span>);</span><br></pre></td></tr></table></figure><p>3）字符串大小写转换函数</p><ul><li><code>LOWER(str)</code> ：把<code>str</code>中字母字符串全转换成小写字母</li><li><code>UPPER(str)</code> ：把<code>str</code>中字母字符串全转换成大写字母</li></ul><p>4）删除空格函数</p><ul><li><p><code>LTRIM(str)</code> ：返回删除前导空格的字符串</p></li><li><p><code>RTRIM(str)</code> ：返回删除后导空格的字符串</p></li><li><p><code>TRIM(str)</code> ：返回删除两侧空格的字符串</p></li></ul><p>5）取子串函数</p><ul><li><code>SUBSTRING(str, start, length)</code> </li></ul><h3 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2. 数学函数"></a>2. 数学函数</h3><ul><li><code>ABS(x)</code></li><li><code>PI()</code></li><li><code>SQRT()</code> ：非复数的二次方根</li><li><code>mod(m,n)</code> ：返回<code>m</code>被<code>n</code>除后的余数</li><li><code>ROUND(x,y)</code> ：把 <code>x</code> 四舍五入到 <code>y</code> 指定的精度返回。<code>y</code> 为负数，则将保留  <code>x</code> 值到小数点左边 <code>y</code> 位；</li></ul><h3 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3. 日期和时间函数"></a>3. 日期和时间函数</h3><p>1）获取当前系统的日期及取日期的年、月、日的函数；</p><ul><li><code>CURDDATE</code></li><li><code>year(d)</code>、<code>MONTH(d)</code>、<code>DAY(d)</code> ：分别返回日期或日期时间 <code>d</code> 的年、月、日的值；</li></ul><p>2）获取当前系统的日期时间的函数；</p><ul><li><code>CURRENT_TIMESTAMP()</code></li><li><code>LOCALTIME()</code></li><li><code>NOW()</code></li><li><code>SYSDATE()</code></li></ul><p>上面几个函数作用相同，均返回当前系统的日期时间；格式为：<code>YYYY-MM-DD HH:MM:SS</code> ；</p><h3 id="4-系统信息函数"><a href="#4-系统信息函数" class="headerlink" title="4. 系统信息函数"></a>4. 系统信息函数</h3><ul><li><code>USER()</code> ：返回当前登录的用户名</li><li><code>DATABASE()</code> ：返回当前所使用数据库的名</li><li><code>VERSION()</code> ：返回 <code>MySQL</code> 服务器版本号</li></ul><h3 id="5-条件控制函数"><a href="#5-条件控制函数" class="headerlink" title="5. 条件控制函数"></a>5. 条件控制函数</h3><p>1）<code>IF()</code>函数：格式为 <code>IF(条件表达式, v1, v2)</code> ，如果表达式为真，则函数返回 <code>v1</code> 值，否则返回 <code>v2</code> 值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, <span class="keyword">IF</span>(comm <span class="keyword">IS</span> <span class="literal">NULL</span>, <span class="number">0</span>, comm) 奖金</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>2）<code>CASE()</code>函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE 表达式</span><br><span class="line">WHEN v1 THEN r1</span><br><span class="line">WHEN v2 THEN r2</span><br><span class="line">...</span><br><span class="line">[ ELSE rn ]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="6-数据类型转换函数"><a href="#6-数据类型转换函数" class="headerlink" title="6. 数据类型转换函数"></a>6. 数据类型转换函数</h3><p><code>CASE(x AS 新类型)</code> 和 <code>CONVERT(x 新类型)</code> 两个函数作用相同，都是把一种类型的值转换为另一种类型的值；</p><h1 id="3-2-程序控制流语句"><a href="#3-2-程序控制流语句" class="headerlink" title="3.2 程序控制流语句"></a>3.2 程序控制流语句</h1><p>MySQL有编写过程化代码的语法结构，可进行顺序、分支、循环、存储过程、存储函数、触发器等程序设计；</p><h2 id="3-2-1-语句块、注释和重置命令结束标记"><a href="#3-2-1-语句块、注释和重置命令结束标记" class="headerlink" title="3.2.1 语句块、注释和重置命令结束标记"></a>3.2.1 语句块、注释和重置命令结束标记</h2><h3 id="1-语句块"><a href="#1-语句块" class="headerlink" title="1. 语句块"></a>1. 语句块</h3><p>​    <code>BEGIN ··· END</code> 用于定义SQL语句块，语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SQL</span>语句 | <span class="keyword">SQL</span>语句块</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>（1）<code>BEGIN ··· END</code> 语句块包含了该程序块的所有处理操作，允许语法块嵌套</p><p>（2）单独使用 <code>BEGIN ··· END</code> 语法块没有任何意义，主要用于<strong>存储过程</strong>、<strong>存储函数</strong>、<strong>触发器</strong>等存储程序内部才有意义；</p><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><p>单行注释和多行注释</p><p>1）单行注释 ：使用 “ # ” 符号</p><p>2）多行注释： <code>/*</code> 和 <code>*/</code> 括起来是多行注释</p><h3 id="3-重置命令结束标记"><a href="#3-重置命令结束标记" class="headerlink" title="3. 重置命令结束标记"></a>3. 重置命令结束标记</h3><p><strong>为什么要重置命令结束标记？</strong></p><p>因为MySQL中，服务器处理的语句是以分号为结束标记的；但在创建存储函数、存储过程的时候，在函数体或存储过程体中可以包含多个SQL语句，每个SQL语句都是以分号为结尾的，而服务器处理程序遇到分号则结束程序的执行；所以需要重置命令结束标记；</p><p><strong>MySQL使用 DELIMITER 语句将MySQL语句的结束标记修改为其他符号</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 符号</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>（1）符号可以是一些特殊符号，例如两个“#”、两个“@”、两个“$”、两个“%”等。</p><p>（2）恢复使用分号为结束标记，执行 “ <code>DELIMITER ;</code> ” 即可；</p><h2 id="3-2-2-存储函数"><a href="#3-2-2-存储函数" class="headerlink" title="3.2.2 存储函数"></a>3.2.2 存储函数</h2><p>用MySQL编写程序可以根据应用程序的需要创建<strong>存储函数</strong></p><h3 id="1-存储函数的创建"><a href="#1-存储函数的创建" class="headerlink" title="1. 存储函数的创建"></a>1. 存储函数的创建</h3><p>创建存储函数的，要用到 <code>CREATE FUNCTION</code> 语句， 语法为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名 ( [ 参数名 参数数据类型 [ ,··· ] ] )</span><br><span class="line"><span class="keyword">RETURNS</span> 函数返回值的数据类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体;</span><br><span class="line">RETURN 语句;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="2-调用存储函数"><a href="#2-调用存储函数" class="headerlink" title="2. 调用存储函数"></a>2. 调用存储函数</h3><p>对新创建的存储函数，调用方法与调用系统函数相同，语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名 ( [ 参数值 [ ,··· ] ] )</span><br></pre></td></tr></table></figure><p>接下来的例子涉及了 <code>delimeter</code> 在定义存储函数时的使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> name_fn(dno <span class="built_in">DECIMAL</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">14</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept</span><br><span class="line"><span class="keyword">WHERE</span> deptno = dno );</span><br><span class="line"><span class="keyword">END</span>@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">SELECT</span> name_fn(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="3-删除存储函数"><a href="#3-删除存储函数" class="headerlink" title="3. 删除存储函数"></a>3. 删除存储函数</h3><p>用 <code>DROP FUNCTION</code> 语句删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名;</span><br></pre></td></tr></table></figure><h2 id="3-2-3-条件判断语句"><a href="#3-2-3-条件判断语句" class="headerlink" title="3.2.3 条件判断语句"></a>3.2.3 条件判断语句</h2><h3 id="1-程序中变量的使用"><a href="#1-程序中变量的使用" class="headerlink" title="1. 程序中变量的使用"></a>1. 程序中变量的使用</h3><p>局部变量可在程序中声明并使用，这些变量的作用范围是 <code>BEGIN···END</code> 语法块</p><p>1） 声明变量</p><p>在存储程序（例如存储函数、存储过程、触发器等）中需要使用 <code>DECLARE</code> 语句声明局部变量，语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 局部变量名 [ ,局部变量名,··· ] 数据类型 [ DEFAULT 默认值 ];</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>（1）<code>DECLARE</code> 声明的局部变量，变量名前不能加 <code>@</code></p><p>（2）<code>DEFAULT</code> 子句提供了一个默认值，如果没有给默认值，则局部变量的初始值默认为 <code>NULL</code> ；</p><p>2）为变量赋值</p><p>变量声明后，用 <code>SET</code> 命令为变量赋值；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 局部变量名 = 表达式<span class="number">1</span> [, 局部变量名 = 表达式<span class="number">2</span>,··· ];</span><br></pre></td></tr></table></figure><h3 id="2-IF语句"><a href="#2-IF语句" class="headerlink" title="2. IF语句"></a>2. IF语句</h3><p><code>IF</code> 有两种形式：</p><p>1）形式一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;条件&gt; THEN</span><br><span class="line">SQL语句块 1;</span><br><span class="line">[ELSE</span><br><span class="line">SQL语句块 2; ]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><p>2）形式二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF &lt;条件1&gt; THEN</span><br><span class="line">SQL语句块 1;</span><br><span class="line">ELSEIF &lt;条件2&gt; THEN</span><br><span class="line">SQL语句块 2;</span><br><span class="line">···</span><br><span class="line">ELSE</span><br><span class="line">SQL语句块n;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure><h3 id="3-CASE语句"><a href="#3-CASE语句" class="headerlink" title="3. CASE语句"></a>3. CASE语句</h3><p>1）形式一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE &lt;表达式&gt;</span><br><span class="line">WHEN &lt;表达式1&gt; THEN SQL语句块1;</span><br><span class="line">WHEN &lt;表达式2&gt; THEN SQL语句块2；</span><br><span class="line">···</span><br><span class="line">WHEN &lt;表达式n&gt; THEN SQL语句块n;</span><br><span class="line">[ ELSE SQL语句块n+1; ]</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>2）形式二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">WHEN &lt;条件1&gt; THEN SQL语句1;</span><br><span class="line">WHEN &lt;条件2&gt; THEN SQL语句2;</span><br><span class="line">···</span><br><span class="line">WHEN &lt;条件n&gt; THEN SQL语句n;</span><br><span class="line">ELSE SQL语句块 n+1;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2 id="3-2-4-循环语句"><a href="#3-2-4-循环语句" class="headerlink" title="3.2.4 循环语句"></a>3.2.4 循环语句</h2><h3 id="1-LOOP循环"><a href="#1-LOOP循环" class="headerlink" title="1. LOOP循环"></a>1. LOOP循环</h3><p>LOOP循环为无条件循环，如果没有指定 <code>LEAVE</code> 语句，循环将一直运行，成为死循环；通常是结合条件语句使用；条件语句里嵌入 <code>LEAVE</code> 语句；条件为真，跳出循环；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标签: LOOP# # 标签 是自定义的</span><br><span class="line">SQL语句块;</span><br><span class="line">IF &lt;条件表达式&gt; THEN</span><br><span class="line">LEAVE 标签;# # 通过自己定义的标签结束 LOOP 循环</span><br><span class="line">END IF;</span><br><span class="line">END LOOP;</span><br></pre></td></tr></table></figure><h3 id="2-WHILE循环"><a href="#2-WHILE循环" class="headerlink" title="2. WHILE循环"></a>2. WHILE循环</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE &lt;条件表达式&gt; DO</span><br><span class="line">SQL语句块</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br></pre></td></tr></table></figure><h3 id="3-REPEAT循环"><a href="#3-REPEAT循环" class="headerlink" title="3. REPEAT循环"></a>3. REPEAT循环</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">SQL语句块;</span><br><span class="line">UNTIL &lt;条件表达式&gt;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure><h1 id="3-3-存储过程"><a href="#3-3-存储过程" class="headerlink" title="3.3 存储过程"></a>3.3 存储过程</h1><p>概念：<strong>存储过程</strong>就是一条或多条SQL语句的集合；利用这些SQL语句完成一个或多个逻辑功能；</p><p>环境：存储过程可以被赋予参数，存储在数据库中，可以被用户调用，也可以被JAVA 或 C# 等调用；</p><p>特性：并且存储过程都是编译好的，调用时不用再次编译，提高了程序的运行效率；</p><h2 id="3-3-1-创建存储过程"><a href="#3-3-1-创建存储过程" class="headerlink" title="3.3.1 创建存储过程"></a>3.3.1 创建存储过程</h2><p>要用 <code>CREATE PROCEDURE</code> 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名()</span><br><span class="line">BEGIN</span><br><span class="line">过程体;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="3-3-2-调用存储过程"><a href="#3-3-2-调用存储过程" class="headerlink" title="3.3.2 调用存储过程"></a>3.3.2 调用存储过程</h2><p>使用 <code>CALL</code> 语句直接调用存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名();</span><br></pre></td></tr></table></figure><h2 id="3-3-3-存储过程的参数"><a href="#3-3-3-存储过程的参数" class="headerlink" title="3.3.3 存储过程的参数"></a>3.3.3 存储过程的参数</h2><p>存储过程可以接受和返回 0 到多个参数，使程序变得灵活； MySQL 有3种参数模式，即 <code>IN</code>、 <code>OUT</code>、 <code>INOUT</code>。</p><blockquote><p>创建带参数的存储过程的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(</span><br><span class="line">[ <span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT ] 参数<span class="number">1</span> 数据类型</span><br><span class="line">[ <span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT ] 参数<span class="number">2</span> 数据类型</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">过程体;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-IN参数"><a href="#1-IN参数" class="headerlink" title="1. IN参数"></a>1. IN参数</h3><p><code>IN</code> 参数作为输入参数，该参数值由<strong>调用者</strong>传入，并且只能够被存储过程读取；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE dept_pl(</span><br><span class="line">IN p_deptno DECIMAL(2,0),</span><br><span class="line">IN p_dname VARCHAR(14),</span><br><span class="line">IN p_loc VARCHAR(13)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO dept</span><br><span class="line">VALUES (p_deptno, p_name, p_loc);</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL dept_pl(50, &#39;HR&#39;, &#39;CHINA&#39;);</span><br><span class="line">SELECT * FROM dept WHERE deptno &#x3D; 50;</span><br></pre></td></tr></table></figure><h3 id="2-OUT参数"><a href="#2-OUT参数" class="headerlink" title="2. OUT参数"></a>2. OUT参数</h3><p><code>OUT</code>参数为输出参数，该类型的参数值由存储过程写入；</p><p>比较适合于向调用者返回多条信息的过程；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE dept_p2(</span><br><span class="line">IN i_no DECIMAL(2,0),</span><br><span class="line">OUT o_name VARCHAR(14),</span><br><span class="line">OUT o_loc VARCHAR(13)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT dname, loc INTO o_name, o_loc FROM dept</span><br><span class="line">WHERE deptno &#x3D; i_no;</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL dept_p2(10, @v_name, @v_loc);</span><br><span class="line">SELECT @v_dname, @v_loc;</span><br></pre></td></tr></table></figure><h3 id="3-INOUT参数"><a href="#3-INOUT参数" class="headerlink" title="3. INOUT参数"></a>3. INOUT参数</h3><p><code>INOUT</code> 类型得参数同时具有 <code>IN</code> , <code>OUT</code> 的特性，在过程中可以读取和写入该类型参数；</p><p><code>IN</code> 参数可以接收一个值，但不能修改这个值；</p><p><code>OUT</code>参数被调用时为空，在执行过程中将这个参数指定一个值，过程执行结束后返回；</p><p><strong>使用 <code>INOUT</code> 参数实现两个数的交换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE swap(</span><br><span class="line">INOUT p_num1 int,</span><br><span class="line">INOUT p_num2 int</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE var_temp int;</span><br><span class="line">SET var_temp &#x3D; p_num1;</span><br><span class="line">SET p_num1 &#x3D; p_num2;</span><br><span class="line">SET p_num2 &#x3D; var_temp;</span><br><span class="line">END@@</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">SET @v_num1 &#x3D; 1;</span><br><span class="line">SET @v_num2 &#x3D; 2;</span><br><span class="line">CALL swap(@V_num1, @v_num2);</span><br><span class="line">SELECT @v_num1, @v_num2;</span><br></pre></td></tr></table></figure><h2 id="3-3-4-删除存储过程"><a href="#3-3-4-删除存储过程" class="headerlink" title="3.3.4 删除存储过程"></a>3.3.4 删除存储过程</h2><p>指删除数据库中已存在的存储过程；使用 <code>DROP PROCEDUER</code> 语句来删除存储过程；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE 存储过程名;</span><br></pre></td></tr></table></figure><h1 id="3-4-游标"><a href="#3-4-游标" class="headerlink" title="3.4 游标"></a>3.4 游标</h1><p>当通过 <code>SELECT</code> 语句查询时，返回的是一个由多行记录组成的集合；而程序设计语言不能处理以集合形式返回的数据，为此SQL提供了游标机制；</p><p>游标充当指针使用，使应用程序设计语言一次只能处理查询结果中的一行；</p><h2 id="3-4-1-游标的定义和使用"><a href="#3-4-1-游标的定义和使用" class="headerlink" title="3.4.1 游标的定义和使用"></a>3.4.1 游标的定义和使用</h2><p>游标是在存储程序中使用包含 <code>SELECT</code> 语句</p><h3 id="1-声明游标"><a href="#1-声明游标" class="headerlink" title="1. 声明游标"></a>1. 声明游标</h3><p>使用 <code>DECLARE</code> 语句；<strong>语法形式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 游标名 CURSOR</span><br><span class="line">FOR SELECT 语句;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>（1）声明游标的作用是得到一个 <code>SELECT</code> 查询结果集。游标为用户提供逐行处理的途径；</p><p>（2）<code>SELECT</code> 语句是对表或视图的擦汗寻语句；可以带 <code>WHERE</code>，<code>ORDER BY</code>，<code>GROUP BY</code> 等子句；但不能使用<code>INTO</code></p><h3 id="2-打开游标"><a href="#2-打开游标" class="headerlink" title="2. 打开游标"></a>2. 打开游标</h3><p>打开游标使用<code>OPEN</code>语句，语句形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN 游标名;</span><br></pre></td></tr></table></figure><p><strong>游标必须先声明后打开</strong>，在打开游标时，<code>SELECT</code>语句的查询结果被传送到了游标工具区，供用户读取；</p><h3 id="3-提取数据"><a href="#3-提取数据" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><p>打开游标后，使用 <code>FETCH</code> 语句将游标工作区中的数据读取到变量中，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH 游标名 INTO 变量名1[, 变量名2···];</span><br></pre></td></tr></table></figure><p>成功打开游标时，游标指针在第一行之前，而 <code>FETCH</code> 语句使游标指向下一行。</p><p>可以在循环中使用 <code>FETCH</code> 语句，每次循环都会从表中读取一行数据；</p><h3 id="4-关闭游标"><a href="#4-关闭游标" class="headerlink" title="4. 关闭游标"></a>4. 关闭游标</h3><p>游标使用完后，需要用 <code>CLOSE</code> 语句关闭，<strong>语法形式</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE 游标名;</span><br></pre></td></tr></table></figure><h2 id="3-4-2-异常处理"><a href="#3-4-2-异常处理" class="headerlink" title="3.4.2 异常处理"></a>3.4.2 异常处理</h2><p>在存储过程中出现错误可能导致程序终止。</p><p>错误发生时希望不要终止执行，而是通过MySQL的错误处理机制帮助控制程序流程；</p><p>存储过程中的错误处理通过 <strong><code>DECLARE HANDLER</code> 语句</strong>实现，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 错误处理类型 HANDLER FOR 错误触发条件 自定义错误处理程序;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>（1）一般情况下，异常处理语句置于存储程序中才有意义；</p><p>（2）异常处理语句必须放在所有变量和游标定义之后，所有MySQL表达式之前；</p><p>（3）<strong>错误处理类型</strong>：错误处理类型只有 <code>CONTINUE</code> 和 <code>EXIT</code> 两种；</p><ul><li><strong><code>CONTINUE</code></strong> 表示错误发生后MySQL立即执行自定义错误处理程序，然后忽略该错误继续执行其他的程序；</li><li><strong><code>EXIT</code></strong> 表示错误发生后 MySQL 立即执行自定义错误处理程序，然后立即停止其他MySQL语句的执行；</li></ul><p>（4）<strong>错误触发条件</strong>：错误除法条件定义了自定义错误处理程序运行的时机；错误触发条件的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQLSTATE &#39;ANSI标准错误代码&#39;</span><br><span class="line">|MySQL错误代码</span><br><span class="line">|SQLWARNING</span><br><span class="line">|NOT FOUND</span><br><span class="line">|SQLEXCEPTION</span><br></pre></td></tr></table></figure><ul><li>错误触发条件支持标准的SQLSTATE定义，也支持MySQL的错误代码；</li><li><code>SQLWARNING</code>表示对所有以01开头的SQLSTATE代码的速记；</li><li><code>NOT FOUND</code>表示对所有以02开头的SQLSTATE代码的速记</li><li><code>SQLEXCEPTION</code> 表示对所有没有被 <code>SQLWARNING</code> 或 <code>NOT FOUND</code> 捕获的 <code>SQLSTATE</code> 代码的速记；</li></ul><p>（5）自定义错误处理程序    错误发生后，MySQL会立即执行自定义错误处理程序中的 MySQL 语句；</p><p>// 这个过程比较抽象；我觉得需要结合代码来认识；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER @@</span><br><span class="line">CREATE PROCEDURE emp_up_pro()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE v_empno DECIMAL(4,0);</span><br><span class="line">DECLARE v_sal DECIMAL(7,2);</span><br><span class="line">DECLARE v_comm DECIMAL(7,2);</span><br><span class="line">DECLARE flag BOOLEAN DEFAULT TRUE;</span><br><span class="line">DECLARE comm_cur CURSOR</span><br><span class="line">FOR SELECT empno, sal FROM emp_c;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND</span><br><span class="line">SET flag &#x3D; FALSE;</span><br><span class="line">OPEN comm_cur;</span><br><span class="line">WHILE flag DO</span><br><span class="line">FETCH comm_cur INTO v_empno, v_sal;</span><br><span class="line">IF v_sal &lt; 500 THEN SET v_comm &#x3D; v_sal * 0.25;</span><br><span class="line">ELSEIF v_sal &lt; 1000 THEN SET v_comm &#x3D; v_sal * 0.2;</span><br><span class="line">ELSEif v_sal &lt; 3000 THEN SET v_comm &#x3D; v_sal * 0.15;</span><br><span class="line">ELSE SET v_comm &#x3D; v_sal * 0.12;</span><br><span class="line">END IF;</span><br><span class="line">UPDATE emp_c SET comm &#x3D; v_comm</span><br><span class="line">WHERE empno &#x3D; v_empno;</span><br><span class="line">END WHILE;</span><br><span class="line">CLOSE comm_cur;</span><br><span class="line">END@@</span><br></pre></td></tr></table></figure><p>这里面的异常处理用于处理在游标到达空指针时使得程序正常结束；</p><h1 id="3-5-嵌入式SQL"><a href="#3-5-嵌入式SQL" class="headerlink" title="3.5 嵌入式SQL"></a>3.5 嵌入式SQL</h1><p>被嵌入的程序设计语言被称为宿主语言，简称主语言；</p><h2 id="3-5-1-SQL与宿主语言接口"><a href="#3-5-1-SQL与宿主语言接口" class="headerlink" title="3.5.1 SQL与宿主语言接口"></a>3.5.1 SQL与宿主语言接口</h2><p>嵌入式SQL语句一般采用预编译方法处理，由RDBMS的预处理程序对源程序进行扫描，识别出ESQL语句，把他们转换成主语言调用语句，以使主语言编译程序能够识别它们，最后由主语言的编译程序将整个源程序编译成目标码；（SQL语句被转为了一种供主语言调用的语句）</p><h3 id="1-区分主语言语句与SQL语句"><a href="#1-区分主语言语句与SQL语句" class="headerlink" title="1. 区分主语言语句与SQL语句"></a>1. 区分主语言语句与SQL语句</h3><p>在嵌入式SQL中需要区分主语言语句与SQL语句；所以需要把所有的SQL语句加前缀；C语言时的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL SQL语句;</span><br></pre></td></tr></table></figure><h3 id="2-嵌入式SQL语句与主语言的通信"><a href="#2-嵌入式SQL语句与主语言的通信" class="headerlink" title="2. 嵌入式SQL语句与主语言的通信"></a>2. 嵌入式SQL语句与主语言的通信</h3><p>程序执行过程中，主语言需要与SQL语句进行信息交换，其间的通信过程如下：</p><ul><li><p>SQL语句将执行状态信息传递给主语言；</p><ul><li>主语言得到状态信息后，可以根据这个状态信息来控制程序流程；</li><li>向主语言传递SQL执行信息，主要用SQL通信区实现；</li></ul></li><li><p>主语言需要提供一些变量参数给SQL语句；</p><ul><li>在主语言中定义主变量，在SQL语句中使用主变量，将参数值传递给SQL语句；</li></ul></li><li>将SQL语句查询数据库的结果返回给主语言做进一步处理；<ul><li>如果SQL语句返回的时一条数据库记录，可使用主变量；若返回值为多条记录的集合，则使用游标；</li></ul></li></ul><h2 id="3-5-2-SQL通信区"><a href="#3-5-2-SQL通信区" class="headerlink" title="3.5.2 SQL通信区"></a>3.5.2 SQL通信区</h2><p>SQL语句执行后要返回给应用程序若干信息，主要包括描述系统当前状态和运行环境的各种参数；这些信息被送到SQL通信区——SQLCA中。</p><p>主语言的应用程序从SQLCA中取出这些状态信息，据此决定后面语句的执行；</p><p>SQLCA是一个数据结构，其中有一个系统变量SQLCODE，用来存放每次执行SQL语句后返回的代码；</p><p>应用程序每执行一条SQL语句后均测试一下SQLCODE的值，了解SQL语句的执行情况并作相应的处理；如果SQLCODE等于预定义的常量SUCCESS，则表示成功，否则在SQLCODE中存放错误代码。</p><h2 id="3-5-3-主变量的定义与使用"><a href="#3-5-3-主变量的定义与使用" class="headerlink" title="3.5.3 主变量的定义与使用"></a>3.5.3 主变量的定义与使用</h2><p>在嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据。在SQL语句中使用的主语言程序变量简称为主变量。</p><p>主变量根据作用不同，分为输入变量和输出变量；</p><ul><li>在 <code>SELECT INTO</code> 和 <code>FETCH</code> 语句之后的主变量称为“输出主变量”</li><li>除了<code>SELECT INTO</code> 和 <code>FETCH</code> 语句以外的其他SQL语句称为“输入主变量”</li></ul><h3 id="1-主变量的定义"><a href="#1-主变量的定义" class="headerlink" title="1. 主变量的定义"></a>1. 主变量的定义</h3><p>在使用主变量之前，必须在SQL语句 <code>BEGIN DECLARE SECTION</code> 与 <code>END DECLARE SECTION</code> 之间声明；</p><p>声明后可以在SQL语句中任何一个能够使用表达式的地方出现，为了与数据库对象名区别，应在SQL语句中的主变量名前加冒号（:）；</p><p><strong>注意</strong></p><p>（1）主变量使用前，必须在嵌入SQL语句的说明部分明确定义；</p><p>（2）主变量定义时，所用的数据类型为主语言提供的数据类型；注意大小写；</p><p>（3）在SQL语句中使用主变量时，必须在主变量前加一个冒号（:），在主语言语句中不需要加冒号</p><p>（4）主变量不能是SQL命令的关键字；</p><p>（5）在一条SQL语句中，主变量只能使用一次；</p><h3 id="2-在SELECT语句中使用主变量"><a href="#2-在SELECT语句中使用主变量" class="headerlink" title="2. 在SELECT语句中使用主变量"></a>2. 在SELECT语句中使用主变量</h3><p>在嵌入式SQL中，如果查询结果为单记录，则 <code>SELECT</code> 语句需要用 <code>INTO</code> 子句指定查询结果的存放地点——主变量；</p><h3 id="3-在INSERT语句中使用主变量"><a href="#3-在INSERT语句中使用主变量" class="headerlink" title="3. 在INSERT语句中使用主变量"></a>3. 在INSERT语句中使用主变量</h3><p>在 <code>INSERT</code> 语句的 <code>VALUES</code> 子句中，可以使用主变量指定插入的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL INSERT INTO grade(学号,课号,分数)</span><br><span class="line">VALUES(:hsno, :hcno, :hgrade);</span><br></pre></td></tr></table></figure><h3 id="4-在UPDATE语句中使用主变量"><a href="#4-在UPDATE语句中使用主变量" class="headerlink" title="4. 在UPDATE语句中使用主变量"></a>4. 在UPDATE语句中使用主变量</h3><p>在 <code>UPDATE</code> 语句的 <code>SET</code> 子句和 <code>WHERE</code> 子句中，均可使用主变量；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">UPDATE</span> grade</span><br><span class="line"><span class="keyword">SET</span> 分数 = :mgrade</span><br><span class="line"><span class="keyword">WHERE</span> 学号 = :msno <span class="keyword">AND</span> 课号 = :mcno;</span><br></pre></td></tr></table></figure><h3 id="5-在DELETE语句中使用主变量"><a href="#5-在DELETE语句中使用主变量" class="headerlink" title="5. 在DELETE语句中使用主变量"></a>5. 在DELETE语句中使用主变量</h3><p>在 <code>DELETE</code> 语句的 <code>WHERE</code> 子句中，可以使用主变量指定删除条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DELETE</span> <span class="keyword">FROM</span> grade</span><br><span class="line"><span class="keyword">WHERE</span> 学号 = :msno;</span><br></pre></td></tr></table></figure><h2 id="3-5-4-嵌入式SQL中游标的定义与使用"><a href="#3-5-4-嵌入式SQL中游标的定义与使用" class="headerlink" title="3.5.4 嵌入式SQL中游标的定义与使用"></a>3.5.4 嵌入式SQL中游标的定义与使用</h2><p>用嵌入式 SQL 语句查询数据分为两类情况：一类是多行结果，一类是多行结果；</p><p>对于单行结果，可以使用 <code>SELECT INTO</code> 语句；</p><p>对于多行结果，必须使用游标来完成；</p><p>包括四步：声明游标，打开游标，提取数据，关闭游标；</p><h3 id="1-声明游标-1"><a href="#1-声明游标-1" class="headerlink" title="1. 声明游标"></a>1. 声明游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">SELECT</span> 语句;</span><br></pre></td></tr></table></figure><h3 id="2-打开游标-1"><a href="#2-打开游标-1" class="headerlink" title="2. 打开游标"></a>2. 打开游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN 游标名;</span><br></pre></td></tr></table></figure><h3 id="3-提取数据-1"><a href="#3-提取数据-1" class="headerlink" title="3. 提取数据"></a>3. 提取数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH 游标名 INTO 主变量[,主变量，···];</span><br></pre></td></tr></table></figure><h3 id="4-关闭游标-1"><a href="#4-关闭游标-1" class="headerlink" title="4. 关闭游标"></a>4. 关闭游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE 游标名;</span><br></pre></td></tr></table></figure><h2 id="3-5-5-动态SQL语句"><a href="#3-5-5-动态SQL语句" class="headerlink" title="3.5.5 动态SQL语句"></a>3.5.5 动态SQL语句</h2><p>动态SQL技术主要有以下两个SQL语句；</p><p>1）动态SQL预备语句；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL PREPARE 动态 SQL 语句名 FROM 共享变量或字符串;</span><br></pre></td></tr></table></figure><p>2）动态SQL执行语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL EXECUTE 动态 SQL 语句名;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;标准SQL是非过程化的查询语言，具有操作统一，面向集合、功能丰富、使用简单等多项优点；&lt;/p&gt;
&lt;p&gt;但它的缺点在于——缺少流程控制能力，难以实现应用业务中的逻辑控制；所以引入了SQL编程；&lt;/p&gt;
&lt;h1 id=&quot;3-1-MySQL编程基础&quot;&gt;&lt;a href=&quot;#3-1-MySQL编程基础&quot; class=&quot;headerlink&quot; title=&quot;3.1 MySQL编程基础&quot;&gt;&lt;/a&gt;3.1 MySQL编程基础&lt;/h1&gt;&lt;p&gt;需要将频繁使用的业务逻辑封装成存储程序；&lt;/p&gt;
&lt;p&gt;MySQL提供了用于编写结构化程序的数据类型、常量、变量、运算符和表达式等；&lt;/p&gt;
&lt;h2 id=&quot;3-1-1-常量与变量&quot;&gt;&lt;a href=&quot;#3-1-1-常量与变量&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 常量与变量&quot;&gt;&lt;/a&gt;3.1.1 常量与变量&lt;/h2&gt;&lt;p&gt;程序本身不能改变的数据成为常量；程序运行中可以改变其值的数据成为变量；&lt;/p&gt;
&lt;h3 id=&quot;1-常量&quot;&gt;&lt;a href=&quot;#1-常量&quot; class=&quot;headerlink&quot; title=&quot;1. 常量&quot;&gt;&lt;/a&gt;1. 常量&lt;/h3&gt;&lt;p&gt;常量的格式取决于其数据类型，常用的常量包括字符串常量、数值常量、日期和时间常量、布尔值常量和&lt;code&gt;NULL&lt;/code&gt;值；&lt;/p&gt;
&lt;p&gt;1）字符串常量&lt;/p&gt;
&lt;p&gt;​    用单引号与双引号括起来的字符序列。推荐使用单引号；&lt;/p&gt;
&lt;p&gt;2）数值常量&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库原理及应用" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="数据库基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>第二章 关系数据库标准语言 SQL</title>
    <link href="http://yoursite.com/2020/10/24/database-principle-and-application-chapter-02/"/>
    <id>http://yoursite.com/2020/10/24/database-principle-and-application-chapter-02/</id>
    <published>2020-10-24T07:01:21.000Z</published>
    <updated>2020-10-24T07:13:58.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-SQL语言介绍"><a href="#2-1-SQL语言介绍" class="headerlink" title="2.1 SQL语言介绍"></a>2.1 SQL语言介绍</h1><p>SQL（Structured Query Language）语言是一种在关系数据库中定义和操纵数据的标准语言，是用户与数据库之间进行交流的接口。</p><h2 id="2-1-1-SQL数据库的体系结构"><a href="#2-1-1-SQL数据库的体系结构" class="headerlink" title="2.1.1 SQL数据库的体系结构"></a>2.1.1 SQL数据库的体系结构</h2><p>SQL语言支持关系数据库的三级模式、二级映像的结构，二级映像保证了数据库的数据独立性；</p><p>SQL的关系数据库具有的特点：</p><ol><li>SQL用户可以是应用程序，也可以是终端用户。（嵌入应用程序中，也可以直接访问）</li><li>SQL用户可以用SQL语言对基本表和视图进行查询。</li><li>一个视图是从若干基本表或其他视图上导出的表。在数据库中只存放该视图的定义，不存放该视图所对应的数据。数据都是来自于基本表。视图是一个虚表；</li><li>一个或一些基本表对应一个数据文件<ul><li>一个基本表也可以放在若干数据文件中。</li><li>一个数据文件对应存储设备上的一个存储文件；</li></ul></li><li>一个基本表可以带若干索引。索引也放在数据文件中。</li><li>一个表空间可以由若干数据文件组成；</li><li>一个数据库可以由多个存储文件组成；</li></ol><a id="more"></a><p><img src="/.com//image-20201016162050404.png" alt="image-20201016162050404"></p><h2 id="2-1-2-SQL的特点"><a href="#2-1-2-SQL的特点" class="headerlink" title="2.1.2 SQL的特点"></a>2.1.2 SQL的特点</h2><p>SQL语言是一个综合的、通用的、功能极强的同时简洁易学的语言；集数据定义、数据查询、数据操纵和数据控制于一体；</p><ol><li>综合统一：风格统一，可以完成数据生命周期中的全部活动。</li><li>高度非过程化：指示做什么，而与去做的过程无关；</li><li>面向集合的操作方式：一次操作得到若干记录；</li><li>同一种语法结构提供两种使用方式：SQL既可以是独立式语言，又是嵌入式语言；</li><li>语言简洁，易学易用</li></ol><div class="table-container"><table><thead><tr><th>Sql功能</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td>数据定义</td><td style="text-align:center">CREATE、DROP、ALTER</td></tr><tr><td>数据操纵</td><td style="text-align:center">INSERT、DELETE、UPDATE、SELECT</td></tr><tr><td>数据控制</td><td style="text-align:center">COMMIT、ROLLBACK、GRANT、REVOKE</td></tr></tbody></table></div><h2 id="2-1-3-SQL语言的组成"><a href="#2-1-3-SQL语言的组成" class="headerlink" title="2.1.3 SQL语言的组成"></a>2.1.3 SQL语言的组成</h2><h3 id="1-数据定义语言（DDL）"><a href="#1-数据定义语言（DDL）" class="headerlink" title="1. 数据定义语言（DDL）"></a>1. 数据定义语言（DDL）</h3><p>​    创建、修改、删除和重命名数据库（CREATE、DROP、ALTER、RENAME）；还有删除表中所有行，但不删除表（TRUNCATE）</p><h3 id="2-数据操作语言（DML）"><a href="#2-数据操作语言（DML）" class="headerlink" title="2. 数据操作语言（DML）"></a>2. 数据操作语言（DML）</h3><p>​    增删改查现有数据行</p><h3 id="3-数据控制语言（DCL）"><a href="#3-数据控制语言（DCL）" class="headerlink" title="3. 数据控制语言（DCL）"></a>3. 数据控制语言（DCL）</h3><p>​    用于事务控制，并发控制，完整性和安全性控制等；</p><h1 id="2-2-数据定义"><a href="#2-2-数据定义" class="headerlink" title="2.2 数据定义"></a>2.2 数据定义</h1><p>SQL的数据定义包括数据库定义、表的定义、视图和索引的定义；</p><h2 id="2-2-1-数据库的定义和删除"><a href="#2-2-1-数据库的定义和删除" class="headerlink" title="2.2.1 数据库的定义和删除"></a>2.2.1 数据库的定义和删除</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>数据库名</span><br></pre></td></tr></table></figure><h3 id="2-选则数据库"><a href="#2-选则数据库" class="headerlink" title="2. 选则数据库"></a>2. 选则数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名</span><br></pre></td></tr></table></figure><h3 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名</span><br></pre></td></tr></table></figure><h2 id="2-2-2-数据类型"><a href="#2-2-2-数据类型" class="headerlink" title="2.2.2 数据类型"></a>2.2.2 数据类型</h2><p>Mysql支持的数据库类型主要分为4类，即<strong>字符串类型</strong>、<strong>数值类型</strong>、<strong>日期和时间类型</strong>，<strong>布尔类型</strong>。</p><h3 id="1-字符串类型"><a href="#1-字符串类型" class="headerlink" title="1. 字符串类型"></a>1. 字符串类型</h3><p>常用字符类型式<code>CHAR</code>, <code>VARCHAR</code>类型</p><ul><li><code>CHAR</code>：描述定长的字符串，说明格式的语法为：<code>CHAR(L)</code>；L表示字符串最大长度，取值范围为 1 ~ 255；比L大截断，小了补空格填补；</li><li><code>VARCHAR</code>：描述变长的字符串，说明格式为：<code>VARCHAR(L)</code>；L表示字符串长度，取值范围为 1 ~ 255；比L大截断，<strong>小了不会用空格填补，按实际长度存储</strong>；</li></ul><p>​    字符串要用单引号或双引号括起来；</p><h3 id="2-数值类型"><a href="#2-数值类型" class="headerlink" title="2. 数值类型"></a>2. 数值类型</h3><p>常用数值类型是<code>INT</code>,<code>DECIMAL</code>类型</p><ul><li><code>INT</code>：表示整数，存储长度默认为4个字节。说明格式为<code>INT</code>;</li><li><code>DECIMAL</code>：用来表示所有的数值数据，说明格式为<code>DECIMAL(p,s)</code>，<code>p</code>表示数值数据的最大长度， <code>s</code>表示数值数据中小数点后的数组位数，<code>p</code>，<code>s</code>在定义时可以省略；</li></ul><h3 id="3-日期和时间类型"><a href="#3-日期和时间类型" class="headerlink" title="3. 日期和时间类型"></a>3. 日期和时间类型</h3><p>常用的日期和时间类型时<code>DATA</code>，<code>TIME</code>，<code>DATETIME</code>类型</p><ul><li><code>DATE</code>：用来保存固定长度的日期数据，说明格式为<code>DATE</code>; 日期值格式为<code>YYYY-MM-DD</code>;</li><li><code>TIME</code>：保存固定长度的时间数据，说明格式为<code>TIME</code>；时间值格式为<code>HH:MM:SS</code>;</li><li><code>DATETIME</code>：保存固定长度的日期时间数据，说明格式为<code>DATETIME</code>；日期时间值格式为<code>YYYY-MM-DD HH:MM:SS</code>；</li></ul><h3 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4. 布尔类型"></a>4. 布尔类型</h3><p>布尔类型<code>BOOLEAN</code>类型只有两个值——<code>TRUE</code>和<code>FALSE</code>，即真值和假值；</p><h2 id="2-2-3-基本表的定义、删除和修改"><a href="#2-2-3-基本表的定义、删除和修改" class="headerlink" title="2.2.3 基本表的定义、删除和修改"></a>2.2.3 基本表的定义、删除和修改</h2><p>表是数据库存储数据的基本单元；</p><p>表中存储数据的逻辑结构是一张二维表，即表由行、列两部分组成。</p><p>称表中的一行 为  一条记录；</p><p>称表中的一列 为 一个属性；</p><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h3><pre class="mermaid">graph TDA[创建表] -->B(定义表的结构)B -->C[表名]B -->D[各个列]D -->E[列名]D -->F[列的数据类型]D -->H[列上的约束]B -->G[表上的约束]</pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">(</span><br><span class="line">&lt;列明&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span>&lt;默认值&gt;]</span><br><span class="line">[,···]</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><p><strong>TIP</strong>：</p><ol><li>使用 <code>DESC</code> 显示表的结构</li><li>设置了自增类型的字段，需将其设置为主键，否则创建失败。</li><li>表明日期时间可用当下系统时间补充，用<code>CURRENT_TIMESTAMP</code>;</li></ol><h3 id="2-利用子查询来创建表"><a href="#2-利用子查询来创建表" class="headerlink" title="2. 利用子查询来创建表"></a>2. 利用子查询来创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">SELECT</span> 语法；</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_c</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept；</span><br></pre></td></tr></table></figure><h3 id="3-修改表的结构"><a href="#3-修改表的结构" class="headerlink" title="3. 修改表的结构"></a>3. 修改表的结构</h3><p>对表的修改包括：增加新的列，删除原有的列或修改列的数据类型，宽度等；</p><p>​    1）增加一个新列    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] &lt;列名&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span> &lt;默认值&gt;];</span><br></pre></td></tr></table></figure><p>一次只能增加一个新列</p><p>​    2）修改一个表中已有的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  MOIFY [<span class="keyword">COLUMN</span>] &lt;列名&gt; &lt;数据类型&gt; [<span class="keyword">DEFAULT</span> &lt;默认值&gt;];</span><br></pre></td></tr></table></figure><p>​    3）从一个表中删除一列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">  <span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] &lt;列名&gt;；</span><br></pre></td></tr></table></figure><h3 id="4-截断表和删除表"><a href="#4-截断表和删除表" class="headerlink" title="4. 截断表和删除表"></a>4. 截断表和删除表</h3><p>​    1）截断表：删除数据保留表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure><p>​    2）删除表：删除数据和表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure><h1 id="2-3-数据查询"><a href="#2-3-数据查询" class="headerlink" title="2.3 数据查询"></a>2.3 数据查询</h1><p><code>SELECT</code>语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * | &lt;列名 | 列表达式&gt;[,&lt;列名 | 列表达式&gt;]···</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt;]···</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组列名<span class="number">1</span>&gt;[,&lt;分组列名<span class="number">2</span>&gt;]]···</span><br><span class="line">[ <span class="keyword">HAVING</span> &lt;组条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序列名<span class="number">1</span> [ <span class="keyword">ASC</span>| <span class="keyword">DESC</span> ]&gt;[,&lt;排序列名<span class="number">2</span> [ <span class="keyword">ASC</span>| <span class="keyword">DESC</span> ]&gt;]···];</span><br></pre></td></tr></table></figure><p><code>[]</code>表示该部分可选；<code>&lt;&gt;</code>表示该部分必有。</p><p>执行过程如下</p><ol><li>读取<code>FROM</code>子句中的表、视图的数据，如果是多个表或视图，执行笛卡尔积操作；</li><li>选择满足<code>WHERE</code>子句中给出的条件表达式的记录；</li><li>按<code>GROUP BY</code>子句中指定列的值对记录进行分组，同时提取满足HAVING子句中组条件表达式的那些组；</li><li>按<code>SELECT</code>子句中给出的列名或列表达式求值输出；</li><li><code>ORDER BY</code>子句对输出的记录进行排序；</li></ol><h2 id="2-3-1-基本查询"><a href="#2-3-1-基本查询" class="headerlink" title="2.3.1 基本查询"></a>2.3.1 基本查询</h2><h3 id="1-SELECT子句的规定"><a href="#1-SELECT子句的规定" class="headerlink" title="1. SELECT子句的规定"></a>1. SELECT子句的规定</h3><p><code>SELECT</code>子句用于描述输出值的列明或表达式；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ <span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span> ] * | &lt;列名或列名表达式&gt;</span><br></pre></td></tr></table></figure><p><code>DISTINCT</code>：表示输出无重复结果的记录； <code>ALL</code>：选项是默认的表示输出所有记录，包括重复记录</p><p>1）查询所有列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure><p>2）查询指定的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, dname <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure><p>3）去掉重复的行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><p>上面的这个语句会把所有的输出出来，有重复的行值出现，需要去掉重复的记录，则可以用下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> deptno, job <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><h3 id="2-为列起别名的操作"><a href="#2-为列起别名的操作" class="headerlink" title="2. 为列起别名的操作"></a>2. 为列起别名的操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原字段名 [AS] 列别名</span><br></pre></td></tr></table></figure><h3 id="3-使用WHERE子句指定查询条件"><a href="#3-使用WHERE子句指定查询条件" class="headerlink" title="3. 使用WHERE子句指定查询条件"></a>3. 使用WHERE子句指定查询条件</h3><p><code>WHERE</code>子句后的行表达式可以由运算符组合而成，常用的比较运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符名称</th><th style="text-align:center">符号及格式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">算术比较判断</td><td style="text-align:center"><code>&lt;、&lt;=、&gt;、&gt;=、&lt;&gt;、!=、=</code></td><td style="text-align:center">比较两个表达式的值</td></tr><tr><td style="text-align:center">逻辑比较判断</td><td style="text-align:center"><code>NOT、AND、OR</code></td><td style="text-align:center">非与或操作（优先级高低排序）</td></tr><tr><td style="text-align:center">之间判断</td><td style="text-align:center"><code>&lt;表达式&gt;[ NOT ] BETWEEN &lt;值1&gt; AND &lt;值2&gt;</code></td><td style="text-align:center">搜索（不）在指定范围里的值</td></tr><tr><td style="text-align:center">字符串模糊判$断^1$</td><td style="text-align:center"><code>&lt;字符串&gt; [ NOT ] LIKE &lt;匹配模式&gt;</code></td><td style="text-align:center">查找（不）在给定模式的值</td></tr><tr><td style="text-align:center">空值判断</td><td style="text-align:center"><code>&lt;表达式&gt; IS [ NOT ] NULL</code></td><td style="text-align:center">判断是否为空值</td></tr><tr><td style="text-align:center">之内判断</td><td style="text-align:center"><code>&lt;表达式&gt; [ NOT ] IN (&lt;集合&gt;)</code></td><td style="text-align:center">判断表示式的值是否在集合内</td></tr></tbody></table></div><p>模糊判断匹配字符串模式使用通配符 <code>%</code> 和 <code>_</code> 。<code>%</code>用于表示0个或任意多个字符，<code>_</code>表示任意一个字符；</p><h3 id="4-使用ORDER-BY子句对查询结果排序"><a href="#4-使用ORDER-BY子句对查询结果排序" class="headerlink" title="4. 使用ORDER BY子句对查询结果排序"></a>4. 使用ORDER BY子句对查询结果排序</h3><p>使用<code>ORDER BY</code>子句对查询结果进行排序时要注意一下两点：</p><p>（1）当<code>SELECT</code>语句中包含多个子句时，<code>ORDER BY</code> 必须是最后一个；</p><p>（2）可以使用列的别名、列的位置（SELECT子句中的顺序）进行排序；</p><h2 id="2-3-2-分组查询"><a href="#2-3-2-分组查询" class="headerlink" title="2.3.2 分组查询"></a>2.3.2 分组查询</h2><p>数据分组市容过在<code>SELECT</code>语句中加入<code>GROUP BY</code>子句完成的。通常用聚合函数对每个组的数据进行汇总、统计；用 <code>HAVING</code> 子句来限定查询结果集中只显示分组后的、其聚合函数的值满足指定条件的那些组；</p><h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>COUNT(*)</code> <code>COUNT(&lt;列名&gt;)</code></td><td style="text-align:center">记录的个数；对一列中的值计算个数</td></tr><tr><td style="text-align:center"><code>SUM(&lt;列名&gt;)</code></td><td style="text-align:center">求某一列的总和</td></tr><tr><td style="text-align:center"><code>AVG(&lt;列名&gt;)</code></td><td style="text-align:center">求某一列的平均值</td></tr><tr><td style="text-align:center"><code>MAX(&lt;列名&gt;)</code></td><td style="text-align:center">求某一列的最大值</td></tr><tr><td style="text-align:center"><code>MIN()</code></td><td style="text-align:center">求某一列的最小值</td></tr></tbody></table></div><p>使用聚合函数要注意的点：</p><p>（1）聚合函数只能出现在所查询的列、<code>ORDER BY</code>子句、<code>HAVING</code>子句中，不能出现在<code>WHERE</code>子句、<code>GROUP BY</code>子句中。</p><p>（2）除了<code>COUNT(*)</code>之外，其他聚合函数都忽略对列值为<code>NULL</code>的统计；</p><h3 id="2-使用GROUP-BY子句"><a href="#2-使用GROUP-BY子句" class="headerlink" title="2. 使用GROUP BY子句"></a>2. 使用GROUP BY子句</h3><p>1）按单列分组</p><p>【例】查询emp表中每个部门的平均工资和最高工资，按部门编号升序排列；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资，<span class="keyword">MAX</span>(sal) 最高工资 <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno；</span><br></pre></td></tr></table></figure><p>2）按多列分组</p><p>【例】查询emp表中每个部门、每种岗位的平均工资和最高工资；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资，<span class="keyword">MAX</span>(sal) 最高工资 <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno, job</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> deptno；</span><br></pre></td></tr></table></figure><h3 id="3-使用HAVING子句"><a href="#3-使用HAVING子句" class="headerlink" title="3. 使用HAVING子句"></a>3. 使用HAVING子句</h3><p>【例】查询部门编号在30以下的各个部门的部门编号、平均工资，要求只显示平均工资大于等于2000的信息；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">AVG</span>(sal) 平均工资 <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno&lt;<span class="number">30</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sal)&gt;=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-3-连接查询"><a href="#2-3-3-连接查询" class="headerlink" title="2.3.3 连接查询"></a>2.3.3 连接查询</h2><p>连接查询是指对两个或两个以上的表或视图的查询。连接查询是关系数据库中最主要、最有意义的查询，是关系数据库的一项核心功能；</p><p>MySql提供了4种类型的连接，即<strong>相等连接</strong>、<strong>自身连接</strong>、<strong>不等连接</strong>和<strong>外连接</strong>；</p><h3 id="1-相等连接"><a href="#1-相等连接" class="headerlink" title="1. 相等连接"></a>1. 相等连接</h3><p>也称为简单连接或内连接，是把两个表中指定列的值相等的行连接起来；</p><p>【例】查询工资大于等于3000的员工的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal, e.deptno, loc</span><br><span class="line"><span class="keyword">FROM</span> emp e, dept d</span><br><span class="line"><span class="keyword">WHERE</span> e.deptno = d.deptno</span><br><span class="line"><span class="keyword">AND</span> sal &gt;= <span class="number">3000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.deptno;</span><br></pre></td></tr></table></figure><p>可用ON子句来实现内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal, e.deptno, loc</span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno = d.deptno</span><br><span class="line"><span class="keyword">WHERE</span> sal &gt;= <span class="number">3000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.deptno;</span><br></pre></td></tr></table></figure><h3 id="2-自身连接"><a href="#2-自身连接" class="headerlink" title="2. 自身连接"></a>2. 自身连接</h3><p>是通过把一个表定义为两个不同别名的方法来完成自身连接的；</p><p>【例】一个雇员表，含有雇员编号，管理员编号。管理员也是雇员；所以这两列有参照关系；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename 雇员, m.ename 管理员</span><br><span class="line"><span class="keyword">FROM</span> emp e, emp m</span><br><span class="line"><span class="keyword">WHERE</span> m.empno = e.mgr</span><br><span class="line"><span class="keyword">AND</span> e.deptno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="3-不等连接"><a href="#3-不等连接" class="headerlink" title="3. 不等连接"></a>3. 不等连接</h3><p>用其他运算符产生的连接叫做不等连接；</p><h3 id="4-左外连接"><a href="#4-左外连接" class="headerlink" title="4. 左外连接"></a>4. 左外连接</h3><p>左外连接的格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM 表 1 LEFT OUTER JOIN 表 2 ON 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure><p>左外连接的结果是显示表1中的所有记录和表2中与表1.列相同的记录；</p><h3 id="5-右外连接"><a href="#5-右外连接" class="headerlink" title="5. 右外连接"></a>5. 右外连接</h3><p>右外连接的格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM 表1 RIGHT OUTER JOIN 表2 ON 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure><p>左外连接的结果是显示表2中的所有记录和表1中与表2.列相同的记录；</p><h2 id="2-3-4-子查询"><a href="#2-3-4-子查询" class="headerlink" title="2.3.4 子查询"></a>2.3.4 子查询</h2><p>子查询是指嵌入在其他SQL语句中的一个查询。最多可以嵌套255层；</p><p>使用子查询可以用一系列简单的查询构成复杂的查询，从而增强SQL语句的功能；</p><p><strong>执行步骤</strong></p><p>（1）首先取外层查询中表的第一个记录，根据它与内存查询相关列值进行内层查询的处理，若处理结果为真，则取此记录放入结果集。</p><p>（2）然后取外层表的下一个记录进行内层查询的处理</p><p>（3）重复这一过程，直到外层查询中表的全部记录处理完为止；</p><h3 id="1-返回单值的子查询"><a href="#1-返回单值的子查询" class="headerlink" title="1. 返回单值的子查询"></a>1. 返回单值的子查询</h3><p>单值子查询向外层查询值返回一个值；</p><h3 id="2-返回多值的子查询"><a href="#2-返回多值的子查询" class="headerlink" title="2. 返回多值的子查询"></a>2. 返回多值的子查询</h3><p>多值子查询可以向外层查询返回多个值；在WHERE子句中使用多值子查询时必须使用多值比较运算符，例如 <code>[not] IN</code>，<code>[not] EXISTS</code>，<code>ANY</code>，<code>ALL</code>，其中<code>ANY</code>，<code>ALL</code>必须与比较运算符结合使用；</p><p><strong>1）使用 IN 操作符的多值子查询</strong></p><p>比较运算符<code>IN</code>的含义为子查询返回列表中的任何一个。</p><p><code>IN</code>操作符比较子查询返回列表中的每一个值，并且显示任何相等的数据行；</p><p>【例】查询所在岗位工资最高的员工信息，不包括CLERK和PRESIDENT；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, sal <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> job)</span><br><span class="line"><span class="keyword">AND</span> job&lt;&gt;<span class="string">'CLERK'</span> <span class="keyword">AND</span> job&lt;&gt;<span class="string">'PRESIDENT'</span>;</span><br></pre></td></tr></table></figure><p>注：这个例子的答案是错误的；根据薪资不能成立某岗薪资最高员工的参照关系；</p><p>大约应该写成这样才是正确的，不过这已经失去了展示 IN 操作符的意义了；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, sal <span class="keyword">FROM</span> emp, (<span class="keyword">SELECT</span> job, <span class="keyword">MAX</span>(sal) <span class="keyword">as</span> MAXsal <span class="keyword">FROM</span> emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> job) <span class="keyword">as</span> M</span><br><span class="line"><span class="keyword">WHERE</span> job = M.job <span class="keyword">AND</span> sal = M.Maxsal</span><br><span class="line"><span class="keyword">AND</span> job&lt;&gt;<span class="string">'CLERK'</span> <span class="keyword">AND</span> job&lt;&gt;<span class="string">'PRESIDENT'</span>;</span><br></pre></td></tr></table></figure><p><strong>2）使用ALL操作符的多值子查询</strong></p><p><code>ALL</code>操作符比较子查询返回列表中的每一个值。 <code>&lt; ALL</code> 为小于最小的，  <code>&gt; ALL</code> 为大于最大的；</p><p>【例】查询高于部门20的所有雇员工资的雇员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal &gt; <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno = <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><strong>3）使用ANY操作符的多值子查询</strong></p><p><code>ANY</code>操作符比较子查询返回列表中的每一个值。 <code>&lt; ALL</code> 为小于最大的，  <code>&gt; ALL</code> 为大于最小的；</p><p>【例】查询高于部门20的任何雇员工资的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal &gt; <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno = <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>4）使用EXISTS操作符的多行查询</strong></p><p><code>EXISTS</code>操作符比较子查询返回列表中的每一个行。</p><p>使用 <code>EXISTS</code> 时应注意外层查询的 <code>WHERE</code> 子句格式为 <code>WHERE EXISTS</code>；  在内层子查询必须有<code>WHERE</code> 子句；</p><h2 id="2-3-5-合并查询结果"><a href="#2-3-5-合并查询结果" class="headerlink" title="2.3.5 合并查询结果"></a>2.3.5 合并查询结果</h2><p>当两个 <code>SELECT</code> 查询结果的结构完全一致时，可以对这两个查询执行合并运算，运算符为 <code>UNION</code>；</p><p><code>UNION</code> 的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 语句<span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> XXX;</span><br></pre></td></tr></table></figure><ul><li><p><code>UNION</code> 在连接数据表的查询结果时，结果会删除重复的行，返回的行都是唯一的；</p></li><li><p>在使用 <code>UNION ALL</code> 的时候，结果不会删除重复行；</p></li><li>对合并查询结果进行排序，要排序的列名一定是来自第一个表中的列名（即使是别名）；</li></ul><h1 id="2-4-数据的维护"><a href="#2-4-数据的维护" class="headerlink" title="2.4 数据的维护"></a>2.4 数据的维护</h1><p>数据维护是指用<code>INSERT</code>, <code>DELETE</code>，<code>UPDATE</code>语句来插入、删除、更新数据库表中记录行的数据，由DML语言实现；</p><h2 id="2-4-1-插入数据"><a href="#2-4-1-插入数据" class="headerlink" title="2.4.1 插入数据"></a>2.4.1 插入数据</h2><h3 id="1-INSERT语句"><a href="#1-INSERT语句" class="headerlink" title="1. INSERT语句"></a>1. INSERT语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 [ ( 列名<span class="number">1</span>[, 列名<span class="number">2</span>···]) ]</span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>[,值<span class="number">2</span>···])</span><br><span class="line">[,(值<span class="number">1</span>[,值<span class="number">2</span>···]),···,(值<span class="number">1</span>[,值<span class="number">2</span>···])]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>（1）插入数据时，列的个数、数据类型、顺序必须要和所提供数据的个数、数据类型，顺序保持一致或匹配；</p><p>（2）如果省略了表名后面列的列名表，即表示要为所有列插入数据，则必须根据表结构定义中的顺序为所有列提供数据，否则会出错；</p><p>【例】复制另一个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_c</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dept;</span><br></pre></td></tr></table></figure><p>【例】插入数据示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_c(deptno, dname, loc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">50</span>, <span class="string">'PERSONNEL'</span>, <span class="string">'HONGKONG'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_c</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">50</span>, <span class="string">'PERSONNEL'</span>, <span class="string">'HONGKONG'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-利用子查询向表中插入数据"><a href="#2-利用子查询向表中插入数据" class="headerlink" title="2. 利用子查询向表中插入数据"></a>2. 利用子查询向表中插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[ ( 列名<span class="number">1</span> [ ,列名<span class="number">2</span>··· ] ) ]</span><br><span class="line"><span class="keyword">SELECT</span> 语句;</span><br></pre></td></tr></table></figure><h2 id="2-4-2-更新数据"><a href="#2-4-2-更新数据" class="headerlink" title="2.4.2 更新数据"></a>2.4.2 更新数据</h2><h3 id="1-UPDATE语句"><a href="#1-UPDATE语句" class="headerlink" title="1. UPDATE语句"></a>1. UPDATE语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列名 = 值 [,列名=值,··· ]</span><br><span class="line">[ <span class="keyword">where</span> &lt;条件&gt; ];</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：如果不用<code>WHERE</code>子句先定要更新的数据行，则会更新整个表的数据行；</p><p><strong>注意</strong>：MySql运行在 <code>SAFE_UPDATES</code> 模式下，该模式会导致在非主键条件下无法执行 <code>UPDATE</code> 或 <code>DELETE</code> 命令，需要执行 <code>SET SAFE_UPDATES = 0</code> 修改数据库模式；</p><p>【例】更新 dept_c 表中部门10的地址为 <code>CHINA</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SAFE_UPDATES = <span class="number">0</span></span><br><span class="line"><span class="keyword">UPDATE</span> dept_c</span><br><span class="line"><span class="keyword">SET</span> loc = <span class="string">'CHINA'</span></span><br><span class="line"><span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>【例】将 dept_c 表中所有部门的地址改为 <code>CHICAGO</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE dept_c</span><br><span class="line">SET loc &#x3D; &#39;CHICAGO&#39;;</span><br></pre></td></tr></table></figure><h3 id="2-利用子查询修改记录"><a href="#2-利用子查询修改记录" class="headerlink" title="2. 利用子查询修改记录"></a>2. 利用子查询修改记录</h3><p>【例】更新部门40的部门名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dept_c</span><br><span class="line"><span class="keyword">SET</span> dname = (<span class="keyword">SELECT</span> dname <span class="keyword">FROM</span> dept <span class="keyword">WHERE</span> deptno=<span class="number">40</span>)</span><br><span class="line"><span class="keyword">WHERE</span> deptno = <span class="number">40</span>;</span><br></pre></td></tr></table></figure><h2 id="2-4-3-删除数据"><a href="#2-4-3-删除数据" class="headerlink" title="2.4.3 删除数据"></a>2.4.3 删除数据</h2><h3 id="1-DELETE语句"><a href="#1-DELETE语句" class="headerlink" title="1. DELETE语句"></a>1. DELETE语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"> [ <span class="keyword">WHERE</span> &lt;条件&gt; ];</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>（1）DELETE 是按行删除数据，不是删除行中某些列的数据；</p><p>（2）如果不用WHERE子句限定要删除的数据行，则会删除整个表的数据行。</p><p>（也可以用截断表的语句实现，格式为 <code>TRUNCATE TABLE 表名</code> )</p><h3 id="2-利用子查询删除行"><a href="#2-利用子查询删除行" class="headerlink" title="2. 利用子查询删除行"></a>2. 利用子查询删除行</h3><h1 id="2-5-索引和视图"><a href="#2-5-索引和视图" class="headerlink" title="2.5 索引和视图"></a>2.5 索引和视图</h1><p><strong>索引</strong>可以帮助用户提高查询数据的效率，类似于书中的目录。</p><p><strong>视图</strong>是一张虚拟表，是基于一个或几个数据表生成的逻辑表；</p><h2 id="2-5-1-索引的创建与删除"><a href="#2-5-1-索引的创建与删除" class="headerlink" title="2.5.1 索引的创建与删除"></a>2.5.1 索引的创建与删除</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><p>创建索引有两种办法：</p><p>（1）系统自动建立：当用户在一个表上建立主键（PRIMARY KEY）或唯一（UNIQUE）约束时，系统会自动创建唯一索引（UNIQUE INDEX）；</p><p>（2）手工建立：用户在一个表中的一列或多列上用CREATE INDEX语句来创建非唯一索引（NONUNIQUE INDEX）。</p><p><strong>创建索引的语句格式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> ] <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名(列名[ ,列名 ]···);</span><br></pre></td></tr></table></figure><p>【例】为 emp_c 表按员工的名字建立索引，索引名为emp_ename_idx;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> emp_ename_idx</span><br><span class="line"><span class="keyword">ON</span> emp_c(ename);</span><br></pre></td></tr></table></figure><p>【例】为 emp_c 表按工作和工资建立索引，索引名为<code>emp_job_sal_idx</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> emp_job_sal_idx</span><br><span class="line"><span class="keyword">ON</span> emp_c(job,sal);</span><br></pre></td></tr></table></figure><p>索引名的命名一般采用 <code>表名_列名_idx</code> 方式；</p><h3 id="2-查看索引"><a href="#2-查看索引" class="headerlink" title="2. 查看索引"></a>2. 查看索引</h3><p>查看索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>【例】查看emp_c的索引信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> emp_c;</span><br></pre></td></tr></table></figure><h3 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3. 删除索引"></a>3. 删除索引</h3><p>当一个索引不再需要时，应该删除它；</p><p><strong>删除索引的语句格式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名</span><br></pre></td></tr></table></figure><h3 id="4-使用索引时应注意的问题"><a href="#4-使用索引时应注意的问题" class="headerlink" title="4. 使用索引时应注意的问题"></a>4. 使用索引时应注意的问题</h3><p>一条DML只要涉及到索引关键字，DBMS就得调整索引；</p><p>索引是需要消耗磁盘空间的；如果表很大，其索引消耗磁盘空间的量也会很大。</p><p>满足以下条件之一，<strong>就可以为该列建立索引</strong></p><p>（1）表上的 <code>INSERT</code> , <code>DELETE</code>， <code>UPDATE</code>操作较少；</p><p>（2）一列或多列经常出现在<code>WHERE</code>子句或连接条件中；</p><p>（3）一列或多列经常出现在 <code>GROUP BY</code> 或 <code>ORDER BY</code> 操作中；</p><p>（4）如果表很大，但大多数查询返回的数据量很少。因为如果返回数据量很大，就不如顺序地扫描这个表了；</p><p>（5）刺裂的取值范围很广，一般为随机分布；</p><p>（6）表中包含了大量的NULL值；</p><h2 id="2-5-2-视图"><a href="#2-5-2-视图" class="headerlink" title="2.5.2 视图"></a>2.5.2 视图</h2><p><strong>视图（View）</strong>是由 <code>SELECT</code> 子查询语句定义的一个逻辑表；只有定义没有数据，是一个“虚表”；</p><p>视图的使用和管理是可以被创建、更改和删除；</p><p>视图是查看和操作表中数据的一种方法。除了 <code>SELECT</code> 之外，视图在 <code>INSERT</code>、 <code>UPDATE</code>、<code>DELETE</code>方面受到某些限制；</p><h3 id="1-为什么建立视图"><a href="#1-为什么建立视图" class="headerlink" title="1. 为什么建立视图"></a>1. 为什么建立视图</h3><p>1）提供各种数据表现形式，隐藏数据的逻辑复杂性并简化查询语句；</p><p>​    可以使用各种不同的方式将基础表的数据展现在数据面前，以便符合用户的使用习惯；（比如提供多表查询视图。让用户在视图上操作，隐藏了多表数据的复杂逻辑，简化了用户查询语句）</p><p>2）提供某些安全性保证，简化用户权限管理</p><p>​    视图可以实现让不同的用户看见不同的列，从而保证某些敏感数据不被某些用户看到；可以面向视图的对象权限授予用户，简化用户的权限定义；</p><p>3）对重构数据库提供了一定的逻辑独立性</p><p>​    视图是数据库三级模式中外模式在具体 <code>DBMS</code> 中的体现；概念模式发生改变，外模式具有逻辑独立性；</p><h3 id="2-创建视图"><a href="#2-创建视图" class="headerlink" title="2. 创建视图"></a>2. 创建视图</h3><p>通过 <code>CREATE VIEW</code> 语句创建视图，创建视图的语句格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">VIEW</span> 视图名[ (别名 [ ,别名 ] ) ]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 语句</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：</p><p>（1）<code>OR REPLACE</code> : 创建的视图已存在，MySQL系统会重建这个视图。</p><p>（2）<strong>别名</strong> ：为视图所产生的列定义的列名</p><p>（3）<code>WITH CHECK OPTION</code> ： 所插入或修改的数据行必须满足视图所定义的约束条件；</p><p>（4）在子查询语句中不能包含 <code>ORDER BY</code> 子句</p><p>【例】创建带有 <code>WITH CHECK OPTION</code> 选项的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_dept</span><br><span class="line">  <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  <span class="keyword">WHERE</span> deptno = <span class="number">10</span></span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><p>这个条件的限制了只能插入<code>deptno</code>为10的；</p><h3 id="3-修改视图"><a href="#3-修改视图" class="headerlink" title="3. 修改视图"></a>3. 修改视图</h3><p>MySQL中可以通过 <code>CREATE OR REPLACE VIEW</code> 语句和 <code>ALTER</code>语句来修改视图；</p><p><code>CREATE OR REPLACE VIEW</code> 是用创建视图的语句将原来的视图覆盖掉；</p><p>【例】修改上一例中的视图。取消约束条件检查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> v_dept</span><br><span class="line">  <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  <span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>ALTER</code> 语句修改视图，语句格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名[ (别名 [ ,别名 ]···) ] </span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> 语句</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><p>【例】修改上上一例中的视图。取消约束条件检查</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> v_dept_chk</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno <span class="keyword">FROM</span> emp</span><br><span class="line">  <span class="keyword">WHERE</span> deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除视图"><a href="#4-删除视图" class="headerlink" title="4. 删除视图"></a>4. 删除视图</h3><p>使用 <code>DROP VIEW</code> 语句删除视图，删除视图对创建该视图的基础表或视图没有任何影响。其语句格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名 [, 视图,···]</span><br></pre></td></tr></table></figure><h3 id="5-使用视图进行DML操作"><a href="#5-使用视图进行DML操作" class="headerlink" title="5. 使用视图进行DML操作"></a>5. 使用视图进行DML操作</h3><p>用户通过视图对基本表中的数据进行 <code>DML</code> 的<code>UPDATE</code>、 <code>INSERT</code>、 <code>DELETE</code> 操作。</p><p>视图分为 <strong>简单视图</strong> 和 <strong>复杂视图</strong> 它们的区别如下：</p><p>1）简单视图</p><p>（1）数据是仅从一个表中提取的</p><p>（2）不包含函数和分组数据</p><p>（3）可以通过该视图进行DML操作</p><p>2）复杂视图</p><p>（1）数据是从多个表中提取的</p><p>（2）包含函数和分组数据</p><p>（3）不一定能够通过该视图进行DML操作</p><p>下面给出通过视图进行 DML 操作的规则</p><p>（1）可以在简单视图上执行 <code>DML</code> 操作</p><p>（2）如果在一个视图中包含了分组函数，<code>GROUP BY</code>子句，或 <code>DISTINCT</code>关键字，则不能通过该视图进行增删改操作；</p><p>（3）如果在一个视图中包含了由表达式组成的列，则不能通过该视图进行 <code>UPDATE</code>、<code>INSERT</code>操作</p><p>（4）如果在一个视图中没有包含引用表中那些不能为空的列，则不能通过该视图进行 <code>INSERT</code> 操作</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2-1-SQL语言介绍&quot;&gt;&lt;a href=&quot;#2-1-SQL语言介绍&quot; class=&quot;headerlink&quot; title=&quot;2.1 SQL语言介绍&quot;&gt;&lt;/a&gt;2.1 SQL语言介绍&lt;/h1&gt;&lt;p&gt;SQL（Structured Query Language）语言是一种在关系数据库中定义和操纵数据的标准语言，是用户与数据库之间进行交流的接口。&lt;/p&gt;
&lt;h2 id=&quot;2-1-1-SQL数据库的体系结构&quot;&gt;&lt;a href=&quot;#2-1-1-SQL数据库的体系结构&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 SQL数据库的体系结构&quot;&gt;&lt;/a&gt;2.1.1 SQL数据库的体系结构&lt;/h2&gt;&lt;p&gt;SQL语言支持关系数据库的三级模式、二级映像的结构，二级映像保证了数据库的数据独立性；&lt;/p&gt;
&lt;p&gt;SQL的关系数据库具有的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SQL用户可以是应用程序，也可以是终端用户。（嵌入应用程序中，也可以直接访问）&lt;/li&gt;
&lt;li&gt;SQL用户可以用SQL语言对基本表和视图进行查询。&lt;/li&gt;
&lt;li&gt;一个视图是从若干基本表或其他视图上导出的表。在数据库中只存放该视图的定义，不存放该视图所对应的数据。数据都是来自于基本表。视图是一个虚表；&lt;/li&gt;
&lt;li&gt;一个或一些基本表对应一个数据文件&lt;ul&gt;
&lt;li&gt;一个基本表也可以放在若干数据文件中。&lt;/li&gt;
&lt;li&gt;一个数据文件对应存储设备上的一个存储文件；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个基本表可以带若干索引。索引也放在数据文件中。&lt;/li&gt;
&lt;li&gt;一个表空间可以由若干数据文件组成；&lt;/li&gt;
&lt;li&gt;一个数据库可以由多个存储文件组成；&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库原理及应用" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="数据库基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-02-代码</title>
    <link href="http://yoursite.com/2020/10/19/zuoshen-basic-class-2-code/"/>
    <id>http://yoursite.com/2020/10/19/zuoshen-basic-class-2-code/</id>
    <published>2020-10-19T03:13:05.000Z</published>
    <updated>2020-12-11T10:00:09.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        swap(arr, l + (<span class="keyword">int</span>)(Math.random() * (r - l + <span class="number">1</span>)), r);   <span class="comment">// 随机找一个数作为分割的数字；</span></span><br><span class="line">        <span class="keyword">int</span>[] p = partition(arr,l, r);  <span class="comment">// 返回less部分后一位和more部分前一位组成的数组；</span></span><br><span class="line">        quickSort(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;    <span class="comment">// 荷兰国旗式的partition</span></span><br><span class="line">    <span class="keyword">int</span> less = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">            swap(arr, ++less, l++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;</span><br><span class="line">            swap(arr, --more, l);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">        swap(arr, index, (index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        largest = arr[index] &lt; arr[largest] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, index, largest);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || arr.length &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    quickSort(arr, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, arr.length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="排序" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="快速排序" scheme="http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>第一章 数据库系统的基本原理</title>
    <link href="http://yoursite.com/2020/10/09/database-principle-and-application-chapter-01/"/>
    <id>http://yoursite.com/2020/10/09/database-principle-and-application-chapter-01/</id>
    <published>2020-10-09T02:25:19.000Z</published>
    <updated>2020-10-09T02:32:03.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h1><h2 id="1-1-2-数据库系统的概念"><a href="#1-1-2-数据库系统的概念" class="headerlink" title="1.1.2 数据库系统的概念"></a>1.1.2 数据库系统的概念</h2><p>数据库的总目标就是使用户能有效且方便的管理和使用数据库数据。</p><h3 id="1-数据（Data）"><a href="#1-数据（Data）" class="headerlink" title="1. 数据（Data）"></a><strong>1. 数据</strong>（Data）</h3><p>数据是数据库存储的基本对象；描述现实世界中各种具体事务或抽象概念的、可存储并具有明确意义的符号记录。</p><h3 id="2-数据库（Database-DB）"><a href="#2-数据库（Database-DB）" class="headerlink" title="2. 数据库（Database. DB）"></a><strong>2. 数据库</strong>（Database. DB）</h3><p>数据库是长期存储在计算机内、有组织的、可共享的（1）<strong>大量数据的集合</strong>。数据库中的数据按一定的数据模型组织，描述和存储，具有（2）<strong>较小的冗余</strong>、（3）<strong>较高的数据独立性</strong>和（4）<strong>易扩展性</strong>。</p><h3 id="3-数据库管理系统（Database-Management-System，-DBMS）"><a href="#3-数据库管理系统（Database-Management-System，-DBMS）" class="headerlink" title="3. 数据库管理系统（Database Management System， DBMS）"></a><strong>3. 数据库管理系统</strong>（Database Management System， DBMS）</h3><p>数据库管理系统是数据库系统的核心；</p><p>它位于用户和操作系统之间的一层数据库管理软件；</p><p>它为用户或应用程序提供访问数据库的方法，包括数据库的（1）<strong>定义</strong>、（2）<strong>建立</strong>、（3）<strong>查询</strong>、（4）<strong>更新</strong>及各种数据控制等。</p><a id="more"></a><ul><li><p><strong>数据定义语言</strong></p><p>DBMS提供了数据定义语言（Data Definition Language， DDL）；</p><p>通过它可以定义：（1）数据对象（包括表，视图，索引，存储过程等）（2）数据的完整约束 等</p><p>​    数据的完整性约束主要有<strong>实体完整性</strong>、<strong>参照完整性</strong>和<strong>用户定义的完整性</strong>；</p></li><li><p><strong>数据操纵语言</strong></p><p>DBMS提供了数据操纵语言（Data Manipulation Language，DML），用户可以通过它对数据库数据进行增加，删除，修改和查询操作，简称为“增删改查”；</p></li><li><p><strong>数据控制语言</strong></p><p>DBMS提供了数据控制语言（Data Control Language， DCL）</p><p>（1）用户可以通过它完成对用户访问权限的授予和撤销，即安全性控制；</p><p>（2）解决多用户对数据库的并发使用所产生的事务处理问题，即并发控制；</p><p>（3）数据库的转储，恢复功能；</p><p>（4）数据库的性能监视、分析功能；</p></li><li><p>数据的组织、存储和管理</p><p>DBMS要分类组织、存储和管理各种数据；确定以何种存储方式存储数据，以何种方法来提取存取效率；这些都要由DBMS来自动实现；</p></li></ul><h3 id="4-数据库系统（DataBase-System，DBS）"><a href="#4-数据库系统（DataBase-System，DBS）" class="headerlink" title="4. 数据库系统（DataBase System，DBS）"></a>4. 数据库系统（DataBase System，DBS）</h3><p>​    数据库系统是指在计算机系统中引入数据库后的系统，一般由数据库（DB）、数据库管理系统、应用系统和数据库管理员构成；</p><h3 id="5-数据库应用系统（DataBase-Application-System，DBAS）"><a href="#5-数据库应用系统（DataBase-Application-System，DBAS）" class="headerlink" title="5. 数据库应用系统（DataBase Application System，DBAS）"></a>5. 数据库应用系统（DataBase Application System，DBAS）</h3><p>数据库应用系统主要是指实现业务逻辑的应用程序；</p><h2 id="1-1-3-数据管理技术的发展阶段"><a href="#1-1-3-数据管理技术的发展阶段" class="headerlink" title="1.1.3 数据管理技术的发展阶段"></a>1.1.3 数据管理技术的发展阶段</h2><p>数据管理技术的发展经历了人工管理、文件管理系统、数据库系统和高级数据库系统4个阶段。</p><h3 id="1-人工发展阶段"><a href="#1-人工发展阶段" class="headerlink" title="1. 人工发展阶段"></a>1. 人工发展阶段</h3><p>这阶段计算机主要用于科学计算。外存储器只有磁带、卡片和纸袋等；软件只有汇编语言；数据处理方式基本上是批处理。具有的特点：</p><p>1）数据不保存</p><p>2）数据不具有独立性（数据与程序没有解耦合）</p><p>3）数据不共享：数据是面向程序的；</p><p>4）只有程序的概念，没有文件的概念；</p><h3 id="2-文件管理系统阶段"><a href="#2-文件管理系统阶段" class="headerlink" title="2. 文件管理系统阶段"></a>2. 文件管理系统阶段</h3><p>这一阶段，计算机不仅仅用于科学计算，还用于信息管理。</p><p>也已经有了外存储器，可以进行长期保存。</p><p>软件方面有了操作系统进行文件管理；</p><p>数据处理方式不仅有批处理还有联机实时处理；</p><p>这个阶段，数据被存储在不同的文件中，程序开发人员需要编写不同的应用程序将记录从不同的文件中提取出来进行访问，或者将记录加入到相应的文件中。</p><p><strong>文件管理系统阶段存储、组织信息的主要弊端如下：</strong></p><p>1）数据的冗余和不一致</p><p>​        相同信息可能在多个文件中重复存储，并且可能出些不一致的情况    </p><p>2）数据独立性差</p><p>​        数据与程序之间存在关联。通常是一个程序管理一份数据文件，而难以再扩充功能。</p><p>3）数据孤立</p><p>​        这些数据分散在不同的文件中，文件又可能具有不同的格式，所以编写新应用程序检索多个文件中的数据是很困难的；</p><h3 id="3-数据库系统阶段"><a href="#3-数据库系统阶段" class="headerlink" title="3. 数据库系统阶段"></a>3. 数据库系统阶段</h3><p><strong>数据库系统的特点</strong></p><ol><li><p>数据结构化</p><p>数据库系统中实现了整体数据的结构化，即不仅要考虑某个应用的数据结构，还要考虑整个组织的数据结构，而且数据之间时具有联系的；比如：学生数据的组织不仅仅只是面向教务处的学生选课系统，而是应该面向各个与学生相关的部门的不同应用；</p></li><li><p>数据的共享性高，冗余度低，易扩充</p><p>数据库系统是从整体角度来看待和描述数据的，数据可以被多个用户、多个应用共享使用。</p><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还可以避免数据之间的不一致性问题；</p><p>并且数据是面向系统的，可以很容易的增加新应用。</p></li><li><p>数据独立性高</p><p>数据独立性是指应用程序与数据库的数据结构之间相互独立，其包括物理独立性和逻辑独立性；</p><p><strong>物理独立性</strong> 指当数据的<strong>物理结构</strong>改变时尽量不影响<strong>整体逻辑结构</strong>及<strong>应用程序</strong>；</p><p><strong>逻辑独立性</strong> 指当数据的<strong>整体逻辑结构</strong>改变时尽量不影响<strong>应用程序</strong>，这样就认为数据库达到了逻辑独立性；</p><p>数据和程序的独立把数据的定义从程序中分离出来，加上存取数据的方法由DBMS负责提供；</p></li><li><p>数据由DBMS统一管理和控制</p><p>数据库中数据的共享使得DBMS必须提供以下数据控制功能</p><ul><li><strong>数据的完整性检查</strong>：数据的完整性指数据的<strong>正确性</strong>、<strong>有效性</strong>和<strong>相容性</strong>。把数据控制在有效的范围内，保证数据之间满足一定的关系；</li><li><strong>并发控制</strong>：多个用户同时操作数据时可能会相互干扰而得到错误结果；因此对多用户的并发擦破做加以控制和协调。</li><li><strong>数据的安全性保护</strong>：数据库安全性是防止不合法的使用造成数据的泄露和破坏，使每个用户只能按规定对某些数据以某些方式进行使用和处理；</li><li><strong>数据库的恢复</strong>：DBMS提供了数据的备份和恢复功能，可将数据库从错误状态恢复到某一已知的正确状态；</li></ul></li></ol><h2 id="1-1-4-数据库系统的用户"><a href="#1-1-4-数据库系统的用户" class="headerlink" title="1.1.4 数据库系统的用户"></a>1.1.4 数据库系统的用户</h2><h3 id="1-数据库管理员（Database-Administrator-DBA）"><a href="#1-数据库管理员（Database-Administrator-DBA）" class="headerlink" title="1. 数据库管理员（Database Administrator,DBA）"></a>1. 数据库管理员（Database Administrator,DBA）</h3><p>职责如下：</p><ol><li><p>参与数据库的设计</p></li><li><p>定义数据的安全性要求和完整性约束条件</p></li><li><p>日常维护</p><ul><li>定期备份数据库</li><li>监视数据库运行</li><li>确保正常运行所需的空余磁盘空间，并且需要时升级磁盘空间；</li></ul></li><li><p>数据库的改进和重组、重构</p><ul><li>监视系统与性期间的各个性能指标，对运行情况进行记录、统计分析，不断改进数据库设计</li><li>数据库运行过程中，大量数据不断插入、删除和修改，时间一长，会影响系统的性能。因此DBA要定期对数据库进行重组，以提高系统性能；</li><li>当用户需求增加或改变时，要对数据库进行较大改造，包括修改部分设计，即进行数据库的重构；</li></ul></li></ol><h3 id="2-数据库用户"><a href="#2-数据库用户" class="headerlink" title="2. 数据库用户"></a>2. 数据库用户</h3><p>根据工作性质及人员的技能把数据库用户分为四类：</p><ol><li>最终用户</li><li>专业用户</li><li>系统分析员和数据库设计人员</li><li>应用程序员</li></ol><h1 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h1><p>在数据库技术中，用数据模型的概念来描述数据库的结构和语义，对现实世界的数据进行抽象；</p><h2 id="1-2-1-数据抽象过程"><a href="#1-2-1-数据抽象过程" class="headerlink" title="1.2.1 数据抽象过程"></a>1.2.1 数据抽象过程</h2><p>根据数据抽象的级别定义了4种模型，即<strong>概念模型</strong>、<strong>逻辑模型</strong>，<strong>外部模型</strong>和<strong>内部模型</strong></p><p><strong>概念模型</strong> 是表达用户需求观点的数据库全局逻辑结构的模型；</p><p><strong>逻辑模型</strong> 是表达计算机实现观点的数据库全局逻辑结构的模型；</p><p><strong>外部模型</strong> 是表达用户使用观点的数据库局部逻辑结构的模型；</p><p><strong>内部模型</strong> 是表达数据库物理结构的模型</p><p><img src="/.com//940167-20180116172511756-1457166920.png" alt="数据库系统的基本概念（第一章）-----数据抽象的级别"></p><p>数据抽象的过程即数据库设计的过程：</p><p><strong>step - 1</strong>：根据用户需求设计数据库的概念模型，这是”综合“的过程；</p><p><strong>step - 2</strong>：根据转换规则把概念模型转换成数据库的逻辑模型，这是一个”转换“的过程；</p><p><strong>step - 3</strong>：根据用户的业务特点设计不同的外部模型，给应用程序使用。</p><p><strong>step - 4</strong>：实现数据库式，要根据逻辑模型设计其内部模型； </p><h3 id="1-概念模型"><a href="#1-概念模型" class="headerlink" title="1. 概念模型"></a>1. 概念模型</h3><p>抽象的最高级别；</p><p><strong>概念模型的特点：</strong></p><blockquote><ol><li>概念模型表达了数据库的整体逻辑结构，是<strong>实体管理人员</strong>面对实体的全面描述；</li><li>概念模型是从用户需求的观点出发对数据建模；</li><li>概念模型独立于软件和硬件；</li><li>概念模型是数据库设计人员和用户之间进行交流的工具</li></ol></blockquote><p>概念模型主要采用的是 <strong>实体-联系模型</strong>，即<strong>E-R模型</strong>。</p><p><strong>实体</strong>是客观世界可以相互区别的对象，这种对象可以是具体的，也可以是抽象的；</p><p><strong>联系</strong>是两个或多个实体之间的关联。两个实体之间的联系可以分为三种：一对一(1:1)，一对多(1:n)，多对多（n:m）；</p><h3 id="2-逻辑模型"><a href="#2-逻辑模型" class="headerlink" title="2. 逻辑模型"></a>2. 逻辑模型</h3><p>选定DBMS后，就要将概念模型按照选定的DBMS的特点转换成逻辑模型；</p><p><strong>逻辑模型的特点：</strong></p><blockquote><ol><li>逻辑模型表达了数据库的整体逻辑结构，是<strong>设计人员</strong>面对实体数据库的全面描述；</li><li>逻辑模型是从数据库实现的观点出发对数据建模；</li><li><p>逻辑模型硬件独立，但软件依赖；</p></li><li><p>逻辑模型是数据库设计人员和应用程序员之进行交流的工具；</p></li></ol></blockquote><p>逻辑模型有三种：<strong>层次模型</strong>，<strong>网状模型</strong>，<strong>关系模型</strong>；</p><p><strong>层次模型</strong>的数据结构是树状结构；</p><p><strong>网状模型</strong>的数据结构是有向图；</p><p><strong>关系模型</strong>采用二维表格存储数据；</p><h3 id="3-外部模型"><a href="#3-外部模型" class="headerlink" title="3. 外部模型"></a>3. 外部模型</h3><p>根据不同业务特点，可以分别设计不同的外部模型；</p><p><strong>外部模型的特点</strong>：</p><blockquote><ol><li>外部模型是逻辑模型的一个逻辑子集；</li><li>硬件独立，软件依赖；</li><li>外部模型反映了用户使用数据库的特点；</li></ol></blockquote><p>从整个系统考查，外部模型具有下列特点：</p><blockquote><ol><li>简化了用户的观点；外部模型是根据应用需要设计的，无关数据不放入，使用户更为简便的使用数据库；</li><li>有助于数据库的安全保护；无关数据不会放入，保证了数据安全；</li><li>外部模型是对概念模型的支持；</li></ol></blockquote><h3 id="4-内部模型"><a href="#4-内部模型" class="headerlink" title="4. 内部模型"></a>4. 内部模型</h3><p>内部模型又称为物理模型，是数据库最底层的抽象，它描述数据在磁盘上的存储方式、存取设备和存取方式。</p><p>内部模型是与硬件和软件紧密相连的。但目前的计算机系统的发展使得人们不必考虑内部级的设计细节，由系统自动实现；</p><h2 id="1-2-2-关系模型"><a href="#1-2-2-关系模型" class="headerlink" title="1.2.2 关系模型"></a>1.2.2 关系模型</h2><h3 id="1-数据模型的三要素"><a href="#1-数据模型的三要素" class="headerlink" title="1. 数据模型的三要素"></a>1. 数据模型的三要素</h3><p>数据模型是数据库概念的核心和基础，精确的描述了系统的静态特性、动态特性和完整性约束条件；</p><p>数据模型通常由<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>数据完整性约束</strong>3个部分组成；</p><ol><li><p>数据结构</p><p>常见的数据模型有<strong>层次模型</strong>、<strong>网状模型</strong>和<strong>关系模型</strong>，关系模型占统治地位；</p><p>数据结构是所描述的对象类型的集合，是对<strong>系统静态特性</strong>的描述；</p></li><li><p>数据操作</p><p>是对数据库表中记录的值允许执行的操作集合，包括操作及有关的操作规则。</p><p>数据库对数据操作主要有增删改查4种操作；数据模型必须定义这些操作的含义，符号，操作规则及实现语言；</p><p>数据操作是对<strong>系统动态特性</strong>的描述；</p></li><li><p>数据的完整性约束</p><p>完整性规则是给定的数据模型种数据及其联系所具有的制约和依存规则，用于限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容；</p><p>在关系模型中，任何关系都必须满足实体完整性和参照完整性；</p></li></ol><h3 id="2-关系数据模型的数据结构"><a href="#2-关系数据模型的数据结构" class="headerlink" title="2. 关系数据模型的数据结构"></a>2. 关系数据模型的数据结构</h3><p>关系模型中的一些术语：</p><ol><li><p>关系（Relation）</p><p>一个关系就是一张规范的二维表；一个规范化的关系必须满足的最基本的一条是关系的每一列不可再分；</p></li><li><p>元组（Tuple)</p><p>表中的一行即为一个元组；</p></li><li><p>属性（Attribute）</p><p>表中的一列即为一个属性；</p></li><li><p>码（Key）</p><p>码也称为关键字或关键码；</p><p>表中的某个属性或者属性的组合能唯一的确定一个元组，那么这个属性或者属性的组合就成为码；</p><p>在一个关系中可以有多个码；</p></li><li><p>关系模式</p><p>对关系的描述一般表示为：</p><blockquote><p>关系名（属性1，属性2，属性3，… ,属性n）</p></blockquote></li></ol><h3 id="3-关系数据模型的操作与完整性约束"><a href="#3-关系数据模型的操作与完整性约束" class="headerlink" title="3. 关系数据模型的操作与完整性约束"></a>3. 关系数据模型的操作与完整性约束</h3><p>关系数据模型的操作主要包括查询、插入、删除和更新数据。这些操作必须满足关系的完整性约束条件；</p><h1 id="1-3-数据库体系结构"><a href="#1-3-数据库体系结构" class="headerlink" title="1.3 数据库体系结构"></a>1.3 数据库体系结构</h1><p>数据库系统的设计目标是允许用户逻辑地处理数据，而不涉及数据在计算机内部的存储，在数据组织和用户应用之间提供某种程度的独立性；</p><h2 id="1-3-1-数据库系统的三级结构"><a href="#1-3-1-数据库系统的三级结构" class="headerlink" title="1.3.1 数据库系统的三级结构"></a>1.3.1 数据库系统的三级结构</h2><p><img src="/.com//672567-20180825135457384-1547424591.png" alt="数据库技术丛书:SQ"></p><p>数据库分为3个抽象级，用户级，概念级和物理级；</p><h3 id="1-用户级数据库"><a href="#1-用户级数据库" class="headerlink" title="1. 用户级数据库"></a>1. 用户级数据库</h3><p>用户级对应于外模式，是用户看到和使用的数据库；</p><h3 id="2-概念级数据库"><a href="#2-概念级数据库" class="headerlink" title="2. 概念级数据库"></a>2. 概念级数据库</h3><p>概念级数据库对应于概念模式。介于用户级和物理级之间，是数据库管理员看到和管理的数据库，又称为DBA视图；</p><p>概念级模式把用户视图有机地结合成一个整体，综合、平衡考虑所有用户要求，实现数据的一致性，最大限度地降低数据冗余，准确反映数据之间的联系；</p><h3 id="3-物理级数据库"><a href="#3-物理级数据库" class="headerlink" title="3. 物理级数据库"></a>3. 物理级数据库</h3><p>物理级数据库对应用内模式，是数据库的底层表示，是描述数据的实际存储组织，是最接近物理存储的级，又称为内部视图；</p><p><strong>物理级数据库由内部记录组成</strong>，物理级数据库不是真正的物理存储，而是最接近物理存储的级；</p><h2 id="1-3-2-数据库系统的三级模式"><a href="#1-3-2-数据库系统的三级模式" class="headerlink" title="1.3.2 数据库系统的三级模式"></a>1.3.2 数据库系统的三级模式</h2><p>数据库系统包括三级模式，即概念模式、外模式和内模式；</p><h3 id="1-概念模式"><a href="#1-概念模式" class="headerlink" title="1. 概念模式"></a>1. 概念模式</h3><p>概念模式又称为模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图；</p><p>一个数据库仅有一个概念模式；</p><p>定义概念模式时，不仅要定义<strong>数据的逻辑结构</strong>（数据记录的数据项，数据项名字，类型，取值范围等），而且还要定义<strong>数据之间的联系</strong>，定义<strong>与数据有关的安全性、完整性要求</strong>；</p><h3 id="2-外模式"><a href="#2-外模式" class="headerlink" title="2. 外模式"></a>2. 外模式</h3><p>外模式又称为子模式或用户模式，是数据库用户能看到和使用局部数据的逻辑结构和特征的描述，是数据库用户的数据视图；</p><p>他与某一应用有关的数据的逻辑表示；</p><p>一个数据库可以有多个外模式；</p><p>外模式主要描述用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件；</p><h3 id="3-内模式"><a href="#3-内模式" class="headerlink" title="3. 内模式"></a>3. 内模式</h3><p>内模式又称为存储模式或物理模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p><p>一个数据库只有一个内模式；</p><p>内模式定义的是 存储记录的类型、存储域的表示、存储记录的物理顺序、 索引和存储路径等数据的存储组织；</p><h2 id="1-3-3-数据库系统的二级映射和数据独立性"><a href="#1-3-3-数据库系统的二级映射和数据独立性" class="headerlink" title="1.3.3 数据库系统的二级映射和数据独立性"></a>1.3.3 数据库系统的二级映射和数据独立性</h2><h3 id="1-数据库系统的二级映射"><a href="#1-数据库系统的二级映射" class="headerlink" title="1. 数据库系统的二级映射"></a>1. 数据库系统的二级映射</h3><p>二级映射是：<strong>外模式/概念模式映射</strong> 和 <strong>概念模式/内模式映射</strong></p><p>三个抽象级通过二级映射相互转换。</p><h3 id="2-数据独立性"><a href="#2-数据独立性" class="headerlink" title="2. 数据独立性"></a>2. 数据独立性</h3><p>数据独立性是指应用程序和数据之间的独立性；包括物理独立性和逻辑独立性；</p><ol><li><p>数据独立性</p><p>物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是独立的。通过<strong>概念模式/内模式映射</strong>来实现；</p><p>当数据库存储结构改变时，由DBA对模式/内模式映射作相应的改变，可以使概念模式保持不变；</p></li><li><p>逻辑独立性</p><p>逻辑独立性是指用户的应用程序与逻辑结构是相互独立的。逻辑独立性是通过<strong>外模式/概念模式映射</strong>来实现的；</p><p>当概念模式改变时，由DBA对<strong>外模式/概念模式映射</strong>作相应改变，可使外模式保持不变；</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-1-数据库系统概述&quot;&gt;&lt;a href=&quot;#1-1-数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 数据库系统概述&quot;&gt;&lt;/a&gt;1.1 数据库系统概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-2-数据库系统的概念&quot;&gt;&lt;a href=&quot;#1-1-2-数据库系统的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 数据库系统的概念&quot;&gt;&lt;/a&gt;1.1.2 数据库系统的概念&lt;/h2&gt;&lt;p&gt;数据库的总目标就是使用户能有效且方便的管理和使用数据库数据。&lt;/p&gt;
&lt;h3 id=&quot;1-数据（Data）&quot;&gt;&lt;a href=&quot;#1-数据（Data）&quot; class=&quot;headerlink&quot; title=&quot;1. 数据（Data）&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 数据&lt;/strong&gt;（Data）&lt;/h3&gt;&lt;p&gt;数据是数据库存储的基本对象；描述现实世界中各种具体事务或抽象概念的、可存储并具有明确意义的符号记录。&lt;/p&gt;
&lt;h3 id=&quot;2-数据库（Database-DB）&quot;&gt;&lt;a href=&quot;#2-数据库（Database-DB）&quot; class=&quot;headerlink&quot; title=&quot;2. 数据库（Database. DB）&quot;&gt;&lt;/a&gt;&lt;strong&gt;2. 数据库&lt;/strong&gt;（Database. DB）&lt;/h3&gt;&lt;p&gt;数据库是长期存储在计算机内、有组织的、可共享的（1）&lt;strong&gt;大量数据的集合&lt;/strong&gt;。数据库中的数据按一定的数据模型组织，描述和存储，具有（2）&lt;strong&gt;较小的冗余&lt;/strong&gt;、（3）&lt;strong&gt;较高的数据独立性&lt;/strong&gt;和（4）&lt;strong&gt;易扩展性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;3-数据库管理系统（Database-Management-System，-DBMS）&quot;&gt;&lt;a href=&quot;#3-数据库管理系统（Database-Management-System，-DBMS）&quot; class=&quot;headerlink&quot; title=&quot;3. 数据库管理系统（Database Management System， DBMS）&quot;&gt;&lt;/a&gt;&lt;strong&gt;3. 数据库管理系统&lt;/strong&gt;（Database Management System， DBMS）&lt;/h3&gt;&lt;p&gt;数据库管理系统是数据库系统的核心；&lt;/p&gt;
&lt;p&gt;它位于用户和操作系统之间的一层数据库管理软件；&lt;/p&gt;
&lt;p&gt;它为用户或应用程序提供访问数据库的方法，包括数据库的（1）&lt;strong&gt;定义&lt;/strong&gt;、（2）&lt;strong&gt;建立&lt;/strong&gt;、（3）&lt;strong&gt;查询&lt;/strong&gt;、（4）&lt;strong&gt;更新&lt;/strong&gt;及各种数据控制等。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库原理及应用" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    <category term="数据库基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-02-笔记</title>
    <link href="http://yoursite.com/2020/10/08/zuoshen-basic-class-2-note/"/>
    <id>http://yoursite.com/2020/10/08/zuoshen-basic-class-2-note/</id>
    <published>2020-10-08T08:43:08.000Z</published>
    <updated>2020-12-11T09:59:37.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="问题一：partition"><a href="#问题一：partition" class="headerlink" title="问题一：partition"></a>问题一：partition</h2><blockquote><p>给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，大于$num$的数放在数组的右边。</p><p>要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$;</p></blockquote><p><strong>解决答案</strong></p><p><img src="/.com//image-20201002124018348.png" alt="image-20201002124018348"><a id="more"></a></p><p><img src="/.com//image-20201002124024185.png" alt="image-20201002124024185"></p><p><img src="/.com//image-20201002124028365.png" alt="image-20201002124028365"></p><h2 id="问题二：荷兰国旗问题"><a href="#问题二：荷兰国旗问题" class="headerlink" title="问题二：荷兰国旗问题"></a>问题二：荷兰国旗问题</h2><blockquote><p>给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，等于$num$的数放在中间，大于$num$的数放在数组的右边。</p><p>要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$;</p></blockquote><p><strong>解决答案</strong></p><p>三个变量$less$, $cur$ 和 $more$;</p><p>$less$ 表示 $0$ ~ $less $为小于$num$的区域；初始为 -1；</p><p>$cur$ 表示 当前判断的数在数组的下标；初始为0；并且 0 ~ $cur$的数组区域都是小于等于$num$的值；</p><p>$more$ 表示 $more$ ~ $arr.length-1$为大于$num$的区域；初始为 $arr.length$；</p><pre class="mermaid">graph TDA[开始] -->B(less初始值为-1)    A -->F(cur初始值为0)    A -->G(more初始值为arr.length)    F -->I{cur是否小于more}    G -->I    B --> I    C{判断arr的cur上的值} -->|小于num| D[cur位置和less+1位置交换 less+=1]    C -->|等于num| H[cur= cur+1]    C -->|大于num| E[cur位置和more-1位置交换 more-=1]    D --> H    H --> I    E --> I    I -->|是| C    I -->|否| J[结束 返回less+1,more-1]</pre><p>要考虑一下一些情况：</p><ol><li><p>如果等于区域不存在</p></li><li><p>小于区域不存在</p></li><li><p>大于区域不存在</p></li><li><p>小于等于区域不存在</p></li><li><p>大于等于区域不存在</p></li><li><p>小于大于不存在（全是等于）</p></li></ol><h2 id="经典快速排序"><a href="#经典快速排序" class="headerlink" title="经典快速排序"></a>经典快速排序</h2><p>原始经典快速排序；</p><p>荷兰国旗问题来改进；</p><p><strong>经典快排的问题</strong></p><p>划分出来的区域不是等规模的：特别在差不多有序情况下进行经典快排则会导致$O(N^2)$；本质上和数据状况是有关系的；</p><h2 id="随机快速排序"><a href="#随机快速排序" class="headerlink" title="随机快速排序"></a>随机快速排序</h2><h3 id="随机快速排序的细节和复杂度分析"><a href="#随机快速排序的细节和复杂度分析" class="headerlink" title="随机快速排序的细节和复杂度分析"></a><strong>随机快速排序的细节和复杂度分析</strong></h3><p>和经典快排不同的地方在于选择<code>partition</code>的<code>num</code>值；经典快排都是选择一个确定位置的值（第一个值或者最后一个值）来对整个数组进行划分；而这样就和数据状况存在关系。所以随机快速排序随机选择划分整个过程的<code>num</code>值。虽然这样选择的值也可能出现划分出来的区域不是等规模的。但是这只是一个概率事件，我们不能得知其时间复杂度的最差情况；只能用长期期望的方式算出它的时间复杂度。我们长期期望得到的时间复杂度为：$O(N*log N)$；</p><h3 id="随机快速排序的组成"><a href="#随机快速排序的组成" class="headerlink" title="随机快速排序的组成"></a>随机快速排序的组成</h3><ol><li><p>主函数：输入一个要排序的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快排主函数：</span></span><br><span class="line"><span class="comment">先判断数组需不需要排序</span></span><br><span class="line"><span class="comment">然后对 0 ~ arr.length-1 区间里调用2函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br></pre></td></tr></table></figure></li><li><p>对区间里进行快速排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果左边界小于右边界</span></span><br><span class="line"><span class="comment">在数组中随机选一个数作为分割数num，将其交换到l最后一个位置去</span></span><br><span class="line"><span class="comment">按上一步找的数用 3 partition 把数组分为三部分：[小于num的，等于num的，大于num的]，返回 [等于num的] 的边界，方便后两步</span></span><br><span class="line"><span class="comment">对 [小于num的] 执行快速排序</span></span><br><span class="line"><span class="comment">对 [大于num的] 执行快速排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure></li><li><p>分割数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">partition需要 less = l-1记录小于num的区域的边界，more = r记录大于num区域的边界 cur=l arr[r]保存着分割数num</span></span><br><span class="line"><span class="comment">这个思想与框图里的一样：</span></span><br><span class="line"><span class="comment">【l~less：小于num的区域， less+1~cur-1：等于num的区域， cur~more-1：未分类的区域， more~r-1：大于num的区域】</span></span><br><span class="line"><span class="comment">只要未分类的区域还存在循环不停止：</span></span><br><span class="line"><span class="comment">如果arr[cur] &lt; arr[r]:要把它换到小于区域的下一个，而这个值是等于num区域的值；交换 ++less 和 cur++；</span></span><br><span class="line"><span class="comment">如果arr[cur] &gt; arr[r]:把他换到大于区域前一个，交换过来的这个是未知区域的值；则要继续对cur位置做判断；</span></span><br><span class="line"><span class="comment">如果arr[cur] = arr[r]:当前数要划分进等于num的区域，直接cur++；</span></span><br><span class="line"><span class="comment">直接结束，交换more与r位置的数；</span></span><br><span class="line"><span class="comment">返回：[less+1, more]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><br></pre></td></tr></table></figure></li></ol><p><strong>规避数据状况对算法的影响的方法</strong></p><ol><li>随机</li><li>哈希函数</li></ol><p><strong>时间复杂度$O(N*log N)$，额外空间复杂度$O(log N)$</strong></p><p>空间复杂度为什么是$O(log N)$？为了记录大于<code>num</code>和小于<code>num</code>的位置，并且需要递归记录。所以额外的空间承了一颗二叉树一样得。所以是$O(log N)$</p><p><strong>题外话</strong>：任何递归函数都可以改写为非递归函数；</p><p>递归函数的压栈是对函数进行压栈，消耗的常数级空间和资源都比较大。并且系统栈是有限的，深度递归会造成不安全。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆的表示"><a href="#堆的表示" class="headerlink" title="堆的表示"></a>堆的表示</h2><p><strong>堆的数据结构</strong>：完全二叉树</p><p><strong>物理表示</strong>：一个数组，分为<strong>以0位置为根节点</strong>和<strong>以1位置为根节点</strong>两种表示方式；</p><p><strong>以0位置为根节点</strong>：</p><blockquote><p><code>i</code>位置的左孩子：$2*i+1$</p><p>​               右孩子：$2*i+2$；</p><p><code>i</code>位置的父节点： $\frac{i-1}{2}$</p></blockquote><p><strong>以1位置为根节点</strong>：</p><blockquote><p><code>i</code>位置的左孩子：$2*i$</p><p>​               右孩子：$2*i+1$</p><p><code>i</code>位置的父节点：$\frac{i}{2}$</p></blockquote><h2 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h2><p>分为大顶堆和小顶堆</p><p><strong>大根堆</strong>：在这个完全二叉树中任何一个子树的最大值都在子树的根上。</p><p><strong>小根堆</strong>：在这个完全二叉树中任何一个子树的最小值都在子树的根上。</p><h2 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h2><p>以大顶堆为例；</p><p><strong>思想</strong>：给定一个数组把它构建为一个大顶堆；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">宏观：我们认为0 ~ i-1间已构成大顶堆，然后插入第i个数；i初始值为0，不断插入堆中，不断增长，一直到N-1；</span><br><span class="line">中层：</span><br><span class="line"> 把一个数插入进完全二叉树：</span><br><span class="line"> 循环判断：if i是否有父节点 并且 i位置数大于父节点：</span><br><span class="line"> 与父结点进行交换</span><br><span class="line"> else:</span><br><span class="line"> 结束；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">    heapInsert(arr, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tip</strong>：这里看到左神代码，可以符合<code>i</code>没有父节点和大于父节点两种情况的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断i位置和其父节点</span></span><br><span class="line"><span class="keyword">while</span> (arr[i] &gt; arr[(i-<span class="number">1</span>)/<span class="number">2</span>])&#123;<span class="comment">// 在i=0时是否合适？</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    经过验证java中的整除除法的整除，如果是负值则会往比较大的方向贴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> / <span class="number">4</span> ： <span class="number">0</span></span><br><span class="line">-<span class="number">3</span> / <span class="number">4</span> ： <span class="number">0</span></span><br><span class="line">-<span class="number">4</span> / <span class="number">4</span> ： -<span class="number">1</span></span><br><span class="line">-<span class="number">5</span> / <span class="number">4</span> ： -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    而python不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span> // <span class="number">4</span> ： <span class="number">-1</span></span><br><span class="line"><span class="number">-3</span> // <span class="number">4</span> ： <span class="number">-1</span></span><br><span class="line"><span class="number">-5</span> // <span class="number">4</span> ： <span class="number">-2</span></span><br></pre></td></tr></table></figure><h2 id="插入堆（heapinsert）"><a href="#插入堆（heapinsert）" class="headerlink" title="插入堆（heapinsert）"></a>插入堆（heapinsert）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure><p>插入堆就是要不停的与父节点进行比较。如果大于就交换，小于则停止；</p><h2 id="调整堆（heapify）"><a href="#调整堆（heapify）" class="headerlink" title="调整堆（heapify）"></a>调整堆（heapify）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p>大顶堆中的一个数变小了，要对这样的情况进行调整；把它与他的两个子节点进行比较；如果大于它的左右节点那么就不调整了，如果小于就与较大的子节点进行交换。直到其大于他的左右子节点。当然结束条件不仅仅是大于两个子节点，也有子节点越界的情况。</p><blockquote><p>已知：堆数组arr，调整数的下标 index，堆大小 heapsize</p></blockquote><pre class="mermaid">graph TDA[开始] -->B[左节点下标 left = index * 2 + 1]B --> C{left < heapsize}C -->|yes|D[获得左右节点的较大值]C -->|no|E[结束]D -->F{index大于子节点}F -->|yes|GG -->EF -->|no|HH -->I[交换子节点较大值与index]I -->J[index=较大值]J -->B</pre><h2 id="堆的使用"><a href="#堆的使用" class="headerlink" title="堆的使用"></a>堆的使用</h2><p><strong>例一：一个数据流不停的输出数；求当前输出数字的中位数；</strong></p><p><strong>分析</strong>：请求中位数是随时可能出现的；所以用普通线性容器对其进行排序所需的时间复杂度很高。</p><p>所以用堆来实现这个过程就很方便：</p><blockquote><p><strong>题解：</strong></p><p>​    <strong>需要</strong>：一个大根堆存放较小的$\frac{N}{2}$个数；用大根堆把他们的最大值放在根部；</p><p>​                一个小根堆存放较大的$\frac{N}{2}$个数；用小根堆把他们的最小值放在根部；</p><p>​                大根堆和小根堆中元素的个数差不超过1；</p><p>​    <strong>分析</strong>：当大根堆和小根堆元素个数相同时：中位数为两个堆顶部元素的均方；</p><p>​                当大根堆和小根堆元素个数差1时：中位数为元素较多所在堆的根部；</p><p>​    <strong>维护堆</strong>：</p><p>​                初始：把元素加入进大顶堆；</p><p>​                插入元素：</p><p>​                            a. 判断插入元素是否小于大顶堆根部，如果是则插入大顶堆，否则插入小顶堆</p><p>​                            b. 再判断大顶堆和小顶堆元素个数的差；如果大于1，则弹出元素数较大的堆的根，再插入元素数较小的堆中；使其平衡；</p></blockquote><h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><pre class="mermaid">graph TDA[开始] --> B{数组大小大于1}B -->|是|H[构建堆] H -->C[将堆中最后一个数与根交换]C --> D[堆大小减1]D --> F{堆大小不为空}F --> |是|E[调整堆做一次heapify]E -->CF --> |否|GB -->|否| G[排序完成]</pre><h1 id="排序算法的稳定性及其汇总"><a href="#排序算法的稳定性及其汇总" class="headerlink" title="排序算法的稳定性及其汇总"></a>排序算法的稳定性及其汇总</h1><p><strong>稳定性</strong>：相同的值经过排序之后他们在序列中的相对顺序会不会被打乱；不被打乱就是稳定的；</p><p><strong>冒泡排序：</strong>可以实现稳定，大数沉底，但是遇到相等的时候不交换就可以实现稳定；</p><p><strong>插入排序：</strong>可以实现稳定；从后往前插入，遇到相等的就停止。</p><p><strong>选择排序：</strong>不是稳定的；需要与i位置往后最小值交换，使得其相对顺序会变化；</p><p><strong>归并排序：</strong>可以实现稳定；元素相等情况下，先把左边数组的相等值优先拷贝进辅助数组，再拷贝右边数组的相等值；</p><p><strong>快速排序：</strong>不是稳定的；partition的过程也有随机交换的地方；</p><p><strong>堆排序：</strong>不是稳定的；</p><p>稳定性有什么意义？ 现实世界有可能需要保证他的原始顺序；</p><h1 id="工程中的综合排序算法"><a href="#工程中的综合排序算法" class="headerlink" title="工程中的综合排序算法"></a>工程中的综合排序算法</h1><p>工程中使用的排序算法则不是利用某种排序算法，它是一个综合考虑各种情况各种排序算法优劣的算法；</p><ul><li><p>如果需要排序的数组长度很长</p><p>先判断里面装的是基础类型，还是自定义类型？因为基础类型不需要考虑稳定性；</p><ul><li>基础类型：用快排</li><li>自定义类型：归并排序</li></ul></li><li><p>数组长度很短则直接用插入排序；因为插入排序所需的常数项操作很低。</p></li></ul><h1 id="有关排序问题的补充"><a href="#有关排序问题的补充" class="headerlink" title="有关排序问题的补充"></a>有关排序问题的补充</h1><ul><li>归并排序所需的时间复杂度<code>O(n)</code>的可以变成<code>O(1)</code>的，可以学习：“ 归并排序 内部缓存法 ”；非常难；</li><li>快速排序可以做到稳定性，可以学习：“ 01 stable sort ”；非常难；</li></ul><h1 id="认识比较器的使用"><a href="#认识比较器的使用" class="headerlink" title="认识比较器的使用"></a>认识比较器的使用</h1><p><code>Arrays.sort</code> 里有一个比较器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a,<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> toIndex, Comparator c)</span></span></span><br></pre></td></tr></table></figure><p>通过自定义比较类型的比较器可以实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdAscendingComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> 负数;<span class="comment">// 比较时第一个数o1放在o2前面</span></span><br><span class="line">        <span class="keyword">return</span> 正数；<span class="comment">// 比较时第二个数o2放在o1前面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>；<span class="comment">// 认为这样个数一样大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为自定义类型不告诉排序函数它用什么比较器，那么排序函数就会用内存地址对他们进行比较；</p><p>同样的java里还有优先队列；优先队列也就是一个堆；堆是大顶堆还是小顶堆都是需要用比较器来说明的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Student&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> IdAscendingComparator());</span><br></pre></td></tr></table></figure><p>还有<code>TreeSet&lt;Student&gt; treeset = new TreeSet&lt;&gt;(new IdAscendingComparator());</code></p><h1 id="桶排序、计数排序、基数排序"><a href="#桶排序、计数排序、基数排序" class="headerlink" title="桶排序、计数排序、基数排序"></a>桶排序、计数排序、基数排序</h1><p><strong>【例】</strong>一串数字，他们都是0~60范围里的数。要对这串数字进行排序；</p><p>可以实现一个数组用来统计相应位置上的数出现的个数。在利用整个数组得到排序后的结果；</p><p>而这里数组中的 <code>i</code> 位置保存数字 <code>i</code> 的个数。这就是一个桶；</p><p>桶保存了一种数据状况出现的词频，是容器；</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>而桶排序是一种思想，它不是具体的某一个排序算法。而基数排序与计数排序都是对它的具体实现；</p><p>但是可以看到这种排序是有局限性的，它的使用与数据状况关联很大；</p><p>计数排序要求被排序的数字在某一个范围里面；不然的话所需的范围极大，所需的桶也极多。这是它不好的地方；</p><h2 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h2><blockquote><p><strong>给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序。</strong></p></blockquote><p><strong>step-1</strong> : 排序数组有N个数，那么准备N+1个桶</p><p><strong>step-2</strong> : 遍历整个数组找到其最大值与最小值</p><p><strong>step-3</strong> : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0；</p><p><strong>step-4</strong> : 如果不相等则分别把最小值放在0号桶里，把最大值放在N号桶里。</p><p><strong>step-5</strong> : 把桶按最小值与最大值之间的范围等分为N+1份</p><p><strong>分析</strong>：</p><p>​        设一个桶能装的范围是p，它是由 $\frac{最大值 - 最小值}{N-1}$ 计算而来</p><p>​        由于有N个数放进N+1个桶里。那么起码会出现一个空桶；</p><p>​            相邻的两个数会出现在两个地方：在同一个桶里，在不同的桶里；</p><p>​                相邻的两个数在一个桶里他们的差值不会大于桶的范围：$(1, p-1)$；</p><p>​                两个数在相邻两个桶，他们的差值范围在 $(1, 2*p-1)$；</p><p>​                而两个数中间有一个空桶的相邻数一定大于桶的范围 $(p+1, 3p-1)$；</p><p>​            因为起码会出现一个空桶，所以相邻数的差的最大值不会出现在同一个桶里。所以只需要查看桶之间的差值就好了。</p><p>对这个过程进行完整的描述：</p><p><strong>step-1</strong> : 排序数组有N个数，那么准备N+1个桶；这个桶只保存有没有进来过数，进来数中最大值，最小值，这三样信息；</p><p><strong>step-2</strong> : 遍历整个数组找到其最大值与最小值</p><p><strong>step-3</strong> : 如果最大值与最小值相等则说明数组中都是一样的数，就直接返回0； </p><p><strong>step-4</strong> : 如果不相等则分别用最小值更新0号桶布尔值，最大值和最小值，用最大值更新N号桶的布尔值，最大值和最小值。</p><p><strong>step-5</strong> : 然后依次把数组中的数字填入相对应的桶中；</p><p><strong>step-6</strong> : 对桶进行遍历，依次比较当前桶的最小值与上一个非空桶最大值的差，找到其中最大的值；</p><p><img src="/.com//image-20201020174415858.png" alt="image-20201020174415858"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;h2 id=&quot;问题一：partition&quot;&gt;&lt;a href=&quot;#问题一：partition&quot; class=&quot;headerlink&quot; title=&quot;问题一：partition&quot;&gt;&lt;/a&gt;问题一：partition&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组$arr$， 和一个数$num$，请把小于等于$num$的数放在数组的左边，大于$num$的数放在数组的右边。&lt;/p&gt;
&lt;p&gt;要求额外空间复杂度 $O(1)$ , 时间复杂度$O(N)$;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解决答案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/.com//image-20201002124018348.png&quot; alt=&quot;image-20201002124018348&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="排序" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="快速排序" scheme="http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-01-代码</title>
    <link href="http://yoursite.com/2020/10/07/zuoshen-basic-class-1-code/"/>
    <id>http://yoursite.com/2020/10/07/zuoshen-basic-class-1-code/</id>
    <published>2020-10-07T03:39:21.000Z</published>
    <updated>2020-12-11T09:59:59.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><p>常用的获取随机数组的技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random()*(n-m)+m <span class="comment">//生成大于等于m小于n的随机数；</span></span><br></pre></td></tr></table></figure><p>因为这个课程开始针对对数器的认识就是排序。它有自身的输入输出的特点。所以对数器是这样写的。但是针对不同的数据结构类型，对数器的写法是不同的。</p><a id="more"></a><h1 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h1><p><code>i==j</code>时这个交换功能会出错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span> ; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i-<span class="number">1</span>] &gt; arr[i])&#123;</span><br><span class="line">                swap(arr,i-<span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>] ; j--) &#123;</span><br><span class="line">            swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[minIndex] &gt; arr[j] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);   <span class="comment">// 位运算优先级低于加减，所以一定要加上括号</span></span><br><span class="line">    sortProcess(arr, L, mid);</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[i + L] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mergeSort(arr, l, m) + mergeSort(arr, m + <span class="number">1</span>, r) + merge(arr, l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + <span class="number">1</span>) : <span class="number">0</span>;<span class="comment">// 最重要的一句</span></span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;对数器&quot;&gt;&lt;a href=&quot;#对数器&quot; class=&quot;headerlink&quot; title=&quot;对数器&quot;&gt;&lt;/a&gt;对数器&lt;/h1&gt;&lt;p&gt;常用的获取随机数组的技巧：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Math.random()*(n-m)+m 	&lt;span class=&quot;comment&quot;&gt;//生成大于等于m小于n的随机数；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为这个课程开始针对对数器的认识就是排序。它有自身的输入输出的特点。所以对数器是这样写的。但是针对不同的数据结构类型，对数器的写法是不同的。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="排序" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="冒泡排序" scheme="http://yoursite.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="选择排序" scheme="http://yoursite.com/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="http://yoursite.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
    <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="对数器" scheme="http://yoursite.com/tags/%E5%AF%B9%E6%95%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>左神算法-基础课-01-笔记</title>
    <link href="http://yoursite.com/2020/10/07/zuoshen-basic-class-1/"/>
    <id>http://yoursite.com/2020/10/07/zuoshen-basic-class-1/</id>
    <published>2020-10-07T03:34:15.000Z</published>
    <updated>2020-12-11T09:59:47.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>每次把当前数组最大值通过交换放到最后；时间复杂度：$O(N^2)$</p><p>对这个算法描述分为三个层面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">宏观： 用end控制前面数组中的最大值存放的位置；它的初始值为N-1，结束值为1；</span><br><span class="line">中层： 把0 ~ end里的最大值传递到end位置；</span><br><span class="line">微观： 从&#96;0 ~ end-1&#96; 针对于相邻两个元素进行比较（位置0 和 位置1 比较； 然后位置1 和 位置2 比较；直到位置end-1 和 位置end 比较；）；</span><br><span class="line">  前面的大于后面的则交换;</span><br></pre></td></tr></table></figure><p>微观层面的算法是对中层的具体实现；中层又是宏观中的一部分；</p><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><code>0 ~ N-1</code>范围内找到最小的放在 <code>0</code> 位置</p><p><code>1 ~ N-1</code>范围内找到最小的放在 <code>1</code> 位置</p><p><code>2 ~ N-1</code>范围内找到最小的放在 <code>2</code> 位置</p><p>每次找到<code>i ~ N-1</code>位置里的最小值的下标，与<code>i</code>位置进行交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1： 第 i 位置后的最小值放在 i 位置；于是 i 取值范围为 0 ~ N-2 ； （因为 N - 1 之后没有数了， 也就是它自己了）</span><br><span class="line">2： 需要一个变量 minIndex 来保存最小值的下标；在 i ~ N-1 范围里找最小值；</span><br><span class="line">3： 交换 i 位置上的数和 minIndex 上的数；</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><code>0 ~ 0</code>范围内的数只有一个，认为是已排序的；</p><p><code>0 ~ 1</code> 范围里的数，如果判断 <code>1</code> 位置上的数小于  <code>0</code> 位置上数则进行交换， 否则不交换；</p><p><code>0 ~ 2</code> 范围里的数，把 <code>2</code> 位置上的数从后往前依次比较，如果小于则，交换，如果大于则停止；</p><p>从已排序的部分最大值往前比较，如果大与它前一个值就不交换。如果小于则与他前一个值交换。</p><p>差不多已经排序了的数组可以用插入排序。这个和数据状况有关系。完全有序<code>O(N)</code> ；完全逆序就是 <code>O(N^2)</code> ;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1： 变量 i 表示要插入数的位置； i 的范围是 1 ~ N-1</span><br><span class="line">2： 要把 i 位置数插入到 0 ~ i-1 范围里面去；</span><br><span class="line">3： 变量 j 表示要插入值目前的位置： 如果 j 大于 0 且 j 位置上的数小于 j-1 位置上的数， 则交换， j--； 否则停止；</span><br><span class="line">    j 的范围是 1 ~ i</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>​    最好情况 <code>O(N)</code>    最差情况 <code>O(N^2)</code>    平均情况 <code>O(N)</code> ~  <code>O(N^2)</code></p><p>​    </p><h2 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h2><h3 id="对数器的作用"><a href="#对数器的作用" class="headerlink" title="对数器的作用"></a>对数器的作用</h3><p><strong>1. 无测试样例时可以用对数器测试代码</strong></p><p><strong>2. 小样本测试过了，但是面对大样本测试出错，可以用对数器帮助修改bug</strong></p><p><strong>3.  如何证明贪心策略是对的？这是很难的。所以用对数器可以试贪心策略是对是错。</strong></p><h3 id="对数器的构成"><a href="#对数器的构成" class="headerlink" title="对数器的构成"></a>对数器的构成</h3><p><strong>1. 产生随机样本的函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">生成随机长度， 随机内容的数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> size, <span class="keyword">int</span> maxValue)</span><br></pre></td></tr></table></figure><p>  <img src="/.com//image-20200927100143765.png" alt="image-20200927100143765"></p><p><strong>2. 一个绝对正确的方法</strong></p><p>那么这个方法可能是来自于系统提供的；</p><p>或者是自己写的一个绝对正确但是时间复杂度过不了的方法；</p><p><strong>3. 大样本测试</strong></p><p>我们把自动生成的测试样例输入进 <code>绝对正确的方法</code> 和 <code>想要测得方法</code> ； 然后判断他们的输出是否一致；把这个过程重复很多次，可以是很大的值，也就是说可以也许穷尽所有的可能性；</p><p><img src="/.com//image-20200927100804767.png" alt=" "></p><p><img src="/.com//image-20200927100836217.png" alt="image-20200927100836217"></p><p><img src="/.com//image-20200927100948115.png" alt="image-20200927100948115"></p><h3 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h3><ol><li>有一个你想要测的方法a，</li><li>实现一个绝对正确但是复杂度不好的方法b，</li><li>实现一个随机样本产生器</li><li>实现比对的方法</li><li>把方法a和方法b比对很多次来验证方法a是否正确。</li><li>如果有一个样本使得比对出错，打印样本分析是哪个方法出错；</li><li>当样本数量很多时比对测试依然正确，可以确定方法a已经 正确。</li></ol><h3 id="笔试的时候要准备对数器"><a href="#笔试的时候要准备对数器" class="headerlink" title="笔试的时候要准备对数器"></a>笔试的时候要准备对数器</h3><p>我大概想到要写一个类；然后由各种继承得到；要覆写的东西也是很多；</p><p>python的话，有使输入格式规范的包；</p><h2 id="剖析递归行为和递归行为时间复杂度的估算"><a href="#剖析递归行为和递归行为时间复杂度的估算" class="headerlink" title="剖析递归行为和递归行为时间复杂度的估算"></a>剖析递归行为和递归行为时间复杂度的估算</h2><p><strong>剖析递归行为</strong></p><p>​    把当前运行函数压进系统栈中，保留当前函数的所有信息。调用的函数就在栈顶。</p><p>​    任何递归行为都可以改为非递归；</p><p><strong>递归行为时间复杂度的估算</strong></p><p>​    大部分的递归过程都可以用这个公式来表示</p><script type="math/tex; mode=display">T(N) = aT( \frac{N}{b} ) + O(N^d)</script><p>$N$表示样本量，$T(N)$表示时间复杂度；那么这个复杂度分成了$a$个$T(N/b)$个子问题的过程加上一个$O(N^d)$剩余时间过程的时间；</p><p>满足这个公式的递归过程的时间复杂度的计算如下：</p><script type="math/tex; mode=display">T(N) =     \begin{cases}    O(N^{log_ba}), & {log_ba} > d \\    O(N^d*{logN}), & {log_ba} = d \\    O(N^d), & {log_ba} < d    \end{cases}</script><p>但是像$T(N)=T(\frac{N}{5})+T(\frac{2}{3}N)+O(N^2)$这样的公式就不符合上面的这个过程；</p><p><strong>补充阅读</strong>：<a href="https://blog.gocalf.com/algorithm-complexity-and-master-theorem" target="_blank" rel="noopener">算法的复杂度与 Master 定理</a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把一个数组分为左右两个部分。先把左侧的排好序，再把右侧的排好序。最后用外排的方式排好序。这个过程的时间复杂度是下式：</p><script type="math/tex; mode=display">T(N) = 2 *T(\frac{N}{2})+O(N)</script><p>把这个公式带入到上一节，就可以查到它的时间复杂度为 $O(N*logN)$ 。并且归并排序的过程仅仅需要用到一个和原数组长度一样的数组，那么它的空间复杂度为$O(N)$</p><h3 id="归并排序的思想"><a href="#归并排序的思想" class="headerlink" title="归并排序的思想"></a>归并排序的思想</h3><p>针对一个数组将其分为两个部分，分别对这两个部分用归并排序。然后对整个数组进行一个外部排序。</p><p>外部排序：针对有序的两个数组；分别用两个指针指向他们的头部。然后依次往一个辅助数组里填入两个指针中更小的值；直到两个部分都填入了辅助数组后，再把已排序好的填回原数组。</p><h3 id="归并排序的组成部分"><a href="#归并排序的组成部分" class="headerlink" title="归并排序的组成部分"></a>归并排序的组成部分</h3><ol><li><p>主函数用来对整个数组进行排序，它调用第二个组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对未排序的数组<code>L</code>到<code>R</code>部分的排序过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果L==R则范围里只有一个数，那么直接返回就好了。可以认定他是有序的；</span></span><br><span class="line"><span class="comment">  如果有多余一个的数则把它分为前后两部分，分别进行归并排序。然后再对这两部分进行外部排序；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br></pre></td></tr></table></figure></li><li><p>合并<code>L</code>到<code>mid</code> 和 <code>mid+1</code>到<code>R</code>两个排序好的部分：把她两排序整合到一个辅助数组里，然后再拷贝回去；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">外部排序需要：一个辅助数组（大小为：R-L+1），两个指针（分别指向已排序好的两部分的头部），辅助数组下标；</span></span><br><span class="line"><span class="comment">过程：</span></span><br><span class="line"><span class="comment">1. 谁小填谁：进行一个循环（两个指针都不超过他们的边界的情况下），谁小就把谁填进辅助数组中；</span></span><br><span class="line"><span class="comment">2. 谁没了把另一个剩下的全部填入辅助数组中：因为上一个循环已经破除则一定有且只有一个指针越界（因为每次只填入一个数，一次只可能有一个越界）</span></span><br><span class="line"><span class="comment">所以这里会分别对两个指针进行判断是否到边界。他们是非此即彼的关系，即只会执行一个。</span></span><br><span class="line"><span class="comment">3. 最后需要把 辅助数组拷贝回 L到R之间的位置；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="归并排序的应用：小和问题和逆序对问题"><a href="#归并排序的应用：小和问题和逆序对问题" class="headerlink" title="归并排序的应用：小和问题和逆序对问题"></a>归并排序的应用：小和问题和逆序对问题</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line"></span><br><span class="line">[1,3,4,2,5] </span><br><span class="line"></span><br><span class="line">1左边比1小的数，没有； </span><br><span class="line"></span><br><span class="line">3左边比3小的数，1； </span><br><span class="line"></span><br><span class="line">4左边比4小的数，1、3； </span><br><span class="line"></span><br><span class="line">2左边比2小的数，1； </span><br><span class="line"></span><br><span class="line">5左边比5小的数，1、3、4、2； </span><br><span class="line"></span><br><span class="line">所以小和为1+1+3+1+1+3+4+2&#x3D;16</span><br></pre></td></tr></table></figure><p><strong>注意这个题不是算一个数之前有多少比它小的个数，而是算比它小的数的和。</strong></p><h4 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h4><p>这个笨办法就是进行遍历看这个数之前有几个数比它小；可以把它做对数器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序的思路"><a href="#归并排序的思路" class="headerlink" title="归并排序的思路"></a>归并排序的思路</h4><pre class="mermaid">graph TDA[1,3,4,2,5] --> B[1,3,4]B --> D[1,3]D --> H[1]D --> I[3]B --> E[4]A --> C[2,5]C --> F[2]C --> G[5]H -->|产生一个小和| J[1,3]I -->|数字1*后面长度1| JJ -->| 数字1*长度1| K[1,3,4]E -->| 数字3*长度1| KF -->| 数字2*长度1| L[2,5]G --> LK -->|数字1*长度2 + 不产生小和| M[1,2,3,4,5]L -->|数字3*长度1 + 数字4*长度1| M</pre><h4 id="归并排序求小和的组成部分"><a href="#归并排序求小和的组成部分" class="headerlink" title="归并排序求小和的组成部分"></a>归并排序求小和的组成部分</h4><ol><li><p>主函数，主要就是判断输入进来的数组是否符合规定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br></pre></td></tr></table></figure></li><li><p>归并排序求得数组小范围内的小和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure></li><li><p>合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure><p>这里代码与归并排序都是一样的不过在比较时多了一句算小和的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res += arr[p1] &lt; arr[p2] ? arr[p1] * (r - p2 + <span class="number">1</span>) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;每次把当前数组最大值通过交换放到最后；时间复杂度：$O(N^2)$&lt;/p&gt;
&lt;p&gt;对这个算法描述分为三个层面&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;宏观： 用end控制前面数组中的最大值存放的位置；它的初始值为N-1，结束值为1；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;中层： 把0 ~ end里的最大值传递到end位置；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;微观： 从&amp;#96;0 ~ end-1&amp;#96; 针对于相邻两个元素进行比较（位置0 和 位置1 比较； 然后位置1 和 位置2 比较；直到位置end-1 和 位置end 比较；）；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  前面的大于后面的则交换;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;微观层面的算法是对中层的具体实现；中层又是宏观中的一部分；&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    <category term="左神算法" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    <category term="排序" scheme="http://yoursite.com/categories/algorithm/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="冒泡排序" scheme="http://yoursite.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="选择排序" scheme="http://yoursite.com/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="http://yoursite.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
    <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="对数器" scheme="http://yoursite.com/tags/%E5%AF%B9%E6%95%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器</title>
    <link href="http://yoursite.com/2020/08/31/python-decorator/"/>
    <id>http://yoursite.com/2020/08/31/python-decorator/</id>
    <published>2020-08-31T03:28:16.000Z</published>
    <updated>2020-09-01T07:21:30.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-装饰器的原型"><a href="#1-装饰器的原型" class="headerlink" title="1. 装饰器的原型"></a>1. 装饰器的原型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">foo = showtime(foo)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>对<code>foo</code>函数进行增强；</p><a id="more"></a><h1 id="2-不带参数的装饰器-装饰器-被装饰函数都不带参数"><a href="#2-不带参数的装饰器-装饰器-被装饰函数都不带参数" class="headerlink" title="2. 不带参数的装饰器:(装饰器,被装饰函数都不带参数)"></a>2. 不带参数的装饰器:(装饰器,被装饰函数都不带参数)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #doo = showtime(doo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    foo()</span><br><span class="line">    doo()</span><br></pre></td></tr></table></figure><h1 id="3-带参数的被装饰的函数"><a href="#3-带参数的被装饰的函数" class="headerlink" title="3. 带参数的被装饰的函数"></a>3. 带参数的被装饰的函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(a,b)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #add = showtime(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime #sub = showtime(sub)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(a-b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    add(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">    sub(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">spend is 1.0008258819580078</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">spend is 1.0002799034118652</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="4-带参数的装饰器-装饰函数"><a href="#4-带参数的装饰器-装饰函数" class="headerlink" title="4. 带参数的装饰器(装饰函数)"></a>4. 带参数的装饰器(装饰函数)</h1><p>实际是对原有装饰器的一个函数的封装,并返回一个装饰器(一个含有参数的闭包函数),<br>当使用@time_logger(3)调用的时候,Python能发现这一层封装,并将参数传递到装饰器的环境去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_logger</span><span class="params">(flag = <span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            start_time = time.time()</span><br><span class="line">            func(a,b)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                print(<span class="string">'将此操作保留至日志'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> showtime</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_logger(2)  #得到闭包函数showtime,add = showtime(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a+b)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    add(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>多加一层闭包，把参数传进去</p><h1 id="5-类装饰器-一般依靠类内部的call方法"><a href="#5-类装饰器-一般依靠类内部的call方法" class="headerlink" title="5. 类装饰器:一般依靠类内部的call方法"></a>5. 类装饰器:一般依靠类内部的<strong>call</strong>方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        self._func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo  #bar = Foo(bar)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'bar..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bar()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bar..</span></span><br><span class="line"><span class="string">spend is 2.000215768814087</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="6-使用装饰器的缺点"><a href="#6-使用装饰器的缺点" class="headerlink" title="6. 使用装饰器的缺点"></a>6. 使用装饰器的缺点</h1><p>1.位置错误的代码 不能在装饰器之外添加逻辑功能<br>2.不能装饰@staticmethod 或者 @classmethod已经装饰过的方法<br>3.装饰器会对原函数的元信息进行更改,比如函数的docstring,<strong>name</strong>,参数列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(foo.__name__)</span><br><span class="line">    print(doo.__name__)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    wrapper</span></span><br><span class="line"><span class="string">    doo</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure><p>由此可以看出,装饰器会对原函数的元信息进行更改,可以使用wraps,进行原函数信息的添加</p><p>注解:wraps本身也是一个装饰器,他能把函数的元信息拷贝到装饰器函数中使得装饰器函数与原函数有一样的元信息</p><p>以下是一个wraps的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#6.4. 使用wraps把被装饰的函数信息绑定进装饰器</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtime</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(<span class="string">'spend is &#123;&#125;'</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@showtime  #foo = showtime(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'foo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'doo..'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(foo.__name__)</span><br><span class="line">    print(doo.__name__)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string">doo</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="常用的内置装饰器"><a href="#常用的内置装饰器" class="headerlink" title="常用的内置装饰器"></a>常用的内置装饰器</h1><ol><li><p><strong>staticmethod</strong>: 类似实现了静态方法 注入以后,可以直接 : 类名.方法</p></li><li><p><strong>property</strong>: 经过property装饰过的函数 不再是一个函数,而是一个property, <strong>类似实现get,set方法</strong></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property</span><br><span class="line">def width(self):</span><br><span class="line">    return self.__width</span><br><span class="line"></span><br><span class="line">@width.setter</span><br><span class="line">def width(self, newWidth):</span><br><span class="line">    self.__width &#x3D; newWidth</span><br></pre></td></tr></table></figure><ol><li><strong>classmethod</strong>: 与<strong>staticmethod</strong>很相似,貌似就只有这一点区别:<pre><code>第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</code></pre></li></ol><p><a href="https://www.cnblogs.com/cicaday/p/python-decorator.html#_caption_0" target="_blank" rel="noopener">详解Python的装饰器</a></p><p><a href="https://www.jianshu.com/p/ee82b941772a" target="_blank" rel="noopener">理解Python装饰器(Decorator)</a></p><p><a href="https://blog.csdn.net/u013380694/article/details/90019571" target="_blank" rel="noopener">python 闭包，装饰器</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-装饰器的原型&quot;&gt;&lt;a href=&quot;#1-装饰器的原型&quot; class=&quot;headerlink&quot; title=&quot;1. 装饰器的原型&quot;&gt;&lt;/a&gt;1. 装饰器的原型&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;showtime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        start_time = time.time()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        func()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end_time = time.time()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;spend is &amp;#123;&amp;#125;&#39;&lt;/span&gt;.format(end_time - start_time))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wrapper&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;foo..&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time.sleep(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = showtime(foo)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对&lt;code&gt;foo&lt;/code&gt;函数进行增强；&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="装饰器" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python闭包</title>
    <link href="http://yoursite.com/2020/08/31/python-closure/"/>
    <id>http://yoursite.com/2020/08/31/python-closure/</id>
    <published>2020-08-31T03:06:55.000Z</published>
    <updated>2020-08-31T03:27:23.231Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><h1 id="python-闭包"><a href="#python-闭包" class="headerlink" title="python 闭包"></a><a href="https://blog.csdn.net/u013380694/article/details/90019571" target="_blank" rel="noopener">python 闭包</a></h1><p>如果在一个函数的内部定义了另一个函数，外部的函数叫它外函数，内部的函数叫它内函数。</p><h2 id="1-闭包条件"><a href="#1-闭包条件" class="headerlink" title="1.  闭包条件"></a>1.  闭包条件</h2><ol><li><p>在一个外函数中定义了一个内函数。</p></li><li><p>内函数里运用了外函数的临时变量。</p></li><li><p>并且外函数的返回值是内函数的引用。</p></li></ol><p>一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#闭包函数的实例</span></span><br><span class="line"><span class="comment"># outer是外部函数 a和b都是外函数的临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">( a )</span>:</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    <span class="comment"># inner是内函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment">#在内函数中 用到了外函数的临时变量</span></span><br><span class="line">        print(a+b)</span><br><span class="line">    <span class="comment"># 外函数的返回值是内函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 在这里我们调用外函数传入参数5</span></span><br><span class="line">    <span class="comment">#此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span></span><br><span class="line">    <span class="comment"># 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span></span><br><span class="line">    demo = outer(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span></span><br><span class="line">    <span class="comment"># demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span></span><br><span class="line">    demo() <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">    demo2 = outer(<span class="number">7</span>)</span><br><span class="line">    demo2()<span class="comment">#17</span></span><br></pre></td></tr></table></figure><h3 id="A-外函数返回了内函数的引用"><a href="#A-外函数返回了内函数的引用" class="headerlink" title="A 外函数返回了内函数的引用"></a><strong>A 外函数返回了内函数的引用</strong></h3><p>返回内函数，对于闭包，在外函数outer中 最后return inner，在调用外函数 demo = outer() 的时候，outer返回了inner，inner是一个函数的引用，这个引用被存入了demo中。所以接下来再进行使用demo() 的时候，相当于使用了inner函数。</p><p>一个函数，如果函数名后紧跟一对括号，说明现在就要调用这个函数，如果不跟括号，只是一个函数的名字，里面存了函数所在位置的引用。</p><h3 id="B-外函数把临时变量绑定给内函数"><a href="#B-外函数把临时变量绑定给内函数" class="headerlink" title="B 外函数把临时变量绑定给内函数"></a><strong>B 外函数把临时变量绑定给内函数</strong></h3><p>一个函数结束的时候，会把自己的临时变量都释放给内存，之后变量都不存在了。一般情况下，确实是这样的。但是闭包是一个特别的情况。外部函数发现，自己的临时变量会在将来的内部函数中用到，自己在结束的时候，返回内函数的同时，会把外函数的临时变量和内函数绑定在一起。所以外函数已经结束了，调用内函数的时候仍然能够使用外函数的临时变量。</p><h2 id="2-闭包中内函数修改外函数局部变量"><a href="#2-闭包中内函数修改外函数局部变量" class="headerlink" title="2. 闭包中内函数修改外函数局部变量"></a>2. 闭包中内函数修改外函数局部变量</h2><p>在闭包内函数中，可以随意使用外函数绑定来的临时变量，但是如果想修改外函数临时变量数值的时候发现出问题了！</p><p>在基本的python语法当中，一个函数可以随意读取全局数据，但是要修改全局数据的时候有两种方法:</p><ol><li><p>global 声明全局变量</p></li><li><p>全局变量是可变类型数据的时候可以修改</p></li></ol><p>在闭包内函数也是类似的情况。在内函数中想修改闭包变量（外函数绑定给内函数的局部变量）的时候：</p><ol><li><p>在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</p></li><li><p>在python2中，没有nonlocal这个关键字，可以把闭包变量改成可变类型数据进行修改，比如列表。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改闭包变量的实例</span></span><br><span class="line"><span class="comment"># outer是外部函数 a和b都是外函数的临时变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">( a )</span>:</span></span><br><span class="line">    b = <span class="number">10</span>  <span class="comment"># a和b都是闭包变量</span></span><br><span class="line">    c = [a] <span class="comment">#这里对应修改闭包变量的方法2</span></span><br><span class="line">    <span class="comment"># inner是内函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment">#内函数中想修改闭包变量</span></span><br><span class="line">        <span class="comment"># 方法1 nonlocal关键字声明</span></span><br><span class="line">        <span class="keyword">nonlocal</span>  b</span><br><span class="line">        b+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 方法二，把闭包变量修改成可变数据类型 比如列表</span></span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        print(c[<span class="number">0</span>])</span><br><span class="line">        print(b)</span><br><span class="line">    <span class="comment"># 外函数的返回值是内函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    demo = outer(<span class="number">5</span>)</span><br><span class="line">    demo() <span class="comment"># 6  11</span></span><br></pre></td></tr></table></figure><p>从上面代码中能看出来，在内函数中，分别对闭包变量进行了修改，打印出来的结果也确实是修改之后的结果。以上两种方法就是内函数修改闭包变量的方法。</p><p>还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x+=y</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = outer(<span class="number">10</span>)</span><br><span class="line">print(a(<span class="number">1</span>)) //<span class="number">11</span></span><br><span class="line">print(a(<span class="number">3</span>)) //<span class="number">14</span></span><br></pre></td></tr></table></figure><p>外部函数的变量会跟着变</p><h2 id="3-闭包用途"><a href="#3-闭包用途" class="headerlink" title="3. 闭包用途"></a>3. 闭包用途</h2><p><strong>3.1 装饰器</strong>！装饰器是做什么的？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。</p><p> <strong>3.2 面向对象！</strong>经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程</p><p><strong>3.3 实现单利模式！</strong> 其实这也是装饰器的应用。单利模式毕竟比较高大，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    &lt;/p&gt;
&lt;h1 id=&quot;python-闭包&quot;&gt;&lt;a href=&quot;#python-闭包&quot; class=&quot;headerlink&quot; title=&quot;python 闭包&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/u013380694/article/details/90019571&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python 闭包&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;如果在一个函数的内部定义了另一个函数，外部的函数叫它外函数，内部的函数叫它内函数。&lt;/p&gt;
&lt;h2 id=&quot;1-闭包条件&quot;&gt;&lt;a href=&quot;#1-闭包条件&quot; class=&quot;headerlink&quot; title=&quot;1.  闭包条件&quot;&gt;&lt;/a&gt;1.  闭包条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在一个外函数中定义了一个内函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内函数里运用了外函数的临时变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并且外函数的返回值是内函数的引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般情况下，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>python和java的垃圾回收机制</title>
    <link href="http://yoursite.com/2020/08/31/garbage_Collection/"/>
    <id>http://yoursite.com/2020/08/31/garbage_Collection/</id>
    <published>2020-08-31T02:01:33.000Z</published>
    <updated>2020-08-31T02:14:11.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python垃圾回收机制详解"><a href="#Python垃圾回收机制详解" class="headerlink" title="Python垃圾回收机制详解"></a><a href="https://blog.csdn.net/xiongchengluo1129/article/details/80462651" target="_blank" rel="noopener">Python垃圾回收机制详解</a></h1><h2 id="一、引用计数"><a href="#一、引用计数" class="headerlink" title="一、引用计数"></a>一、引用计数</h2><p>Python垃圾回收主要以引用计数为主，分代回收为辅。</p><h3 id="1-引用计数增加的情况"><a href="#1-引用计数增加的情况" class="headerlink" title="1.引用计数增加的情况"></a>1.引用计数增加的情况</h3><p>当发生以下四种情况的时候，该对象的引用计数器<strong>+1</strong></p><ol><li><strong>对象被创建  a=14</strong></li><li><strong>对象被引用  b=a</strong></li><li><strong>对象被作为参数,传到函数中   func(a)</strong></li><li><strong>对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}</strong></li></ol><h3 id="2-引用计数减少的情况"><a href="#2-引用计数减少的情况" class="headerlink" title="2. 引用计数减少的情况"></a>2. 引用计数减少的情况</h3><p>与上述情况相对应，当发生以下四种情况时，该对象的引用计数器<strong>-1</strong></p><ol><li><strong>当该对象的别名被显式销毁时  del a</strong></li><li><strong>当该对象的引别名被赋予新的对象，   a=26</strong></li><li><strong>一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）</strong></li><li><strong>将该元素从容器中删除时，或者容器被销毁时。</strong></li></ol><p>当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁</p><a id="more"></a><h3 id="3-引用计数法有很明显的优点："><a href="#3-引用计数法有很明显的优点：" class="headerlink" title="3.引用计数法有很明显的优点："></a>3.<strong>引用计数法有很明显的优点：</strong></h3><ol><li>高效</li><li>运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</li><li>对象有确定的生命周期</li><li>易于实现</li></ol><h3 id="4-原始的引用计数法也有明显的缺点："><a href="#4-原始的引用计数法也有明显的缺点：" class="headerlink" title="4. 原始的引用计数法也有明显的缺点："></a>4. 原始的引用计数法也有明显的缺点：</h3><ol><li>维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。</li><li>无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。<br>循环引用的示例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 &#x3D; []</span><br><span class="line">list2 &#x3D; []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure><h2 id="二、标记-清除"><a href="#二、标记-清除" class="headerlink" title="二、标记-清除"></a>二、标记-清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p><p><img src="/.com//mark-sweep.svg" alt="laji"></p><p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p><h2 id="三、分代回收"><a href="#三、分代回收" class="headerlink" title="三、分代回收"></a>三、分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p><h1 id="深入理解java垃圾回收机制"><a href="#深入理解java垃圾回收机制" class="headerlink" title="深入理解java垃圾回收机制"></a><a href="https://www.cnblogs.com/sunniest/p/4575144.html" target="_blank" rel="noopener">深入理解java垃圾回收机制</a></h1><h2 id="一、垃圾回收机制的意义"><a href="#一、垃圾回收机制的意义" class="headerlink" title="一、垃圾回收机制的意义"></a>一、垃圾回收机制的意义</h2><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</p><p>　　<em>ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</em></p><h2 id="二、垃圾回收机制中的算法"><a href="#二、垃圾回收机制中的算法" class="headerlink" title="二、垃圾回收机制中的算法"></a>二、垃圾回收机制中的算法</h2><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。　　</p><h3 id="1-引用计数法-Reference-Counting-Collector"><a href="#1-引用计数法-Reference-Counting-Collector" class="headerlink" title="1.引用计数法(Reference Counting Collector)"></a>1.引用计数法(Reference Counting Collector)</h3><h4 id="1-1算法分析"><a href="#1-1算法分析" class="headerlink" title="1.1算法分析　"></a>1.1算法分析　</h4><p>　　引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><h4 id="1-2优缺点"><a href="#1-2优缺点" class="headerlink" title="1.2优缺点"></a>1.2优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>　　引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>　　无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p><h4 id="1-3引用计数算法无法解决循环引用问题"><a href="#1-3引用计数算法无法解决循环引用问题" class="headerlink" title="1.3引用计数算法无法解决循环引用问题"></a>1.3引用计数算法无法解决循环引用问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line">         </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">         </span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <span style="color:red">最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</span></p><h3 id="2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><a href="#2-tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep" class="headerlink" title="2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)"></a>2. tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h3><h4 id="2-1-根搜索算法"><a href="#2-1-根搜索算法" class="headerlink" title="2.1 根搜索算法"></a>2.1 根搜索算法</h4><p><img src="/.com//141050566294022.jpg" alt="img"></p><p>　根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p>java中可作为GC Root的对象有</p><div style="color:red">    1.虚拟机栈中引用的对象（本地变量表）<br>    2.方法区中静态属性引用的对象<br>    3. 方法区中常量引用的对象<br>    4.本地方法栈中引用的对象（Native对象）<br>　</div><h4 id="2-2-tracing算法的示意图"><a href="#2-2-tracing算法的示意图" class="headerlink" title="2.2 tracing算法的示意图"></a>2.2 tracing算法的示意图</h4><p><img src="/.com//141048430359736.jpg" alt="img"></p><h4 id="2-3标记-清除算法分析"><a href="#2-3标记-清除算法分析" class="headerlink" title="2.3标记-清除算法分析"></a>2.3标记-清除算法分析</h4><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><h3 id="3-compacting算法-或-标记-整理算法"><a href="#3-compacting算法-或-标记-整理算法" class="headerlink" title="3.compacting算法 或 标记-整理算法"></a>3.compacting算法 或 标记-整理算法</h3><p><img src="/.com//141120037076681.jpg" alt="img"></p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p><h3 id="4-copying算法-Compacting-Collector"><a href="#4-copying算法-Compacting-Collector" class="headerlink" title="4.copying算法(Compacting Collector)"></a>4.copying算法(Compacting Collector)</h3><p><img src="/.com//141112115351233.jpg" alt="img"></p><p>　该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。</p><p>它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p><p>一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p><h3 id="5-generation算法-Generational-Collector"><a href="#5-generation算法-Generational-Collector" class="headerlink" title="5.generation算法(Generational Collector)"></a>5.generation算法(Generational Collector)</h3><p><img src="/.com//141332429573819.jpg" alt="img"></p><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p><p><span style="color:red"><strong>年轻代（Young Generation）</strong></span></p><ol><li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li><li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li><li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</li><li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</li></ol><p><span style="color:red"><strong>年老代（Old Generation）</strong></span></p><p>1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p><p><span style="color:red"><strong>持久代（Permanent Generation）</strong></span></p><p>​    用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><h2 id="三-GC（垃圾收集器）"><a href="#三-GC（垃圾收集器）" class="headerlink" title="三.GC（垃圾收集器）"></a>三.GC（垃圾收集器）</h2><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p><p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p><p><img src="/.com//141513122384006.jpg" alt="img"></p><p><span style="color:red"><strong>Serial收集器（复制算法)</strong></span></p><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p><p><span style="color:red"><strong>Serial Old收集器(标记-整理算法)</strong></span></p><p>老年代单线程收集器，Serial收集器的老年代版本。</p><p><span style="color:red"><strong>ParNew收集器(停止-复制算法)</strong></span></p><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><p><span style="color:red"><strong>Parallel Scavenge收集器(停止-复制算法)</strong></span></p><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p><p><span style="color:red"><strong>Parallel Old收集器(停止-复制算法)</strong></span></p><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p><p><span style="color:red"><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></span></p><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p><h2 id="四、GC的执行机制"><a href="#四、GC的执行机制" class="headerlink" title="四、GC的执行机制"></a>四、GC的执行机制</h2><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<span style="color:red">Scavenge GC</span>和<span style="color:red">Full GC</span>。</p><p><span style="color:red"><strong>Scavenge GC</strong></span></p><p>   一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><p><span style="color:red"><strong>Full GC</strong></span></p><p>   对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><pre><code>&lt;div style=color:red&gt;    1.年老代（Tenured）被写满&lt;br&gt;    2.持久代（Perm）被写满 &lt;br&gt;    3.System.gc()被显示调用 &lt;br&gt;    4.上一次GC之后Heap的各域分配策略动态变化 &lt;/div&gt;</code></pre><h2 id="五、Java有了GC同样会出现内存泄露问题"><a href="#五、Java有了GC同样会出现内存泄露问题" class="headerlink" title="五、Java有了GC同样会出现内存泄露问题"></a>五、Java有了GC同样会出现内存泄露问题</h2><p><span style="color:red">1. 静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v &#x3D; new Vector(); </span><br><span class="line">for (int i &#x3D; 1; i&lt;100; i++) </span><br><span class="line">&#123; </span><br><span class="line">    Object o &#x3D; new Object(); </span><br><span class="line">    v.add(o); </span><br><span class="line">    o &#x3D; null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。</p><p><span style="color:red">2. 各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</span></p><p><span style="color:red">3. 监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python垃圾回收机制详解&quot;&gt;&lt;a href=&quot;#Python垃圾回收机制详解&quot; class=&quot;headerlink&quot; title=&quot;Python垃圾回收机制详解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/xiongchengluo1129/article/details/80462651&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python垃圾回收机制详解&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、引用计数&quot;&gt;&lt;a href=&quot;#一、引用计数&quot; class=&quot;headerlink&quot; title=&quot;一、引用计数&quot;&gt;&lt;/a&gt;一、引用计数&lt;/h2&gt;&lt;p&gt;Python垃圾回收主要以引用计数为主，分代回收为辅。&lt;/p&gt;
&lt;h3 id=&quot;1-引用计数增加的情况&quot;&gt;&lt;a href=&quot;#1-引用计数增加的情况&quot; class=&quot;headerlink&quot; title=&quot;1.引用计数增加的情况&quot;&gt;&lt;/a&gt;1.引用计数增加的情况&lt;/h3&gt;&lt;p&gt;当发生以下四种情况的时候，该对象的引用计数器&lt;strong&gt;+1&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象被创建  a=14&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象被引用  b=a&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象被作为参数,传到函数中   func(a)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-引用计数减少的情况&quot;&gt;&lt;a href=&quot;#2-引用计数减少的情况&quot; class=&quot;headerlink&quot; title=&quot;2. 引用计数减少的情况&quot;&gt;&lt;/a&gt;2. 引用计数减少的情况&lt;/h3&gt;&lt;p&gt;与上述情况相对应，当发生以下四种情况时，该对象的引用计数器&lt;strong&gt;-1&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当该对象的别名被显式销毁时  del a&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当该对象的引别名被赋予新的对象，   a=26&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将该元素从容器中删除时，或者容器被销毁时。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="垃圾回收" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>python中的锁</title>
    <link href="http://yoursite.com/2020/08/31/python_GIL/"/>
    <id>http://yoursite.com/2020/08/31/python_GIL/</id>
    <published>2020-08-31T02:01:33.000Z</published>
    <updated>2020-08-31T02:11:11.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python中的锁"><a href="#Python中的锁" class="headerlink" title="Python中的锁"></a>Python中的锁</h1><h2 id="一、全局解释器锁（GIL）"><a href="#一、全局解释器锁（GIL）" class="headerlink" title="一、全局解释器锁（GIL）"></a>一、全局解释器锁（GIL）</h2><h3 id="1、什么是全局解释器锁"><a href="#1、什么是全局解释器锁" class="headerlink" title="1、什么是全局解释器锁"></a>1、什么是全局解释器锁</h3><p>在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才能使用全局解释器（cpu）, 即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。</p><ul><li>GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU 上运行该进程的一个线程。</li><li>CPython中<ol><li><strong>IO密集型</strong>，某个线程阻塞，就会调度其他就绪线程；</li><li><strong>CPU密集型</strong>，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。</li></ol></li><li>在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL。</li><li><strong>Python中绝大多数内置数据结构的读、写操作都是原子操作。</strong></li><li><strong>由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是 线程安全类型。</strong></li></ul><a id="more"></a><h3 id="2、全局解释器锁的好处"><a href="#2、全局解释器锁的好处" class="headerlink" title="2、全局解释器锁的好处"></a>2、全局解释器锁的好处</h3><p>1、避免了大量的加锁解锁的好处</p><p>2、使数据更加安全，解决多线程间的数据完整性和状态同步</p><h3 id="3、全局解释器的缺点"><a href="#3、全局解释器的缺点" class="headerlink" title="3、全局解释器的缺点"></a>3、全局解释器的缺点</h3><p>多核处理器退化成单核处理器，只能并发不能并行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同一时刻的某个进程下的某个线程只能被一个cpu所处理，所以在GIL锁下的线程只能被并发，不能被并行。</span><br></pre></td></tr></table></figure><h2 id="二、同步锁"><a href="#二、同步锁" class="headerlink" title="二、同步锁"></a>二、同步锁</h2><h3 id="1、什么是同步锁？"><a href="#1、什么是同步锁？" class="headerlink" title="1、什么是同步锁？"></a>1、什么是同步锁？</h3><p>　　　　同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。</p><h3 id="2、为什么用同步锁？"><a href="#2、为什么用同步锁？" class="headerlink" title="2、为什么用同步锁？"></a>2、为什么用同步锁？</h3><p>　　　　因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程　　序结果的完整性。</p><h3 id="3、怎么使用同步锁？"><a href="#3、怎么使用同步锁？" class="headerlink" title="3、怎么使用同步锁？"></a>3、怎么使用同步锁？</h3><p>　　　　只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。</p><h3 id="4、实例："><a href="#4、实例：" class="headerlink" title="4、实例："></a>4、实例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">R = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    R.acquire() <span class="comment"># 加锁，保证同一时刻只有一个线程可以修改数据</span></span><br><span class="line">    num -= <span class="number">1</span></span><br><span class="line">    R.release() <span class="comment"># 修改完成就可以解锁</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span>  <span class="comment"># 定义一个全局变量</span></span><br><span class="line">l = []  <span class="comment"># 定义一个空列表，用来存放所有的列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  <span class="comment"># for循环100次</span></span><br><span class="line">    t = threading.Thread(target=sub)  <span class="comment"># 每次循环开启一个线程</span></span><br><span class="line">    t.start()  <span class="comment"># 开启线程</span></span><br><span class="line">    l.append(t)  <span class="comment"># 将线程加入列表l</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    i.join()  <span class="comment"># 这里加上join保证所有的线程结束后才运行下面的代码</span></span><br><span class="line">print(num)</span><br><span class="line"><span class="comment"># 输出结果为0</span></span><br></pre></td></tr></table></figure><h3 id="5、扩展知识"><a href="#5、扩展知识" class="headerlink" title="5、扩展知识"></a>5、扩展知识</h3><p>　1、GIL的作用：多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。</p><p>　2、同步锁的作用：为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。</p><h2 id="三、递归锁和死锁"><a href="#三、递归锁和死锁" class="headerlink" title="三、递归锁和死锁"></a>三、递归锁和死锁</h2><h3 id="1、什么是死锁？"><a href="#1、什么是死锁？" class="headerlink" title="1、什么是死锁？"></a>1、什么是死锁？</h3><p>指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源而相互等待的一个现象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">A = threading.Lock()</span><br><span class="line">B = threading.Lock()</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a()   <span class="comment"># 如果两个锁同时被多个线程运行，就会出现死锁现象</span></span><br><span class="line">        self.b()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(<span class="string">'123'</span>)</span><br><span class="line">        B.acquire()</span><br><span class="line">        print(<span class="number">456</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        B.release()</span><br><span class="line">        print(<span class="string">'qweqwe'</span>)</span><br><span class="line">        A.release()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(self)</span>:</span></span><br><span class="line">        B.acquire()</span><br><span class="line">        print(<span class="string">'asdfaaa'</span>)</span><br><span class="line">        A.acquire()</span><br><span class="line">        print(<span class="string">'(⊙o⊙)哦(⊙v⊙)嗯'</span>)</span><br><span class="line">        A.release()</span><br><span class="line">        B.release()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):  <span class="comment"># 循环两次，运行四个线程，第一个线程成功处理完数据，第二个和第三个就会出现死锁</span></span><br><span class="line">    t = obj()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>这是python里写一个死锁的标准写法了吧；当b获取了B锁，a获取了A锁，a想要B锁继续，b想要A锁继续，于是就产生了死锁；</p><h3 id="2、什么是递归锁？"><a href="#2、什么是递归锁？" class="headerlink" title="2、什么是递归锁？"></a>2、什么是递归锁？</h3><p>​        在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">A = threading.RLock()  <span class="comment"># 这里设置锁为递归锁</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a()</span><br><span class="line">        self.b()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span>  <span class="comment"># 递归锁，就是将多个锁的钥匙放到一起，要拿就全拿，要么一个都拿不到</span></span><br><span class="line">        <span class="comment"># 以实现锁</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(str(threading.currentThread().name) + <span class="string">'  123'</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">"  456"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  qweqwe'</span>)</span><br><span class="line">        A.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.acquire()</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  asdfaaa'</span>)</span><br><span class="line">        print(str(threading.currentThread().name) +<span class="string">'  (⊙o⊙)哦(⊙v⊙)嗯'</span>)</span><br><span class="line">        A.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        t = obj()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">有锁时的输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thread-1  123</span></span><br><span class="line"><span class="string">Thread-1  456</span></span><br><span class="line"><span class="string">Thread-1  qweqwe</span></span><br><span class="line"><span class="string">Thread-1  asdfaaa</span></span><br><span class="line"><span class="string">Thread-1  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string">Thread-2  123</span></span><br><span class="line"><span class="string">Thread-2  456</span></span><br><span class="line"><span class="string">Thread-2  qweqwe</span></span><br><span class="line"><span class="string">Thread-2  asdfaaa</span></span><br><span class="line"><span class="string">Thread-2  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">去掉锁的输出</span></span><br><span class="line"><span class="string">Thread-1  123</span></span><br><span class="line"><span class="string">Thread-1  456</span></span><br><span class="line"><span class="string">Thread-2  123</span></span><br><span class="line"><span class="string">Thread-2  456</span></span><br><span class="line"><span class="string">Thread-2  qweqweThread-1  qweqwe    # 这里说明，线程2把数据写入了输出缓冲区，还没来得及输出呢，就被线程1给抢了，随着线程1一起输出了；</span></span><br><span class="line"><span class="string">Thread-1  asdfaaa</span></span><br><span class="line"><span class="string">Thread-1  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string">                                    # 这一个空行就是线程2为打印出来的，它回来接着这里打印 </span></span><br><span class="line"><span class="string">Thread-2  asdfaaa</span></span><br><span class="line"><span class="string">Thread-2  (⊙o⊙)哦(⊙v⊙)嗯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">之所以能被抢还是因为这是IO操作，释放了全局解释器锁</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="四、信号量（semaphore）"><a href="#四、信号量（semaphore）" class="headerlink" title="四、信号量（semaphore）"></a>四、信号量（semaphore）</h2><h3 id="1、什么是信号量？"><a href="#1、什么是信号量？" class="headerlink" title="1、什么是信号量？"></a>1、什么是信号量？</h3><p>同进程的一样，semaphore管理一个内置的计数器，每当调用acquire()时内置函数-1，每当调用release()时内置函数+1。</p><p>计数器不能为0，当计数器为0时acquire（）将阻塞线程，直到其他线程调用release（）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mysf = threading.Semaphore(<span class="number">5</span>)  <span class="comment"># 创建信号量对象,(5表示这个锁同时支持的个数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> mysf.acquire():  <span class="comment"># 因为使用了信号量，下面的输出就会5个5个的同时输出</span></span><br><span class="line">        print(threading.currentThread().getName() + <span class="string">'  get semaphore'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        mysf.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        t = threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><h1 id="为什么在python中推荐使用多进程而不是多线程"><a href="#为什么在python中推荐使用多进程而不是多线程" class="headerlink" title="为什么在python中推荐使用多进程而不是多线程"></a><a href="https://www.cnblogs.com/raind/p/10078873.html" target="_blank" rel="noopener">为什么在python中推荐使用多进程而不是多线程</a></h1><h2 id="每个CPU在同一时间只能执行一个线程"><a href="#每个CPU在同一时间只能执行一个线程" class="headerlink" title="每个CPU在同一时间只能执行一个线程"></a>每个CPU在同一时间只能执行一个线程</h2><p>在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生</p><h2 id="在Python多线程下，每个线程的执行方式"><a href="#在Python多线程下，每个线程的执行方式" class="headerlink" title="在Python多线程下，每个线程的执行方式"></a>在Python多线程下，每个线程的执行方式</h2><p>1、获取GIL</p><p> 2、执行代码直到sleep或者是python虚拟机将其挂起。</p><p> 3、释放GIL   </p><p> 可见，某个线程想要执行，必须先拿到GIL，GIL会根据执行的字节码行数以及时间片释放，并且在遇到io操作的时候会主动释放。我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。 而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。</p><h2 id="那么是不是python的多线程就完全没用了呢？"><a href="#那么是不是python的多线程就完全没用了呢？" class="headerlink" title="那么是不是python的多线程就完全没用了呢？"></a>那么是不是python的多线程就完全没用了呢？</h2><p>在这里我们进行分类讨论：        </p><p> 1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。         </p><p>2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。                 </p><p>而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。                                         </p><p>请注意：多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低                                          </p><p>回到最开始的问题：经常我们会听到老手说：“python下想要充分利用多核CPU，就用多进程”，原因是什么呢？         </p><p>原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。   </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Python中的锁&quot;&gt;&lt;a href=&quot;#Python中的锁&quot; class=&quot;headerlink&quot; title=&quot;Python中的锁&quot;&gt;&lt;/a&gt;Python中的锁&lt;/h1&gt;&lt;h2 id=&quot;一、全局解释器锁（GIL）&quot;&gt;&lt;a href=&quot;#一、全局解释器锁（GIL）&quot; class=&quot;headerlink&quot; title=&quot;一、全局解释器锁（GIL）&quot;&gt;&lt;/a&gt;一、全局解释器锁（GIL）&lt;/h2&gt;&lt;h3 id=&quot;1、什么是全局解释器锁&quot;&gt;&lt;a href=&quot;#1、什么是全局解释器锁&quot; class=&quot;headerlink&quot; title=&quot;1、什么是全局解释器锁&quot;&gt;&lt;/a&gt;1、什么是全局解释器锁&lt;/h3&gt;&lt;p&gt;在同一个进程中只要有一个线程获取了全局解释器（cpu）的使用权限，那么其他的线程就必须等待该线程的全局解释器（cpu）使用权消失后才能使用全局解释器（cpu）, 即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU 上运行该进程的一个线程。&lt;/li&gt;
&lt;li&gt;CPython中&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;IO密集型&lt;/strong&gt;，某个线程阻塞，就会调度其他就绪线程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU密集型&lt;/strong&gt;，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在CPython中由于有GIL存在，IO密集型，使用多线程较为合算；CPU密集型，使用多进程，要绕开GIL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python中绝大多数内置数据结构的读、写操作都是原子操作。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身 不是 线程安全类型。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="全局解释器锁" scheme="http://yoursite.com/tags/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"/>
    
    <category term="同步锁" scheme="http://yoursite.com/tags/%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    
    <category term="递归锁" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E9%94%81/"/>
    
    <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="信号量" scheme="http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://yoursite.com/2020/08/07/redis/"/>
    <id>http://yoursite.com/2020/08/07/redis/</id>
    <published>2020-08-07T03:20:32.000Z</published>
    <updated>2020-08-31T02:14:31.080Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、-概念"><a href="#一、-概念" class="headerlink" title="一、 概念"></a>一、 概念</h2><pre><code>redis是一款高性能的NOSQL系列的非关系型数据库</code></pre><h3 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1.什么是NOSQL"></a>1.1.什么是NOSQL</h3><pre><code>        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</code></pre><h4 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1.    NOSQL和关系型数据库比较"></a>1.1.1.    NOSQL和关系型数据库比较</h4><pre><code>            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。</code></pre><p><img src="/.com//1.关系型和非关系型数据库比较.bmp" alt="1.关系型和非关系型数据库比较"></p><a id="more"></a><h4 id="1-1-2-非关系型数据库的优势："><a href="#1-1-2-非关系型数据库的优势：" class="headerlink" title="1.1.2.    非关系型数据库的优势："></a>1.1.2.    非关系型数据库的优势：</h4><pre><code>            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</code></pre><h4 id="1-1-3-关系型数据库的优势："><a href="#1-1-3-关系型数据库的优势：" class="headerlink" title="1.1.3.    关系型数据库的优势："></a>1.1.3.    关系型数据库的优势：</h4><pre><code>            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</code></pre><h4 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4.    总结"></a>1.1.4.    总结</h4><pre><code>            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，            让NoSQL数据库对关系型数据库的不足进行弥补。            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</code></pre><h3 id="1-2-主流的NOSQL产品"><a href="#1-2-主流的NOSQL产品" class="headerlink" title="1.2.主流的NOSQL产品"></a>1.2.主流的NOSQL产品</h3><pre><code>        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</code></pre><h3 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h3><pre><code>        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset</code></pre><h4 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h4><pre><code>            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离</code></pre><h2 id="二、下载安装"><a href="#二、下载安装" class="headerlink" title="二、下载安装"></a>二、下载安装</h2><pre><code>    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端</code></pre><h2 id="三、命令操作"><a href="#三、命令操作" class="headerlink" title="三、命令操作"></a>三、命令操作</h2><h3 id="1-redis的数据结构："><a href="#1-redis的数据结构：" class="headerlink" title="1. redis的数据结构："></a>1. redis的数据结构：</h3><pre><code>        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</code></pre><p><img src="/.com//2.redis数据结构.bmp" alt="2.redis数据结构"></p><h3 id="2-字符串类型-string"><a href="#2-字符串类型-string" class="headerlink" title="2. 字符串类型 string"></a>2. 字符串类型 string</h3><pre><code>        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1</code></pre><h3 id="3-哈希类型-hash"><a href="#3-哈希类型-hash" class="headerlink" title="3. 哈希类型 hash"></a>3. 哈希类型 hash</h3><pre><code>        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1</code></pre><h3 id="4-列表类型-list"><a href="#4-列表类型-list" class="headerlink" title="4. 列表类型 list"></a>4. 列表类型 list</h3><p><strong>可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong></p><pre><code>        1. 添加：            1. lpush key value: 将元素加入列表左表            2. rpush key value：将元素加入列表右边                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回</code></pre><h3 id="5-集合类型-set-：-不允许重复元素"><a href="#5-集合类型-set-：-不允许重复元素" class="headerlink" title="5. 集合类型 set ： 不允许重复元素"></a>5. 集合类型 set ： 不允许重复元素</h3><pre><code>        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1</code></pre><h3 id="6-有序集合类型"><a href="#6-有序集合类型" class="headerlink" title="6. 有序集合类型"></a>6. 有序集合类型</h3><p>sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><pre><code>        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1</code></pre><h3 id="7-通用命令"><a href="#7-通用命令" class="headerlink" title="7. 通用命令"></a>7. 通用命令</h3><pre><code>        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value</code></pre><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><pre><code>    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化</code></pre><h2 id="五、Java客户端-Jedis"><a href="#五、Java客户端-Jedis" class="headerlink" title="五、Java客户端 Jedis"></a>五、Java客户端 Jedis</h2><h3 id="一、Jedis"><a href="#一、Jedis" class="headerlink" title="一、Jedis"></a>一、Jedis</h3><p>一款java操作redis数据库的工具.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 使用步骤：</span><br><span class="line"><span class="number">1</span>. 下载jedis的jar包</span><br><span class="line"><span class="number">2</span>. 使用</span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">   Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">  <span class="comment">//2. 操作</span></span><br><span class="line">  jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">   <span class="comment">//3. 关闭连接</span></span><br><span class="line">   jedis.close();</span><br></pre></td></tr></table></figure><h3 id="二、Jedis操作各种redis中的数据结构"><a href="#二、Jedis操作各种redis中的数据结构" class="headerlink" title="二、Jedis操作各种redis中的数据结构"></a>二、Jedis操作各种redis中的数据结构</h3><h4 id="1-字符串类型-string"><a href="#1-字符串类型-string" class="headerlink" title="1) 字符串类型 string"></a>1) 字符串类型 string</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">get</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">//存储</span></span><br><span class="line">      jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">      <span class="comment">//获取</span></span><br><span class="line">      String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">      System.out.println(username);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">      jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure><h4 id="2-哈希类型-hash-：-map格式"><a href="#2-哈希类型-hash-：-map格式" class="headerlink" title="2) 哈希类型 hash ： map格式"></a>2) 哈希类型 hash ： map格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hset</span><br><span class="line">hget</span><br><span class="line">hgetAll</span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// 存储hash</span></span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取hash</span></span><br><span class="line">      String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">      System.out.println(name);</span><br><span class="line">      <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">      Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// keyset</span></span><br><span class="line">      Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line">      <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">          <span class="comment">//获取value</span></span><br><span class="line">          String value = user.get(key);</span><br><span class="line">          System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure><h4 id="3-列表类型-list-：-linkedlist格式。支持重复元素"><a href="#3-列表类型-list-：-linkedlist格式。支持重复元素" class="headerlink" title="3) 列表类型 list ： linkedlist格式。支持重复元素"></a>3) 列表类型 list ： linkedlist格式。支持重复元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lpush / rpush</span><br><span class="line">lpop / rpop</span><br><span class="line">lrange start end : 范围获取</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// list 存储</span></span><br><span class="line">      jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">      jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// list 弹出</span></span><br><span class="line">      String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element1);</span><br><span class="line"></span><br><span class="line">      String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure><h4 id="4-集合类型-set-：-不允许重复元素"><a href="#4-集合类型-set-：-不允许重复元素" class="headerlink" title="4) 集合类型 set  ： 不允许重复元素"></a>4) 集合类型 set  ： 不允许重复元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sadd</span><br><span class="line">smembers:获取所有元素</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// set 存储</span></span><br><span class="line">      jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// set 获取</span></span><br><span class="line">      Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">      System.out.println(myset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure><h4 id="5-有序集合类型-sortedset：不允许重复元素，且元素有顺序"><a href="#5-有序集合类型-sortedset：不允许重复元素，且元素有顺序" class="headerlink" title="5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序"></a>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zadd</span><br><span class="line">zrange</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// sortedset 存储</span></span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// sortedset 获取</span></span><br><span class="line">      Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mysortedset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="三、jedis连接池：-JedisPool"><a href="#三、jedis连接池：-JedisPool" class="headerlink" title="三、jedis连接池： JedisPool"></a>三、jedis连接池： JedisPool</h3><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 创建JedisPool连接池对象</span><br><span class="line"><span class="number">2</span>. 调用方法 getResource()方法获取Jedis连接</span><br><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">       JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">       config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">       config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">       JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.获取连接</span></span><br><span class="line">       Jedis jedis = jedisPool.getResource();</span><br><span class="line">       <span class="comment">//3. 使用</span></span><br><span class="line">       jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line">       <span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">       jedis.close();</span><br></pre></td></tr></table></figure><h4 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;一、-概念&quot;&gt;&lt;a href=&quot;#一、-概念&quot; class=&quot;headerlink&quot; title=&quot;一、 概念&quot;&gt;&lt;/a&gt;一、 概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;redis是一款高性能的NOSQL系列的非关系型数据库
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-1-什么是NOSQL&quot;&gt;&lt;a href=&quot;#1-1-什么是NOSQL&quot; class=&quot;headerlink&quot; title=&quot;1.1.什么是NOSQL&quot;&gt;&lt;/a&gt;1.1.什么是NOSQL&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1-1-1-NOSQL和关系型数据库比较&quot;&gt;&lt;a href=&quot;#1-1-1-NOSQL和关系型数据库比较&quot; class=&quot;headerlink&quot; title=&quot;1.1.1.    NOSQL和关系型数据库比较&quot;&gt;&lt;/a&gt;1.1.1.    NOSQL和关系型数据库比较&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;            优点：
                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。
                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。
                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。

            缺点：
                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。
                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。
                3）不提供关系型数据库对事务的处理。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/.com//1.关系型和非关系型数据库比较.bmp&quot; alt=&quot;1.关系型和非关系型数据库比较&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="redis" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX_JSON</title>
    <link href="http://yoursite.com/2020/08/07/AJAX-JSON/"/>
    <id>http://yoursite.com/2020/08/07/AJAX-JSON/</id>
    <published>2020-08-07T00:47:37.000Z</published>
    <updated>2020-08-31T02:15:04.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>ASynchronous JavaScript And XML    异步的JavaScript 和 XML</code></pre><h3 id="1-异步和同步：客户端和服务器端相互通信的基础上"><a href="#1-异步和同步：客户端和服务器端相互通信的基础上" class="headerlink" title="1. 异步和同步：客户端和服务器端相互通信的基础上"></a>1. 异步和同步：客户端和服务器端相互通信的基础上</h3><pre><code>        * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。        * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。        Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1]         通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。        提升用户的体验</code></pre><p><img src="/.com//1.同步和异步.bmp" alt="1.同步和异步"></p><a id="more"></a><h2 id="二、实现方式："><a href="#二、实现方式：" class="headerlink" title="二、实现方式："></a>二、实现方式：</h2><h3 id="1-原生的JS实现方式（了解）"><a href="#1-原生的JS实现方式（了解）" class="headerlink" title="1. 原生的JS实现方式（了解）"></a>1. 原生的JS实现方式（了解）</h3><pre><code>                 //1.创建核心对象                var xmlhttp;                if (window.XMLHttpRequest)                {// code for IE7+, Firefox, Chrome, Opera, Safari                    xmlhttp=new XMLHttpRequest();                }                else                {// code for IE6, IE5                    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);                }                //2. 建立连接                /*                    参数：                        1. 请求方式：GET、POST                            * get方式，请求参数在URL后边拼接。send方法为空参                            * post方式，请求参数在send方法中定义                        2. 请求的URL：                        3. 同步或异步请求：true（异步）或 false（同步）                 */                xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);                //3.发送请求                xmlhttp.send();                //4.接受并处理来自服务器的响应结果                //获取方式 ：xmlhttp.responseText                //什么时候获取？当服务器响应成功后再获取                //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。                xmlhttp.onreadystatechange=function()                {                    //判断readyState就绪状态是否为4，判断status响应状态码是否为200                    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)                    {                       //获取服务器的响应结果                        var responseText = xmlhttp.responseText;                        alert(responseText);                    }                }</code></pre><h3 id="2-JQeury实现方式"><a href="#2-JQeury实现方式" class="headerlink" title="2. JQeury实现方式"></a>2. JQeury实现方式</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* 语法：$.ajax(&#123;键值对&#125;);</span><br><span class="line"> <span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">              url:"ajaxServlet1111" , // 请求路径</span><br><span class="line">              type:"POST" , //请求方式</span><br><span class="line">              <span class="comment">//data: "username=jack&amp;age=23",//请求参数</span></span><br><span class="line">              data:&#123;"username":"jack","age":23&#125;,</span><br><span class="line">              success:function (data) &#123;</span><br><span class="line">                  alert(data);</span><br><span class="line">              &#125;,//响应成功后的回调函数</span><br><span class="line">              error:function () &#123;</span><br><span class="line">                  alert("出错啦...")</span><br><span class="line">              &#125;,//表示如果请求响应出现错误，会执行的回调函数</span><br><span class="line"></span><br><span class="line">              dataType:"text"//设置接受到的响应数据的格式</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><h4 id="get-：发送get请求"><a href="#get-：发送get请求" class="headerlink" title="$.get()：发送get请求"></a>$.get()：发送get请求</h4><pre><code>            * 语法：$.get(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型</code></pre><h4 id="post-：发送post请求"><a href="#post-：发送post请求" class="headerlink" title="$.post()：发送post请求"></a>$.post()：发送post请求</h4><pre><code>            * 语法：$.post(url, [data], [callback], [type])                * 参数：                    * url：请求路径                    * data：请求参数                    * callback：回调函数                    * type：响应结果的类型</code></pre><h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><h2 id="一、概念-1"><a href="#一、概念-1" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>JavaScript Object Notation        JavaScript对象表示法    Person p = new Person();    p.setName(&quot;张三&quot;);    p.setAge(23);    p.setGender(&quot;男&quot;);    var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;};    * json现在多用于存储和交换文本信息的语法    * 进行数据的传输    * JSON 比 XML 更小、更快，更易解析。</code></pre><h2 id="二、语法："><a href="#二、语法：" class="headerlink" title="二、语法："></a>二、语法：</h2><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><pre><code>        * 数据在名称/值对中：json数据是由键值对构成的            * 键用引号(单双都行)引起来，也可以不使用引号            * 值得取值类型：                1. 数字（整数或浮点数）                2. 字符串（在双引号中）                3. 逻辑值（true 或 false）                4. 数组（在方括号中）    {&quot;persons&quot;:[{},{}]}                5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}}                6. null        * 数据由逗号分隔：多个键值对由逗号分隔        * 花括号保存对象：使用{}定义json 格式        * 方括号保存数组：[]</code></pre><h3 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据:"></a>2. 获取数据:</h3><pre><code>        1. json对象.键名        2. json对象[&quot;键名&quot;]        3. 数组对象[索引]        4. 遍历                 //1.定义基本格式                var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &#39;gender&#39;: true};                var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true},                    {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true},                    {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}];                //获取person对象中所有的键和值                //for in 循环               /* for(var key in person){                    //这样的方式获取不行。因为相当于  person.&quot;name&quot;                    //alert(key + &quot;:&quot; + person.key);                    alert(key+&quot;:&quot;+person[key]);                }*/               //获取ps中的所有值                for (var i = 0; i &lt; ps.length; i++) {                    var p = ps[i];                    for(var key in p){                        alert(key+&quot;:&quot;+p[key]);                    }                }</code></pre><h2 id="三、JSON数据和Java对象的相互转换"><a href="#三、JSON数据和Java对象的相互转换" class="headerlink" title="三、JSON数据和Java对象的相互转换"></a>三、JSON数据和Java对象的相互转换</h2><pre><code>    * JSON解析器：        * 常见的解析器：Jsonlib，Gson，fastjson，jackson</code></pre><h3 id="1-JSON转为Java对象"><a href="#1-JSON转为Java对象" class="headerlink" title="1. JSON转为Java对象"></a>1. JSON转为Java对象</h3><pre><code>        1. 导入jackson的相关jar包        2. 创建Jackson核心对象 ObjectMapper        3. 调用ObjectMapper的相关方法进行转换            1. readValue(json字符串数据,Class)</code></pre><h3 id="2-Java对象转换JSON"><a href="#2-Java对象转换JSON" class="headerlink" title="2. Java对象转换JSON"></a>2. Java对象转换JSON</h3><pre><code>        1. 使用步骤：            1. 导入jackson的相关jar包            2. 创建Jackson核心对象 ObjectMapper            3. 调用ObjectMapper的相关方法进行转换                1. 转换方法：                    * writeValue(参数1，obj):                        参数1：                            File：将obj对象转换为JSON字符串，并保存到指定的文件中                            Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中                            OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中                    * writeValueAsString(obj):将对象转为json字符串                2. 注解：                    1. @JsonIgnore：排除属性。                    2. @JsonFormat：属性值得格式化                        * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)                3. 复杂java对象转换                    1. List：数组                    2. Map：对象格式一致</code></pre><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><pre><code>* 校验用户名是否存在    1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：        1. $.get(type):将最后一个参数type指定为&quot;json&quot;        2. 在服务器端设置MIME类型            response.setContentType(&quot;application/json;charset=utf-8&quot;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AJAX：&quot;&gt;&lt;a href=&quot;#AJAX：&quot; class=&quot;headerlink&quot; title=&quot;AJAX：&quot;&gt;&lt;/a&gt;AJAX：&lt;/h1&gt;&lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ASynchronous JavaScript And XML    异步的JavaScript 和 XML
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-异步和同步：客户端和服务器端相互通信的基础上&quot;&gt;&lt;a href=&quot;#1-异步和同步：客户端和服务器端相互通信的基础上&quot; class=&quot;headerlink&quot; title=&quot;1. 异步和同步：客户端和服务器端相互通信的基础上&quot;&gt;&lt;/a&gt;1. 异步和同步：客户端和服务器端相互通信的基础上&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;        * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。
        * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。

        Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 
        通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

        提升用户的体验
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;/.com//1.同步和异步.bmp&quot; alt=&quot;1.同步和异步&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>JQuery</title>
    <link href="http://yoursite.com/2020/08/06/JQuery-beginning/"/>
    <id>http://yoursite.com/2020/08/06/JQuery-beginning/</id>
    <published>2020-08-06T06:37:54.000Z</published>
    <updated>2020-08-31T02:16:12.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JQuery-基础："><a href="#JQuery-基础：" class="headerlink" title="JQuery 基础："></a>JQuery 基础：</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><pre><code>    一个JavaScript框架。简化JS开发    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已</code></pre><h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><pre><code>    1. 步骤：        1. 下载JQuery            * 目前jQuery有三个大版本：                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，                     最终版本：1.12.4 (2016年5月20日)                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，                     最终版本：2.2.4 (2016年5月20日)                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）            * jquery-xxx.js 与 jquery-xxx.min.js区别：                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快        2. 导入JQuery的js文件：导入min.js文件        3. 使用            var div1 = $(&quot;#div1&quot;);            alert(div1.html());</code></pre><h2 id="三、JQuery对象和JS对象区别与转换"><a href="#三、JQuery对象和JS对象区别与转换" class="headerlink" title="三、JQuery对象和JS对象区别与转换"></a>三、JQuery对象和JS对象区别与转换</h2><pre><code>    1. JQuery对象在操作时，更加方便。    2. JQuery对象和js对象方法不通用的.    3. 两者相互转换        * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引)        * js -- &gt; jq : $(js对象)</code></pre><a id="more"></a><h2 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a>四、选择器</h2><p>筛选具有相似特征的元素(标签)</p><h3 id="1-基本操作学习："><a href="#1-基本操作学习：" class="headerlink" title="1. 基本操作学习："></a>1. 基本操作学习：</h3><h4 id="（1）-事件绑定"><a href="#（1）-事件绑定" class="headerlink" title="（1） 事件绑定"></a>（1） 事件绑定</h4><pre><code>            //1.获取b1按钮            $(&quot;#b1&quot;).click(function(){                alert(&quot;abc&quot;);            });</code></pre><h4 id="（2）-入口函数"><a href="#（2）-入口函数" class="headerlink" title="（2） 入口函数"></a>（2） 入口函数</h4><pre><code>             $(function () {                });             window.onload  和 $(function) 区别                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉                 * $(function)可以定义多次的。</code></pre><h4 id="（3）-样式控制：css方法"><a href="#（3）-样式控制：css方法" class="headerlink" title="（3） 样式控制：css方法"></a>（3） 样式控制：css方法</h4><pre><code>             // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;);              $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;);</code></pre><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><h4 id="（1）-基本选择器"><a href="#（1）-基本选择器" class="headerlink" title="（1） 基本选择器"></a>（1） 基本选择器</h4><pre><code>            1. 标签选择器（元素选择器）                * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素            2. id选择器                 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素            3. 类选择器                * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素            4. 并集选择器：                * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素</code></pre><h4 id="2-层级选择器"><a href="#2-层级选择器" class="headerlink" title="(2) 层级选择器"></a>(2) 层级选择器</h4><pre><code>            1. 后代选择器                * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素                    2. 子选择器                * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素</code></pre><h4 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="(3) 属性选择器"></a>(3) 属性选择器</h4><pre><code>            1. 属性名称选择器                 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器            2. 属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器            3. 复合属性选择器                * 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器</code></pre><h4 id="4-过滤选择器"><a href="#4-过滤选择器" class="headerlink" title="(4) 过滤选择器"></a>(4) 过滤选择器</h4><pre><code>            1. 首元素选择器                 * 语法： :first 获得选择的元素中的第一个元素            2. 尾元素选择器                 * 语法： :last 获得选择的元素中的最后一个元素            3. 非元素选择器                * 语法： :not(selector) 不包括指定内容的元素            4. 偶数选择器                * 语法： :even 偶数，从 0 开始计数            5. 奇数选择器                * 语法： :odd 奇数，从 0 开始计数            6. 等于索引选择器                * 语法： :eq(index) 指定索引元素            7. 大于索引选择器                 * 语法： :gt(index) 大于指定索引元素            8. 小于索引选择器                 * 语法： :lt(index) 小于指定索引元素            9. 标题选择器                * 语法： :header 获得标题（h1~h6）元素，固定写法</code></pre><h4 id="5-表单过滤选择器"><a href="#5-表单过滤选择器" class="headerlink" title="(5) 表单过滤选择器"></a>(5) 表单过滤选择器</h4><pre><code>            1. 可用元素选择器                 * 语法： :enabled 获得可用元素            2. 不可用元素选择器                 * 语法： :disabled 获得不可用元素            3. 选中选择器                 * 语法： :checked 获得单选/复选框选中的元素            4. 选中选择器                 * 语法： :selected 获得下拉框选中的元素</code></pre><h2 id="五、DOM操作"><a href="#五、DOM操作" class="headerlink" title="五、DOM操作"></a>五、DOM操作</h2><pre><code>    1. 内容操作        1. html(): 获取/设置元素的标签体内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt;  --&gt; &lt;font&gt;内容&lt;/font&gt;        2. text(): 获取/设置元素的标签体纯文本内容   &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容        3. val()： 获取/设置元素的value属性值    2. 属性操作        1. 通用属性操作            1. attr(): 获取/设置元素的属性            2. removeAttr():删除属性            3. prop():获取/设置元素的属性            4. removeProp():删除属性            * attr和prop区别？                1. 如果操作的是元素的固有属性，则建议使用prop                2. 如果操作的是元素自定义的属性，则建议使用attr        2. 对class属性操作            1. addClass():添加class属性值            2. removeClass():删除class属性值            3. toggleClass():切换class属性                * toggleClass(&quot;one&quot;):                     * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。  如果元素对象上不存在class=&quot;one&quot;，则添加            4. css():    3. CRUD操作:        1. append():父元素将子元素追加到末尾            * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾        2. prepend():父元素将子元素追加到开头            * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头        3. appendTo():            * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾        4. prependTo()：            * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头        5. after():添加元素到元素后边            * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系        6. before():添加元素到元素前边            * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        7. insertAfter()            * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系        8. insertBefore()            * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系        9. remove():移除元素            * 对象.remove():将对象删除掉        10. empty():清空元素的所有后代元素。            * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</code></pre><h2 id="六、案例"><a href="#六、案例" class="headerlink" title="六、案例"></a>六、案例</h2><h1 id="JQuery-高级"><a href="#JQuery-高级" class="headerlink" title="JQuery 高级"></a>JQuery 高级</h1><h2 id="一、动画"><a href="#一、动画" class="headerlink" title="一、动画"></a>一、动画</h2><h3 id="1-三种方式显示和隐藏元素"><a href="#1-三种方式显示和隐藏元素" class="headerlink" title="1. 三种方式显示和隐藏元素"></a>1. 三种方式显示和隐藏元素</h3><pre><code>        1. 默认显示和隐藏方式            1. show([speed,[easing],[fn]])                1. 参数：                    1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000)                    2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;                        * swing：动画执行时效果是 先慢，中间快，最后又慢                        * linear：动画执行时速度是匀速的                    3. fn：在动画完成时执行的函数，每个元素执行一次。            2. hide([speed,[easing],[fn]])            3. toggle([speed],[easing],[fn])        2. 滑动显示和隐藏方式            1. slideDown([speed],[easing],[fn])            2. slideUp([speed,[easing],[fn]])            3. slideToggle([speed],[easing],[fn])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed],[easing],[fn])            2. fadeOut([speed],[easing],[fn])            3. fadeToggle([speed,[easing],[fn]])</code></pre><h2 id="二、遍历"><a href="#二、遍历" class="headerlink" title="二、遍历"></a>二、遍历</h2><h3 id="1-js的遍历方式"><a href="#1-js的遍历方式" class="headerlink" title="1. js的遍历方式"></a>1. js的遍历方式</h3><pre><code>        * for(初始化值;循环结束条件;步长)</code></pre><h3 id="2-jq的遍历方式"><a href="#2-jq的遍历方式" class="headerlink" title="2. jq的遍历方式"></a>2. jq的遍历方式</h3><h4 id="1-jq对象-each-callback"><a href="#1-jq对象-each-callback" class="headerlink" title="(1) jq对象.each(callback)"></a>(1) jq对象.each(callback)</h4><pre><code>            1. 语法：                jquery对象.each(function(index,element){});                    * index:就是元素在集合中的索引                    * element：就是集合中的每一个元素对象                    * this：集合中的每一个元素对象            2. 回调函数返回值：                * true:如果当前function返回为false，则结束循环(break)。                * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)</code></pre><h4 id="2-each-object-callback"><a href="#2-each-object-callback" class="headerlink" title="(2) $.each(object, [callback])"></a>(2) $.each(object, [callback])</h4><h4 id="3-for-of-jquery-3-0-版本之后提供的方式"><a href="#3-for-of-jquery-3-0-版本之后提供的方式" class="headerlink" title="(3) for..of: jquery 3.0 版本之后提供的方式"></a>(3) for..of: jquery 3.0 版本之后提供的方式</h4><pre><code>            for(元素对象 of 容器对象)</code></pre><h2 id="三、-事件绑定"><a href="#三、-事件绑定" class="headerlink" title="三、 事件绑定"></a>三、 事件绑定</h2><h3 id="1-jquery标准的绑定方式"><a href="#1-jquery标准的绑定方式" class="headerlink" title="1. jquery标准的绑定方式"></a>1. jquery标准的绑定方式</h3><pre><code>        * jq对象.事件方法(回调函数)；        * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。            * 表单对象.submit();//让表单提交</code></pre><h3 id="2-on绑定事件-off解除绑定"><a href="#2-on绑定事件-off解除绑定" class="headerlink" title="2. on绑定事件/off解除绑定"></a>2. on绑定事件/off解除绑定</h3><pre><code>        * jq对象.on(&quot;事件名称&quot;,回调函数)        * jq对象.off(&quot;事件名称&quot;)            * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑</code></pre><h3 id="3-事件切换：toggle"><a href="#3-事件切换：toggle" class="headerlink" title="3. 事件切换：toggle"></a>3. 事件切换：toggle</h3><pre><code>        * jq对象.toggle(fn1,fn2...)            * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....        * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。             &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></pre><h2 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h2><pre><code>    1. 广告显示和隐藏        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt;            &lt;style&gt;                #content{width:100%;height:500px;background:#999}            &lt;/style&gt;            &lt;!--引入jquery--&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script&gt;                /*                    需求：                        1. 当页面加载完，3秒后。自动显示广告                        2. 广告显示5秒后，自动消失。                    分析：                        1. 使用定时器来完成。setTimeout (执行一次定时器)                        2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display                        3. 使用  show/hide方法来完成广告的显示                 */                //入口函数，在页面加载完成之后，定义定时器，调用这两个方法                $(function () {                   //定义定时器，调用adShow方法 3秒后执行一次                   setTimeout(adShow,3000);                   //定义定时器，调用adHide方法，8秒后执行一次                    setTimeout(adHide,8000);                });                //显示广告                function adShow() {                    //获取广告div，调用显示方法                    $(&quot;#ad&quot;).show(&quot;slow&quot;);                }                //隐藏广告                function adHide() {                    //获取广告div，调用隐藏方法                    $(&quot;#ad&quot;).hide(&quot;slow&quot;);                }</code></pre><p>​<br>​                &lt;/script&gt;<br>​            &lt;/head&gt;<br>​            <body><br>​            <!-- 整体的DIV --><br>​            <div>​                <!-- 广告DIV -->​                <div id="ad" style="display: none;">​                    <img style="width:100%" src="/.com//../../../../../video/study/黑马java57期/java/03-javaWeb/day21_JQuery高级/img/adv.jpg">​                </div><br>​            </div></body></p><pre><code>            &lt;!-- 下方正文部分 --&gt;            &lt;div id=&quot;content&quot;&gt;                正文部分            &lt;/div&gt;        &lt;/div&gt;        &lt;/body&gt;        &lt;/html&gt;    2. 抽奖        &lt;!DOCTYPE html&gt;        &lt;html&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;jquery案例之抽奖&lt;/title&gt;            &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;            &lt;script language=&#39;javascript&#39; type=&#39;text/javascript&#39;&gt;                /*                    分析：                        1. 给开始按钮绑定单击事件                            1.1 定义循环定时器                            1.2 切换小相框的src属性                                * 定义数组，存放图片资源路径                                * 生成随机数。数组索引                        2. 给结束按钮绑定单击事件                            1.1 停止定时器                            1.2 给大相框设置src属性                 */                var imgs = [&quot;../img/man00.jpg&quot;,                            &quot;../img/man01.jpg&quot;,                            &quot;../img/man02.jpg&quot;,                            &quot;../img/man03.jpg&quot;,                            &quot;../img/man04.jpg&quot;,                            &quot;../img/man05.jpg&quot;,                            &quot;../img/man06.jpg&quot;,                            ];                var startId;//开始定时器的id                var index;//随机角标                $(function () {                    //处理按钮是否可以使用的效果                    $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                    $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);                   //1. 给开始按钮绑定单击事件                    $(&quot;#startID&quot;).click(function () {                        // 1.1 定义循环定时器 20毫秒执行一次                        startId = setInterval(function () {                            //处理按钮是否可以使用的效果                            $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true);                            $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false);                            //1.2生成随机角标 0-6                            index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999                            //1.3设置小相框的src属性                            $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]);                        },20);                    });                    //2. 给结束按钮绑定单击事件                    $(&quot;#stopID&quot;).click(function () {                        //处理按钮是否可以使用的效果                        $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false);                        $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true);                       // 1.1 停止定时器                        clearInterval(startId);                       // 1.2 给大相框设置src属性                        $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide();                        //显示1秒之后                        $(&quot;#img2ID&quot;).show(1000);                    });                });</code></pre><p>​<br>​<br>​                &lt;/script&gt;<br>​            </p><pre><code>        &lt;/head&gt;        &lt;body&gt;        &lt;!-- 小像框 --&gt;        &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt;            &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 大像框 --&gt;        &lt;div                style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt;            &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt;        &lt;/div&gt;        &lt;!-- 开始按钮 --&gt;        &lt;input                id=&quot;startID&quot;                type=&quot;button&quot;                value=&quot;点击开始&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;        &lt;!-- 停止按钮 --&gt;        &lt;input                id=&quot;stopID&quot;                type=&quot;button&quot;                value=&quot;点击停止&quot;                style=&quot;width:150px;height:150px;font-size:22px&quot;&gt;        &lt;/body&gt;        &lt;/html&gt;</code></pre><h2 id="五、插件：增强JQuery的功能"><a href="#五、插件：增强JQuery的功能" class="headerlink" title="五、插件：增强JQuery的功能"></a>五、插件：增强JQuery的功能</h2><pre><code>    1. 实现方式：        1. $.fn.extend(object)             * 增强通过Jquery获取的对象的功能  $(&quot;#id&quot;)        2. $.extend(object)            * 增强JQeury对象自身的功能  $/jQuery</code></pre><p>​            </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JQuery-基础：&quot;&gt;&lt;a href=&quot;#JQuery-基础：&quot; class=&quot;headerlink&quot; title=&quot;JQuery 基础：&quot;&gt;&lt;/a&gt;JQuery 基础：&lt;/h1&gt;&lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    一个JavaScript框架。简化JS开发
    * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨    是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优    化HTML文档操作、事件处理、动画设计和Ajax交互。

    * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;二、快速入门&quot;&gt;&lt;a href=&quot;#二、快速入门&quot; class=&quot;headerlink&quot; title=&quot;二、快速入门&quot;&gt;&lt;/a&gt;二、快速入门&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    1. 步骤：
        1. 下载JQuery
            * 目前jQuery有三个大版本：
                1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，
                     功能不再新增。因此一般项目来说，使用1.x版本就可以了，
                     最终版本：1.12.4 (2016年5月20日)
                2.x：不兼容ie678，很少有人使用，官方只做BUG维护，
                     功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，
                     最终版本：2.2.4 (2016年5月20日)
                3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，
                     一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。
                     目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）
            * jquery-xxx.js 与 jquery-xxx.min.js区别：
                1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些
                2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快

        2. 导入JQuery的js文件：导入min.js文件
        3. 使用
            var div1 = $(&amp;quot;#div1&amp;quot;);
            alert(div1.html());
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;三、JQuery对象和JS对象区别与转换&quot;&gt;&lt;a href=&quot;#三、JQuery对象和JS对象区别与转换&quot; class=&quot;headerlink&quot; title=&quot;三、JQuery对象和JS对象区别与转换&quot;&gt;&lt;/a&gt;三、JQuery对象和JS对象区别与转换&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    1. JQuery对象在操作时，更加方便。
    2. JQuery对象和js对象方法不通用的.
    3. 两者相互转换
        * jq -- &amp;gt; js : jq对象[索引] 或者 jq对象.get(索引)
        * js -- &amp;gt; jq : $(js对象)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
    <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
    <category term="JQuery" scheme="http://yoursite.com/tags/JQuery/"/>
    
  </entry>
  
</feed>
