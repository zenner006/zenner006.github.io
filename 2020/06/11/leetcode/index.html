<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构,算法,编程题," />










<meta name="description" content="leetcode标签（空格分隔）： 2020 编程 [TOC]">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="http://yoursite.com/2020/06/11/leetcode/index.html">
<meta property="og:site_name" content="zenner&#39;s Blog">
<meta property="og:description" content="leetcode标签（空格分隔）： 2020 编程 [TOC]">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-06-11T12:22:50.000Z">
<meta property="article:modified_time" content="2020-10-07T09:20:41.501Z">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="编程题">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/11/leetcode/"/>





  <title>leetcode | zenner's Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zenner's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">巨饼的技术博</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/11/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zenner's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-11T20:22:50+08:00">
                2020-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p>标签（空格分隔）： 2020 编程</p>
<p>[TOC]</p>
<a id="more"></a>
<hr>
<h1 id="2-两数相加-中等）"><a href="#2-两数相加-中等）" class="headerlink" title="2. 两数相加 (中等）"></a>2. 两数相加 (中等）</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        L = ListNode(-1)
        i = L
        if not l1:return l2
        if not l2:return l1
        n = 0
        while l1 and l2:
            a = l1.val +l2.val + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            l1 = l1.next
            l2 = l2.next
        B = l1 if not l2 else l2
        while B:
            a = B.val + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            B = B.next
        if n != 0:
            i.next = ListNode(n)
        return L.next
</code></pre><p>一个修正了的答案</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        L = ListNode(-1)
        i = L
        if not l1:return l2
        if not l2:return l1
        n = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            a = x + y + n
            m = a%10
            n = a//10
            i.next = ListNode(m)
            i = i.next
            if l1:l1 = l1.next
            if l2:l2 = l2.next
        if n != 0:
            i.next = ListNode(n)
        return L.next
</code></pre><hr>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<pre><code># 我的这个答案的结果很差，勉强能通过
class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        if not s:
            return 0
        dp = [1]*len(s)
        for i in range(len(s)):
            for j in range(i+1,len(s)):
                if s[j] not in s[i:j]:
                    dp[i] += 1
                else:
                    break
        return max(dp)
</code></pre><p>看了一下答案，这个题目是可以学习滑动窗口的！</p>
<hr>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line"><span class="function">    # 走一个滑动窗口，长度为2（两种相同的字符）或者3（第一个和第三个相同）</span></span><br><span class="line"><span class="function">    # 需要记录最长回文子串的变量t</span></span><br><span class="line"><span class="function">    # 最长自串长度用<span class="title">len</span><span class="params">(t)</span>得到</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> not s:</span></span><br><span class="line"><span class="function">        return s</span></span><br><span class="line"><span class="function">    e </span>= len(s)</span><br><span class="line">    r1,r2 = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    t = s[<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">for</span> l in <span class="title">range</span><span class="params">(len(s)</span>):</span></span><br><span class="line"><span class="function">        <span class="title">print</span><span class="params">(<span class="string">"l:"</span>+str(l)</span>+" r1:"+<span class="title">str</span><span class="params">(r1)</span>+" r2:"+<span class="title">str</span><span class="params">(r2)</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> r2&lt;e and s[l] </span>== s[r2]:</span><br><span class="line">            i,j = l,r2</span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> and j&lt;len(s):</span><br><span class="line">                <span class="keyword">if</span> i-<span class="number">1</span>&lt;<span class="number">0</span> or j+<span class="number">1</span>==e or s[i-<span class="number">1</span>] != s[j+<span class="number">1</span>]:</span><br><span class="line">                    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(t)</span> &lt; j-i+1:</span></span><br><span class="line"><span class="function">                        t </span>= s[i:j+<span class="number">1</span>]</span><br><span class="line">                        print(i)</span><br><span class="line">                        print(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r1&lt;e and s[l] == s[r1]:</span><br><span class="line">            i,j = l,r1</span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> and j&lt;len(s):</span><br><span class="line">                    <span class="keyword">if</span> i-<span class="number">1</span>&lt;<span class="number">0</span> or j+<span class="number">1</span>==e or s[i-<span class="number">1</span>] != s[j+<span class="number">1</span>]:</span><br><span class="line">                        <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(t)</span> &lt; j-i+1:</span></span><br><span class="line"><span class="function">                            t </span>= s[i:j+<span class="number">1</span>]</span><br><span class="line">                            print(i)</span><br><span class="line">                            print(j)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        i -= <span class="number">1</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">        r1+=<span class="number">1</span></span><br><span class="line">        r2+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure>
<!-- more -->
<hr>
<h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a>6. Z 字形变换</h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L   C   I   R<br>E T O E S I I G<br>E   D   H   N</p>
<pre><code>def convert(self, s: str, numRows: int) -&gt; str:
    if not s or numRows&lt;2:
        return s
    size = len(s)
    Lines = [[] for _ in range(numRows)]
    p = 0
    d = 1
    for i in s:
        print(p)
        Lines[p].append(i)
        if p == numRows - 1:
            d = -1
        if p == 0:
            d = 1
        p += d
    T = &quot;&quot;
    for i in Lines:
        T += &quot;&quot;.join(i)
    return T
</code></pre><hr>
<h1 id="7-整数翻转"><a href="#7-整数翻转" class="headerlink" title="7. 整数翻转"></a>7. 整数翻转</h1><pre><code># 用字符串反转达成
# python3
class Solution:
def reverse(self, x: int) -&gt; int:
    f = True
    if x &lt; 0 :
        f = False
    y = str(abs(x))
    y = list(y)
    y = y[::-1]
    z = 0
    for i in y:
        z = 10*z + int(i)
    if z &gt; pow(2,31)-1 or z &lt; -pow(2,31):
        return 0
    else:
        if not f:
            z = -z
        return z
</code></pre><hr>
<h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h1><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：</p>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<pre><code>def myAtoi(self, str: str) -&gt; int:
    p = True
    N = 0
    str = str.strip()
    if not str:
        return 0
    if str[0] == &quot;+&quot; or str[0] == &quot;-&quot; or ord(str[0]) &gt;= 48 and ord(str[0]) &lt;= 57:
        if str[0] == &quot;+&quot;:
            p = True
            str = str[1:]
        elif str[0] == &quot;-&quot;:
            p = False
            str = str[1:]
        if not str:
            return 0
        i = 0
        t = ord(str[0])
        while t &gt;= 48 and t &lt;= 57:
            N = N * 10 + (t - 48)
            i += 1
            if i &lt; len(str):
                t = ord(str[i])
            else:
                break
        if not p:
            N = -N
        if N &lt; -2147483648:
            return -2147483648
        if N &gt; 2147483647:
            return 2147483647
        return N
    else:
        return 0
</code></pre><hr>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h1><pre><code># 字符串解法
# python3
class Solution:
def isPalindrome(self, x: int) -&gt; bool:
    y = str(x)
    y = list(y)
    l = len(y)
    for i in range(l):
        if y[i] != y[l-1-i]:
            return False
    return True
</code></pre><hr>
<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<pre><code># 双指针法
class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        l,r = 0,len(height)-1
        Max = 0
        while l &lt; r:
            if (r-l)*min(height[l],height[r]) &gt; Max:
                Max = (r-l)*min(height[l],height[r])
            if height[l] &lt; height[r]:
                l += 1
            else:
                r -= 1
        return Max
</code></pre><hr>
<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><pre><code>def intToRoman(self, num: int) -&gt; str:
    Roman_char = {1000:&quot;M&quot;,900:&quot;CM&quot;, 500:&quot;D&quot;, 400:&quot;CD&quot;,
     100:&quot;C&quot;, 90:&quot;XC&quot;, 50:&quot;L&quot;, 40:&quot;XL&quot;, 10:&quot;X&quot;, 9:&quot;IX&quot;, 5:&quot;V&quot;, 4:&quot;IV&quot;, 1:&quot;I&quot;}
    L = &quot;&quot;
    for i in Roman_char:
        L += Roman_char[i]*(num // i)
        num = num - (num // i)*i
    return L
</code></pre><hr>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><pre><code># 在编译器帮助下运行通过的
# python3
class Solution:
def romanToInt(self, s: str) -&gt; int:
    roman = {&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000,
                 &#39;IV&#39;:4,&#39;IX&#39;:9,&#39;XL&#39;:40,&#39;XC&#39;:90,&#39;CD&#39;:400,&#39;CM&#39;:900}
    right = False
    num = 0
    if len(s) == 1:
        num += roman[s]
    else:
        for i in range(len(s)-1):
            if right:
                right = False
                continue
            if roman[s[i]] &lt; roman[s[i+1]]:
                right = True
                num += roman[s[i]+s[i+1]]
            else:
                num += roman[s[i]]
        if not right:
            num += roman[s[i+1]]
    return num
</code></pre><hr>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><pre><code># python3
class Solution:
def longestCommonPrefix(self, strs: List[str]) -&gt; str:
    s = &#39;&#39;
    l = len(strs)
    if l==0:
        return s
    mi = min([len(i) for i in strs])

    for i in range(mi):
        a = strs[0][i]
        b = True
        for j in range(1,l):
            if a != strs[j][i]:
                b = False
                break
        if b:
            s = s + a
        else:
            break
    return s
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    length = len(strs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">        <span class="keyword">if</span> len(item) &lt; length:</span><br><span class="line">            length = len(item)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; length:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        cur_char = strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> item[i] != cur_char:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        res += cur_char</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">    N = len(strs)</span><br><span class="line">    <span class="keyword">if</span> N &gt; <span class="number">2</span>:</span><br><span class="line">        mid = N//<span class="number">2</span></span><br><span class="line">        str1 = self.longestCommonPrefix(strs[<span class="number">0</span>:mid])</span><br><span class="line">        str2 = self.longestCommonPrefix(strs[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.longestCommonPrefix([str1,str2])</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">        min_length = len(strs[<span class="number">0</span>]) <span class="keyword">if</span> len(strs[<span class="number">0</span>]) &lt;= len(strs[<span class="number">1</span>]) <span class="keyword">else</span> len(strs[<span class="number">1</span>])</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min_length):</span><br><span class="line">            <span class="keyword">if</span> strs[<span class="number">0</span>][i] != strs[<span class="number">1</span>][i]:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            res += strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> N == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<pre><code>def letterCombinations(self, digits: str) -&gt; List[str]:
    hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;],
                &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;],
                &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]}
    temp_list = []
    last_list = []
    for n in digits:
        if not last_list:
            last_list = hash_table[n]
            continue
        for key in hash_table[n]:
            for i in range(len(last_list)):
                temp_list.append(last_list[i]+key)
        last_list = temp_list
        temp_list = []
    return last_list

def letterCombinations(self, digits: str) -&gt; List[str]:
    # 回溯法
    hash_table = {&quot;2&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;3&quot;:[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], &quot;4&quot;:[&quot;g&quot;,&quot;h&quot;,&quot;i&quot;],
                &quot;5&quot;:[&quot;j&quot;,&quot;k&quot;,&quot;l&quot;], &quot;6&quot;:[&quot;m&quot;,&quot;n&quot;,&quot;o&quot;],&quot;7&quot;:[&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;],
                &quot;8&quot;:[&quot;t&quot;,&quot;u&quot;,&quot;v&quot;],&quot;9&quot;:[&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]}
    L = []
    length = len(digits)
    print(length)
    if length &lt; 1:
        return L
    def helper(n,temp_s):
        if n == length:
            L.append(temp_s)
        else:
            c = digits[n]
            chars = hash_table[c]
            for item in chars:
                helper(n+1,temp_s + item)

    s = &quot;&quot;
    helper(0,s)
    return L
</code></pre><hr>
<h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
<pre><code>def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
    L = ListNode(-1)
    L.next = head
    p = head
    i = 0
    while p:
        i += 1
        p = p.next
    print(i)
    p = L
    for _ in range(i-n):
        p = p.next
    print(p.val)
    p.next = p.next.next
    return L.next
</code></pre><hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><pre><code># python3
class Solution:
def isValid(self, s: str) -&gt; bool:
    bracket = {&#39;(&#39;:1,&#39;)&#39;:2,&#39;[&#39;:4,&#39;]&#39;:5,&#39;{&#39;:7,&#39;}&#39;:8}
    stack = []
    for i in s:
        if stack:
            if bracket[stack[-1]]+1 == bracket[i]:
                stack.pop()
            else:
                stack.append(i)
        else:
            stack.append(i)
    if stack:
        return False
    else:
        return True
</code></pre><hr>
<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<pre><code>def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
    L = ListNode(-1)
    p = L
    while l1 and l2:
        l3 = None
        if l1.val &gt; l2.val:
            l3 = l2
            l2 = l2.next
        else:
            l3 = l1
            l1 = l1.next
        p.next = l3
        p = p.next
    if 1:
        p.next = l1
    else:
        p.next = l2
    return L.next
</code></pre><hr>
<h1 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<pre><code>def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
    if not lists:
        return None
    L = ListNode(-1)
    x = L
    cur_min = None
    while len(lists) &gt; 1:
        n = len(lists)
        if lists[0] != None:
            cur_min = lists[0]
        else:
            lists.pop(0)
            continue
        # print(&quot;cur_min: &quot;+str(cur_min.val))
        # 找到最小的值
        t = 0
        for i in range(n):
            if lists[i] == None:
                continue
            if lists[i].val &lt; cur_min.val:
                cur_min = lists[i]
                t = i
        if lists[t].next != None:
            lists[t] = lists[t].next
        else:
            lists.pop(t)
        cur_min.next = None
        x.next = cur_min
        x = x.next
    x.next = lists[0]
    return L.next
</code></pre><hr>
<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<pre><code>def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode:
    if not head:
        return head
    res = ListNode(-1)
    res.next = head
    def revereKnode(k,L):
        # 不足k个，直接返回
        t = L   # 用t来表示结尾
        for _ in range(k):
            if t.next == None:
                return L.next, None
            t= t.next

        # 足够k个进行翻转
        d = L.next   # d表示正序列上的末尾节点
        u = L.next
        while u != t:
            u = d.next
            d.next = u.next
            u.next = L.next
            L.next = u
        return L.next,d
    R = res
    E = res
    while E:
        R = E
        R.next,E = revereKnode(k,R)
    return res.next
</code></pre><h2 id="​"><a href="#​" class="headerlink" title="​          "></a>​          </h2><h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h1><pre><code># python3
class Solution:
def removeDuplicates(self, nums: List[int]) -&gt; int:
    if nums:
        a = nums[0]
        for i in nums[1:]:

            if i == a:
                nums.remove(i)
            else:
                a = i
        return len(nums)    
    else:
        return 0
</code></pre><hr>
<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h1><pre><code># python3
class Solution:
def strStr(self, haystack: str, needle: str) -&gt; int:
    if needle:
        if needle not in haystack:
            return -1
        else:
            return haystack.index(needle)
    else:
        return 0

# 这个题目水很深需要再多再看看KMP算法之流多翻一翻
</code></pre><hr>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<pre><code>def nextPermutation(self, nums: List[int]) -&gt; None:
    n = len(nums)
    if n == 0:
        return None
    for i in range(-1,-n,-1):
        if nums[i-1] &lt; nums[i]:
            t = 0
            j = -1
            # 找到下一个值,把它与i-1位置的元素交换
            while j &gt; i-1:
                if nums[j] &gt; nums[i-1]:
                    nums[i-1],nums[j] = nums[j],nums[i-1]
                    break
                j -= 1
            # i-1 后面一定是逆序的
            L = i
            R = -1
            while L&lt;R:
                nums[L], nums[R] = nums[R],nums[L]
                L += 1
                R -= 1
            return None
    nums.sort()
    return None
</code></pre><hr>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<pre><code>def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
    res = []
    n = len(nums)
    p = False
    for i in range(n):
        if not p and nums[i] == target:
            res.append(i)
            p = True
        if p and (i+1 == n or nums[i+1] != target):
            res.append(i)
            p = False
    if not res:
        return [-1,-1]
    return res

def searchRange(self, nums: List[int], target: int) -&gt; List[int]:
    res = []
    n = len(nums)
    for i in range(n):
        if nums[i] == target:
            res.append(i)
    if not res:
        return [-1,-1]
    return [res[0],res[-1]]

def searchRange(self, nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            left_idx = i
            break
        else:
            return [-1, -1]
    for j in range(len(nums)-1, -1, -1):
        if nums[j] == target:
            right_idx = j
            break

    return [left_idx, right_idx]
</code></pre><hr>
<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><pre><code># python3 自己写的
class Solution:
def searchInsert(self, nums: List[int], target: int) -&gt; int:
    if target not in nums:
        for i in range(len(nums)):
            if target &lt;= nums[i]:
                nums.insert(i,target)
                return i
        nums.append(target)
        return len(nums)-1
    else:
        return nums.index(target)
</code></pre><hr>
<h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h1><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<pre><code>def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
    # 三重判定
    # 判定行
    for L in board:
        temp = []
        for i in L:
            if i != &quot;.&quot;:
                temp.append(i)
        if len(temp) != len(set(temp)):
            return False
    print(&quot;行OK&quot;)
    # 判定列
    for j in range(9):
        temp = []
        for i in range(9):
            if board[i][j] != &quot;.&quot;:
                temp.append(board[i][j])
        if len(temp) != len(set(temp)):
            return False
    print(&quot;列OK&quot;)
    # 判定方格
    for x in range(0,9,3):
        for y in range(0,9,3):
            print((x,y))
            temp = []
            for i in range(3):
                for j in range(3):
                    if board[x+i][y+j] != &quot;.&quot;:
                        temp.append(board[x+i][y+j])
            print(temp)
            if len(temp) != len(set(temp)):
                return False
    return True

def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
    # 只遍历一次的答案
    Row = [{} for _ in range(9)]
    Col = [{} for _ in range(9)]
    Square = [{} for _ in range(9)]
    for i in range(9):
        for j in range(9):
            if board[i][j] != &quot;.&quot;:
                if board[i][j] not in Row[i]:
                    Row[i][board[i][j]] = 1
                else:
                    return False
                if board[i][j] not in Col[j]:
                    Col[j][board[i][j]] = 1
                else:
                    return False
                local = (i//3)*3 + j //3
                if board[i][j] not in Square[local]:
                    Square[local][board[i][j]] = 1
                else:
                    return False
    return True
</code></pre><hr>
<h1 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a>38. 报数</h1><pre><code># python3自己解决
class Solution:
def countAndSay(self, n: int) -&gt; str:
    s = &quot;1&quot;
    for j in range(n-1):
        a = s[0]
        x = 1
        re = &quot;&quot;
        for i in s[1:]:
            if i == a:
                x = x + 1
            else:
                re = re + str(x) + str(a)
                a = i
                x = 1
        s = re + str(x) + str(a)
    return s
</code></pre><p>​    </p>
<p>l3 = []<br>        while l1 and l2:<br>            if l1[0] &gt;= l2[0]:<br>                l3.append(l2.pop(0))<br>            elif l1[0] &lt; l2[0]:<br>                l3.append(l1[0].pop(0))<br>        return l3</p>
<hr>
<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<pre><code>def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
    candidates.sort()
    def help(candidates,target,temp_list):
        print(temp_list)
        if target &gt;= candidates[0]:
            i = 0
            while i &lt; len(candidates) and candidates[i] &lt;= target:
                if target == candidates[i]:
                    print(&quot;yeap!!&quot;)
                    temp = temp_list.copy()
                    temp.append(target)
                    print(temp)
                    res.append(temp)
                temp = temp_list.copy()
                temp.append(candidates[i])
                help(candidates[i:],target-candidates[i],temp)
                i += 1
    res = []
    temp = []
    help(candidates,target,temp)
    return res
</code></pre><hr>
<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<pre><code>def multiply(self, num1: str, num2: str) -&gt; str:
    if num1 == &#39;0&#39; or num2 == &#39;0&#39;:
        return &quot;0&quot;
    n1 = len(num1)
    n2 = len(num2)
    digits = [0]*(n1+n2)
    for i in range(n1-1, -1, -1):
        for j in range(n2-1, -1, -1):
            prod = (ord(num1[i])-ord(&#39;0&#39;))*(ord(num2[j])-ord(&#39;0&#39;))
            sum_ = 0
            sum_ = prod + digits[i+j+1]
            digits[i+j] += sum_ //10
            digits[i+j+1] = sum_ %10
    # for i in range(n1 + n2 - 1, 0, -1):
    #     carry = digits[i] // 10
    #     digits[i] = digits[i] % 10
    #     digits[i - 1] += carry
    return &#39;&#39;.join([str(i) for i in digits]).lstrip(&#39;0&#39;)
</code></pre><hr>
<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h1><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<pre><code>class Solution:
def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
    res = []
    if not nums:
        return res
    nums.sort()
    N = len(nums)
    def helper(start,temp,unused):
        if start == N:
            print(str(start)+ &quot; &quot;+str(temp)+&quot; &quot;+str(unused))
            res.append(temp[:])
        i = 0
        while i &lt; len(unused):
            if i &gt; 0 and unused[i] == unused[i-1]:
                i += 1
                continue

            temp.append(unused[i])
            a = unused.pop(i)
            helper(start+1,temp,unused)
            temp.pop()
            unused.insert(i,a)
            i += 1
    helper(0,[],nums)
    return res
</code></pre><hr>
<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h1><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<pre><code>def rotate(self, matrix: List[List[int]]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify matrix in-place instead.
    &quot;&quot;&quot;
    N = len(matrix) # 矩阵行列数
    C = N //2 # 旋转层数
    for t in range(C):
        print(t)
        for i in range(0,N-t*2-1):
            a = matrix[t][t+i]   # 左上角
            matrix[t][t+i] = matrix[N-t-1-i][t]  # 左下角
            matrix[N-t-1-i][t] = matrix[N-t-1][N-t-1-i]    # 右下角
            matrix[N-t-1][N-t-1-i] = matrix[t+i][N-t-1]   # 右上角
            matrix[t+i][N-t-1] = a

            # a = matrix[t+i,N-t-1]   # 右上角
            # matrix[t+i,N-t-1]  = matrix[t][t+i] # 左上角
            # b = matrix[N-t-1][N-t-1-i]    # 右下角
            # matrix[N-t-1][N-t-1-i] = a
            # a = matrix[N-t-1-i][t]  # 左下角
            # matrix[N-t-1-i][t] = b
            # matrix[t][t+i] = a
</code></pre><hr>
<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h1><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<pre><code>from collections import defaultdict
class Solution:
    def groupAnagrams(self, strs):
        ans = collections.defaultdict(list)
        for s in strs:
            ans[tuple(sorted(s))].append(s)
        return ans.values()

class Solution:
    def groupAnagrams(self, strs):
        ans = {}
        for s in strs:
            if tuple(sorted(s)) in ans:
                ans[tuple(sorted(s))].append(s)
            else:
                ans[tuple(sorted(s))] = [s]
        return list(ans.values())
</code></pre><hr>
<h1 id="53-最大子序和-（在这个题中学暴力法，动态规划和分治法）"><a href="#53-最大子序和-（在这个题中学暴力法，动态规划和分治法）" class="headerlink" title="53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）"></a>53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）</h1><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><pre><code># 这道题不会做。
# 答案中有四种解法：暴力法，动态规划，贪心法，分治法；
# 我都可以学！！！

# 2020年1月8日学会第一种暴力法！

# 这种暴力法超时了！！
class Solution:
def maxSubArray(self, nums: List[int]) -&gt; int:
    Max = nums[0]
    for i in range(len(nums)):
        Sum = 0
        for j in range(i,len(nums)):
            Sum += nums[j]
            if Sum &gt; Max:
                Max = Sum
    return Max

# 一个更为先进的暴力法，好吧，说好一起暴力呢，你怎么动起了脑子
class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        Sum = nums[0]
        Max = nums[0]
        for i in range(1,len(nums)):
            if Sum + nums[i] &gt; nums[i]:
                Sum = Sum + nums[i]
            else:
                Sum = nums[i]
            Max = max(Max,Sum)
        return Max

    # 20200109
</code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>（动态规划代码在上面第二段）</p>
<blockquote>
<p>通常我们遍历子串或者子序列有三种遍历方式</p>
<ol>
<li><p>以某个节点为开头的所有子序列: 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]。</p>
<ol>
<li>根据子序列的长度为标杆，如先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等。</li>
<li><p>以子序列的结束节点为基准，先遍历出以某个节点为结束的所有子序列，因为每个节点都可能会是子序列的结束节点，因此要遍历下整个序列，如: 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]。</p>
<p>而动态规划就是第三种方式，求出以某个节点结束节点的最大值。</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><pre><code># 分治法
class Solution:
def maxSubArray(self, nums: List[int]) -&gt; int:
    n = len(nums)
    #递归终止条件
    if n == 1:
        return nums[0]
    else:
        #递归计算左半边最大子序和
        max_left = self.maxSubArray(nums[0:len(nums) // 2])
        #递归计算右半边最大子序和
        max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)])

    max_l = nums[len(nums)//2-1]
    tmp = 0
    for i in range(len(nums)//2-1,-1,-1):
        tmp += nums[i]
        max_l = max(max_l, tmp)

    max_r = nums[len(nums)//2]
    tmp = 0
    for i in range(len(nums)//2,len(nums)):
        tmp += nums[i]
        max_r = max(max_r, tmp)
    return max(max_left,max_right,max_l+max_r)
</code></pre><hr>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h1><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<pre><code>def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
    res = []
    if not matrix:
        return res
    m = len(matrix)
    n = len(matrix[0])

    def next_item(i,j): 
        # 这里可以用另一个矩阵来表示这个是否被换过了。
        # 返回一个值，如果没返回则结束

        # 如果上下左右都不能走则返回None结束
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;):
            return None
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == 0 or matrix[i][j-1]== &quot;*&quot;) and not (j == n-1 or matrix[i][j+1]== &quot;*&quot;):
            return (i,j+1)
        if (i==0 or matrix[i-1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (i == m-1 or matrix[i+1][j] == &quot;*&quot;):
            return (i+1,j)
        if (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and (j == n-1 or matrix[i][j+1]== &quot;*&quot;) and not (j == 0 or matrix[i][j-1]== &quot;*&quot;):
            return (i,j-1)
        if (j == 0 or matrix[i][j-1]== &quot;*&quot;) and (i == m-1 or matrix[i+1][j] == &quot;*&quot;) and not (i==0 or matrix[i-1][j] == &quot;*&quot;):
            return (i-1,j)

    t = (0,0)
    while t:
        i,j = t
        res.append(matrix[i][j])
        matrix[i][j] = &quot;*&quot;
        t = next_item(i,j)
    return res
</code></pre><hr>
<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<pre><code>def canJump(self, nums: List[int]) -&gt; bool:
    # dp
    n = len(nums)
    dp = [False]*n
    for i in range(n-1,-1,-1):
        if i == n-1:
            dp[i] = True
            continue
        for j in range(i+1,min(i+nums[i]+1,n)):
            if dp[j] == True:
                dp[i] = True
                break
    print(dp)
    return dp[0]
</code></pre><hr>
<h1 id><a href="#" class="headerlink" title=" "></a> </h1><hr>
<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h1><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code>class Solution:
def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
    if not head:
        return head
    temp = ListNode(-1)
    temp.next = head
    node_count = 0
    point = temp
    while point.next:
        node_count+= 1
        point = point.next
    if k&gt;node_count:
        k = k%node_count
    elif k == node_count:
        return head
    # 再走node_count - k 步
    point = temp
    for _ in range(node_count-k):
        point = point.next
    t = point
    while t.next:
        t = t.next
    t.next = temp.next
    temp.next = point.next
    point.next = None
    return temp.next
</code></pre><h2 id="​-1"><a href="#​-1" class="headerlink" title="​        "></a>​        </h2><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<pre><code>def uniquePaths(self, m: int, n: int) -&gt; int:
    N = m + n -2
    c = min(m,n)-1
    res = 1
    for i in range(1,c+1):
        res *= N
        res = res//i
        N = N-1
    return res
</code></pre><hr>
<h1 id="63-不同路径-II-（动态规划，浅拷贝陷阱）"><a href="#63-不同路径-II-（动态规划，浅拷贝陷阱）" class="headerlink" title="63. 不同路径 II   （动态规划，浅拷贝陷阱）"></a>63. 不同路径 II   （动态规划，浅拷贝陷阱）</h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<pre><code>def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
    print(obstacleGrid)
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    print(m,n)
    dp = [[0]*n for _ in range(m)]  # 不要用下面这样的浅拷贝
    # dp = [[0]*n]*m    # 这样赋值会把整个列赋值成一样值
    # 放第一行，第一列：
    for i in range(m):
        if obstacleGrid[i][0] == 1:
            break
        dp[i][0] = 1
    for j in range(n):
        if obstacleGrid[0][j] == 1:
            break
        dp[0][j] = 1
    for i in range(1,m):
        for j in range(1,n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
                continue
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
    return dp[-1][-1]
</code></pre><hr>
<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<pre><code>def minPathSum(self, grid: List[List[int]]) -&gt; int:
    m = len(grid)
    n = len(grid[0])
    dp = [[0]*n for _ in range(m)]
    for i in range(m):
        if i == 0:
            dp[0][0] = grid[0][0]
            continue
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for i in range(1,n):
        dp[0][i] = dp[0][i-1] + grid[0][i]
    for i in range(1,m):
        for j in range(1,n):
            dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
    print(dp)
    return dp[-1][-1]
</code></pre><p>​    </p>
<h2 id="​-2"><a href="#​-2" class="headerlink" title="​        "></a>​        </h2><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h1><p>这个题的第一印象就是把数组转成数字，加一后再转成数组；</p>
<pre><code>class Solution:
def plusOne(self, digits: List[int]) -&gt; List[int]:
    Sum = 0
    for i in digits:
        Sum = 10*Sum + i
    Sum =Sum + 1
    D_list = []
    while Sum:
        D_list.append(Sum%10)
        Sum = Sum//10
    D_list.reverse()
    return D_list
</code></pre><p>这个结果速度还可以，但是内存消耗大</p>
<p>第二个想法就是在原数组上进行</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        Up = False  # 进位符
        # 给最低位加一
        if digits[-1] + 1 &gt; 9:
            digits[-1] = (digits[-1] + 1)%10
            Up = True
        else:
            digits[-1] = digits[-1] + 1
        # 给整个数字进位：
        for i in range(len(digits)-2,-1,-1):
            if Up:
                digits[i] = digits[i] + 1
                if digits[i] &gt; 9:
                    digits[i] = digits[i]%10
                    Up = True
                else:
                    return digits
        # 多进位
        if Up:
            digits.insert(0,1)
            Up = False
        return digits
</code></pre><h2 id="​-3"><a href="#​-3" class="headerlink" title="​            "></a>​            </h2><h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h1><p>一个不用内置函数的解法</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    Up = False
    C = &quot;&quot;
    if len(a)&gt;len(b):
        b = (len(a)-len(b))*&quot;0&quot; + b
    else:
        a = (len(b)-len(a))*&quot;0&quot; + a
    for i in range(len(a)-1,-1,-1):
        z = int(a[i])+int(b[i])
        if Up:
            z = z + 1
            Up = False
        C = str(z%2) + C
        if z//2:
            Up = True
    if Up:
        C = &quot;1&quot; + C
    return C
</code></pre><p>题解里的一个答案：时间和空间都优于我写的</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    r, p = &#39;&#39;, 0
    d = len(b) - len(a)
    a = &#39;0&#39; * d + a
    b = &#39;0&#39; * -d + b
    for i, j in zip(a[::-1], b[::-1]):
        s = int(i) + int(j) + p
        r = str(s % 2) + r
        p = s // 2
    return &#39;1&#39; + r if p else r
</code></pre><p>用内置函数的解法</p>
<pre><code>class Solution:
def addBinary(self, a: str, b: str) -&gt; str:
    return bin(int(a,2)+int(b,2))[2:]
</code></pre><hr>
<h1 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69. x的平方根"></a>69. x的平方根</h1><p>我的答案：<br>    class Solution:<br>    def mySqrt(self, x: int) -&gt; int:<br>        start = 0<br>        end = x<br>        while start + 1 != end:<br>            mid = (end-start)//2 + start<br>            if mid <em> mid == x:<br>                return mid<br>            elif mid </em> mid &gt; x:<br>                if (mid-1)<em>(mid-1) &lt; x:<br>                    return mid-1<br>                end = mid<br>            elif mid </em> mid &lt; x:<br>                if (mid+1)*(mid+1) &gt; x:<br>                    return mid<br>                start = mid<br>        return end</p>
<hr>
<h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h1><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<pre><code>def simplifyPath(self, path: str) -&gt; str:
    res = []
    i = 0
    while i&lt;len(path):
        if path[i] == &quot;/&quot;:
            i += 1
            continue
        j = i
        while j &lt; len(path) and path[j] != &quot;/&quot;:
            j += 1
        if j-i == 2 and path[i:j] == &quot;..&quot;:
            if res:
                res.pop()
        elif j-i == 1 and path[i:j] == &quot;.&quot;:
            pass
        else:
            res.append(path[i:j])
        i = j
    res_S = &quot;/&quot;
    if res:
        res_S += &quot;/&quot;.join(res)
    return res_S
</code></pre><hr>
<h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h1><p>给定一个 m x n 的矩阵，如果一个元素为0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<pre><code>def setZeroes(self, matrix: List[List[int]]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify matrix in-place instead.
    &quot;&quot;&quot;
    res = []
    m = len(matrix)
    n = len(matrix[0])
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                res.append((i,j))
    for i,j in res:
        for t in range(n):
            matrix[i][t] = 0
        for t in range(m):
            matrix[t][j] = 0
</code></pre><hr>
<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h1><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<pre><code>def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:
    if not matrix or not matrix[0]:
        return False
    m = len(matrix)
    n = len(matrix[0])
    for row in range(m):
        if target &gt;= matrix[row][0] and target &lt;= matrix[row][-1]:
            for col in range(n):
                if matrix[row][col] == target:
                    return True
            return False
    return False
</code></pre><hr>
<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h1><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<pre><code>def sortColors(self, nums: List[int]) -&gt; None:
    &quot;&quot;&quot;
    Do not return anything, modify nums in-place instead.
    &quot;&quot;&quot;
    n = len(nums)
    l1 = 0
    for i in range(n):
        if nums[i] == 0:
            nums.pop(i)
            nums.insert(0,0)
            l1 += 1
        if nums[i] == 1:
            nums.pop(i)
            nums.insert(l1,1)
</code></pre><hr>
<h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h1><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<pre><code>def minWindow(self, s: str, t: str) -&gt; str:
    t_table = defaultdict(int)
    for i in t:
        t_table[i] += 1
    hash_table = defaultdict(list)
    left , right = 0,len(s)
    count = 0
    flag = False
    for i in range(len(s)):
        if count &lt;len(t) and s[i] in t:
            if s[i] not in hash_table or len(hash_table[s[i]])&lt;t_table[s[i]]:
                count += 1
                hash_table[s[i]].append(i)
            else:
                hash_table[s[i]].pop(0)
                hash_table[s[i]].append(i)
        if count == len(t):
            flag = True
            alp_left = min(hash_table, key = lambda k: hash_table[k][0])
            alp_right = max(hash_table,key = lambda k: hash_table[k][-1])
            if hash_table[alp_right][-1]-hash_table[alp_left][0] &lt; right-left:
                right, left = hash_table[alp_right][-1], hash_table[alp_left][0]
            if len(hash_table[alp_left]) &gt;1:
                hash_table[alp_left].pop(0)
            else:
                hash_table.pop(alp_left)
            count -= 1
    if not flag:
        return &quot;&quot;
    return s[left:right+1]
</code></pre><hr>
<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<pre><code>def combine(self, n: int, k: int) -&gt; List[List[int]]:
    help_List = list(range(1,n+1))
    def help(temp,help_List):
        l = len(temp)
        T = len(help_List)
        if l == k:
            res.append(temp)
        else:
            for i in range(T-k+1+l):
                help(temp + [help_List[i]],help_List[i+1:])
    res = []
    help([],help_List)
    return res

# 第二种解法很厉害的！！ 94%
def combine(self, n: int, k: int) -&gt; List[List[int]]:
    def help(temp):
        l = len(temp)
        T = n - temp[-1] if l != 0 else n
        if l == k:
            res.append(temp)
        else:
            for i in range(1,T-k+1+l+1):
                if temp:
                    help(temp + [temp[-1]+i])
                else:
                    help([i])
    res = []
    help([])
    return res
</code></pre><hr>
<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h1><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
<pre><code>def subsets(self, nums: List[int]) -&gt; List[List[int]]:
    res = []
    if not nums:
        return [[]]
    N = len(nums)

    def help(temp,remain):
        res.append(temp)
        for i in range(len(remain)):
            help(temp+[remain[i]],remain[i+1:])

    help([],nums)
    return res
</code></pre><hr>
<h1 id="79-单词搜索-这道题是有点东西的"><a href="#79-单词搜索-这道题是有点东西的" class="headerlink" title="79. 单词搜索 (这道题是有点东西的)"></a>79. 单词搜索 <strong><em>(这道题是有点东西的)</em></strong></h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<pre><code>def exist(self, board: List[List[str]], word: str) -&gt; bool:
    m = len(board)
    n = len(board[0])
    # word = &quot;SEE&quot;
    def dfs(visited,word):
        l = len(visited)
        if l == len(word):
            return True
        x,y = visited[-1]
        dir_x = [-1,0,1,0]
        dir_y = [0,-1,0,1]
        for dx,dy in zip(dir_x,dir_y):
            if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and (x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[l] and dfs(visited+[(x+dx,y+dy)],word):
            # 这里的大判断分别判断了以下几件事：
            #       判断越界
            #       判断是否被访问过
            #       判断当下是否等于那个字母
            #       判断它以后是否找得到
            #   这些都满足了，把它返回True
                return True
        # 四个方向都不满足，就否定它
        return False

        # print(&quot;嘿嘿我进来了 &quot;+str((i,j)))
        # visited = [(i,j)]
        # dir_x = [-1,0,1,0]
        # dir_y = [0,-1,0,1]
        # x,y = i,j
        # for alp in range(1,len(word)):
        #     flag = False
        # for dx,dy in zip(dir_x,dir_y):
        #     if x+dx&gt;=0 and x+dx&lt;m and y+dy&gt;=0 and y+dy&lt;n and(x+dx,y+dy) not in visited and board[x+dx][y+dy]==word[alp]:
        #             flag = True
        #             x,y = x+dx,y+dy
        #             print(x,y,word[alp])
        #             visited.append((x,y))
        #     if not flag:
        #         return False
        # return True
</code></pre><p>​<br>​        for i in range(m):<br>​            for j in range(n):<br>​                if board[i][j] == word[0] and dfs([(i,j)],word):<br>​                    return True<br>​        return False</p>
<hr>
<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<pre><code>def search(self, nums: List[int], target: int) -&gt; bool:
    if len(nums) &lt;= 0:
        return False
    left = 0
    right = len(nums) - 1
    while left &lt; right:
        mid = (right - left) // 2 + left
        if nums[mid] == target:
            return True
        if nums[left] == nums[mid]:
            left += 1
            continue
        if nums[left] &lt; nums[mid]:
            if nums[left] &lt;= target &lt;= nums[mid]:
                right = mid
            else:
                # 这里 +1，因为上面是 &lt;= 符号
                left = mid + 1
        else:
            # 注意：这里必须是 mid+1，因为根据我们的比较方式，mid属于左边的序列
            if nums[mid+1] &lt;= target &lt;= nums[right]:
                left = mid + 1
            else:
                right = mid
    return True if nums[left] == target else False
</code></pre><hr>
<h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h1><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现 的数字。</p>
<pre><code>def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
    Temp = ListNode(-1)
    Temp.next = head
    t = Temp
    while t:
        if t.next and t.next.next:
            if t.next.val == t.next.next.val:
                R = t.next.next
                while R.next:
                    if R.next.val == R.val:
                        R = R.next
                    else:
                        break
                t.next = R.next
            else:
                t = t.next
        else:
            t = t.next
    return Temp.next
</code></pre><hr>
<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        cur = head
        if not cur:
            return head
        V = cur.val
        while cur.next:
            if cur.next.val != V:
                V = cur.next.val
                cur = cur.next
            else:
                cur.next = cur.next.next
        return head
</code></pre><hr>
<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h1><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">    hash_table = &#123;&#125;</span><br><span class="line">    area = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">        delete = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> hash_table:</span><br><span class="line">            <span class="keyword">if</span> heights[i] &lt; item:</span><br><span class="line">                <span class="keyword">if</span> item * hash_table[item] &gt; area:</span><br><span class="line">                    area = item * hash_table[item]</span><br><span class="line">                delete.append(item)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[item] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> heights[i] <span class="keyword">not</span> <span class="keyword">in</span> hash_table:</span><br><span class="line">            m = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> delete:</span><br><span class="line">                <span class="keyword">if</span> hash_table[item] &gt; m:</span><br><span class="line">                    m = hash_table[item]</span><br><span class="line">            hash_table[heights[i]] = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> delete:</span><br><span class="line">            hash_table.pop(item)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> hash_table:</span><br><span class="line">        <span class="keyword">if</span> item * hash_table[item] &gt; area:</span><br><span class="line">            area = item * hash_table[item]</span><br><span class="line">    <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h1><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">    temp = ListNode(<span class="number">-1</span>)</span><br><span class="line">    temp.next = head</span><br><span class="line">    t = temp</span><br><span class="line">    p1 = temp</span><br><span class="line">    pass_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> t <span class="keyword">and</span> p1:</span><br><span class="line">        R = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> t.next:</span><br><span class="line">            <span class="keyword">if</span> pass_flag <span class="keyword">and</span> t.next.val &lt; x:</span><br><span class="line">                R = t.next</span><br><span class="line">                t.next = R.next</span><br><span class="line">                R.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> t.next <span class="keyword">and</span> t.next.val &gt;= x:</span><br><span class="line">                pass_flag = <span class="literal">True</span></span><br><span class="line">                t = t.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pass_flag:</span><br><span class="line">                t = t.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            <span class="keyword">if</span> p1.next.val &lt; x:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> R:</span><br><span class="line">                    R.next = p1.next</span><br><span class="line">                    p1.next = R</span><br><span class="line">                    p1 = p1.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> temp.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">    temp = ListNode(<span class="number">-1</span>)</span><br><span class="line">    temp.next = head</span><br><span class="line">    t = temp</span><br><span class="line">    p1 = temp</span><br><span class="line">    pass_flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> p1.next:</span><br><span class="line">        <span class="keyword">if</span> p1.next.val &lt; x:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> t:</span><br><span class="line">        R = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> t.next:</span><br><span class="line">            <span class="keyword">if</span> pass_flag <span class="keyword">and</span> t.next.val &lt; x:</span><br><span class="line">                R = t.next</span><br><span class="line">                t.next = R.next</span><br><span class="line">                R.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> t.next <span class="keyword">and</span> t.next.val &gt;= x:</span><br><span class="line">                pass_flag = <span class="literal">True</span></span><br><span class="line">                t = t.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pass_flag:</span><br><span class="line">                t = t.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> R:</span><br><span class="line">            R.next = p1.next</span><br><span class="line">            p1.next = R</span><br><span class="line">            p1 = p1.next</span><br><span class="line">    <span class="keyword">return</span> temp.next</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h1><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>
<p>格雷编码序列必须以 0 开头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    res = [<span class="number">0</span>]</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>&lt;&lt;n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 判断第i位需要怎么变</span></span><br><span class="line">            flag = temp</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(i):</span><br><span class="line">                flag = flag // <span class="number">2</span></span><br><span class="line">            flag  = flag % <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span> temp - (<span class="number">1</span>&lt;&lt;i) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(temp - (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                    temp = temp - (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> temp + (<span class="number">1</span>&lt;&lt;i) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                    res.append(temp + (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                    temp = temp + (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>下面这是一个完全理解了格雷码产生方式的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">    res,head = [<span class="number">0</span>],<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):  <span class="comment"># n次</span></span><br><span class="line">        <span class="comment"># 每一轮把列表里的值的二进制前面加一个1逆序添加进列表中</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):   </span><br><span class="line">            res.append(head+res[j])</span><br><span class="line">        head &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h1><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        N = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(step,temp)</span>:</span></span><br><span class="line">            res.append(temp[:])</span><br><span class="line">            <span class="keyword">if</span> step &lt;= N:</span><br><span class="line">                i = step</span><br><span class="line">                <span class="keyword">while</span> i &lt; N:</span><br><span class="line">                    <span class="keyword">if</span> i &gt; step <span class="keyword">and</span> nums[i] != nums[i<span class="number">-1</span>]:</span><br><span class="line">                        help(i+<span class="number">1</span>,temp+[nums[i]])</span><br><span class="line">                    <span class="keyword">elif</span> i==step:</span><br><span class="line">                        help(i+<span class="number">1</span>,temp+[nums[i]])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        help(<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h1><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># head = ListNode(3)</span></span><br><span class="line">    <span class="comment"># head.next = ListNode(5)</span></span><br><span class="line">    <span class="comment"># m = 3</span></span><br><span class="line">    <span class="comment"># n = 4</span></span><br><span class="line">    Length = n-m+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> Length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    L = ListNode(<span class="number">-1</span>)</span><br><span class="line">    L.next = head</span><br><span class="line">    p = L</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">        p = p.next</span><br><span class="line">    end = p.next</span><br><span class="line">    start = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(Length):</span><br><span class="line">        <span class="comment"># 切除</span></span><br><span class="line">        temp = p.next</span><br><span class="line">        p.next = temp.next</span><br><span class="line">        <span class="comment"># 头插入</span></span><br><span class="line">        temp.next = start</span><br><span class="line">        start = temp</span><br><span class="line">    <span class="comment"># 再插入</span></span><br><span class="line">    end.next = p.next</span><br><span class="line">    p.next = start</span><br><span class="line">    <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p and q:
            if p.val != q.val:
                return False
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
        elif not p and not q:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        if not root.left and not root.right:
            return True
        elif root.left and root.right:
            return self.isSameTree(root.left,root.right)
        else:
            return False
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p and q:
            if p.val != q.val:
                return False
            return self.isSameTree(p.left,q.right) and self.isSameTree(p.right,q.left)
        elif not p and not q:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root:
            MD = 1
            return MD + max(self.maxDepth(root.left),self.maxDepth(root.right))
        else:
            return 0
</code></pre><hr>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h1><pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return None
        head = TreeNode(preorder[0])
        ind_inorder = inorder.index(preorder[0])
        head.left = self.buildTree(preorder[1:1+ind_inorder],inorder[0:ind_inorder])
        head.right = self.buildTree(preorder[1+ind_inorder:], inorder[ind_inorder+1:])
        return head
</code></pre><hr>
<h1 id="107-二叉树的层次遍历"><a href="#107-二叉树的层次遍历" class="headerlink" title="107. 二叉树的层次遍历"></a>107. 二叉树的层次遍历</h1><pre><code>def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        A = []
        B = []
        if root.left:
            B.append(root.left)
        if root.right:
            B.append(root.right)
        nextL = [root.val]
        while nextL:
            A.insert(0,nextL)
            nextL = []
            nextNodes = []
            while B:
                c = B.pop(0)
                nextL.append(c.val)
                if c.left:
                    nextNodes.append(c.left)
                if c.right:
                    nextNodes.append(c.right)
            B = nextNodes
        return A
</code></pre><hr>
<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>首先答案是不一致的，则需要将他做成符合一定规则的结果。<br>emmmm最后的答案还是非常简单的。首先应该抓住他是一个生成平衡树的题目。其他的要求都是细节。有的细节需要技巧得出。有的细节自然而然就可以得出来结果。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        def helper(left, right):
            if left &gt; right:
                return None
            p = (left + right)//2
            root = TreeNode(nums[p])
            root.left = helper(left, p-1)
            root.right = helper(p+1, right)
            return root
        return helper(0,len(nums)-1)
</code></pre><hr>
<h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>首先它是一个判断题。针对每个节点都有可能进行对比。</p>
<pre><code># 这是一个暴力解法，从上到下
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        def helper(root):
            if not root:
                return 0
            return 1+ max(helper(root.left),helper(root.right))
        if abs(helper(root.left)-helper(root.right)) &gt; 1:
            return False
        else:
            return self.isBalanced(root.left) and self.isBalanced(root.right)
</code></pre><p>这里是从底到顶的解法</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        def helper(root):
            if not root:
                return 0
            left = helper(root.left)
            if left == -1:
                return -1
            right = helper(root.right)
            if right == -1:
                return -1
            return max(left,right)+1 if abs(left-right) &lt; 2 else -1
        return helper(root)!= -1
</code></pre><hr>
<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        mLeft = self.minDepth(root.left)
        mRight = self.minDepth(root.right)
        if mLeft &gt; 0 and mRight &gt; 0:
            return 1 + min(mLeft,mRight)
        elif mRight == 0:
            return 1+ mLeft
        elif mLeft == 0:
            return 1+ mRight
</code></pre><hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:
        def helper(root,temp):
            temp += root.val
            if not root.left and not root.right:    # 叶子节点
                return temp == sum
            elif root.left and not root.right:      # 有左节点没有右节点
                return  helper(root.left, temp)
            elif not root.left and root.right:      # 有右节点没有左节点
                return helper(root.right, temp)
            else:
                return helper(root.left, temp) or helper(root.right, temp)
        if not root:
            return False
        return helper(root,0)
</code></pre><hr>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h1><pre><code>class Solution:
def generate(self, numRows: int) -&gt; List[List[int]]:
    L = []
    for i in range(numRows):
        temp = (i+1)*[1]
        if i&gt;1:
            for j in range(i-1):
                temp[j+1] = L[i-1][j] +L[i-1][j+1]
        L.append(temp)
    return L
# 优秀解法
class Solution:
    def generate(self, numRows: int) -&gt; List[List[int]]:
        if numRows == 0: return []
        res = [[1]]
        while len(res) &lt; numRows:
            newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])]
            res.append(newRow)      
        return res
</code></pre><h1 id="119-杨辉三角II"><a href="#119-杨辉三角II" class="headerlink" title="119.杨辉三角II"></a>119.杨辉三角II</h1><pre><code>class Solution:
    def getRow(self, rowIndex: int) -&gt; List[int]:
        res = [1]
        while len(res) &lt;= rowIndex:
            res = [a+b for a, b in zip([0]+res, res+[0])]     
        return re
</code></pre><hr>
<h1 id="121-买股票的最佳时机"><a href="#121-买股票的最佳时机" class="headerlink" title="121.买股票的最佳时机"></a>121.买股票的最佳时机</h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>暴力法：</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        m = 0
        for i in range(1,len(prices)):
            a = min(prices[0:i])
            if m &lt; prices[i]-a:
                m = prices[i]-a
        return m
</code></pre><p>改进：x5i</p>
<pre><code>class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        minprice = prices[0]
        maxprofit = 0
        for i in range(1,len(prices)):
            if minprice &gt; prices[i]:
                minprice = prices[i]
            elif prices[i]-minprice &gt; maxprofit:
                maxprofit = prices[i]-minprice
        return maxprofit
</code></pre><hr>
<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h1><pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        if not s:
            return True
        # 1.字符串格式转换
        s = s.lower()
        t = &quot;&quot;
        for i in s:
            if (i&gt;=&quot;0&quot; and i&lt;=&quot;9&quot;) or (i&gt;=&quot;a&quot; and i&lt;=&quot;z&quot;):
                t = t+i
        # 2.对字符串进行翻转
        S = t[::-1]
        return S == t
        # 3.判断两字符串是否相等
</code></pre><hr>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h1><p>哈希表是最快的！！！</p>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        # 暴力一点，
        only = 0
        l = len(nums)
        for i in range(0,l):
            only = nums[i]
            if only not in nums[0:i] and only not in nums[i+1:l]:
                return only

class Solution(object):
    def singleNumber(self, nums):
        # 列表操作
        tale = []
        for i in nums:
            if i not in tale:
                tale.append(i)
            else:
                tale.remove(i)
        return tale[0]



class Solution(object):
    def singleNumber(self, nums):
        # 哈希操作
        hash_table = {}
        for i in nums:
            try:
                hash_table.pop(i)
            except:
                hash_table[i] = 1
        return hash_table.popitem()[0]
</code></pre><p>​<br>​    class Solution(object):<br>​        def singleNumber(self, nums):<br>​            # 位操作<br>​            “””<br>​            :type nums: List[int]<br>​            :rtype: int<br>​            “””<br>​            a = 0<br>​            for i in nums:<br>​                a ^= i<br>​            return a</p>
<hr>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        # 列表法
        hash_table = []
        t = head
        while t:
            if t in hash_table:
                return True
            else:
                hash_table.append(t)
            t = t.next
        return False

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        # 哈希法
        hash_table = {}
        t = head
        while t:
            try:
                hash_table.pop(t)
                return True
            except:
                hash_table[t] = 1
            t = t.next
        return False

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        if head == None or head.next == None:
            return False
        # 双指针法
        fast = head.next
        slow = head

        while slow != fast:
            if fast ==None or fast.next == None:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
</code></pre><hr>
<h1 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h1><pre><code>class Solution:
    def reverseWords(self, s: str) -&gt; str:
        if not s:
            return s
        s = s.strip()
        L = []
        P = False
        j = 0
        for i in range(len(s)):
            if s[i]!=&quot; &quot;:
                if not P:
                    j = i
                    P = True
            else:
                if P:
                    P = False
                    L.append(s[j:i])
        L.append(s[j:])
        return &quot; &quot;.join(L[::-1])
</code></pre><hr>
<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h1><p>给你一个整数数组 nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<pre><code>def maxProduct(self, nums: List[int]) -&gt; int:
    hash_table = {}
    hash_table[-1] = 1
    posi = [-1]
    nega = []
    Max = nums[0]
    for i in range(len(nums)):
        t = nums[i] * hash_table[i-1]
        if t &gt; 0:
            if Max &lt; t/hash_table[posi[0]]:
                Max = t//hash_table[posi[0]]
            hash_table[i] = t
        elif t &lt; 0:
            if nega:
                if Max &lt; t/hash_table[nega[0]]:
                    Max = t//hash_table[nega[0]]
            else:
                nega.append(i)
            hash_table[i] = t
        else:
            posi = [i]
            nega = []
            hash_table[i] = 1
            if Max &lt; 0:
                Max = 0
    return Max
</code></pre><h1 id="153-寻找旋转排序数组中的最小值-二分查找"><a href="#153-寻找旋转排序数组中的最小值-二分查找" class="headerlink" title="153. 寻找旋转排序数组中的最小值(二分查找)"></a>153. 寻找旋转排序数组中的最小值(二分查找)</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。</p>
<pre><code>def findMin(self, nums: List[int]) -&gt; int:
    # nums = [4,5,6,7,0,1,2]
    # 二分查找走一波
    left = 0
    right = len(nums)-1
    while left &lt; right:
        mid = left + (right-left)//2
        print(left,mid,right)
        if nums[mid] &lt; nums[mid-1]:
            return nums[mid]
        if nums[left] &lt;= nums[right]:
            return nums[left]
        if nums[mid] &gt;= nums[left]:
            left = mid+1
        else:
            right = mid
    return nums[left]
</code></pre><p>​    </p>
<hr>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        # 第一个想法，简单法：弄两个列表然后得到答案
        if not headA or not headB:
            return None
        listA = []
        listB = []
        A = headA
        B = headB
        while A:
            listA.append(A)
            A = A.next
        while B :
            listB.append(B)
            B = B.next
        if listA[-1] != listB[-1]:
            return None
        t = listA[-1]
        for i in range(1,min(len(listB),len(listA))+1):
            if listA[-i] != listB[-i]:
                return t
            else:
                t = listA[-i]
        return t
</code></pre><hr>
<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h1><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞。</p>
<pre><code>def findPeakElement(self, nums: List[int]) -&gt; int:
    left = 0
    right = len(nums) -1
    while left &lt; right:
        mid = left + (right - left)//2
        if nums[mid] &gt; nums[mid+1]:
            right = mid
        else:
            left = mid + 1
    return left
</code></pre><hr>
<h1 id="167-相交链表"><a href="#167-相交链表" class="headerlink" title="167.相交链表"></a>167.相交链表</h1><pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        m=0;n = 0

        for i in range(len(numbers)):
            T = target-numbers[i]
            if T in numbers[i+1:]:
                m = i+1
                n = numbers[m:].index(T)+m+1
                break
        return [m,n]
</code></pre><hr>
<h1 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a>168. Excel表列名称</h1><pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        L = &quot;&quot;
        while n != 0:
            j = n % 26 
            if j == 0:
                j = 26
                n -= 1
            L = chr(ord(&quot;A&quot;) + j -1) + L
            n = n//26
        return L
</code></pre><hr>
<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h1><pre><code>class Solution:
    def majorityElement(self, nums: List[int]) -&gt; int:
        hashtable = {}
        for i in nums:
            if i in hashtable:
                hashtable[i] += 1
            else:
                hashtable[i] = 1
        M = 0
        N = 0
        for i in list(hashtable):
            if hashtable[i]&gt;M:
                N = i
                M = hashtable[i]
        return N
</code></pre><hr>
<h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a>171. Excel表列序号</h1><pre><code>class Solution:
    def titleToNumber(self, s: str) -&gt; int:
        N = 0
        for i in s:
            w = ord(i)-ord(&quot;A&quot;)+1
            N = N*26 +w
        return N
</code></pre><hr>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h1><pre><code>class Solution:
    def trailingZeroes(self, n: int) -&gt; int:
        count = 0
        while n &gt;= 5:
            n = n//5
            count += n
        return count
</code></pre><hr>
<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h1><pre><code>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
</code></pre><p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<hr>
<h1 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
<pre><code>class Solution:
    def reverseBits(self, n: int) -&gt; int:
        a = bin(n)[2:]
        if len(a) &lt; 32:
            a = &quot;0&quot;*(32-len(a))+a
        return int(a[::-1],2)
</code></pre><hr>
<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<pre><code>class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        return bin(n)[2:].count(&quot;1&quot;)
</code></pre><hr>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<blockquote>
<p>我开始想把奇数与偶数分开算，但发现了例外测试。就是第一个和第四个加起来是最大的。所以我采用了动态规划的方法。</p>
</blockquote>
<pre><code>class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums) &lt;2:
            return nums[0]
        table = [0]*len(nums)
        table[0] = nums[0]
        table[1] = nums[1]
        for i in range(2,len(nums)):
            table[i] = nums[i] + max(table[0:i-1])
        return max(table)
</code></pre><p>我要看看答案里有没有更好的结果。</p>
<hr>
<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<pre><code>def numIslands(self, grid: List[List[str]]) -&gt; int:
    if not grid:
        return 0
    R = len(grid)
    C = len(grid[0])
    def modify_grid(i,j):
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        if i &gt;= 0 and i &lt; R and j &gt;= 0 and j &lt; C:
            if grid[i][j] == &quot;1&quot;:
                grid[i][j] = &quot;0&quot;
                for p,q in zip(x,y):
                    modify_grid(i+p,j+q)
    I_num = 0
    for i in range(R):
        for j in range(C):
            # print(i)
            # print(j)
            if grid[i][j] == &quot;1&quot;:
                I_num += 1
                modify_grid(i,j)
    return I_num
</code></pre><hr>
<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h1><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<pre><code>class Solution:
    def isHappy(self, n: int) -&gt; bool:
        while True:
            n = sum([int(i)**2 for i in str(n)])
            if n == 4:
                return False
            if n == 1:
                return True
</code></pre><hr>
<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h1><p>删除链表中等于给定值 val 的所有节点。<br>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        L = ListNode(-1) 
        L.next = head
        head = L
        while L.next:
            if L.next.val == val:
                L.next = L.next.next
            else:
                L = L.next
        return head.next
</code></pre><hr>
<h1 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h1><p>关于质数的计算还是很有讲究的。</p>
<pre><code>class Solution:
    def countPrimes(self, n: int) -&gt; int:
        if n &lt; 3:
            return 0
        results = [1]*n
        results[0],results[1] = 0, 1
        for i in range(2,int(n**0.5)+1):
            if results[i] == 1:
                results[i*2:n:i] = [0]*len(results[i*2:n:i])
        return sum(results)-1
</code></pre><hr>
<h1 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h1><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “egg”, t = “add”<br>输出: true</p>
</blockquote>
<pre><code>class Solution:
    def isIsomorphic(self, s: str, t: str) -&gt; bool:
        hashtable1 = {}
        hashtable2 = {}
        x = 0
        for i in s:
            if i not in hashtable1:
                hashtable1[i] = x
                x = x + 1
        x = 0
        for i in t:
            if i not in hashtable2:
                hashtable2[i] = x
                x = x + 1
        for i,j in zip(s,t):
            if hashtable1[i] != hashtable2[j]:
                return False
        return True
</code></pre><hr>
<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre = None
        cur = head
        while cur:
            n = cur.next
            cur.next = pre
            pre = cur
            cur = n
        return pre
</code></pre><hr>
<h1 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h1><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<pre><code># 广度优先和深度优先方法的解法
def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
    # 存储有向图
    edges = collections.defaultdict(list)
    # 存储每个节点的入度
    indeg = [0] * numCourses
    # 存储答案
    result = list()

    for info in prerequisites:
        edges[info[1]].append(info[0])
        indeg[info[0]] += 1
    q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
    while q:
        # 从队首取出一个节点
        u = q.popleft()
        # 放入答案中
        result.append(u)
        for v in edges[u]:
            indeg[v] -= 1
            # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
            if indeg[v] == 0:
                q.append(v)
    if len(result) != numCourses:
        result = list()
    return result

def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
    # 存储有向图
    edges = collections.defaultdict(list)
    # 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    visited = [0] * numCourses
    # 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
    result = list()
    # 判断有向图中是否有环
    invalid = False

    for info in prerequisites:
        edges[info[1]].append(info[0])

    def dfs(u: int):
        nonlocal invalid
        # 将节点标记为「搜索中」
        visited[u] = 1
        # 搜索其相邻节点
        # 只要发现有环，立刻停止搜索
        for v in edges[u]:
            if visited[v] == 0:
                dfs(v)
                if invalid:
                    return
            # 如果「搜索中」说明找到了环
            elif visited[v] == 1:
                invalid = True
                return
        # 将节点标记为「已完成」
        visited[u] = 2
        # 将节点入栈
        result.append(u)

    # 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
    for i in range(numCourses):
        if not invalid and not visited[i]:
            dfs(i)

    if invalid:
        return list()
    # 如果没有环，那么就有拓扑排序
    # 注意下标 0 为栈底，因此需要将数组反序输出
    return result[::-1]
</code></pre><hr>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<pre><code>class Solution:
    def containsDuplicate(self, nums: List[int]) -&gt; bool:
        hashtable = {}
        for i in nums:
            if i in hashtable:
                return True
            else:
                hashtable[i] = 1
        return False 
</code></pre><hr>
<h1 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h1><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<pre><code>class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:
        n = len(nums)
        table = n * [0]
        hashtable = {}
        for i in range(n):
            if nums[i] not in hashtable:
                hashtable[nums[i]] = i
                table[i] = 0
            else:
                table[i] = i - hashtable[nums[i]]
                hashtable[nums[i]] = i
        print(table)
        for i in table:
            if i&gt;0 and i&lt;=k:
                return True
        return False
</code></pre><hr>
<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h1><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含1的最大正方形，并返回其面积。</p>
<pre><code>def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
    if not matrix:
        return 0
    if not matrix[0]:
        return 0
    Row = len(matrix)
    Col = len(matrix[0])
    Max = 0
    for i in range(Row):
        for j in range(Col):
            if matrix[i][j] == &quot;1&quot;:
                print(i,j)
                temp = self.getArea(matrix,Row,Col,i,j)
                print(temp)
                if temp &gt; Max:
                    Max = temp
    return Max

# 判定以该节点为左上角所能得到的最大正方形面积
def getArea(self, matrix,Row, Col, i, j):
    x,y = i,j
    t = 1
    R = t
    flag = True
    while x+t &lt; Row and y+t &lt; Col:
        t += 1
        for p in range(t):
            if matrix[x+p][y+t-1] == &quot;0&quot;:
                flag = False
                break
        if not flag:
            break
        for q in range(t-1):
            if matrix[x+t-1][y+q]== &quot;0&quot;:
                flag = False
                break
        if not flag:
            break
        R = t
    return R*R
</code></pre><hr>
<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h1><p>使用队列实现栈的下列操作：</p>
<p>push(x) — 元素 x 入栈<br>pop() — 移除栈顶元素<br>top() — 获取栈顶元素<br>empty() — 返回栈是否为空<br>注意:</p>
<p>你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）</p>
<hr>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h1><p>翻转一棵二叉树。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return root
        a = self.invertTree(root.right)
        root.right = self.invertTree(root.left)
        root.left = a
        return root
</code></pre><hr>
<h1 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h1><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<pre><code>class Solution:
    def isPowerOfTwo(self, n: int) -&gt; bool:
        i = 0
        while i == 0 and n &gt;= 2:
            i = n%2
            n = n//2
        if i == 0 and n &gt; 0:
            return True
        else:
            return False
</code></pre><hr>
<h1 id="234-回文链表（解答明天看一下）"><a href="#234-回文链表（解答明天看一下）" class="headerlink" title="234. 回文链表（解答明天看一下）"></a>234. 回文链表（解答明天看一下）</h1><p>请判断一个链表是否为回文链表。</p>
<p>我的简单解法</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        L = []
        t = head
        while t:
            L.append(t.val)
            t = t.next
        return True if L == L[::-1] else False
</code></pre><hr>
<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return None
        b = p if p.val &gt;= q.val else q
        s = p if p.val &lt; q.val else q
        if root.val &gt; b.val:
            return self.lowestCommonAncestor(root.left,p,q)
        elif root.val &gt;=s.val:
            return root
        else:
            return self.lowestCommonAncestor(root.right,p,q)
</code></pre><hr>
<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<pre><code>def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
    # 两个节点在路径中的最后一个相同的节点
    L1 = self.search(root,p)
    L2 = self.search(root,q)
    i,j = 0,0
    while i&lt;len(L1) and i &lt;len(L2):
        if L1[i] == L2[i]:
            i += 1
        else:
            break
    return L1[i-1]
def search(self, root, p):
    # p在root中的路径
    if not root:
        return []
    if root == p:
        return [root]
    left = self.search(root.left,p)
    right = self.search(root.right,p)
    if not left and not right:
        return []
    if not right:
        return [root] + left
    if not left:
        return [root] + right

def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
    if not root or root == p or root == q: return root
    left = self.lowestCommonAncestor(root.left, p, q)
    right = self.lowestCommonAncestor(root.right, p, q)
    if not left: return right
    if not right: return left
    return root
</code></pre><hr>
<h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        Sum = <span class="number">1</span></span><br><span class="line">        hash_table = &#123;&#125;</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            hash_table[i] = &#123;<span class="string">"pre"</span>:Sum,<span class="string">"rear"</span>:<span class="number">1</span>&#125;</span><br><span class="line">            Sum *= nums[i]</span><br><span class="line">        </span><br><span class="line">        Sum = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            hash_table[n<span class="number">-1</span>-i][<span class="string">"rear"</span>] = Sum</span><br><span class="line">            Sum *= nums[n<span class="number">-1</span>-i]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key,item <span class="keyword">in</span> hash_table.items():</span><br><span class="line">            <span class="comment"># print(key,item)</span></span><br><span class="line">            res.append(hash_table[key][<span class="string">"pre"</span>]*hash_table[key][<span class="string">"rear"</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>一个我写的更好的答案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        pre_Sum = <span class="number">1</span></span><br><span class="line">        rear_Sum = <span class="number">1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        help_table = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            help_table[i][<span class="number">0</span>] = pre_Sum</span><br><span class="line">            help_table[n-i<span class="number">-1</span>][<span class="number">1</span>] = rear_Sum</span><br><span class="line">            pre_Sum *= nums[i]</span><br><span class="line">            rear_Sum *= nums[n-i<span class="number">-1</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res.append(help_table[i][<span class="number">0</span>]*help_table[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = [<span class="number">1</span>] * n</span><br><span class="line">        pre_Sum = <span class="number">1</span></span><br><span class="line">        rear_Sum = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res[i] *= pre_Sum</span><br><span class="line">            res[n-i<span class="number">-1</span>] *= rear_Sum</span><br><span class="line">            pre_Sum *= nums[i] </span><br><span class="line">            rear_Sum *= nums[n-i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre_Value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rear_value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] *= pre_Value;</span><br><span class="line">            res[nums.length-i-<span class="number">1</span>] *= rear_value;</span><br><span class="line">            pre_Value *= nums[i];</span><br><span class="line">            rear_value *= nums[nums.length-i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<pre><code>class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        hash_table1 = {}
        hash_table2 = {}
        for i in s:
            if i in hash_table1:
                hash_table1[i] += 1
            else:
                hash_table1[i] = 1
        for j in t:
            if j in hash_table2:
                hash_table2[j] += 1
            else:
                hash_table2[j] = 1
        if len(hash_table2) != len(hash_table1):
            return False
        else:
            for i in hash_table1:
                if i not in hash_table2:
                    return False
                elif hash_table2[i] != hash_table1[i]:
                    return False
            return True
</code></pre><hr>
<h1 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<hr>
<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h1><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p>
<pre><code>class Solution:
    def addDigits(self, num: int) -&gt; int:
        x = 0
        while num != 0:
            x += num % 10
            num =num // 10
        return self.addDigits(x) if x &gt;= 10 else x
</code></pre><hr>
<h1 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h1><p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<pre><code>class Solution:
    def isUgly(self, num: int) -&gt; bool:
        if num == 0:
            return False
        if num == 1:
            return True
        while True:
            if num % 2 == 0:
                num = num /2
            else: break
        while True:
            if num % 3 == 0:
                num = num /3
            else: break
        while True:
            if num % 5 == 0:
                num = num /5
            else: break
        return True if num == 1 else False
</code></pre><hr>
<h1 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h1><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<pre><code>class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        M = len(nums) + 1
        for i in range(M+1):
            if i not in nums:
                return i
        return M+1
</code></pre><hr>
<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre><code># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        二分排序
        &quot;&quot;&quot;
        i = 1
        j = n
        while i&lt;j:
            x = (i+j)//2
            if isBadVersion(x):
                j = x
            else:
                i = x+1
        return i
</code></pre><hr>
<h1 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h1><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<pre><code>class Solution:
    def wordPattern(self, pattern: str, str: str) -&gt; bool:
        a = str.strip().split()
        b = list(pattern)
        hash_tabel = {}
        if len(a) != len(b):
            return False
        for i,j in zip(a,b):
            if j in hash_tabel:
                if hash_tabel[j] != i:
                    return False
            else:
                hash_tabel[j] = i
        # 判断不同key值不同
        S = []
        for i in hash_tabel:
            if hash_tabel[i] not in S:
                S.append(hash_tabel[i])
            else:
                return False
        return True
</code></pre><hr>
<h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a>292. Nim 游戏</h1><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<pre><code>class Solution:
    def canWinNim(self, n: int) -&gt; bool:
        if n%4==0:
            return False
        else:
            return True
</code></pre><hr>
<h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h1><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
<p>我第一时间想到的也是动态规划，可是没有抓住重点就没写出来。还好。这个代码也是一看就懂的。动态规划的基本要素，一个表来记录已有的最好记录。一步一步推到想要的那一步。表是用来记录最好的结果的。</p>
<pre><code>class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp = len(nums)*[1]
        for i in range(len(nums)):
            t = dp[i]
            for j in range(0,i):
                if nums[j] &lt; nums[i]:
                    if dp[i] &lt; dp[j] + t:
                        dp[i] = dp[j] + t
        return max(dp)
</code></pre><hr>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre><code># 递归解法
def decodeString(self, s: str) -&gt; str:
    res = &quot;&quot;
    i = 0
    while i &lt; len(s) :
        if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
            k = int(s[i])
            i += 1
            while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
                k = k*10 + int(s[i])
                i += 1
            j = i+1
            stack = [&quot;[&quot;]
            while j&lt;len(s) and len(stack)&gt;0:
                if s[j] == &quot;[&quot;:
                    stack.append(&quot;[&quot;)
                elif s[j] == &quot;]&quot;:
                    stack.pop()
                j += 1
            temp = self.decodeString(s[i+1:j-1])
            res += k*temp
            i = j
        else:
            res += s[i]
            i += 1
    return res

# 栈解法
def decodeString(self, s: str) -&gt; str:
    res = &quot;&quot;
    i = 0
    stack = []
    while i &lt; len(s) :
        if ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
            k = int(s[i])
            i += 1
            while ord(s[i]) &gt;= ord(&quot;0&quot;) and ord(s[i]) &lt;= ord(&quot;9&quot;):
                k = k*10 + int(s[i])
                i += 1
            stack.append(k)
        elif s[i] == &quot;]&quot;:
            temp = &quot;&quot;
            t = stack.pop()
            while t != &quot;[&quot;:
                temp = t + temp
                t = stack.pop()
            k = stack.pop()
            stack.append(k*temp)
            i += 1
        else:
            stack.append(s[i])
            i += 1
    return &quot;&quot;.join(stack)
</code></pre><hr>
<h1 id="466-统计重复个数"><a href="#466-统计重复个数" class="headerlink" title="466. 统计重复个数"></a>466. 统计重复个数</h1><p>由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcabcabc”。</p>
<p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p>
<p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。</p>
<p>请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。</p>
<pre><code>def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -&gt; int:
    if n1 == 0:
        return 0
    s1cnt, index, s2cnt = 0, 0, 0
    # recall 是我们用来找循环节的变量，它是一个哈希映射
    # 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符
    # 如果我们之前遍历了 s1cnt&#39; 个 s1 时，匹配到的是第 s2cnt&#39; 个 s2 中同样的第 index 个字符，那么就有循环节了
    # 我们用 (s1cnt&#39;, s2cnt&#39;, index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果
    # 那么哈希映射中的键就是 index，值就是 (s1cnt&#39;, s2cnt&#39;) 这个二元组
    # 循环节就是；
    #    - 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2
    #    - 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2
    # 那么还会剩下 (n1 - s1cnt&#39;) % (s1cnt - s1cnt&#39;) 个 s1, 我们对这些与 s2 进行暴力匹配
    # 注意 s2 要从第 index 个字符开始匹配
    recall = dict()
    while True:
        # 我们多遍历一个 s1，看看能不能找到循环节
        s1cnt += 1
        for ch in s1:
            if ch == s2[index]:
                index += 1
                if index == len(s2):
                    s2cnt, index = s2cnt + 1, 0
        # 还没有找到循环节，所有的 s1 就用完了
        if s1cnt == n1:
            return s2cnt // n2
        # 出现了之前的 index，表示找到了循环节
        if index in recall:
            s1cnt_prime, s2cnt_prime = recall[index]
            # 前 s1cnt&#39; 个 s1 包含了 s2cnt&#39; 个 s2
            pre_loop = (s1cnt_prime, s2cnt_prime)
            # 以后的每 (s1cnt - s1cnt&#39;) 个 s1 包含了 (s2cnt - s2cnt&#39;) 个 s2
            in_loop = (s1cnt - s1cnt_prime, s2cnt - s2cnt_prime)
            break
        else:
            recall[index] = (s1cnt, s2cnt)

    # ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop
    ans = pre_loop[1] + (n1 - pre_loop[0]) // in_loop[0] * in_loop[1]
    # S1 的末尾还剩下一些 s1，我们暴力进行匹配
    rest = (n1 - pre_loop[0]) % in_loop[0]
    for i in range(rest):
        for ch in s1:
            if ch == s2[index]:
                index += 1
                if index == len(s2):
                    ans, index = ans + 1, 0
    # S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2
    return ans // n2
</code></pre><hr>
<h1 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组 (##)"></a>560. 和为K的子数组 (##)</h1><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<pre><code>class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        # 数组还可能有小于0的情况
        res = 0
        s = 0
        n = len(nums)
        hash_table = {}
        hash_table[s] = 1
        for i in range(n):
            pre += nums[i]
            if pre-k in hash_table:
                res += hash_table[s-k]
            if pre in hash_table:
                hash_table[pre] += 1
            else:
                hash_table[pre] = 1
        return res
</code></pre><hr>
<h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h1><p>用深度优先遍历：</p>
<pre><code>class Solution:
def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
    m = len(grid)
    if m == 0: return 0
    n = len(grid[0])
    ans = 0
    def dfs(i,j):
        if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n: return 0
        if grid[i][j] == 0: return 0
        grid[i][j] = 0
        top = dfs(i+1, j)
        bottom = dfs(i-1,j)
        left = dfs(i,j-1)
        right = dfs(i,j+1)
        return 1 + sum([top,bottom,left,right])
    for i in range(m):
        for j in range(n):
            ans = max(ans,dfs(i,j))
    return ans
</code></pre><hr>
<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h1><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    N = len(T)</span><br><span class="line">    res = [<span class="number">0</span>]*N</span><br><span class="line">    M = T[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> T[i] &gt; M:</span><br><span class="line">            M = T[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = i+<span class="number">1</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> T[i]&gt;=T[r]:</span><br><span class="line">                <span class="keyword">if</span> res[r] != <span class="number">0</span>:</span><br><span class="line">                    r = res[r] + r</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res[i] = r-i</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="837-新21点-回溯法超时了，经提示还是用动态规划）"><a href="#837-新21点-回溯法超时了，经提示还是用动态规划）" class="headerlink" title="837. 新21点 (回溯法超时了，经提示还是用动态规划）"></a>837. 新21点 (回溯法超时了，经提示还是用动态规划）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="comment"># 回溯法超时了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &gt;= K <span class="keyword">and</span> score &lt;= N:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> score &gt;= K <span class="keyword">and</span> score &gt; N:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> score &lt; K:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,W+<span class="number">1</span>):</span><br><span class="line">                res += (<span class="number">1</span>/W)*help(score+i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> help(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>动态规划<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(K+W)</span><br><span class="line">    <span class="keyword">if</span> K+W<span class="number">-1</span> &lt;= N:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(K,N+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(K<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,i+<span class="number">1</span>+W):</span><br><span class="line">            dp[i] += dp[j]/W</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i&lt;N+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;N+<span class="number">1</span> &amp;&amp; j&lt;i+<span class="number">1</span>+W;j++)&#123;</span><br><span class="line">                dp[i] += dp[j]/W;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 最终通过的答案！！把相加的步骤优化一下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">        dp=[<span class="literal">None</span>]*(K+W)</span><br><span class="line">        s=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K,K+W):          <span class="comment"># 填蓝色的格子</span></span><br><span class="line">            dp[i] = <span class="number">1</span> <span class="keyword">if</span> i&lt;=N <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s+=dp[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):      <span class="comment"># 填橘黄色格子</span></span><br><span class="line">            dp[i]=s/W</span><br><span class="line">            s=s-dp[i+W]+dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h1><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        L = head
        N = 0
        while L:
            N += 1
            L = L.next
        L = head
        for _ in range(N//2):
            L = L.next
        return L
</code></pre><hr>
<h1 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h1><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p>
<p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p>
<p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p>
<p>你的目标是确切地知道 F 的值是多少。</p>
<p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p>
<pre><code>class Solution:
    def superEggDrop(self, K: int, N: int) -&gt; int:
        memo = {}
        def dp(k, n):
            if (k, n) not in memo:
                if n == 0:
                    ans = 0
                elif k == 1:
                    ans = n
                else:
                    lo, hi = 1, n
                    # keep a gap of 2 X values to manually check later
                    while lo + 1 &lt; hi:
                        x = (lo + hi) // 2
                        t1 = dp(k-1, x-1)
                        t2 = dp(k, n-x)

                        if t1 &lt; t2:
                            lo = x
                        elif t1 &gt; t2:
                            hi = x
                        else:
                            lo = hi = x

                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))
                                  for x in (lo, hi))

                memo[k, n] = ans
            return memo[k, n]

        return dp(K, N)
</code></pre><hr>
<h1 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h1><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<p>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。</p>
<pre><code>class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -&gt; bool:
        hashtable = {}
        for i in deck:
            if i in hashtable:
                hashtable[i] += 1
            else:
                hashtable[i] = 1
        a = set(hashtable.values())
        if len(a) == 1:
            return True if list(a)[0]&gt;1 else False
        else:
            b = min(a)
            for j in range(b,1,-1):
                print(j)
                p = False
                for i in a:
                    if i%j != 0:
                        p = True
                        break
                if p:
                    continue
                return True
            return False
</code></pre><hr>
<h1 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h1><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p>
<pre><code>def subarraysDivByK(self, A: List[int], K: int) -&gt; int:
    hash_table = defaultdict(list)
    hash_table[0] = [-1]
    count = 0
    S = 0
    for i in range(len(A)):
        S += A[i]
        count += len(hash_table[S%K])
        hash_table[S%K].append(i)
    return count
</code></pre><hr>
<h1 id="990-等式方程的可满足性-并查集"><a href="#990-等式方程的可满足性-并查集" class="headerlink" title="990. 等式方程的可满足性 (并查集)"></a>990. 等式方程的可满足性 (并查集)</h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>:<span class="number">3</span>] == <span class="string">"=="</span>:</span><br><span class="line">                S1,S2 = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">                k1,k2 = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(table)):</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">0</span>] <span class="keyword">in</span> table[i]:</span><br><span class="line">                        S1 = table[i]</span><br><span class="line">                        k1 = i</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">3</span>] <span class="keyword">in</span> table[i]:</span><br><span class="line">                        S2 = table[i]</span><br><span class="line">                        k2 = i</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S1 <span class="keyword">and</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    table.append([item[<span class="number">0</span>],item[<span class="number">3</span>]])</span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> S1 <span class="keyword">and</span> S2:</span><br><span class="line">                    S2.append(item[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">elif</span> S1 <span class="keyword">and</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    S1.append(item[<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> S1 != S2:</span><br><span class="line">                        S1.extend(S2)</span><br><span class="line">                        table.pop(k2)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>:<span class="number">3</span>] == <span class="string">"!="</span>:</span><br><span class="line">                S1,S2 = <span class="literal">None</span>,<span class="literal">None</span></span><br><span class="line">                <span class="keyword">for</span> L <span class="keyword">in</span> table:</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">0</span>] <span class="keyword">in</span> L:</span><br><span class="line">                        S1 = L</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="number">3</span>] <span class="keyword">in</span> L:</span><br><span class="line">                        S2 = L</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S1:</span><br><span class="line">                    table.append([item[<span class="number">0</span>]])</span><br><span class="line">                    S1 = table[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> S2:</span><br><span class="line">                    table.append([item[<span class="number">3</span>]])</span><br><span class="line">                    S2 = table[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> S1 == S2:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations: List[str])</span> -&gt; bool:</span></span><br><span class="line">        parent = defaultdict(str)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parent[x] ==<span class="string">""</span>:</span><br><span class="line">                parent[x] = x</span><br><span class="line">            <span class="keyword">while</span> x != parent[parent[x]]:</span><br><span class="line">                parent[x] = parent[parent[x]]</span><br><span class="line">                x = parent[x]</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            parent[find(x)] = find(y)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>] == <span class="string">"="</span>:</span><br><span class="line">                union(item[<span class="number">0</span>],item[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">1</span>] == <span class="string">"!"</span>:</span><br><span class="line">                <span class="keyword">if</span> find(item[<span class="number">0</span>]) == find(item[<span class="number">3</span>]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="999-车的可用捕获量"><a href="#999-车的可用捕获量" class="headerlink" title="999. 车的可用捕获量"></a>999. 车的可用捕获量</h1><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<pre><code>class Solution:
    def numRookCaptures(self, board: List[List[str]]) -&gt; int:
        [(x,y)] = [(i,j) for i in range(8) for j in range(8) if board[i][j]==&quot;R&quot;]
        N = 0
        dx = [-1, 0, 1, 0]
        dy = [0, -1, 0, 1]
        for i,j in zip(dx,dy):
            d = 1
            while True:
                if x + i*d &lt;0 or x + i*d &gt;=8 or y + j*d &lt; 0 or y + j*d &gt;= 8:
                    break
                if board[x + i*d][y + j*d] == &quot;B&quot;:
                    break
                elif board[x + i*d][y + j*d] == &quot;p&quot;:
                    N += 1
                    break
                d += 1
        return N
</code></pre><hr>
<h1 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a>1014. 最佳观光组合</h1><p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。</p>
<p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p>
<p>返回一对观光景点能取得的最高分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时答案</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            cost = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                print(i,j,cost,A[i]+A[j],A[i]+A[j]-cost)</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]-cost &gt; res:</span><br><span class="line">                    res = A[i]+A[j]-cost</span><br><span class="line">                cost += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">    dp = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">        dp = dp + (A[i]-A[i<span class="number">-1</span>]) <span class="number">-1</span></span><br><span class="line">        dp = A[i]+A[i<span class="number">-1</span>] <span class="number">-1</span> <span class="keyword">if</span> A[i]+A[i<span class="number">-1</span>] <span class="number">-1</span> &gt; dp <span class="keyword">else</span> dp</span><br><span class="line">        <span class="keyword">if</span> dp &gt; res:</span><br><span class="line">            res = dp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="1028-从先序遍历还原二叉树"><a href="#1028-从先序遍历还原二叉树" class="headerlink" title="1028. 从先序遍历还原二叉树"></a>1028. 从先序遍历还原二叉树</h1><p>我们从二叉树的根节点 root 开始进行深度优先搜索。</p>
<p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p>
<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>
<p>给出遍历输出 S，还原树并返回其根节点 root。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverFromPreorder</span><span class="params">(self, S: str)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># S = "1-2--3---4-5--6---7"</span></span><br><span class="line">        <span class="comment"># print(self.My_split(S))</span></span><br><span class="line">        val, S1, S2 = self.My_split(S)</span><br><span class="line">        root = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> S1:</span><br><span class="line">            root.left = self.recoverFromPreorder(S1)</span><br><span class="line">        <span class="keyword">if</span> S2:</span><br><span class="line">            root.right = self.recoverFromPreorder(S2)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">My_split</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[i] ==<span class="string">"-"</span>:</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> S[i] != <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j = i</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("step:" + str(step)</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[j] == <span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> S[j] != <span class="string">"-"</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        val = S[i:j]</span><br><span class="line">        window_head = j</span><br><span class="line">        window_rear = window_head+step</span><br><span class="line">        <span class="keyword">while</span> window_rear &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[window_rear] != <span class="string">"-"</span>:</span><br><span class="line">                <span class="comment"># print("window_head: "+ str(window_head)+" window_rear: "+str(window_rear))</span></span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(window_head,window_rear):</span><br><span class="line">                    <span class="keyword">if</span> S[j] != <span class="string">"-"</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    <span class="comment"># print("flag: " + str(S[window_head]))</span></span><br><span class="line">                    <span class="keyword">if</span> (S[window_head<span class="number">-1</span>] != <span class="string">"-"</span>):</span><br><span class="line">                        res.append(window_head)</span><br><span class="line">                window_head = window_rear</span><br><span class="line">                window_rear = window_head+step</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                window_head += <span class="number">1</span></span><br><span class="line">                window_rear += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("res: " + str(res))</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> val, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> val, S[res[<span class="number">0</span>]:],<span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> val, S[res[<span class="number">0</span>]:res[<span class="number">1</span>]],S[res[<span class="number">1</span>]:]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a>1095. 山脉数组中查找目标值</h1><p>（这是一个 交互式问题 ）</p>
<p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p>
<p>如果不存在这样的下标 index，就请返回 -1。</p>
<p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：</p>
<p>首先，A.length &gt;= 3</p>
<p>其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</p>
<p>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p>
<p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p>
<p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p>
<pre><code># &quot;&quot;&quot;
# This is MountainArray&#39;s API interface.
# You should not implement it, or speculate about its implementation
# &quot;&quot;&quot;
#class MountainArray:
#    def get(self, index: int) -&gt; int:
#    def length(self) -&gt; int:

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: &#39;MountainArray&#39;) -&gt; int:
        length = mountain_arr.length()
        left = 0
        right = length -1
        return self.helper(target,mountain_arr,left,right)
</code></pre><p>​<br>​        def helper(self, target,mountain_arr, left, right):<br>​            if left &gt;= right:<br>​                if mountain_arr.get(left) == target:<br>​                    # 这里可以做一个实验，删掉这个判断和有这个有什么区别<br>​                    return left<br>​                return -1<br>​            mid = left + (right - left)//2<br>​            x = mountain_arr.get(index = mid)<br>​            print(“left: “ + str(left) + “ mid: “ + str(mid) + “ right: “ + str(right))<br>​            print(“x: “ +str(x))<br>​            if  x &gt; target:<br>​                # 先找前面，如果有就return，没有就再找后面<br>​                # 也可以判断坡<br>​                t = self.helper(target,mountain_arr, left, mid)<br>​                return t if t != -1 else self.helper(target,mountain_arr, mid+1, right)<br>​            else:<br>​                # 中间值小于目标值先判断在前坡还是后坡<br>​                if mid == 0 or x &gt; mountain_arr.get(mid-1):<br>​                    # 如果在前坡，就舍弃0~mid,查找mid+1到后面<br>​                    # 在前坡与目标值相等，直接返回<br>​                    if x == target:<br>​                        return mid<br>​                    return self.helper(target,mountain_arr, mid+1, right)<br>​                else:<br>​                    # 如果在后坡，就舍弃mid:,查找前面<br>​                    t = self.helper(target,mountain_arr, left, mid)<br>​                    if t != -1:<br>​                        return t<br>​                    else:<br>​                        if x == target:<br>​                            return mid<br>​                        return self.helper(target,mountain_arr, mid+1, right)</p>
<hr>
<h1 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h1><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<pre><code>class Solution:
    def massage(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        curMax = 0
        preMax = 0
        for x in nums:
            temp = curMax
            curMax = max(preMax+x, curMax)
            preMax = temp
        return curMax
</code></pre><hr>
<h1 id="面试题40-最小的k个数"><a href="#面试题40-最小的k个数" class="headerlink" title="面试题40. 最小的k个数"></a>面试题40. 最小的k个数</h1><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的方法就比较暴力，在原来的数组中把最大的几个给删了，剩下k个最小的留下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= len(arr):<span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            arr.remove(min(arr))</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46. 把数字翻译成字符串"></a>面试题46. 把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">    S= str(num)</span><br><span class="line">    N = len(S)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">help</span><span class="params">(step)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> step &gt; N<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            res += help(step+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> step &lt; N<span class="number">-1</span> <span class="keyword">and</span> int(S[step:step+<span class="number">2</span>])&lt;<span class="number">26</span> <span class="keyword">and</span> int(S[step:step+<span class="number">2</span>]) &gt; <span class="number">9</span> :</span><br><span class="line">                res += help(step+<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> help(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">    S= str(num)</span><br><span class="line">    N = len(S)</span><br><span class="line">    dp = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> int(S[i<span class="number">-2</span>:i])&lt;<span class="number">26</span> <span class="keyword">and</span> int(S[i<span class="number">-2</span>:i]) &gt; <span class="number">9</span>:</span><br><span class="line">            dp[i] += dp[i<span class="number">-2</span>]</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面试题51-数组中的逆序对-用分治法和归并排序的经典使用模式）"><a href="#面试题51-数组中的逆序对-用分治法和归并排序的经典使用模式）" class="headerlink" title="面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）"></a>面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）</h1><pre><code>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
</code></pre><p>​<br>​    class Solution:<br>​        def reversePairs(self, nums: List[int]) -&gt; int:<br>​            L = len(nums)<br>​            if L &lt; 2:<br>​                return 0<br>​            def reversePairs(nums, left, right):<br>​                if left == right:<br>​                    return 0<br>​                mid = left + (right - left)//2<br>​                leftpairs = reversePairs(nums, left, mid)<br>​                rightpairs = reversePairs(nums, mid+1, right)<br>​                crosspairs = self.crosspairs(nums, left, mid, right)<br>​                return leftpairs + rightpairs + crosspairs<br>​            return reversePairs(nums, 0, L-1)<br>​<br>​        def crosspairs(self, nums, left, mid, right):<br>​                temp = nums[left:right+1]<br>​                m = mid - left<br>​                r = right - left<br>​                i,j = 0, m+1<br>​                count = 0<br>​                for k in range(left, right+1):<br>​                    if i == m+1:<br>​                        nums[k] = temp[j]<br>​                        j += 1<br>​                    elif j == r + 1:<br>​                        nums[k] = temp[i]<br>​                        i += 1<br>​                    elif temp[i] &lt;= temp[j]:<br>​                        nums[k] = temp[i]<br>​                        i += 1<br>​                    else:<br>​                        nums[k] = temp[j]<br>​                        j += 1<br>​                        count += m - i + 1<br>​                return count</p>
<hr>
<h1 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h1><hr>
<p>[TOC]</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
            <a href="/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/" rel="tag"># 编程题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/11/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" rel="next" title="java高级编程上">
                <i class="fa fa-chevron-left"></i> java高级编程上
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/14/Collections/" rel="prev" title="集合">
                集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">Deep ploughing those days ​​​​</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/1956918893" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-globe"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:juyi006@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://fivelike.xyz/" title="fivelike" target="_blank">fivelike</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.reachdong.cool/" title="ReachDong(dada)" target="_blank">ReachDong(dada)</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode"><span class="nav-text">leetcode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-两数相加-中等）"><span class="nav-text">2. 两数相加 (中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-无重复字符的最长子串"><span class="nav-text">3. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-最长回文子串"><span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Z-字形变换"><span class="nav-text">6. Z 字形变换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-整数翻转"><span class="nav-text">7. 整数翻转</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-字符串转换整数-atoi"><span class="nav-text">8. 字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-回文数"><span class="nav-text">9. 回文数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-盛最多水的容器"><span class="nav-text">11. 盛最多水的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-整数转罗马数字"><span class="nav-text">12. 整数转罗马数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-罗马数字转整数"><span class="nav-text">13. 罗马数字转整数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-最长公共前缀"><span class="nav-text">14. 最长公共前缀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-电话号码的字母组合"><span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-删除链表的倒数第N个节点"><span class="nav-text">19. 删除链表的倒数第N个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-有效的括号"><span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-合并K个排序链表"><span class="nav-text">23. 合并K个排序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-K-个一组翻转链表"><span class="nav-text">25. K 个一组翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#​"><span class="nav-text">​          </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-删除排序数组中的重复项"><span class="nav-text">26. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-实现strStr"><span class="nav-text">28.实现strStr()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-下一个排列"><span class="nav-text">31. 下一个排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-搜索插入位置"><span class="nav-text">35. 搜索插入位置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-有效的数独"><span class="nav-text">36. 有效的数独</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-报数"><span class="nav-text">38. 报数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-组合总和"><span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-字符串相乘"><span class="nav-text">43. 字符串相乘</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-全排列-II"><span class="nav-text">47. 全排列 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-旋转图像"><span class="nav-text">48. 旋转图像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-字母异位词分组"><span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-最大子序和-（在这个题中学暴力法，动态规划和分治法）"><span class="nav-text">53. 最大子序和 （在这个题中学暴力法，动态规划和分治法）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#暴力法"><span class="nav-text">暴力法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分治法"><span class="nav-text">分治法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-螺旋矩阵"><span class="nav-text">54. 螺旋矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-跳跃游戏"><span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-text"> </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-旋转链表"><span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#​-1"><span class="nav-text">​        </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-不同路径"><span class="nav-text">62. 不同路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63-不同路径-II-（动态规划，浅拷贝陷阱）"><span class="nav-text">63. 不同路径 II   （动态规划，浅拷贝陷阱）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-最小路径和"><span class="nav-text">64. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#​-2"><span class="nav-text">​        </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-加一"><span class="nav-text">66. 加一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#​-3"><span class="nav-text">​            </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67-二进制求和"><span class="nav-text">67. 二进制求和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-x的平方根"><span class="nav-text">69. x的平方根</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#71-简化路径"><span class="nav-text">71. 简化路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#73-矩阵置零"><span class="nav-text">73. 矩阵置零</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#74-搜索二维矩阵"><span class="nav-text">74. 搜索二维矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-颜色分类"><span class="nav-text">75. 颜色分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#76-最小覆盖子串"><span class="nav-text">76. 最小覆盖子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-组合"><span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-子集"><span class="nav-text">78. 子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79-单词搜索-这道题是有点东西的"><span class="nav-text">79. 单词搜索 (这道题是有点东西的)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#81-搜索旋转排序数组-II"><span class="nav-text">81. 搜索旋转排序数组 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#82-删除排序链表中的重复元素-II"><span class="nav-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-删除排序链表中的重复元素"><span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#84-柱状图中最大的矩形"><span class="nav-text">84. 柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-分隔链表"><span class="nav-text">86. 分隔链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#89-格雷编码"><span class="nav-text">89. 格雷编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#90-子集-II"><span class="nav-text">90. 子集 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#92-反转链表-II"><span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#100-相同的树"><span class="nav-text">100. 相同的树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-对称二叉树"><span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#107-二叉树的层次遍历"><span class="nav-text">107. 二叉树的层次遍历</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#108-将有序数组转换为二叉搜索树"><span class="nav-text">108.将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#110-平衡二叉树"><span class="nav-text">110.平衡二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-二叉树的最小深度"><span class="nav-text">111.二叉树的最小深度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#112-路径总和"><span class="nav-text">112.路径总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-杨辉三角"><span class="nav-text">118.杨辉三角</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#119-杨辉三角II"><span class="nav-text">119.杨辉三角II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-买股票的最佳时机"><span class="nav-text">121.买股票的最佳时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-验证回文串"><span class="nav-text">125.验证回文串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-只出现一次的数字"><span class="nav-text">136.只出现一次的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-环形链表"><span class="nav-text">141.环形链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#151-翻转字符串里的单词"><span class="nav-text">151.翻转字符串里的单词</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-乘积最大子数组"><span class="nav-text">152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#153-寻找旋转排序数组中的最小值-二分查找"><span class="nav-text">153. 寻找旋转排序数组中的最小值(二分查找)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-相交链表"><span class="nav-text">160.相交链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-寻找峰值"><span class="nav-text">162. 寻找峰值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#167-相交链表"><span class="nav-text">167.相交链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#168-Excel表列名称"><span class="nav-text">168. Excel表列名称</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-多数元素"><span class="nav-text">169. 多数元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel表列序号"><span class="nav-text">171. Excel表列序号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-阶乘后的零"><span class="nav-text">172. 阶乘后的零</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-旋转数组"><span class="nav-text">189. 旋转数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190-颠倒二进制位"><span class="nav-text">190. 颠倒二进制位</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-位1的个数"><span class="nav-text">191. 位1的个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-打家劫舍"><span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-岛屿数量"><span class="nav-text">200. 岛屿数量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-快乐数"><span class="nav-text">202. 快乐数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#203-移除链表元素"><span class="nav-text">203. 移除链表元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#204-计数质数"><span class="nav-text">204. 计数质数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#205-同构字符串"><span class="nav-text">205. 同构字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-反转链表"><span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-课程表-II"><span class="nav-text">210. 课程表 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-存在重复元素"><span class="nav-text">217. 存在重复元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#219-存在重复元素-II"><span class="nav-text">219. 存在重复元素 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-最大正方形"><span class="nav-text">221. 最大正方形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#225-用队列实现栈"><span class="nav-text">225. 用队列实现栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#231-2的幂"><span class="nav-text">231. 2的幂</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-回文链表（解答明天看一下）"><span class="nav-text">234. 回文链表（解答明天看一下）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#235-二叉搜索树的最近公共祖先"><span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-二叉树的最近公共祖先"><span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-除自身以外数组的乘积"><span class="nav-text">238. 除自身以外数组的乘积</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#242-有效的字母异位词"><span class="nav-text">242. 有效的字母异位词</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#257-二叉树的所有路径"><span class="nav-text">257. 二叉树的所有路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#258-各位相加"><span class="nav-text">258. 各位相加</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#263-丑数"><span class="nav-text">263. 丑数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#268-缺失数字"><span class="nav-text">268. 缺失数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#278-第一个错误的版本"><span class="nav-text">278. 第一个错误的版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#290-单词规律"><span class="nav-text">290. 单词规律</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#292-Nim-游戏"><span class="nav-text">292. Nim 游戏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-最长上升子序列"><span class="nav-text">300.最长上升子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划-1"><span class="nav-text">动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#394-字符串解码"><span class="nav-text">394. 字符串解码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#466-统计重复个数"><span class="nav-text">466. 统计重复个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#560-和为K的子数组"><span class="nav-text">560. 和为K的子数组 (##)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#695-岛屿的最大面积"><span class="nav-text">695.岛屿的最大面积</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#739-每日温度"><span class="nav-text">739. 每日温度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#837-新21点-回溯法超时了，经提示还是用动态规划）"><span class="nav-text">837. 新21点 (回溯法超时了，经提示还是用动态规划）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#876-链表的中间结点"><span class="nav-text">876. 链表的中间结点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#887-鸡蛋掉落"><span class="nav-text">887. 鸡蛋掉落</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#914-卡牌分组"><span class="nav-text">914. 卡牌分组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#974-和可被-K-整除的子数组"><span class="nav-text">974. 和可被 K 整除的子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#990-等式方程的可满足性-并查集"><span class="nav-text">990. 等式方程的可满足性 (并查集)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#999-车的可用捕获量"><span class="nav-text">999. 车的可用捕获量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1014-最佳观光组合"><span class="nav-text">1014. 最佳观光组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1028-从先序遍历还原二叉树"><span class="nav-text">1028. 从先序遍历还原二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1095-山脉数组中查找目标值"><span class="nav-text">1095. 山脉数组中查找目标值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题-17-16-按摩师"><span class="nav-text">面试题 17.16. 按摩师</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题40-最小的k个数"><span class="nav-text">面试题40. 最小的k个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题46-把数字翻译成字符串"><span class="nav-text">面试题46. 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题51-数组中的逆序对-用分治法和归并排序的经典使用模式）"><span class="nav-text">面试题51. 数组中的逆序对(用分治法和归并排序的经典使用模式）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题62-圆圈中最后剩下的数字"><span class="nav-text">面试题62. 圆圈中最后剩下的数字</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
